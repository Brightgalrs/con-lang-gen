
==================== FINAL INTERFACE ====================
2016-12-21 17:41:34.697196 UTC

interface con-lang-gen-0.0.0.1-JpecSLrjfNmG1CUMEdSr39:Data.Grammar 8001
  interface hash: b27640aa44d843e374bb72f52f8f8e41
  ABI hash: e3bdf85eebd04aee9ead3a06df4aad28
  export-list hash: 0062e624f7e52b2eec78ca7e68e0f617
  orphan hash: 369309db3bf21ba26b9e04be487f5025
  flag hash: 87177015adbaa5bcec08b7699971b9b7
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Grammar.AffixHopping{Data.Grammar.NoAffixHop Data.Grammar.OblAffixHop}
  Data.Grammar.Bar{Data.Grammar.XBarA Data.Grammar.XBarC adjunct barBar barIl barLC compliment leaf}
  Data.Grammar.ComplementizerInitial{Data.Grammar.CompFinal Data.Grammar.CompInitial}
  Data.Grammar.Grammar{Data.Grammar.Grammar getAH getCI getItoC getNS getNT getOF getObT getPP getQI getSI getTM getVtoI getWHM}
  Data.Grammar.Illoc{Data.Grammar.Decl Data.Grammar.Imper Data.Grammar.Null Data.Grammar.Ques}
  Data.Grammar.ItoCMovement{Data.Grammar.NoItoCMove Data.Grammar.OblItoCMove}
  Data.Grammar.Leaf{Data.Grammar.Leaf Data.Grammar.LeafInfl Data.Grammar.LeafNull leafIl leafInfl leafLC leafStr}
  Data.Grammar.NullSubject{Data.Grammar.NoNullSub Data.Grammar.OptNullSub}
  Data.Grammar.NullTopic{Data.Grammar.NoNullTop Data.Grammar.OptNullTop}
  Data.Grammar.ObjectFinal{Data.Grammar.ObjFinal Data.Grammar.ObjInitial}
  Data.Grammar.ObligatoryTopic{Data.Grammar.OblTopic Data.Grammar.OptTopic}
  Data.Grammar.Phrase{Data.Grammar.XP Data.Grammar.XPNull phraseBar phraseIl phraseLC specifier}
  Data.Grammar.PiedPiping{Data.Grammar.PiedPipe Data.Grammar.PrepStrand}
  Data.Grammar.QuestionInversion{Data.Grammar.NoQuesInv Data.Grammar.OblQuesInv}
  Data.Grammar.SubjectInitial{Data.Grammar.SubFinal Data.Grammar.SubInitial}
  Data.Grammar.TopicMarking{Data.Grammar.NoTopMark Data.Grammar.OblTopMark}
  Data.Grammar.VtoIMovement{Data.Grammar.NoVtoIMove Data.Grammar.OblVtoIMove}
  Data.Grammar.WHMovementObligatory{Data.Grammar.NoWHMove Data.Grammar.OblWHMove}
module dependencies: Data.Inflection Data.Other Data.Phoneme
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         con-lang-gen-0.0.0.1-JpecSLrjfNmG1CUMEdSr39:Data.Inflection
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Enum fdf7ac3e1b0be0a4a37257601bddad14
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Read 817c914615ac8e308afc0c675fb3f671
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  Data.Inflection f266f0dbc95b0bc603741fea34af6d4b
  exports: 3959414e78500c5c160744df7b5d22d7
  Animacy 1f555085a72acd0be7c2a6de830d5d03
  Aspect 73f9fcce4a2a405b233176b51f525cb2
  Case 476440af125c1822cd0b767cc8ac9f95
  Definiteness 1de448f2aa68251f2e0f9da9901aa214
  Evidentiality 18aae8850f4e0825a5c83b6a39cdd02c
  Express 215fe38755b3229d5abb86dd2bfcfba2
  Gender 8099e7e810494d6db288b5ee6338a850
  Honorific fb068a739b47969783c008d0c5ccdfb8
  LexCat ae7b63f8f02a08f901ccdfd454a411ac
  Mood 72dcb6eb4442b59226b0ba8f6714f13e
  Number 7465cc747c74e065f91b84b3f135a27f
  Person 45fed2402e7ed2b24c1d66ccdfd878c7
  Polarity 1c2c61816b840e25aed576544ed551f7
  Specificity 160b967a8965f1dbfdfeda3e8d2f734a
  Tense 66acf52fe96ad50a10594fa2d12d699d
  Topic f6776b7675319519d06c9aea2dc03bf9
  Transitivity 7302fbe55b71c04bf146a8a39e883cde
  Voice 82e4499831c335865b73c47901c341b5
  Volition 637cf4191464029f30da46ab81b77985
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping :: GHC.Enum.Enum Data.Grammar.AffixHopping
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.AffixHopping
                  Data.Grammar.$fEnumAffixHopping_$csucc
                  Data.Grammar.$fEnumAffixHopping_$cpred
                  Data.Grammar.$fEnumAffixHopping_$ctoEnum
                  Data.Grammar.$fEnumAffixHopping_$cfromEnum
                  Data.Grammar.$fEnumAffixHopping_$cenumFrom
                  Data.Grammar.$fEnumAffixHopping_$cenumFromThen
                  Data.Grammar.$fEnumAffixHopping_$cenumFromTo
                  Data.Grammar.$fEnumAffixHopping_$cenumFromThenTo -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping1 :: GHC.Prim.Int# -> Data.Grammar.AffixHopping
  {- Arity: 1, Strictness: <L,U>x -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping2 :: [Data.Grammar.AffixHopping]
  {- Unfolding: (Data.Grammar.$fEnumAffixHopping_go2 1#) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping3 :: [Data.Grammar.AffixHopping]
  {- Unfolding: (Data.Grammar.$fEnumAffixHopping_go3 0#) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping4 :: Data.Grammar.AffixHopping
  {- Strictness: x -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping5 :: Data.Grammar.AffixHopping
  {- Strictness: x -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_$cenumFrom ::
    Data.Grammar.AffixHopping -> [Data.Grammar.AffixHopping]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.AffixHopping) ->
                 case a of wild {
                   Data.Grammar.NoAffixHop -> Data.Grammar.$fEnumAffixHopping3
                   Data.Grammar.OblAffixHop -> Data.Grammar.$fEnumAffixHopping2 }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_$cenumFromThen ::
    Data.Grammar.AffixHopping
    -> Data.Grammar.AffixHopping -> [Data.Grammar.AffixHopping]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.AffixHopping)
                   (b :: Data.Grammar.AffixHopping) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.AffixHopping]
                                    Data.Grammar.$fEnumAffixHopping_c1
                                    (GHC.Types.[] @ Data.Grammar.AffixHopping)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.AffixHopping]
                                    Data.Grammar.$fEnumAffixHopping_c1
                                    (GHC.Types.[] @ Data.Grammar.AffixHopping)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.NoAffixHop -> $j1 0#
                       Data.Grammar.OblAffixHop -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.NoAffixHop -> $j 0#
                   Data.Grammar.OblAffixHop -> $j 1# }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_$cenumFromThenTo ::
    Data.Grammar.AffixHopping
    -> Data.Grammar.AffixHopping
    -> Data.Grammar.AffixHopping
    -> [Data.Grammar.AffixHopping]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.AffixHopping)
                   (x2 :: Data.Grammar.AffixHopping)
                   (y :: Data.Grammar.AffixHopping) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.NoAffixHop
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.AffixHopping]
                                     Data.Grammar.$fEnumAffixHopping_c
                                     (GHC.Types.[] @ Data.Grammar.AffixHopping)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.AffixHopping]
                                     Data.Grammar.$fEnumAffixHopping_c
                                     (GHC.Types.[] @ Data.Grammar.AffixHopping)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OblAffixHop
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.AffixHopping]
                                     Data.Grammar.$fEnumAffixHopping_c
                                     (GHC.Types.[] @ Data.Grammar.AffixHopping)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.AffixHopping]
                                     Data.Grammar.$fEnumAffixHopping_c
                                     (GHC.Types.[] @ Data.Grammar.AffixHopping)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.NoAffixHop -> $j1 0#
                       Data.Grammar.OblAffixHop -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.NoAffixHop -> $j 0#
                   Data.Grammar.OblAffixHop -> $j 1# }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_$cenumFromTo ::
    Data.Grammar.AffixHopping
    -> Data.Grammar.AffixHopping -> [Data.Grammar.AffixHopping]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.AffixHopping)
                   (y :: Data.Grammar.AffixHopping) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.NoAffixHop
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumAffixHopping_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.AffixHopping }
                       Data.Grammar.OblAffixHop
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumAffixHopping_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.AffixHopping } }
                 } in
                 case x of wild {
                   Data.Grammar.NoAffixHop -> $j 0#
                   Data.Grammar.OblAffixHop -> $j 1# }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_$cfromEnum ::
    Data.Grammar.AffixHopping -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.AffixHopping) ->
                 case a of wild {
                   Data.Grammar.NoAffixHop -> GHC.Types.I# 0#
                   Data.Grammar.OblAffixHop -> GHC.Types.I# 1# }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_$cpred ::
    Data.Grammar.AffixHopping -> Data.Grammar.AffixHopping
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.AffixHopping) ->
                 case a of wild {
                   Data.Grammar.NoAffixHop -> Data.Grammar.$fEnumAffixHopping4
                   Data.Grammar.OblAffixHop -> Data.Grammar.NoAffixHop }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_$csucc ::
    Data.Grammar.AffixHopping -> Data.Grammar.AffixHopping
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.AffixHopping) ->
                 case a of wild {
                   Data.Grammar.NoAffixHop -> Data.Grammar.OblAffixHop
                   Data.Grammar.OblAffixHop -> Data.Grammar.$fEnumAffixHopping5 }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.AffixHopping
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum ww1 }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_c ::
    GHC.Types.Int
    -> [Data.Grammar.AffixHopping] -> [Data.Grammar.AffixHopping]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.AffixHopping]) ->
                 GHC.Types.:
                   @ Data.Grammar.AffixHopping
                   (Data.Grammar.$fEnumAffixHopping_$ctoEnum x)
                   ys) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.AffixHopping] -> [Data.Grammar.AffixHopping]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.AffixHopping]) ->
                 GHC.Types.:
                   @ Data.Grammar.AffixHopping
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.AffixHopping a })
                   ys) -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_go ::
    GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
  {- Arity: 1, Strictness: <L,U> -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
  {- Arity: 1, Strictness: <L,U> -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
0ff7119050f64558eef1b9b6c65db897
  $fEnumAffixHopping_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.AffixHopping]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial ::
    GHC.Enum.Enum Data.Grammar.ComplementizerInitial
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ComplementizerInitial
                  Data.Grammar.$fEnumComplementizerInitial_$csucc
                  Data.Grammar.$fEnumComplementizerInitial_$cpred
                  Data.Grammar.$fEnumComplementizerInitial_$ctoEnum
                  Data.Grammar.$fEnumComplementizerInitial_$cfromEnum
                  Data.Grammar.$fEnumComplementizerInitial_$cenumFrom
                  Data.Grammar.$fEnumComplementizerInitial_$cenumFromThen
                  Data.Grammar.$fEnumComplementizerInitial_$cenumFromTo
                  Data.Grammar.$fEnumComplementizerInitial_$cenumFromThenTo -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial1 ::
    GHC.Prim.Int# -> Data.Grammar.ComplementizerInitial
  {- Arity: 1, Strictness: <L,U>x -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial2 ::
    [Data.Grammar.ComplementizerInitial]
  {- Unfolding: (Data.Grammar.$fEnumComplementizerInitial_go2 1#) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial3 ::
    [Data.Grammar.ComplementizerInitial]
  {- Unfolding: (Data.Grammar.$fEnumComplementizerInitial_go3 0#) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial4 :: Data.Grammar.ComplementizerInitial
  {- Strictness: x -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial5 :: Data.Grammar.ComplementizerInitial
  {- Strictness: x -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_$cenumFrom ::
    Data.Grammar.ComplementizerInitial
    -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.ComplementizerInitial) ->
                 case a of wild {
                   Data.Grammar.CompInitial
                   -> Data.Grammar.$fEnumComplementizerInitial3
                   Data.Grammar.CompFinal
                   -> Data.Grammar.$fEnumComplementizerInitial2 }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_$cenumFromThen ::
    Data.Grammar.ComplementizerInitial
    -> Data.Grammar.ComplementizerInitial
    -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.ComplementizerInitial)
                   (b :: Data.Grammar.ComplementizerInitial) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.ComplementizerInitial]
                                    Data.Grammar.$fEnumComplementizerInitial_c1
                                    (GHC.Types.[] @ Data.Grammar.ComplementizerInitial)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.ComplementizerInitial]
                                    Data.Grammar.$fEnumComplementizerInitial_c1
                                    (GHC.Types.[] @ Data.Grammar.ComplementizerInitial)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.CompInitial -> $j1 0#
                       Data.Grammar.CompFinal -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.CompInitial -> $j 0#
                   Data.Grammar.CompFinal -> $j 1# }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_$cenumFromThenTo ::
    Data.Grammar.ComplementizerInitial
    -> Data.Grammar.ComplementizerInitial
    -> Data.Grammar.ComplementizerInitial
    -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.ComplementizerInitial)
                   (x2 :: Data.Grammar.ComplementizerInitial)
                   (y :: Data.Grammar.ComplementizerInitial) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.CompInitial
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.ComplementizerInitial]
                                     Data.Grammar.$fEnumComplementizerInitial_c
                                     (GHC.Types.[] @ Data.Grammar.ComplementizerInitial)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.ComplementizerInitial]
                                     Data.Grammar.$fEnumComplementizerInitial_c
                                     (GHC.Types.[] @ Data.Grammar.ComplementizerInitial)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.CompFinal
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.ComplementizerInitial]
                                     Data.Grammar.$fEnumComplementizerInitial_c
                                     (GHC.Types.[] @ Data.Grammar.ComplementizerInitial)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.ComplementizerInitial]
                                     Data.Grammar.$fEnumComplementizerInitial_c
                                     (GHC.Types.[] @ Data.Grammar.ComplementizerInitial)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.CompInitial -> $j1 0#
                       Data.Grammar.CompFinal -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.CompInitial -> $j 0#
                   Data.Grammar.CompFinal -> $j 1# }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_$cenumFromTo ::
    Data.Grammar.ComplementizerInitial
    -> Data.Grammar.ComplementizerInitial
    -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.ComplementizerInitial)
                   (y :: Data.Grammar.ComplementizerInitial) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.CompInitial
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumComplementizerInitial_go1 x1
                            GHC.Types.True
                            -> GHC.Types.[] @ Data.Grammar.ComplementizerInitial }
                       Data.Grammar.CompFinal
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumComplementizerInitial_go x1
                            GHC.Types.True
                            -> GHC.Types.[] @ Data.Grammar.ComplementizerInitial } }
                 } in
                 case x of wild {
                   Data.Grammar.CompInitial -> $j 0#
                   Data.Grammar.CompFinal -> $j 1# }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_$cfromEnum ::
    Data.Grammar.ComplementizerInitial -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ComplementizerInitial) ->
                 case a of wild {
                   Data.Grammar.CompInitial -> GHC.Types.I# 0#
                   Data.Grammar.CompFinal -> GHC.Types.I# 1# }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_$cpred ::
    Data.Grammar.ComplementizerInitial
    -> Data.Grammar.ComplementizerInitial
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ComplementizerInitial) ->
                 case a of wild {
                   Data.Grammar.CompInitial
                   -> Data.Grammar.$fEnumComplementizerInitial4
                   Data.Grammar.CompFinal -> Data.Grammar.CompInitial }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_$csucc ::
    Data.Grammar.ComplementizerInitial
    -> Data.Grammar.ComplementizerInitial
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ComplementizerInitial) ->
                 case a of wild {
                   Data.Grammar.CompInitial -> Data.Grammar.CompFinal
                   Data.Grammar.CompFinal
                   -> Data.Grammar.$fEnumComplementizerInitial5 }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.ComplementizerInitial
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum1 ww1 }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_c ::
    GHC.Types.Int
    -> [Data.Grammar.ComplementizerInitial]
    -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int)
                   (ys :: [Data.Grammar.ComplementizerInitial]) ->
                 GHC.Types.:
                   @ Data.Grammar.ComplementizerInitial
                   (Data.Grammar.$fEnumComplementizerInitial_$ctoEnum x)
                   ys) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.ComplementizerInitial]
    -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int)
                   (ys :: [Data.Grammar.ComplementizerInitial]) ->
                 GHC.Types.:
                   @ Data.Grammar.ComplementizerInitial
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.ComplementizerInitial a })
                   ys) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_go ::
    GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 1, Strictness: <L,U> -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 1, Strictness: <L,U> -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEnumComplementizerInitial_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.ComplementizerInitial]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc :: GHC.Enum.Enum Data.Grammar.Illoc
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Illoc
                  Data.Grammar.$fEnumIlloc_$csucc
                  Data.Grammar.$fEnumIlloc_$cpred
                  Data.Grammar.$fEnumIlloc_$ctoEnum
                  Data.Grammar.$fEnumIlloc_$cfromEnum
                  Data.Grammar.$fEnumIlloc_$cenumFrom
                  Data.Grammar.$fEnumIlloc_$cenumFromThen
                  Data.Grammar.$fEnumIlloc_$cenumFromTo
                  Data.Grammar.$fEnumIlloc_$cenumFromThenTo -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc1 :: [Data.Grammar.Illoc]
  {- Unfolding: (Data.Grammar.$fEnumIlloc_go4 3#) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc2 :: [Data.Grammar.Illoc]
  {- Unfolding: (Data.Grammar.$fEnumIlloc_go5 2#) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc3 :: [Data.Grammar.Illoc]
  {- Unfolding: (Data.Grammar.$fEnumIlloc_go6 1#) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc4 :: [Data.Grammar.Illoc]
  {- Unfolding: (Data.Grammar.$fEnumIlloc_go7 0#) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc5 :: GHC.Prim.Int# -> Data.Grammar.Illoc
  {- Arity: 1, Strictness: <L,U>x -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc6 :: Data.Grammar.Illoc
  {- Strictness: x -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc7 :: Data.Grammar.Illoc
  {- Strictness: x -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_$cenumFrom ::
    Data.Grammar.Illoc -> [Data.Grammar.Illoc]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.Illoc) ->
                 case a of wild {
                   Data.Grammar.Null -> Data.Grammar.$fEnumIlloc4
                   Data.Grammar.Ques -> Data.Grammar.$fEnumIlloc3
                   Data.Grammar.Decl -> Data.Grammar.$fEnumIlloc2
                   Data.Grammar.Imper -> Data.Grammar.$fEnumIlloc1 }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_$cenumFromThen ::
    Data.Grammar.Illoc -> Data.Grammar.Illoc -> [Data.Grammar.Illoc]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.Illoc)
                   (b :: Data.Grammar.Illoc) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.Illoc]
                                    Data.Grammar.$fEnumIlloc_c
                                    (GHC.Types.[] @ Data.Grammar.Illoc)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.Illoc]
                                    Data.Grammar.$fEnumIlloc_c
                                    (GHC.Types.[] @ Data.Grammar.Illoc)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 3# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.Null -> $j1 0#
                       Data.Grammar.Ques -> $j1 1#
                       Data.Grammar.Decl -> $j1 2#
                       Data.Grammar.Imper -> $j1 3# }
                 } in
                 case a of wild {
                   Data.Grammar.Null -> $j 0#
                   Data.Grammar.Ques -> $j 1#
                   Data.Grammar.Decl -> $j 2#
                   Data.Grammar.Imper -> $j 3# }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_$cenumFromThenTo ::
    Data.Grammar.Illoc
    -> Data.Grammar.Illoc -> Data.Grammar.Illoc -> [Data.Grammar.Illoc]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_$cenumFromTo ::
    Data.Grammar.Illoc -> Data.Grammar.Illoc -> [Data.Grammar.Illoc]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.Illoc)
                   (y :: Data.Grammar.Illoc) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.Null
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumIlloc_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.Illoc }
                       Data.Grammar.Ques
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumIlloc_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.Illoc }
                       Data.Grammar.Decl
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumIlloc_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.Illoc }
                       Data.Grammar.Imper
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumIlloc_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.Illoc } }
                 } in
                 case x of wild {
                   Data.Grammar.Null -> $j 0#
                   Data.Grammar.Ques -> $j 1#
                   Data.Grammar.Decl -> $j 2#
                   Data.Grammar.Imper -> $j 3# }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_$cfromEnum :: Data.Grammar.Illoc -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.Illoc) ->
                 case a of wild {
                   Data.Grammar.Null -> GHC.Types.I# 0#
                   Data.Grammar.Ques -> GHC.Types.I# 1#
                   Data.Grammar.Decl -> GHC.Types.I# 2#
                   Data.Grammar.Imper -> GHC.Types.I# 3# }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_$cpred :: Data.Grammar.Illoc -> Data.Grammar.Illoc
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.Illoc) ->
                 case a of wild {
                   Data.Grammar.Null -> Data.Grammar.$fEnumIlloc6
                   Data.Grammar.Ques -> Data.Grammar.Null
                   Data.Grammar.Decl -> Data.Grammar.Ques
                   Data.Grammar.Imper -> Data.Grammar.Decl }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_$csucc :: Data.Grammar.Illoc -> Data.Grammar.Illoc
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.Illoc) ->
                 case a of wild {
                   Data.Grammar.Null -> Data.Grammar.Ques
                   Data.Grammar.Ques -> Data.Grammar.Decl
                   Data.Grammar.Decl -> Data.Grammar.Imper
                   Data.Grammar.Imper -> Data.Grammar.$fEnumIlloc7 }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_$ctoEnum :: GHC.Types.Int -> Data.Grammar.Illoc
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum2 ww1 }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_c ::
    GHC.Types.Int -> [Data.Grammar.Illoc] -> [Data.Grammar.Illoc]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.Illoc]) ->
                 GHC.Types.:
                   @ Data.Grammar.Illoc
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.Illoc a })
                   ys) -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_go :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
  {- Arity: 1, Strictness: <L,U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_go1 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
  {- Arity: 1, Strictness: <L,U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_go2 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
  {- Arity: 1, Strictness: <L,U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_go3 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
  {- Arity: 1, Strictness: <L,U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_go4 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_go5 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_go6 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e079181c6cea1e829f70da22fe08f7df
  $fEnumIlloc_go7 :: GHC.Prim.Int# -> [Data.Grammar.Illoc]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement :: GHC.Enum.Enum Data.Grammar.ItoCMovement
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ItoCMovement
                  Data.Grammar.$fEnumItoCMovement_$csucc
                  Data.Grammar.$fEnumItoCMovement_$cpred
                  Data.Grammar.$fEnumItoCMovement_$ctoEnum
                  Data.Grammar.$fEnumItoCMovement_$cfromEnum
                  Data.Grammar.$fEnumItoCMovement_$cenumFrom
                  Data.Grammar.$fEnumItoCMovement_$cenumFromThen
                  Data.Grammar.$fEnumItoCMovement_$cenumFromTo
                  Data.Grammar.$fEnumItoCMovement_$cenumFromThenTo -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement1 :: GHC.Prim.Int# -> Data.Grammar.ItoCMovement
  {- Arity: 1, Strictness: <L,U>x -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement2 :: [Data.Grammar.ItoCMovement]
  {- Unfolding: (Data.Grammar.$fEnumItoCMovement_go2 1#) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement3 :: [Data.Grammar.ItoCMovement]
  {- Unfolding: (Data.Grammar.$fEnumItoCMovement_go3 0#) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement4 :: Data.Grammar.ItoCMovement
  {- Strictness: x -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement5 :: Data.Grammar.ItoCMovement
  {- Strictness: x -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_$cenumFrom ::
    Data.Grammar.ItoCMovement -> [Data.Grammar.ItoCMovement]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.ItoCMovement) ->
                 case a of wild {
                   Data.Grammar.NoItoCMove -> Data.Grammar.$fEnumItoCMovement3
                   Data.Grammar.OblItoCMove -> Data.Grammar.$fEnumItoCMovement2 }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_$cenumFromThen ::
    Data.Grammar.ItoCMovement
    -> Data.Grammar.ItoCMovement -> [Data.Grammar.ItoCMovement]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.ItoCMovement)
                   (b :: Data.Grammar.ItoCMovement) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.ItoCMovement]
                                    Data.Grammar.$fEnumItoCMovement_c1
                                    (GHC.Types.[] @ Data.Grammar.ItoCMovement)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.ItoCMovement]
                                    Data.Grammar.$fEnumItoCMovement_c1
                                    (GHC.Types.[] @ Data.Grammar.ItoCMovement)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.NoItoCMove -> $j1 0#
                       Data.Grammar.OblItoCMove -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.NoItoCMove -> $j 0#
                   Data.Grammar.OblItoCMove -> $j 1# }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_$cenumFromThenTo ::
    Data.Grammar.ItoCMovement
    -> Data.Grammar.ItoCMovement
    -> Data.Grammar.ItoCMovement
    -> [Data.Grammar.ItoCMovement]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.ItoCMovement)
                   (x2 :: Data.Grammar.ItoCMovement)
                   (y :: Data.Grammar.ItoCMovement) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.NoItoCMove
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.ItoCMovement]
                                     Data.Grammar.$fEnumItoCMovement_c
                                     (GHC.Types.[] @ Data.Grammar.ItoCMovement)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.ItoCMovement]
                                     Data.Grammar.$fEnumItoCMovement_c
                                     (GHC.Types.[] @ Data.Grammar.ItoCMovement)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OblItoCMove
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.ItoCMovement]
                                     Data.Grammar.$fEnumItoCMovement_c
                                     (GHC.Types.[] @ Data.Grammar.ItoCMovement)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.ItoCMovement]
                                     Data.Grammar.$fEnumItoCMovement_c
                                     (GHC.Types.[] @ Data.Grammar.ItoCMovement)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.NoItoCMove -> $j1 0#
                       Data.Grammar.OblItoCMove -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.NoItoCMove -> $j 0#
                   Data.Grammar.OblItoCMove -> $j 1# }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_$cenumFromTo ::
    Data.Grammar.ItoCMovement
    -> Data.Grammar.ItoCMovement -> [Data.Grammar.ItoCMovement]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.ItoCMovement)
                   (y :: Data.Grammar.ItoCMovement) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.NoItoCMove
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumItoCMovement_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.ItoCMovement }
                       Data.Grammar.OblItoCMove
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumItoCMovement_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.ItoCMovement } }
                 } in
                 case x of wild {
                   Data.Grammar.NoItoCMove -> $j 0#
                   Data.Grammar.OblItoCMove -> $j 1# }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_$cfromEnum ::
    Data.Grammar.ItoCMovement -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ItoCMovement) ->
                 case a of wild {
                   Data.Grammar.NoItoCMove -> GHC.Types.I# 0#
                   Data.Grammar.OblItoCMove -> GHC.Types.I# 1# }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_$cpred ::
    Data.Grammar.ItoCMovement -> Data.Grammar.ItoCMovement
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ItoCMovement) ->
                 case a of wild {
                   Data.Grammar.NoItoCMove -> Data.Grammar.$fEnumItoCMovement4
                   Data.Grammar.OblItoCMove -> Data.Grammar.NoItoCMove }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_$csucc ::
    Data.Grammar.ItoCMovement -> Data.Grammar.ItoCMovement
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ItoCMovement) ->
                 case a of wild {
                   Data.Grammar.NoItoCMove -> Data.Grammar.OblItoCMove
                   Data.Grammar.OblItoCMove -> Data.Grammar.$fEnumItoCMovement5 }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.ItoCMovement
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum3 ww1 }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_c ::
    GHC.Types.Int
    -> [Data.Grammar.ItoCMovement] -> [Data.Grammar.ItoCMovement]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.ItoCMovement]) ->
                 GHC.Types.:
                   @ Data.Grammar.ItoCMovement
                   (Data.Grammar.$fEnumItoCMovement_$ctoEnum x)
                   ys) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.ItoCMovement] -> [Data.Grammar.ItoCMovement]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.ItoCMovement]) ->
                 GHC.Types.:
                   @ Data.Grammar.ItoCMovement
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.ItoCMovement a })
                   ys) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_go ::
    GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
  {- Arity: 1, Strictness: <L,U> -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
  {- Arity: 1, Strictness: <L,U> -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEnumItoCMovement_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.ItoCMovement]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject :: GHC.Enum.Enum Data.Grammar.NullSubject
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.NullSubject
                  Data.Grammar.$fEnumNullSubject_$csucc
                  Data.Grammar.$fEnumNullSubject_$cpred
                  Data.Grammar.$fEnumNullSubject_$ctoEnum
                  Data.Grammar.$fEnumNullSubject_$cfromEnum
                  Data.Grammar.$fEnumNullSubject_$cenumFrom
                  Data.Grammar.$fEnumNullSubject_$cenumFromThen
                  Data.Grammar.$fEnumNullSubject_$cenumFromTo
                  Data.Grammar.$fEnumNullSubject_$cenumFromThenTo -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject1 :: GHC.Prim.Int# -> Data.Grammar.NullSubject
  {- Arity: 1, Strictness: <L,U>x -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject2 :: [Data.Grammar.NullSubject]
  {- Unfolding: (Data.Grammar.$fEnumNullSubject_go2 1#) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject3 :: [Data.Grammar.NullSubject]
  {- Unfolding: (Data.Grammar.$fEnumNullSubject_go3 0#) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject4 :: Data.Grammar.NullSubject
  {- Strictness: x -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject5 :: Data.Grammar.NullSubject
  {- Strictness: x -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_$cenumFrom ::
    Data.Grammar.NullSubject -> [Data.Grammar.NullSubject]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.NullSubject) ->
                 case a of wild {
                   Data.Grammar.NoNullSub -> Data.Grammar.$fEnumNullSubject3
                   Data.Grammar.OptNullSub -> Data.Grammar.$fEnumNullSubject2 }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_$cenumFromThen ::
    Data.Grammar.NullSubject
    -> Data.Grammar.NullSubject -> [Data.Grammar.NullSubject]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.NullSubject)
                   (b :: Data.Grammar.NullSubject) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.NullSubject]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.NullSubject]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.NullSubject]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.NullSubject]
                                    Data.Grammar.$fEnumNullSubject_c1
                                    (GHC.Types.[] @ Data.Grammar.NullSubject)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.NullSubject]
                                    Data.Grammar.$fEnumNullSubject_c1
                                    (GHC.Types.[] @ Data.Grammar.NullSubject)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.NoNullSub -> $j1 0#
                       Data.Grammar.OptNullSub -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.NoNullSub -> $j 0#
                   Data.Grammar.OptNullSub -> $j 1# }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_$cenumFromThenTo ::
    Data.Grammar.NullSubject
    -> Data.Grammar.NullSubject
    -> Data.Grammar.NullSubject
    -> [Data.Grammar.NullSubject]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.NullSubject)
                   (x2 :: Data.Grammar.NullSubject)
                   (y :: Data.Grammar.NullSubject) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.NullSubject]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.NullSubject]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.NoNullSub
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.NullSubject]
                                     Data.Grammar.$fEnumNullSubject_c
                                     (GHC.Types.[] @ Data.Grammar.NullSubject)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.NullSubject]
                                     Data.Grammar.$fEnumNullSubject_c
                                     (GHC.Types.[] @ Data.Grammar.NullSubject)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OptNullSub
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.NullSubject]
                                     Data.Grammar.$fEnumNullSubject_c
                                     (GHC.Types.[] @ Data.Grammar.NullSubject)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.NullSubject]
                                     Data.Grammar.$fEnumNullSubject_c
                                     (GHC.Types.[] @ Data.Grammar.NullSubject)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.NoNullSub -> $j1 0#
                       Data.Grammar.OptNullSub -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.NoNullSub -> $j 0#
                   Data.Grammar.OptNullSub -> $j 1# }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_$cenumFromTo ::
    Data.Grammar.NullSubject
    -> Data.Grammar.NullSubject -> [Data.Grammar.NullSubject]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.NullSubject)
                   (y :: Data.Grammar.NullSubject) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.NullSubject]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.NoNullSub
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumNullSubject_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.NullSubject }
                       Data.Grammar.OptNullSub
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumNullSubject_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.NullSubject } }
                 } in
                 case x of wild {
                   Data.Grammar.NoNullSub -> $j 0#
                   Data.Grammar.OptNullSub -> $j 1# }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_$cfromEnum ::
    Data.Grammar.NullSubject -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.NullSubject) ->
                 case a of wild {
                   Data.Grammar.NoNullSub -> GHC.Types.I# 0#
                   Data.Grammar.OptNullSub -> GHC.Types.I# 1# }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_$cpred ::
    Data.Grammar.NullSubject -> Data.Grammar.NullSubject
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.NullSubject) ->
                 case a of wild {
                   Data.Grammar.NoNullSub -> Data.Grammar.$fEnumNullSubject4
                   Data.Grammar.OptNullSub -> Data.Grammar.NoNullSub }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_$csucc ::
    Data.Grammar.NullSubject -> Data.Grammar.NullSubject
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.NullSubject) ->
                 case a of wild {
                   Data.Grammar.NoNullSub -> Data.Grammar.OptNullSub
                   Data.Grammar.OptNullSub -> Data.Grammar.$fEnumNullSubject5 }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.NullSubject
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum4 ww1 }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_c ::
    GHC.Types.Int
    -> [Data.Grammar.NullSubject] -> [Data.Grammar.NullSubject]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.NullSubject]) ->
                 GHC.Types.:
                   @ Data.Grammar.NullSubject
                   (Data.Grammar.$fEnumNullSubject_$ctoEnum x)
                   ys) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.NullSubject] -> [Data.Grammar.NullSubject]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.NullSubject]) ->
                 GHC.Types.:
                   @ Data.Grammar.NullSubject
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.NullSubject a })
                   ys) -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_go :: GHC.Prim.Int# -> [Data.Grammar.NullSubject]
  {- Arity: 1, Strictness: <L,U> -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.NullSubject]
  {- Arity: 1, Strictness: <L,U> -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.NullSubject]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
c268ade9ae4c288b84a762a1c162513f
  $fEnumNullSubject_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.NullSubject]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic :: GHC.Enum.Enum Data.Grammar.NullTopic
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.NullTopic
                  Data.Grammar.$fEnumNullTopic_$csucc
                  Data.Grammar.$fEnumNullTopic_$cpred
                  Data.Grammar.$fEnumNullTopic_$ctoEnum
                  Data.Grammar.$fEnumNullTopic_$cfromEnum
                  Data.Grammar.$fEnumNullTopic_$cenumFrom
                  Data.Grammar.$fEnumNullTopic_$cenumFromThen
                  Data.Grammar.$fEnumNullTopic_$cenumFromTo
                  Data.Grammar.$fEnumNullTopic_$cenumFromThenTo -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic1 :: GHC.Prim.Int# -> Data.Grammar.NullTopic
  {- Arity: 1, Strictness: <L,U>x -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic2 :: [Data.Grammar.NullTopic]
  {- Unfolding: (Data.Grammar.$fEnumNullTopic_go2 1#) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic3 :: [Data.Grammar.NullTopic]
  {- Unfolding: (Data.Grammar.$fEnumNullTopic_go3 0#) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic4 :: Data.Grammar.NullTopic
  {- Strictness: x -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic5 :: Data.Grammar.NullTopic
  {- Strictness: x -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_$cenumFrom ::
    Data.Grammar.NullTopic -> [Data.Grammar.NullTopic]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.NullTopic) ->
                 case a of wild {
                   Data.Grammar.NoNullTop -> Data.Grammar.$fEnumNullTopic3
                   Data.Grammar.OptNullTop -> Data.Grammar.$fEnumNullTopic2 }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_$cenumFromThen ::
    Data.Grammar.NullTopic
    -> Data.Grammar.NullTopic -> [Data.Grammar.NullTopic]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.NullTopic)
                   (b :: Data.Grammar.NullTopic) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.NullTopic]
                                    Data.Grammar.$fEnumNullTopic_c1
                                    (GHC.Types.[] @ Data.Grammar.NullTopic)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.NullTopic]
                                    Data.Grammar.$fEnumNullTopic_c1
                                    (GHC.Types.[] @ Data.Grammar.NullTopic)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.NoNullTop -> $j1 0#
                       Data.Grammar.OptNullTop -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.NoNullTop -> $j 0#
                   Data.Grammar.OptNullTop -> $j 1# }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_$cenumFromThenTo ::
    Data.Grammar.NullTopic
    -> Data.Grammar.NullTopic
    -> Data.Grammar.NullTopic
    -> [Data.Grammar.NullTopic]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.NullTopic)
                   (x2 :: Data.Grammar.NullTopic)
                   (y :: Data.Grammar.NullTopic) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.NoNullTop
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.NullTopic]
                                     Data.Grammar.$fEnumNullTopic_c
                                     (GHC.Types.[] @ Data.Grammar.NullTopic)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.NullTopic]
                                     Data.Grammar.$fEnumNullTopic_c
                                     (GHC.Types.[] @ Data.Grammar.NullTopic)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OptNullTop
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.NullTopic]
                                     Data.Grammar.$fEnumNullTopic_c
                                     (GHC.Types.[] @ Data.Grammar.NullTopic)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.NullTopic]
                                     Data.Grammar.$fEnumNullTopic_c
                                     (GHC.Types.[] @ Data.Grammar.NullTopic)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.NoNullTop -> $j1 0#
                       Data.Grammar.OptNullTop -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.NoNullTop -> $j 0#
                   Data.Grammar.OptNullTop -> $j 1# }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_$cenumFromTo ::
    Data.Grammar.NullTopic
    -> Data.Grammar.NullTopic -> [Data.Grammar.NullTopic]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.NullTopic)
                   (y :: Data.Grammar.NullTopic) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.NoNullTop
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumNullTopic_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.NullTopic }
                       Data.Grammar.OptNullTop
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumNullTopic_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.NullTopic } }
                 } in
                 case x of wild {
                   Data.Grammar.NoNullTop -> $j 0#
                   Data.Grammar.OptNullTop -> $j 1# }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_$cfromEnum ::
    Data.Grammar.NullTopic -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.NullTopic) ->
                 case a of wild {
                   Data.Grammar.NoNullTop -> GHC.Types.I# 0#
                   Data.Grammar.OptNullTop -> GHC.Types.I# 1# }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_$cpred ::
    Data.Grammar.NullTopic -> Data.Grammar.NullTopic
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.NullTopic) ->
                 case a of wild {
                   Data.Grammar.NoNullTop -> Data.Grammar.$fEnumNullTopic4
                   Data.Grammar.OptNullTop -> Data.Grammar.NoNullTop }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_$csucc ::
    Data.Grammar.NullTopic -> Data.Grammar.NullTopic
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.NullTopic) ->
                 case a of wild {
                   Data.Grammar.NoNullTop -> Data.Grammar.OptNullTop
                   Data.Grammar.OptNullTop -> Data.Grammar.$fEnumNullTopic5 }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_$ctoEnum :: GHC.Types.Int -> Data.Grammar.NullTopic
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum5 ww1 }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_c ::
    GHC.Types.Int
    -> [Data.Grammar.NullTopic] -> [Data.Grammar.NullTopic]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.NullTopic]) ->
                 GHC.Types.:
                   @ Data.Grammar.NullTopic
                   (Data.Grammar.$fEnumNullTopic_$ctoEnum x)
                   ys) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.NullTopic] -> [Data.Grammar.NullTopic]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.NullTopic]) ->
                 GHC.Types.:
                   @ Data.Grammar.NullTopic
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.NullTopic a })
                   ys) -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_go :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
  {- Arity: 1, Strictness: <L,U> -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_go1 :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
  {- Arity: 1, Strictness: <L,U> -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_go2 :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
052b3f964abdaf4269e4020caa0083ce
  $fEnumNullTopic_go3 :: GHC.Prim.Int# -> [Data.Grammar.NullTopic]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal :: GHC.Enum.Enum Data.Grammar.ObjectFinal
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ObjectFinal
                  Data.Grammar.$fEnumObjectFinal_$csucc
                  Data.Grammar.$fEnumObjectFinal_$cpred
                  Data.Grammar.$fEnumObjectFinal_$ctoEnum
                  Data.Grammar.$fEnumObjectFinal_$cfromEnum
                  Data.Grammar.$fEnumObjectFinal_$cenumFrom
                  Data.Grammar.$fEnumObjectFinal_$cenumFromThen
                  Data.Grammar.$fEnumObjectFinal_$cenumFromTo
                  Data.Grammar.$fEnumObjectFinal_$cenumFromThenTo -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal1 :: GHC.Prim.Int# -> Data.Grammar.ObjectFinal
  {- Arity: 1, Strictness: <L,U>x -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal2 :: [Data.Grammar.ObjectFinal]
  {- Unfolding: (Data.Grammar.$fEnumObjectFinal_go2 1#) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal3 :: [Data.Grammar.ObjectFinal]
  {- Unfolding: (Data.Grammar.$fEnumObjectFinal_go3 0#) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal4 :: Data.Grammar.ObjectFinal
  {- Strictness: x -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal5 :: Data.Grammar.ObjectFinal
  {- Strictness: x -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_$cenumFrom ::
    Data.Grammar.ObjectFinal -> [Data.Grammar.ObjectFinal]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.ObjectFinal) ->
                 case a of wild {
                   Data.Grammar.ObjFinal -> Data.Grammar.$fEnumObjectFinal3
                   Data.Grammar.ObjInitial -> Data.Grammar.$fEnumObjectFinal2 }) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_$cenumFromThen ::
    Data.Grammar.ObjectFinal
    -> Data.Grammar.ObjectFinal -> [Data.Grammar.ObjectFinal]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.ObjectFinal)
                   (b :: Data.Grammar.ObjectFinal) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.ObjectFinal]
                                    Data.Grammar.$fEnumObjectFinal_c1
                                    (GHC.Types.[] @ Data.Grammar.ObjectFinal)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.ObjectFinal]
                                    Data.Grammar.$fEnumObjectFinal_c1
                                    (GHC.Types.[] @ Data.Grammar.ObjectFinal)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.ObjFinal -> $j1 0# Data.Grammar.ObjInitial -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.ObjFinal -> $j 0#
                   Data.Grammar.ObjInitial -> $j 1# }) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_$cenumFromThenTo ::
    Data.Grammar.ObjectFinal
    -> Data.Grammar.ObjectFinal
    -> Data.Grammar.ObjectFinal
    -> [Data.Grammar.ObjectFinal]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.ObjectFinal)
                   (x2 :: Data.Grammar.ObjectFinal)
                   (y :: Data.Grammar.ObjectFinal) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.ObjFinal
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.ObjectFinal]
                                     Data.Grammar.$fEnumObjectFinal_c
                                     (GHC.Types.[] @ Data.Grammar.ObjectFinal)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.ObjectFinal]
                                     Data.Grammar.$fEnumObjectFinal_c
                                     (GHC.Types.[] @ Data.Grammar.ObjectFinal)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.ObjInitial
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.ObjectFinal]
                                     Data.Grammar.$fEnumObjectFinal_c
                                     (GHC.Types.[] @ Data.Grammar.ObjectFinal)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.ObjectFinal]
                                     Data.Grammar.$fEnumObjectFinal_c
                                     (GHC.Types.[] @ Data.Grammar.ObjectFinal)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.ObjFinal -> $j1 0# Data.Grammar.ObjInitial -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.ObjFinal -> $j 0#
                   Data.Grammar.ObjInitial -> $j 1# }) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_$cenumFromTo ::
    Data.Grammar.ObjectFinal
    -> Data.Grammar.ObjectFinal -> [Data.Grammar.ObjectFinal]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.ObjectFinal)
                   (y :: Data.Grammar.ObjectFinal) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.ObjFinal
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumObjectFinal_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.ObjectFinal }
                       Data.Grammar.ObjInitial
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumObjectFinal_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.ObjectFinal } }
                 } in
                 case x of wild {
                   Data.Grammar.ObjFinal -> $j 0#
                   Data.Grammar.ObjInitial -> $j 1# }) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_$cfromEnum ::
    Data.Grammar.ObjectFinal -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ObjectFinal) ->
                 case a of wild {
                   Data.Grammar.ObjFinal -> GHC.Types.I# 0#
                   Data.Grammar.ObjInitial -> GHC.Types.I# 1# }) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_$cpred ::
    Data.Grammar.ObjectFinal -> Data.Grammar.ObjectFinal
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ObjectFinal) ->
                 case a of wild {
                   Data.Grammar.ObjFinal -> Data.Grammar.$fEnumObjectFinal4
                   Data.Grammar.ObjInitial -> Data.Grammar.ObjFinal }) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_$csucc ::
    Data.Grammar.ObjectFinal -> Data.Grammar.ObjectFinal
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ObjectFinal) ->
                 case a of wild {
                   Data.Grammar.ObjFinal -> Data.Grammar.ObjInitial
                   Data.Grammar.ObjInitial -> Data.Grammar.$fEnumObjectFinal5 }) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.ObjectFinal
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum6 ww1 }) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_c ::
    GHC.Types.Int
    -> [Data.Grammar.ObjectFinal] -> [Data.Grammar.ObjectFinal]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.ObjectFinal]) ->
                 GHC.Types.:
                   @ Data.Grammar.ObjectFinal
                   (Data.Grammar.$fEnumObjectFinal_$ctoEnum x)
                   ys) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.ObjectFinal] -> [Data.Grammar.ObjectFinal]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.ObjectFinal]) ->
                 GHC.Types.:
                   @ Data.Grammar.ObjectFinal
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.ObjectFinal a })
                   ys) -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_go :: GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
  {- Arity: 1, Strictness: <L,U> -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
  {- Arity: 1, Strictness: <L,U> -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
5690ac32557ef5d251bb18590690680b
  $fEnumObjectFinal_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.ObjectFinal]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic :: GHC.Enum.Enum Data.Grammar.ObligatoryTopic
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ObligatoryTopic
                  Data.Grammar.$fEnumObligatoryTopic_$csucc
                  Data.Grammar.$fEnumObligatoryTopic_$cpred
                  Data.Grammar.$fEnumObligatoryTopic_$ctoEnum
                  Data.Grammar.$fEnumObligatoryTopic_$cfromEnum
                  Data.Grammar.$fEnumObligatoryTopic_$cenumFrom
                  Data.Grammar.$fEnumObligatoryTopic_$cenumFromThen
                  Data.Grammar.$fEnumObligatoryTopic_$cenumFromTo
                  Data.Grammar.$fEnumObligatoryTopic_$cenumFromThenTo -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic1 ::
    GHC.Prim.Int# -> Data.Grammar.ObligatoryTopic
  {- Arity: 1, Strictness: <L,U>x -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic2 :: [Data.Grammar.ObligatoryTopic]
  {- Unfolding: (Data.Grammar.$fEnumObligatoryTopic_go2 1#) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic3 :: [Data.Grammar.ObligatoryTopic]
  {- Unfolding: (Data.Grammar.$fEnumObligatoryTopic_go3 0#) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic4 :: Data.Grammar.ObligatoryTopic
  {- Strictness: x -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic5 :: Data.Grammar.ObligatoryTopic
  {- Strictness: x -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_$cenumFrom ::
    Data.Grammar.ObligatoryTopic -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.ObligatoryTopic) ->
                 case a of wild {
                   Data.Grammar.OblTopic -> Data.Grammar.$fEnumObligatoryTopic3
                   Data.Grammar.OptTopic -> Data.Grammar.$fEnumObligatoryTopic2 }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_$cenumFromThen ::
    Data.Grammar.ObligatoryTopic
    -> Data.Grammar.ObligatoryTopic -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.ObligatoryTopic)
                   (b :: Data.Grammar.ObligatoryTopic) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.ObligatoryTopic]
                                    Data.Grammar.$fEnumObligatoryTopic_c1
                                    (GHC.Types.[] @ Data.Grammar.ObligatoryTopic)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.ObligatoryTopic]
                                    Data.Grammar.$fEnumObligatoryTopic_c1
                                    (GHC.Types.[] @ Data.Grammar.ObligatoryTopic)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.OblTopic -> $j1 0# Data.Grammar.OptTopic -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.OblTopic -> $j 0# Data.Grammar.OptTopic -> $j 1# }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_$cenumFromThenTo ::
    Data.Grammar.ObligatoryTopic
    -> Data.Grammar.ObligatoryTopic
    -> Data.Grammar.ObligatoryTopic
    -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.ObligatoryTopic)
                   (x2 :: Data.Grammar.ObligatoryTopic)
                   (y :: Data.Grammar.ObligatoryTopic) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.OblTopic
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.ObligatoryTopic]
                                     Data.Grammar.$fEnumObligatoryTopic_c
                                     (GHC.Types.[] @ Data.Grammar.ObligatoryTopic)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.ObligatoryTopic]
                                     Data.Grammar.$fEnumObligatoryTopic_c
                                     (GHC.Types.[] @ Data.Grammar.ObligatoryTopic)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OptTopic
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.ObligatoryTopic]
                                     Data.Grammar.$fEnumObligatoryTopic_c
                                     (GHC.Types.[] @ Data.Grammar.ObligatoryTopic)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.ObligatoryTopic]
                                     Data.Grammar.$fEnumObligatoryTopic_c
                                     (GHC.Types.[] @ Data.Grammar.ObligatoryTopic)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.OblTopic -> $j1 0# Data.Grammar.OptTopic -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.OblTopic -> $j 0# Data.Grammar.OptTopic -> $j 1# }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_$cenumFromTo ::
    Data.Grammar.ObligatoryTopic
    -> Data.Grammar.ObligatoryTopic -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.ObligatoryTopic)
                   (y :: Data.Grammar.ObligatoryTopic) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.OblTopic
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumObligatoryTopic_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.ObligatoryTopic }
                       Data.Grammar.OptTopic
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumObligatoryTopic_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.ObligatoryTopic } }
                 } in
                 case x of wild {
                   Data.Grammar.OblTopic -> $j 0# Data.Grammar.OptTopic -> $j 1# }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_$cfromEnum ::
    Data.Grammar.ObligatoryTopic -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ObligatoryTopic) ->
                 case a of wild {
                   Data.Grammar.OblTopic -> GHC.Types.I# 0#
                   Data.Grammar.OptTopic -> GHC.Types.I# 1# }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_$cpred ::
    Data.Grammar.ObligatoryTopic -> Data.Grammar.ObligatoryTopic
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ObligatoryTopic) ->
                 case a of wild {
                   Data.Grammar.OblTopic -> Data.Grammar.$fEnumObligatoryTopic4
                   Data.Grammar.OptTopic -> Data.Grammar.OblTopic }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_$csucc ::
    Data.Grammar.ObligatoryTopic -> Data.Grammar.ObligatoryTopic
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.ObligatoryTopic) ->
                 case a of wild {
                   Data.Grammar.OblTopic -> Data.Grammar.OptTopic
                   Data.Grammar.OptTopic -> Data.Grammar.$fEnumObligatoryTopic5 }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.ObligatoryTopic
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum7 ww1 }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_c ::
    GHC.Types.Int
    -> [Data.Grammar.ObligatoryTopic] -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.ObligatoryTopic]) ->
                 GHC.Types.:
                   @ Data.Grammar.ObligatoryTopic
                   (Data.Grammar.$fEnumObligatoryTopic_$ctoEnum x)
                   ys) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.ObligatoryTopic] -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.ObligatoryTopic]) ->
                 GHC.Types.:
                   @ Data.Grammar.ObligatoryTopic
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.ObligatoryTopic a })
                   ys) -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_go ::
    GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 1, Strictness: <L,U> -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 1, Strictness: <L,U> -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
934ac344d29b59a815d4a00caa639ae9
  $fEnumObligatoryTopic_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.ObligatoryTopic]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping :: GHC.Enum.Enum Data.Grammar.PiedPiping
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.PiedPiping
                  Data.Grammar.$fEnumPiedPiping_$csucc
                  Data.Grammar.$fEnumPiedPiping_$cpred
                  Data.Grammar.$fEnumPiedPiping_$ctoEnum
                  Data.Grammar.$fEnumPiedPiping_$cfromEnum
                  Data.Grammar.$fEnumPiedPiping_$cenumFrom
                  Data.Grammar.$fEnumPiedPiping_$cenumFromThen
                  Data.Grammar.$fEnumPiedPiping_$cenumFromTo
                  Data.Grammar.$fEnumPiedPiping_$cenumFromThenTo -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping1 :: GHC.Prim.Int# -> Data.Grammar.PiedPiping
  {- Arity: 1, Strictness: <L,U>x -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping2 :: [Data.Grammar.PiedPiping]
  {- Unfolding: (Data.Grammar.$fEnumPiedPiping_go2 1#) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping3 :: [Data.Grammar.PiedPiping]
  {- Unfolding: (Data.Grammar.$fEnumPiedPiping_go3 0#) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping4 :: Data.Grammar.PiedPiping
  {- Strictness: x -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping5 :: Data.Grammar.PiedPiping
  {- Strictness: x -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_$cenumFrom ::
    Data.Grammar.PiedPiping -> [Data.Grammar.PiedPiping]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.PiedPiping) ->
                 case a of wild {
                   Data.Grammar.PiedPipe -> Data.Grammar.$fEnumPiedPiping3
                   Data.Grammar.PrepStrand -> Data.Grammar.$fEnumPiedPiping2 }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_$cenumFromThen ::
    Data.Grammar.PiedPiping
    -> Data.Grammar.PiedPiping -> [Data.Grammar.PiedPiping]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.PiedPiping)
                   (b :: Data.Grammar.PiedPiping) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.PiedPiping]
                                    Data.Grammar.$fEnumPiedPiping_c1
                                    (GHC.Types.[] @ Data.Grammar.PiedPiping)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.PiedPiping]
                                    Data.Grammar.$fEnumPiedPiping_c1
                                    (GHC.Types.[] @ Data.Grammar.PiedPiping)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.PiedPipe -> $j1 0# Data.Grammar.PrepStrand -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.PiedPipe -> $j 0#
                   Data.Grammar.PrepStrand -> $j 1# }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_$cenumFromThenTo ::
    Data.Grammar.PiedPiping
    -> Data.Grammar.PiedPiping
    -> Data.Grammar.PiedPiping
    -> [Data.Grammar.PiedPiping]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.PiedPiping)
                   (x2 :: Data.Grammar.PiedPiping)
                   (y :: Data.Grammar.PiedPiping) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.PiedPipe
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.PiedPiping]
                                     Data.Grammar.$fEnumPiedPiping_c
                                     (GHC.Types.[] @ Data.Grammar.PiedPiping)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.PiedPiping]
                                     Data.Grammar.$fEnumPiedPiping_c
                                     (GHC.Types.[] @ Data.Grammar.PiedPiping)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.PrepStrand
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.PiedPiping]
                                     Data.Grammar.$fEnumPiedPiping_c
                                     (GHC.Types.[] @ Data.Grammar.PiedPiping)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.PiedPiping]
                                     Data.Grammar.$fEnumPiedPiping_c
                                     (GHC.Types.[] @ Data.Grammar.PiedPiping)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.PiedPipe -> $j1 0# Data.Grammar.PrepStrand -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.PiedPipe -> $j 0#
                   Data.Grammar.PrepStrand -> $j 1# }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_$cenumFromTo ::
    Data.Grammar.PiedPiping
    -> Data.Grammar.PiedPiping -> [Data.Grammar.PiedPiping]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.PiedPiping)
                   (y :: Data.Grammar.PiedPiping) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.PiedPipe
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumPiedPiping_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.PiedPiping }
                       Data.Grammar.PrepStrand
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumPiedPiping_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.PiedPiping } }
                 } in
                 case x of wild {
                   Data.Grammar.PiedPipe -> $j 0#
                   Data.Grammar.PrepStrand -> $j 1# }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_$cfromEnum ::
    Data.Grammar.PiedPiping -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.PiedPiping) ->
                 case a of wild {
                   Data.Grammar.PiedPipe -> GHC.Types.I# 0#
                   Data.Grammar.PrepStrand -> GHC.Types.I# 1# }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_$cpred ::
    Data.Grammar.PiedPiping -> Data.Grammar.PiedPiping
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.PiedPiping) ->
                 case a of wild {
                   Data.Grammar.PiedPipe -> Data.Grammar.$fEnumPiedPiping4
                   Data.Grammar.PrepStrand -> Data.Grammar.PiedPipe }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_$csucc ::
    Data.Grammar.PiedPiping -> Data.Grammar.PiedPiping
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.PiedPiping) ->
                 case a of wild {
                   Data.Grammar.PiedPipe -> Data.Grammar.PrepStrand
                   Data.Grammar.PrepStrand -> Data.Grammar.$fEnumPiedPiping5 }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.PiedPiping
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum8 ww1 }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_c ::
    GHC.Types.Int
    -> [Data.Grammar.PiedPiping] -> [Data.Grammar.PiedPiping]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.PiedPiping]) ->
                 GHC.Types.:
                   @ Data.Grammar.PiedPiping
                   (Data.Grammar.$fEnumPiedPiping_$ctoEnum x)
                   ys) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.PiedPiping] -> [Data.Grammar.PiedPiping]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.PiedPiping]) ->
                 GHC.Types.:
                   @ Data.Grammar.PiedPiping
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.PiedPiping a })
                   ys) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_go :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
  {- Arity: 1, Strictness: <L,U> -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_go1 :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
  {- Arity: 1, Strictness: <L,U> -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_go2 :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEnumPiedPiping_go3 :: GHC.Prim.Int# -> [Data.Grammar.PiedPiping]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion ::
    GHC.Enum.Enum Data.Grammar.QuestionInversion
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.QuestionInversion
                  Data.Grammar.$fEnumQuestionInversion_$csucc
                  Data.Grammar.$fEnumQuestionInversion_$cpred
                  Data.Grammar.$fEnumQuestionInversion_$ctoEnum
                  Data.Grammar.$fEnumQuestionInversion_$cfromEnum
                  Data.Grammar.$fEnumQuestionInversion_$cenumFrom
                  Data.Grammar.$fEnumQuestionInversion_$cenumFromThen
                  Data.Grammar.$fEnumQuestionInversion_$cenumFromTo
                  Data.Grammar.$fEnumQuestionInversion_$cenumFromThenTo -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion1 ::
    GHC.Prim.Int# -> Data.Grammar.QuestionInversion
  {- Arity: 1, Strictness: <L,U>x -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion2 :: [Data.Grammar.QuestionInversion]
  {- Unfolding: (Data.Grammar.$fEnumQuestionInversion_go2 1#) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion3 :: [Data.Grammar.QuestionInversion]
  {- Unfolding: (Data.Grammar.$fEnumQuestionInversion_go3 0#) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion4 :: Data.Grammar.QuestionInversion
  {- Strictness: x -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion5 :: Data.Grammar.QuestionInversion
  {- Strictness: x -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_$cenumFrom ::
    Data.Grammar.QuestionInversion -> [Data.Grammar.QuestionInversion]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.QuestionInversion) ->
                 case a of wild {
                   Data.Grammar.NoQuesInv -> Data.Grammar.$fEnumQuestionInversion3
                   Data.Grammar.OblQuesInv
                   -> Data.Grammar.$fEnumQuestionInversion2 }) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_$cenumFromThen ::
    Data.Grammar.QuestionInversion
    -> Data.Grammar.QuestionInversion
    -> [Data.Grammar.QuestionInversion]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.QuestionInversion)
                   (b :: Data.Grammar.QuestionInversion) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.QuestionInversion]
                                    Data.Grammar.$fEnumQuestionInversion_c1
                                    (GHC.Types.[] @ Data.Grammar.QuestionInversion)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.QuestionInversion]
                                    Data.Grammar.$fEnumQuestionInversion_c1
                                    (GHC.Types.[] @ Data.Grammar.QuestionInversion)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.NoQuesInv -> $j1 0#
                       Data.Grammar.OblQuesInv -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.NoQuesInv -> $j 0#
                   Data.Grammar.OblQuesInv -> $j 1# }) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_$cenumFromThenTo ::
    Data.Grammar.QuestionInversion
    -> Data.Grammar.QuestionInversion
    -> Data.Grammar.QuestionInversion
    -> [Data.Grammar.QuestionInversion]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.QuestionInversion)
                   (x2 :: Data.Grammar.QuestionInversion)
                   (y :: Data.Grammar.QuestionInversion) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.NoQuesInv
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.QuestionInversion]
                                     Data.Grammar.$fEnumQuestionInversion_c
                                     (GHC.Types.[] @ Data.Grammar.QuestionInversion)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.QuestionInversion]
                                     Data.Grammar.$fEnumQuestionInversion_c
                                     (GHC.Types.[] @ Data.Grammar.QuestionInversion)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OblQuesInv
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.QuestionInversion]
                                     Data.Grammar.$fEnumQuestionInversion_c
                                     (GHC.Types.[] @ Data.Grammar.QuestionInversion)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.QuestionInversion]
                                     Data.Grammar.$fEnumQuestionInversion_c
                                     (GHC.Types.[] @ Data.Grammar.QuestionInversion)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.NoQuesInv -> $j1 0#
                       Data.Grammar.OblQuesInv -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.NoQuesInv -> $j 0#
                   Data.Grammar.OblQuesInv -> $j 1# }) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_$cenumFromTo ::
    Data.Grammar.QuestionInversion
    -> Data.Grammar.QuestionInversion
    -> [Data.Grammar.QuestionInversion]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.QuestionInversion)
                   (y :: Data.Grammar.QuestionInversion) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.NoQuesInv
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumQuestionInversion_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.QuestionInversion }
                       Data.Grammar.OblQuesInv
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumQuestionInversion_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.QuestionInversion } }
                 } in
                 case x of wild {
                   Data.Grammar.NoQuesInv -> $j 0#
                   Data.Grammar.OblQuesInv -> $j 1# }) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_$cfromEnum ::
    Data.Grammar.QuestionInversion -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.QuestionInversion) ->
                 case a of wild {
                   Data.Grammar.NoQuesInv -> GHC.Types.I# 0#
                   Data.Grammar.OblQuesInv -> GHC.Types.I# 1# }) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_$cpred ::
    Data.Grammar.QuestionInversion -> Data.Grammar.QuestionInversion
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.QuestionInversion) ->
                 case a of wild {
                   Data.Grammar.NoQuesInv -> Data.Grammar.$fEnumQuestionInversion4
                   Data.Grammar.OblQuesInv -> Data.Grammar.NoQuesInv }) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_$csucc ::
    Data.Grammar.QuestionInversion -> Data.Grammar.QuestionInversion
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.QuestionInversion) ->
                 case a of wild {
                   Data.Grammar.NoQuesInv -> Data.Grammar.OblQuesInv
                   Data.Grammar.OblQuesInv
                   -> Data.Grammar.$fEnumQuestionInversion5 }) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.QuestionInversion
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum9 ww1 }) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_c ::
    GHC.Types.Int
    -> [Data.Grammar.QuestionInversion]
    -> [Data.Grammar.QuestionInversion]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.QuestionInversion]) ->
                 GHC.Types.:
                   @ Data.Grammar.QuestionInversion
                   (Data.Grammar.$fEnumQuestionInversion_$ctoEnum x)
                   ys) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.QuestionInversion]
    -> [Data.Grammar.QuestionInversion]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.QuestionInversion]) ->
                 GHC.Types.:
                   @ Data.Grammar.QuestionInversion
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.QuestionInversion a })
                   ys) -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_go ::
    GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
  {- Arity: 1, Strictness: <L,U> -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
  {- Arity: 1, Strictness: <L,U> -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
dee16e043daf097681c2796c283f597a
  $fEnumQuestionInversion_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.QuestionInversion]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial :: GHC.Enum.Enum Data.Grammar.SubjectInitial
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.SubjectInitial
                  Data.Grammar.$fEnumSubjectInitial_$csucc
                  Data.Grammar.$fEnumSubjectInitial_$cpred
                  Data.Grammar.$fEnumSubjectInitial_$ctoEnum
                  Data.Grammar.$fEnumSubjectInitial_$cfromEnum
                  Data.Grammar.$fEnumSubjectInitial_$cenumFrom
                  Data.Grammar.$fEnumSubjectInitial_$cenumFromThen
                  Data.Grammar.$fEnumSubjectInitial_$cenumFromTo
                  Data.Grammar.$fEnumSubjectInitial_$cenumFromThenTo -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial1 ::
    GHC.Prim.Int# -> Data.Grammar.SubjectInitial
  {- Arity: 1, Strictness: <L,U>x -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial2 :: [Data.Grammar.SubjectInitial]
  {- Unfolding: (Data.Grammar.$fEnumSubjectInitial_go2 1#) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial3 :: [Data.Grammar.SubjectInitial]
  {- Unfolding: (Data.Grammar.$fEnumSubjectInitial_go3 0#) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial4 :: Data.Grammar.SubjectInitial
  {- Strictness: x -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial5 :: Data.Grammar.SubjectInitial
  {- Strictness: x -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_$cenumFrom ::
    Data.Grammar.SubjectInitial -> [Data.Grammar.SubjectInitial]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.SubjectInitial) ->
                 case a of wild {
                   Data.Grammar.SubInitial -> Data.Grammar.$fEnumSubjectInitial3
                   Data.Grammar.SubFinal -> Data.Grammar.$fEnumSubjectInitial2 }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_$cenumFromThen ::
    Data.Grammar.SubjectInitial
    -> Data.Grammar.SubjectInitial -> [Data.Grammar.SubjectInitial]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.SubjectInitial)
                   (b :: Data.Grammar.SubjectInitial) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.SubjectInitial]
                                    Data.Grammar.$fEnumSubjectInitial_c1
                                    (GHC.Types.[] @ Data.Grammar.SubjectInitial)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.SubjectInitial]
                                    Data.Grammar.$fEnumSubjectInitial_c1
                                    (GHC.Types.[] @ Data.Grammar.SubjectInitial)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.SubInitial -> $j1 0# Data.Grammar.SubFinal -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.SubInitial -> $j 0#
                   Data.Grammar.SubFinal -> $j 1# }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_$cenumFromThenTo ::
    Data.Grammar.SubjectInitial
    -> Data.Grammar.SubjectInitial
    -> Data.Grammar.SubjectInitial
    -> [Data.Grammar.SubjectInitial]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.SubjectInitial)
                   (x2 :: Data.Grammar.SubjectInitial)
                   (y :: Data.Grammar.SubjectInitial) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.SubInitial
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.SubjectInitial]
                                     Data.Grammar.$fEnumSubjectInitial_c
                                     (GHC.Types.[] @ Data.Grammar.SubjectInitial)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.SubjectInitial]
                                     Data.Grammar.$fEnumSubjectInitial_c
                                     (GHC.Types.[] @ Data.Grammar.SubjectInitial)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.SubFinal
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.SubjectInitial]
                                     Data.Grammar.$fEnumSubjectInitial_c
                                     (GHC.Types.[] @ Data.Grammar.SubjectInitial)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.SubjectInitial]
                                     Data.Grammar.$fEnumSubjectInitial_c
                                     (GHC.Types.[] @ Data.Grammar.SubjectInitial)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.SubInitial -> $j1 0# Data.Grammar.SubFinal -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.SubInitial -> $j 0#
                   Data.Grammar.SubFinal -> $j 1# }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_$cenumFromTo ::
    Data.Grammar.SubjectInitial
    -> Data.Grammar.SubjectInitial -> [Data.Grammar.SubjectInitial]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.SubjectInitial)
                   (y :: Data.Grammar.SubjectInitial) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.SubInitial
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumSubjectInitial_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.SubjectInitial }
                       Data.Grammar.SubFinal
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumSubjectInitial_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.SubjectInitial } }
                 } in
                 case x of wild {
                   Data.Grammar.SubInitial -> $j 0#
                   Data.Grammar.SubFinal -> $j 1# }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_$cfromEnum ::
    Data.Grammar.SubjectInitial -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.SubjectInitial) ->
                 case a of wild {
                   Data.Grammar.SubInitial -> GHC.Types.I# 0#
                   Data.Grammar.SubFinal -> GHC.Types.I# 1# }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_$cpred ::
    Data.Grammar.SubjectInitial -> Data.Grammar.SubjectInitial
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.SubjectInitial) ->
                 case a of wild {
                   Data.Grammar.SubInitial -> Data.Grammar.$fEnumSubjectInitial4
                   Data.Grammar.SubFinal -> Data.Grammar.SubInitial }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_$csucc ::
    Data.Grammar.SubjectInitial -> Data.Grammar.SubjectInitial
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.SubjectInitial) ->
                 case a of wild {
                   Data.Grammar.SubInitial -> Data.Grammar.SubFinal
                   Data.Grammar.SubFinal -> Data.Grammar.$fEnumSubjectInitial5 }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.SubjectInitial
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum10 ww1 }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_c ::
    GHC.Types.Int
    -> [Data.Grammar.SubjectInitial] -> [Data.Grammar.SubjectInitial]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.SubjectInitial]) ->
                 GHC.Types.:
                   @ Data.Grammar.SubjectInitial
                   (Data.Grammar.$fEnumSubjectInitial_$ctoEnum x)
                   ys) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.SubjectInitial] -> [Data.Grammar.SubjectInitial]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.SubjectInitial]) ->
                 GHC.Types.:
                   @ Data.Grammar.SubjectInitial
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.SubjectInitial a })
                   ys) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_go ::
    GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
  {- Arity: 1, Strictness: <L,U> -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
  {- Arity: 1, Strictness: <L,U> -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
872e11e1b82c550480a8f63d2a4025ab
  $fEnumSubjectInitial_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.SubjectInitial]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking :: GHC.Enum.Enum Data.Grammar.TopicMarking
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.TopicMarking
                  Data.Grammar.$fEnumTopicMarking_$csucc
                  Data.Grammar.$fEnumTopicMarking_$cpred
                  Data.Grammar.$fEnumTopicMarking_$ctoEnum
                  Data.Grammar.$fEnumTopicMarking_$cfromEnum
                  Data.Grammar.$fEnumTopicMarking_$cenumFrom
                  Data.Grammar.$fEnumTopicMarking_$cenumFromThen
                  Data.Grammar.$fEnumTopicMarking_$cenumFromTo
                  Data.Grammar.$fEnumTopicMarking_$cenumFromThenTo -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking1 :: GHC.Prim.Int# -> Data.Grammar.TopicMarking
  {- Arity: 1, Strictness: <L,U>x -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking2 :: [Data.Grammar.TopicMarking]
  {- Unfolding: (Data.Grammar.$fEnumTopicMarking_go2 1#) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking3 :: [Data.Grammar.TopicMarking]
  {- Unfolding: (Data.Grammar.$fEnumTopicMarking_go3 0#) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking4 :: Data.Grammar.TopicMarking
  {- Strictness: x -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking5 :: Data.Grammar.TopicMarking
  {- Strictness: x -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_$cenumFrom ::
    Data.Grammar.TopicMarking -> [Data.Grammar.TopicMarking]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.TopicMarking) ->
                 case a of wild {
                   Data.Grammar.NoTopMark -> Data.Grammar.$fEnumTopicMarking3
                   Data.Grammar.OblTopMark -> Data.Grammar.$fEnumTopicMarking2 }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_$cenumFromThen ::
    Data.Grammar.TopicMarking
    -> Data.Grammar.TopicMarking -> [Data.Grammar.TopicMarking]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.TopicMarking)
                   (b :: Data.Grammar.TopicMarking) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.TopicMarking]
                                    Data.Grammar.$fEnumTopicMarking_c1
                                    (GHC.Types.[] @ Data.Grammar.TopicMarking)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.TopicMarking]
                                    Data.Grammar.$fEnumTopicMarking_c1
                                    (GHC.Types.[] @ Data.Grammar.TopicMarking)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.NoTopMark -> $j1 0#
                       Data.Grammar.OblTopMark -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.NoTopMark -> $j 0#
                   Data.Grammar.OblTopMark -> $j 1# }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_$cenumFromThenTo ::
    Data.Grammar.TopicMarking
    -> Data.Grammar.TopicMarking
    -> Data.Grammar.TopicMarking
    -> [Data.Grammar.TopicMarking]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.TopicMarking)
                   (x2 :: Data.Grammar.TopicMarking)
                   (y :: Data.Grammar.TopicMarking) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.NoTopMark
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.TopicMarking]
                                     Data.Grammar.$fEnumTopicMarking_c
                                     (GHC.Types.[] @ Data.Grammar.TopicMarking)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.TopicMarking]
                                     Data.Grammar.$fEnumTopicMarking_c
                                     (GHC.Types.[] @ Data.Grammar.TopicMarking)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OblTopMark
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.TopicMarking]
                                     Data.Grammar.$fEnumTopicMarking_c
                                     (GHC.Types.[] @ Data.Grammar.TopicMarking)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.TopicMarking]
                                     Data.Grammar.$fEnumTopicMarking_c
                                     (GHC.Types.[] @ Data.Grammar.TopicMarking)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.NoTopMark -> $j1 0#
                       Data.Grammar.OblTopMark -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.NoTopMark -> $j 0#
                   Data.Grammar.OblTopMark -> $j 1# }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_$cenumFromTo ::
    Data.Grammar.TopicMarking
    -> Data.Grammar.TopicMarking -> [Data.Grammar.TopicMarking]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.TopicMarking)
                   (y :: Data.Grammar.TopicMarking) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.NoTopMark
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumTopicMarking_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.TopicMarking }
                       Data.Grammar.OblTopMark
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumTopicMarking_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.TopicMarking } }
                 } in
                 case x of wild {
                   Data.Grammar.NoTopMark -> $j 0#
                   Data.Grammar.OblTopMark -> $j 1# }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_$cfromEnum ::
    Data.Grammar.TopicMarking -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.TopicMarking) ->
                 case a of wild {
                   Data.Grammar.NoTopMark -> GHC.Types.I# 0#
                   Data.Grammar.OblTopMark -> GHC.Types.I# 1# }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_$cpred ::
    Data.Grammar.TopicMarking -> Data.Grammar.TopicMarking
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.TopicMarking) ->
                 case a of wild {
                   Data.Grammar.NoTopMark -> Data.Grammar.$fEnumTopicMarking4
                   Data.Grammar.OblTopMark -> Data.Grammar.NoTopMark }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_$csucc ::
    Data.Grammar.TopicMarking -> Data.Grammar.TopicMarking
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.TopicMarking) ->
                 case a of wild {
                   Data.Grammar.NoTopMark -> Data.Grammar.OblTopMark
                   Data.Grammar.OblTopMark -> Data.Grammar.$fEnumTopicMarking5 }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.TopicMarking
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum11 ww1 }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_c ::
    GHC.Types.Int
    -> [Data.Grammar.TopicMarking] -> [Data.Grammar.TopicMarking]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.TopicMarking]) ->
                 GHC.Types.:
                   @ Data.Grammar.TopicMarking
                   (Data.Grammar.$fEnumTopicMarking_$ctoEnum x)
                   ys) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.TopicMarking] -> [Data.Grammar.TopicMarking]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.TopicMarking]) ->
                 GHC.Types.:
                   @ Data.Grammar.TopicMarking
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.TopicMarking a })
                   ys) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_go ::
    GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
  {- Arity: 1, Strictness: <L,U> -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
  {- Arity: 1, Strictness: <L,U> -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEnumTopicMarking_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.TopicMarking]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement :: GHC.Enum.Enum Data.Grammar.VtoIMovement
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.VtoIMovement
                  Data.Grammar.$fEnumVtoIMovement_$csucc
                  Data.Grammar.$fEnumVtoIMovement_$cpred
                  Data.Grammar.$fEnumVtoIMovement_$ctoEnum
                  Data.Grammar.$fEnumVtoIMovement_$cfromEnum
                  Data.Grammar.$fEnumVtoIMovement_$cenumFrom
                  Data.Grammar.$fEnumVtoIMovement_$cenumFromThen
                  Data.Grammar.$fEnumVtoIMovement_$cenumFromTo
                  Data.Grammar.$fEnumVtoIMovement_$cenumFromThenTo -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement1 :: GHC.Prim.Int# -> Data.Grammar.VtoIMovement
  {- Arity: 1, Strictness: <L,U>x -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement2 :: [Data.Grammar.VtoIMovement]
  {- Unfolding: (Data.Grammar.$fEnumVtoIMovement_go2 1#) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement3 :: [Data.Grammar.VtoIMovement]
  {- Unfolding: (Data.Grammar.$fEnumVtoIMovement_go3 0#) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement4 :: Data.Grammar.VtoIMovement
  {- Strictness: x -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement5 :: Data.Grammar.VtoIMovement
  {- Strictness: x -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_$cenumFrom ::
    Data.Grammar.VtoIMovement -> [Data.Grammar.VtoIMovement]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.VtoIMovement) ->
                 case a of wild {
                   Data.Grammar.NoVtoIMove -> Data.Grammar.$fEnumVtoIMovement3
                   Data.Grammar.OblVtoIMove -> Data.Grammar.$fEnumVtoIMovement2 }) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_$cenumFromThen ::
    Data.Grammar.VtoIMovement
    -> Data.Grammar.VtoIMovement -> [Data.Grammar.VtoIMovement]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.VtoIMovement)
                   (b :: Data.Grammar.VtoIMovement) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.VtoIMovement]
                                    Data.Grammar.$fEnumVtoIMovement_c1
                                    (GHC.Types.[] @ Data.Grammar.VtoIMovement)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.VtoIMovement]
                                    Data.Grammar.$fEnumVtoIMovement_c1
                                    (GHC.Types.[] @ Data.Grammar.VtoIMovement)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.NoVtoIMove -> $j1 0#
                       Data.Grammar.OblVtoIMove -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.NoVtoIMove -> $j 0#
                   Data.Grammar.OblVtoIMove -> $j 1# }) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_$cenumFromThenTo ::
    Data.Grammar.VtoIMovement
    -> Data.Grammar.VtoIMovement
    -> Data.Grammar.VtoIMovement
    -> [Data.Grammar.VtoIMovement]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.VtoIMovement)
                   (x2 :: Data.Grammar.VtoIMovement)
                   (y :: Data.Grammar.VtoIMovement) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.NoVtoIMove
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.VtoIMovement]
                                     Data.Grammar.$fEnumVtoIMovement_c
                                     (GHC.Types.[] @ Data.Grammar.VtoIMovement)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.VtoIMovement]
                                     Data.Grammar.$fEnumVtoIMovement_c
                                     (GHC.Types.[] @ Data.Grammar.VtoIMovement)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OblVtoIMove
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.VtoIMovement]
                                     Data.Grammar.$fEnumVtoIMovement_c
                                     (GHC.Types.[] @ Data.Grammar.VtoIMovement)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.VtoIMovement]
                                     Data.Grammar.$fEnumVtoIMovement_c
                                     (GHC.Types.[] @ Data.Grammar.VtoIMovement)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.NoVtoIMove -> $j1 0#
                       Data.Grammar.OblVtoIMove -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.NoVtoIMove -> $j 0#
                   Data.Grammar.OblVtoIMove -> $j 1# }) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_$cenumFromTo ::
    Data.Grammar.VtoIMovement
    -> Data.Grammar.VtoIMovement -> [Data.Grammar.VtoIMovement]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.VtoIMovement)
                   (y :: Data.Grammar.VtoIMovement) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.NoVtoIMove
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumVtoIMovement_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.VtoIMovement }
                       Data.Grammar.OblVtoIMove
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumVtoIMovement_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Grammar.VtoIMovement } }
                 } in
                 case x of wild {
                   Data.Grammar.NoVtoIMove -> $j 0#
                   Data.Grammar.OblVtoIMove -> $j 1# }) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_$cfromEnum ::
    Data.Grammar.VtoIMovement -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.VtoIMovement) ->
                 case a of wild {
                   Data.Grammar.NoVtoIMove -> GHC.Types.I# 0#
                   Data.Grammar.OblVtoIMove -> GHC.Types.I# 1# }) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_$cpred ::
    Data.Grammar.VtoIMovement -> Data.Grammar.VtoIMovement
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.VtoIMovement) ->
                 case a of wild {
                   Data.Grammar.NoVtoIMove -> Data.Grammar.$fEnumVtoIMovement4
                   Data.Grammar.OblVtoIMove -> Data.Grammar.NoVtoIMove }) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_$csucc ::
    Data.Grammar.VtoIMovement -> Data.Grammar.VtoIMovement
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.VtoIMovement) ->
                 case a of wild {
                   Data.Grammar.NoVtoIMove -> Data.Grammar.OblVtoIMove
                   Data.Grammar.OblVtoIMove -> Data.Grammar.$fEnumVtoIMovement5 }) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.VtoIMovement
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum12 ww1 }) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_c ::
    GHC.Types.Int
    -> [Data.Grammar.VtoIMovement] -> [Data.Grammar.VtoIMovement]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.VtoIMovement]) ->
                 GHC.Types.:
                   @ Data.Grammar.VtoIMovement
                   (Data.Grammar.$fEnumVtoIMovement_$ctoEnum x)
                   ys) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.VtoIMovement] -> [Data.Grammar.VtoIMovement]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Grammar.VtoIMovement]) ->
                 GHC.Types.:
                   @ Data.Grammar.VtoIMovement
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.VtoIMovement a })
                   ys) -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_go ::
    GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
  {- Arity: 1, Strictness: <L,U> -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
  {- Arity: 1, Strictness: <L,U> -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
26726f546091d6e0b9a4e728fd464566
  $fEnumVtoIMovement_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.VtoIMovement]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory ::
    GHC.Enum.Enum Data.Grammar.WHMovementObligatory
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.WHMovementObligatory
                  Data.Grammar.$fEnumWHMovementObligatory_$csucc
                  Data.Grammar.$fEnumWHMovementObligatory_$cpred
                  Data.Grammar.$fEnumWHMovementObligatory_$ctoEnum
                  Data.Grammar.$fEnumWHMovementObligatory_$cfromEnum
                  Data.Grammar.$fEnumWHMovementObligatory_$cenumFrom
                  Data.Grammar.$fEnumWHMovementObligatory_$cenumFromThen
                  Data.Grammar.$fEnumWHMovementObligatory_$cenumFromTo
                  Data.Grammar.$fEnumWHMovementObligatory_$cenumFromThenTo -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory1 ::
    GHC.Prim.Int# -> Data.Grammar.WHMovementObligatory
  {- Arity: 1, Strictness: <L,U>x -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory2 :: [Data.Grammar.WHMovementObligatory]
  {- Unfolding: (Data.Grammar.$fEnumWHMovementObligatory_go2 1#) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory3 :: [Data.Grammar.WHMovementObligatory]
  {- Unfolding: (Data.Grammar.$fEnumWHMovementObligatory_go3 0#) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory4 :: Data.Grammar.WHMovementObligatory
  {- Strictness: x -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory5 :: Data.Grammar.WHMovementObligatory
  {- Strictness: x -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_$cenumFrom ::
    Data.Grammar.WHMovementObligatory
    -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.WHMovementObligatory) ->
                 case a of wild {
                   Data.Grammar.NoWHMove -> Data.Grammar.$fEnumWHMovementObligatory3
                   Data.Grammar.OblWHMove
                   -> Data.Grammar.$fEnumWHMovementObligatory2 }) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_$cenumFromThen ::
    Data.Grammar.WHMovementObligatory
    -> Data.Grammar.WHMovementObligatory
    -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.WHMovementObligatory)
                   (b :: Data.Grammar.WHMovementObligatory) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Grammar.WHMovementObligatory]
                                    Data.Grammar.$fEnumWHMovementObligatory_c1
                                    (GHC.Types.[] @ Data.Grammar.WHMovementObligatory)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Grammar.WHMovementObligatory]
                                    Data.Grammar.$fEnumWHMovementObligatory_c1
                                    (GHC.Types.[] @ Data.Grammar.WHMovementObligatory)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Grammar.NoWHMove -> $j1 0# Data.Grammar.OblWHMove -> $j1 1# }
                 } in
                 case a of wild {
                   Data.Grammar.NoWHMove -> $j 0#
                   Data.Grammar.OblWHMove -> $j 1# }) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_$cenumFromThenTo ::
    Data.Grammar.WHMovementObligatory
    -> Data.Grammar.WHMovementObligatory
    -> Data.Grammar.WHMovementObligatory
    -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Grammar.WHMovementObligatory)
                   (x2 :: Data.Grammar.WHMovementObligatory)
                   (y :: Data.Grammar.WHMovementObligatory) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Grammar.NoWHMove
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.WHMovementObligatory]
                                     Data.Grammar.$fEnumWHMovementObligatory_c
                                     (GHC.Types.[] @ Data.Grammar.WHMovementObligatory)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.WHMovementObligatory]
                                     Data.Grammar.$fEnumWHMovementObligatory_c
                                     (GHC.Types.[] @ Data.Grammar.WHMovementObligatory)
                                     x4
                                     x5
                                     0# }
                           Data.Grammar.OblWHMove
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Grammar.WHMovementObligatory]
                                     Data.Grammar.$fEnumWHMovementObligatory_c
                                     (GHC.Types.[] @ Data.Grammar.WHMovementObligatory)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Grammar.WHMovementObligatory]
                                     Data.Grammar.$fEnumWHMovementObligatory_c
                                     (GHC.Types.[] @ Data.Grammar.WHMovementObligatory)
                                     x4
                                     x5
                                     1# } }
                     } in
                     case x2 of wild {
                       Data.Grammar.NoWHMove -> $j1 0# Data.Grammar.OblWHMove -> $j1 1# }
                 } in
                 case x1 of wild {
                   Data.Grammar.NoWHMove -> $j 0#
                   Data.Grammar.OblWHMove -> $j 1# }) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_$cenumFromTo ::
    Data.Grammar.WHMovementObligatory
    -> Data.Grammar.WHMovementObligatory
    -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Grammar.WHMovementObligatory)
                   (y :: Data.Grammar.WHMovementObligatory) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Grammar.NoWHMove
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumWHMovementObligatory_go1 x1
                            GHC.Types.True
                            -> GHC.Types.[] @ Data.Grammar.WHMovementObligatory }
                       Data.Grammar.OblWHMove
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Grammar.$fEnumWHMovementObligatory_go x1
                            GHC.Types.True
                            -> GHC.Types.[] @ Data.Grammar.WHMovementObligatory } }
                 } in
                 case x of wild {
                   Data.Grammar.NoWHMove -> $j 0#
                   Data.Grammar.OblWHMove -> $j 1# }) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_$cfromEnum ::
    Data.Grammar.WHMovementObligatory -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.WHMovementObligatory) ->
                 case a of wild {
                   Data.Grammar.NoWHMove -> GHC.Types.I# 0#
                   Data.Grammar.OblWHMove -> GHC.Types.I# 1# }) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_$cpred ::
    Data.Grammar.WHMovementObligatory
    -> Data.Grammar.WHMovementObligatory
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.WHMovementObligatory) ->
                 case a of wild {
                   Data.Grammar.NoWHMove -> Data.Grammar.$fEnumWHMovementObligatory4
                   Data.Grammar.OblWHMove -> Data.Grammar.NoWHMove }) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_$csucc ::
    Data.Grammar.WHMovementObligatory
    -> Data.Grammar.WHMovementObligatory
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Grammar.WHMovementObligatory) ->
                 case a of wild {
                   Data.Grammar.NoWHMove -> Data.Grammar.OblWHMove
                   Data.Grammar.OblWHMove
                   -> Data.Grammar.$fEnumWHMovementObligatory5 }) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_$ctoEnum ::
    GHC.Types.Int -> Data.Grammar.WHMovementObligatory
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$ctoEnum13 ww1 }) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_c ::
    GHC.Types.Int
    -> [Data.Grammar.WHMovementObligatory]
    -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int)
                   (ys :: [Data.Grammar.WHMovementObligatory]) ->
                 GHC.Types.:
                   @ Data.Grammar.WHMovementObligatory
                   (Data.Grammar.$fEnumWHMovementObligatory_$ctoEnum x)
                   ys) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_c1 ::
    GHC.Types.Int
    -> [Data.Grammar.WHMovementObligatory]
    -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int)
                   (ys :: [Data.Grammar.WHMovementObligatory]) ->
                 GHC.Types.:
                   @ Data.Grammar.WHMovementObligatory
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Grammar.WHMovementObligatory a })
                   ys) -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_go ::
    GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 1, Strictness: <L,U> -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_go1 ::
    GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 1, Strictness: <L,U> -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_go2 ::
    GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
b81b310f32810f84d11d228d1654c597
  $fEnumWHMovementObligatory_go3 ::
    GHC.Prim.Int# -> [Data.Grammar.WHMovementObligatory]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
0ff7119050f64558eef1b9b6c65db897
  $fEqAffixHopping :: GHC.Classes.Eq Data.Grammar.AffixHopping
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.AffixHopping
                  Data.Grammar.$fEqAffixHopping_$c==
                  Data.Grammar.$fEqAffixHopping_$c/= -}
0ff7119050f64558eef1b9b6c65db897
  $fEqAffixHopping_$c/= ::
    Data.Grammar.AffixHopping
    -> Data.Grammar.AffixHopping -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.AffixHopping)
                   (b :: Data.Grammar.AffixHopping) ->
                 case a of wild {
                   Data.Grammar.NoAffixHop
                   -> case b of wild1 {
                        Data.Grammar.NoAffixHop -> GHC.Types.False
                        Data.Grammar.OblAffixHop -> GHC.Types.True }
                   Data.Grammar.OblAffixHop
                   -> case b of wild1 {
                        Data.Grammar.NoAffixHop -> GHC.Types.True
                        Data.Grammar.OblAffixHop -> GHC.Types.False } }) -}
0ff7119050f64558eef1b9b6c65db897
  $fEqAffixHopping_$c== ::
    Data.Grammar.AffixHopping
    -> Data.Grammar.AffixHopping -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.AffixHopping)
                   (ds1 :: Data.Grammar.AffixHopping) ->
                 case ds of wild {
                   Data.Grammar.NoAffixHop
                   -> case ds1 of wild1 {
                        Data.Grammar.NoAffixHop -> GHC.Types.True
                        Data.Grammar.OblAffixHop -> GHC.Types.False }
                   Data.Grammar.OblAffixHop
                   -> case ds1 of wild1 {
                        Data.Grammar.NoAffixHop -> GHC.Types.False
                        Data.Grammar.OblAffixHop -> GHC.Types.True } }) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fEqBar :: GHC.Classes.Eq Data.Grammar.Bar
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Bar
                  Data.Grammar.$fEqBar_$c==
                  Data.Grammar.$fEqBar_$c/= -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fEqBar_$c/= ::
    Data.Grammar.Bar -> Data.Grammar.Bar -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.Bar) (b :: Data.Grammar.Bar) ->
                 case Data.Grammar.$fEqBar_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fEqBar_$c== ::
    Data.Grammar.Bar -> Data.Grammar.Bar -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEqComplementizerInitial ::
    GHC.Classes.Eq Data.Grammar.ComplementizerInitial
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ComplementizerInitial
                  Data.Grammar.$fEqComplementizerInitial_$c==
                  Data.Grammar.$fEqComplementizerInitial_$c/= -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEqComplementizerInitial_$c/= ::
    Data.Grammar.ComplementizerInitial
    -> Data.Grammar.ComplementizerInitial -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.ComplementizerInitial)
                   (b :: Data.Grammar.ComplementizerInitial) ->
                 case a of wild {
                   Data.Grammar.CompInitial
                   -> case b of wild1 {
                        Data.Grammar.CompInitial -> GHC.Types.False
                        Data.Grammar.CompFinal -> GHC.Types.True }
                   Data.Grammar.CompFinal
                   -> case b of wild1 {
                        Data.Grammar.CompInitial -> GHC.Types.True
                        Data.Grammar.CompFinal -> GHC.Types.False } }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fEqComplementizerInitial_$c== ::
    Data.Grammar.ComplementizerInitial
    -> Data.Grammar.ComplementizerInitial -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.ComplementizerInitial)
                   (ds1 :: Data.Grammar.ComplementizerInitial) ->
                 case ds of wild {
                   Data.Grammar.CompInitial
                   -> case ds1 of wild1 {
                        Data.Grammar.CompInitial -> GHC.Types.True
                        Data.Grammar.CompFinal -> GHC.Types.False }
                   Data.Grammar.CompFinal
                   -> case ds1 of wild1 {
                        Data.Grammar.CompInitial -> GHC.Types.False
                        Data.Grammar.CompFinal -> GHC.Types.True } }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEqIlloc :: GHC.Classes.Eq Data.Grammar.Illoc
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Illoc
                  Data.Grammar.$fEqIlloc_$c==
                  Data.Grammar.$fEqIlloc_$c/= -}
e079181c6cea1e829f70da22fe08f7df
  $fEqIlloc_$c/= ::
    Data.Grammar.Illoc -> Data.Grammar.Illoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Grammar.Illoc)
                   (b :: Data.Grammar.Illoc) ->
                 case a of wild {
                   Data.Grammar.Null
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Grammar.Null -> GHC.Types.False }
                   Data.Grammar.Ques
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Grammar.Ques -> GHC.Types.False }
                   Data.Grammar.Decl
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Grammar.Decl -> GHC.Types.False }
                   Data.Grammar.Imper
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Grammar.Imper -> GHC.Types.False } }) -}
e079181c6cea1e829f70da22fe08f7df
  $fEqIlloc_$c== ::
    Data.Grammar.Illoc -> Data.Grammar.Illoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Grammar.Illoc)
                   (ds1 :: Data.Grammar.Illoc) ->
                 case ds of wild {
                   Data.Grammar.Null
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Grammar.Null -> GHC.Types.True }
                   Data.Grammar.Ques
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Grammar.Ques -> GHC.Types.True }
                   Data.Grammar.Decl
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Grammar.Decl -> GHC.Types.True }
                   Data.Grammar.Imper
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Grammar.Imper -> GHC.Types.True } }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEqItoCMovement :: GHC.Classes.Eq Data.Grammar.ItoCMovement
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ItoCMovement
                  Data.Grammar.$fEqItoCMovement_$c==
                  Data.Grammar.$fEqItoCMovement_$c/= -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEqItoCMovement_$c/= ::
    Data.Grammar.ItoCMovement
    -> Data.Grammar.ItoCMovement -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.ItoCMovement)
                   (b :: Data.Grammar.ItoCMovement) ->
                 case a of wild {
                   Data.Grammar.NoItoCMove
                   -> case b of wild1 {
                        Data.Grammar.NoItoCMove -> GHC.Types.False
                        Data.Grammar.OblItoCMove -> GHC.Types.True }
                   Data.Grammar.OblItoCMove
                   -> case b of wild1 {
                        Data.Grammar.NoItoCMove -> GHC.Types.True
                        Data.Grammar.OblItoCMove -> GHC.Types.False } }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fEqItoCMovement_$c== ::
    Data.Grammar.ItoCMovement
    -> Data.Grammar.ItoCMovement -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.ItoCMovement)
                   (ds1 :: Data.Grammar.ItoCMovement) ->
                 case ds of wild {
                   Data.Grammar.NoItoCMove
                   -> case ds1 of wild1 {
                        Data.Grammar.NoItoCMove -> GHC.Types.True
                        Data.Grammar.OblItoCMove -> GHC.Types.False }
                   Data.Grammar.OblItoCMove
                   -> case ds1 of wild1 {
                        Data.Grammar.NoItoCMove -> GHC.Types.False
                        Data.Grammar.OblItoCMove -> GHC.Types.True } }) -}
6a5bee7bd58c76567dc95d127514df54
  $fEqLeaf :: GHC.Classes.Eq Data.Grammar.Leaf
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Leaf
                  Data.Grammar.$fEqLeaf_$c==
                  Data.Grammar.$fEqLeaf_$c/= -}
6a5bee7bd58c76567dc95d127514df54
  $fEqLeaf_$c/= ::
    Data.Grammar.Leaf -> Data.Grammar.Leaf -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.Leaf) (b :: Data.Grammar.Leaf) ->
                 case Data.Grammar.$fEqLeaf_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
6a5bee7bd58c76567dc95d127514df54
  $fEqLeaf_$c== ::
    Data.Grammar.Leaf -> Data.Grammar.Leaf -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
c268ade9ae4c288b84a762a1c162513f
  $fEqNullSubject :: GHC.Classes.Eq Data.Grammar.NullSubject
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.NullSubject
                  Data.Grammar.$fEqNullSubject_$c==
                  Data.Grammar.$fEqNullSubject_$c/= -}
c268ade9ae4c288b84a762a1c162513f
  $fEqNullSubject_$c/= ::
    Data.Grammar.NullSubject
    -> Data.Grammar.NullSubject -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.NullSubject)
                   (b :: Data.Grammar.NullSubject) ->
                 case a of wild {
                   Data.Grammar.NoNullSub
                   -> case b of wild1 {
                        Data.Grammar.NoNullSub -> GHC.Types.False
                        Data.Grammar.OptNullSub -> GHC.Types.True }
                   Data.Grammar.OptNullSub
                   -> case b of wild1 {
                        Data.Grammar.NoNullSub -> GHC.Types.True
                        Data.Grammar.OptNullSub -> GHC.Types.False } }) -}
c268ade9ae4c288b84a762a1c162513f
  $fEqNullSubject_$c== ::
    Data.Grammar.NullSubject
    -> Data.Grammar.NullSubject -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.NullSubject)
                   (ds1 :: Data.Grammar.NullSubject) ->
                 case ds of wild {
                   Data.Grammar.NoNullSub
                   -> case ds1 of wild1 {
                        Data.Grammar.NoNullSub -> GHC.Types.True
                        Data.Grammar.OptNullSub -> GHC.Types.False }
                   Data.Grammar.OptNullSub
                   -> case ds1 of wild1 {
                        Data.Grammar.NoNullSub -> GHC.Types.False
                        Data.Grammar.OptNullSub -> GHC.Types.True } }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEqNullTopic :: GHC.Classes.Eq Data.Grammar.NullTopic
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.NullTopic
                  Data.Grammar.$fEqNullTopic_$c==
                  Data.Grammar.$fEqNullTopic_$c/= -}
052b3f964abdaf4269e4020caa0083ce
  $fEqNullTopic_$c/= ::
    Data.Grammar.NullTopic -> Data.Grammar.NullTopic -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.NullTopic) (b :: Data.Grammar.NullTopic) ->
                 case a of wild {
                   Data.Grammar.NoNullTop
                   -> case b of wild1 {
                        Data.Grammar.NoNullTop -> GHC.Types.False
                        Data.Grammar.OptNullTop -> GHC.Types.True }
                   Data.Grammar.OptNullTop
                   -> case b of wild1 {
                        Data.Grammar.NoNullTop -> GHC.Types.True
                        Data.Grammar.OptNullTop -> GHC.Types.False } }) -}
052b3f964abdaf4269e4020caa0083ce
  $fEqNullTopic_$c== ::
    Data.Grammar.NullTopic -> Data.Grammar.NullTopic -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.NullTopic)
                   (ds1 :: Data.Grammar.NullTopic) ->
                 case ds of wild {
                   Data.Grammar.NoNullTop
                   -> case ds1 of wild1 {
                        Data.Grammar.NoNullTop -> GHC.Types.True
                        Data.Grammar.OptNullTop -> GHC.Types.False }
                   Data.Grammar.OptNullTop
                   -> case ds1 of wild1 {
                        Data.Grammar.NoNullTop -> GHC.Types.False
                        Data.Grammar.OptNullTop -> GHC.Types.True } }) -}
5690ac32557ef5d251bb18590690680b
  $fEqObjectFinal :: GHC.Classes.Eq Data.Grammar.ObjectFinal
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ObjectFinal
                  Data.Grammar.$fEqObjectFinal_$c==
                  Data.Grammar.$fEqObjectFinal_$c/= -}
5690ac32557ef5d251bb18590690680b
  $fEqObjectFinal_$c/= ::
    Data.Grammar.ObjectFinal
    -> Data.Grammar.ObjectFinal -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.ObjectFinal)
                   (b :: Data.Grammar.ObjectFinal) ->
                 case a of wild {
                   Data.Grammar.ObjFinal
                   -> case b of wild1 {
                        Data.Grammar.ObjFinal -> GHC.Types.False
                        Data.Grammar.ObjInitial -> GHC.Types.True }
                   Data.Grammar.ObjInitial
                   -> case b of wild1 {
                        Data.Grammar.ObjFinal -> GHC.Types.True
                        Data.Grammar.ObjInitial -> GHC.Types.False } }) -}
5690ac32557ef5d251bb18590690680b
  $fEqObjectFinal_$c== ::
    Data.Grammar.ObjectFinal
    -> Data.Grammar.ObjectFinal -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.ObjectFinal)
                   (ds1 :: Data.Grammar.ObjectFinal) ->
                 case ds of wild {
                   Data.Grammar.ObjFinal
                   -> case ds1 of wild1 {
                        Data.Grammar.ObjFinal -> GHC.Types.True
                        Data.Grammar.ObjInitial -> GHC.Types.False }
                   Data.Grammar.ObjInitial
                   -> case ds1 of wild1 {
                        Data.Grammar.ObjFinal -> GHC.Types.False
                        Data.Grammar.ObjInitial -> GHC.Types.True } }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEqObligatoryTopic :: GHC.Classes.Eq Data.Grammar.ObligatoryTopic
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ObligatoryTopic
                  Data.Grammar.$fEqObligatoryTopic_$c==
                  Data.Grammar.$fEqObligatoryTopic_$c/= -}
934ac344d29b59a815d4a00caa639ae9
  $fEqObligatoryTopic_$c/= ::
    Data.Grammar.ObligatoryTopic
    -> Data.Grammar.ObligatoryTopic -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.ObligatoryTopic)
                   (b :: Data.Grammar.ObligatoryTopic) ->
                 case a of wild {
                   Data.Grammar.OblTopic
                   -> case b of wild1 {
                        Data.Grammar.OblTopic -> GHC.Types.False
                        Data.Grammar.OptTopic -> GHC.Types.True }
                   Data.Grammar.OptTopic
                   -> case b of wild1 {
                        Data.Grammar.OblTopic -> GHC.Types.True
                        Data.Grammar.OptTopic -> GHC.Types.False } }) -}
934ac344d29b59a815d4a00caa639ae9
  $fEqObligatoryTopic_$c== ::
    Data.Grammar.ObligatoryTopic
    -> Data.Grammar.ObligatoryTopic -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.ObligatoryTopic)
                   (ds1 :: Data.Grammar.ObligatoryTopic) ->
                 case ds of wild {
                   Data.Grammar.OblTopic
                   -> case ds1 of wild1 {
                        Data.Grammar.OblTopic -> GHC.Types.True
                        Data.Grammar.OptTopic -> GHC.Types.False }
                   Data.Grammar.OptTopic
                   -> case ds1 of wild1 {
                        Data.Grammar.OblTopic -> GHC.Types.False
                        Data.Grammar.OptTopic -> GHC.Types.True } }) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fEqPhrase :: GHC.Classes.Eq Data.Grammar.Phrase
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Phrase
                  Data.Grammar.$fEqPhrase_$c==
                  Data.Grammar.$fEqPhrase_$c/= -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fEqPhrase_$c/= ::
    Data.Grammar.Phrase -> Data.Grammar.Phrase -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.Phrase) (b :: Data.Grammar.Phrase) ->
                 case Data.Grammar.$fEqPhrase_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fEqPhrase_$c== ::
    Data.Grammar.Phrase -> Data.Grammar.Phrase -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEqPiedPiping :: GHC.Classes.Eq Data.Grammar.PiedPiping
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.PiedPiping
                  Data.Grammar.$fEqPiedPiping_$c==
                  Data.Grammar.$fEqPiedPiping_$c/= -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEqPiedPiping_$c/= ::
    Data.Grammar.PiedPiping
    -> Data.Grammar.PiedPiping -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.PiedPiping) (b :: Data.Grammar.PiedPiping) ->
                 case a of wild {
                   Data.Grammar.PiedPipe
                   -> case b of wild1 {
                        Data.Grammar.PiedPipe -> GHC.Types.False
                        Data.Grammar.PrepStrand -> GHC.Types.True }
                   Data.Grammar.PrepStrand
                   -> case b of wild1 {
                        Data.Grammar.PiedPipe -> GHC.Types.True
                        Data.Grammar.PrepStrand -> GHC.Types.False } }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fEqPiedPiping_$c== ::
    Data.Grammar.PiedPiping
    -> Data.Grammar.PiedPiping -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.PiedPiping)
                   (ds1 :: Data.Grammar.PiedPiping) ->
                 case ds of wild {
                   Data.Grammar.PiedPipe
                   -> case ds1 of wild1 {
                        Data.Grammar.PiedPipe -> GHC.Types.True
                        Data.Grammar.PrepStrand -> GHC.Types.False }
                   Data.Grammar.PrepStrand
                   -> case ds1 of wild1 {
                        Data.Grammar.PiedPipe -> GHC.Types.False
                        Data.Grammar.PrepStrand -> GHC.Types.True } }) -}
dee16e043daf097681c2796c283f597a
  $fEqQuestionInversion ::
    GHC.Classes.Eq Data.Grammar.QuestionInversion
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.QuestionInversion
                  Data.Grammar.$fEqQuestionInversion_$c==
                  Data.Grammar.$fEqQuestionInversion_$c/= -}
dee16e043daf097681c2796c283f597a
  $fEqQuestionInversion_$c/= ::
    Data.Grammar.QuestionInversion
    -> Data.Grammar.QuestionInversion -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.QuestionInversion)
                   (b :: Data.Grammar.QuestionInversion) ->
                 case a of wild {
                   Data.Grammar.NoQuesInv
                   -> case b of wild1 {
                        Data.Grammar.NoQuesInv -> GHC.Types.False
                        Data.Grammar.OblQuesInv -> GHC.Types.True }
                   Data.Grammar.OblQuesInv
                   -> case b of wild1 {
                        Data.Grammar.NoQuesInv -> GHC.Types.True
                        Data.Grammar.OblQuesInv -> GHC.Types.False } }) -}
dee16e043daf097681c2796c283f597a
  $fEqQuestionInversion_$c== ::
    Data.Grammar.QuestionInversion
    -> Data.Grammar.QuestionInversion -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.QuestionInversion)
                   (ds1 :: Data.Grammar.QuestionInversion) ->
                 case ds of wild {
                   Data.Grammar.NoQuesInv
                   -> case ds1 of wild1 {
                        Data.Grammar.NoQuesInv -> GHC.Types.True
                        Data.Grammar.OblQuesInv -> GHC.Types.False }
                   Data.Grammar.OblQuesInv
                   -> case ds1 of wild1 {
                        Data.Grammar.NoQuesInv -> GHC.Types.False
                        Data.Grammar.OblQuesInv -> GHC.Types.True } }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEqSubjectInitial :: GHC.Classes.Eq Data.Grammar.SubjectInitial
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.SubjectInitial
                  Data.Grammar.$fEqSubjectInitial_$c==
                  Data.Grammar.$fEqSubjectInitial_$c/= -}
872e11e1b82c550480a8f63d2a4025ab
  $fEqSubjectInitial_$c/= ::
    Data.Grammar.SubjectInitial
    -> Data.Grammar.SubjectInitial -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.SubjectInitial)
                   (b :: Data.Grammar.SubjectInitial) ->
                 case a of wild {
                   Data.Grammar.SubInitial
                   -> case b of wild1 {
                        Data.Grammar.SubInitial -> GHC.Types.False
                        Data.Grammar.SubFinal -> GHC.Types.True }
                   Data.Grammar.SubFinal
                   -> case b of wild1 {
                        Data.Grammar.SubInitial -> GHC.Types.True
                        Data.Grammar.SubFinal -> GHC.Types.False } }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fEqSubjectInitial_$c== ::
    Data.Grammar.SubjectInitial
    -> Data.Grammar.SubjectInitial -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.SubjectInitial)
                   (ds1 :: Data.Grammar.SubjectInitial) ->
                 case ds of wild {
                   Data.Grammar.SubInitial
                   -> case ds1 of wild1 {
                        Data.Grammar.SubInitial -> GHC.Types.True
                        Data.Grammar.SubFinal -> GHC.Types.False }
                   Data.Grammar.SubFinal
                   -> case ds1 of wild1 {
                        Data.Grammar.SubInitial -> GHC.Types.False
                        Data.Grammar.SubFinal -> GHC.Types.True } }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEqTopicMarking :: GHC.Classes.Eq Data.Grammar.TopicMarking
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.TopicMarking
                  Data.Grammar.$fEqTopicMarking_$c==
                  Data.Grammar.$fEqTopicMarking_$c/= -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEqTopicMarking_$c/= ::
    Data.Grammar.TopicMarking
    -> Data.Grammar.TopicMarking -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.TopicMarking)
                   (b :: Data.Grammar.TopicMarking) ->
                 case a of wild {
                   Data.Grammar.NoTopMark
                   -> case b of wild1 {
                        Data.Grammar.NoTopMark -> GHC.Types.False
                        Data.Grammar.OblTopMark -> GHC.Types.True }
                   Data.Grammar.OblTopMark
                   -> case b of wild1 {
                        Data.Grammar.NoTopMark -> GHC.Types.True
                        Data.Grammar.OblTopMark -> GHC.Types.False } }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fEqTopicMarking_$c== ::
    Data.Grammar.TopicMarking
    -> Data.Grammar.TopicMarking -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.TopicMarking)
                   (ds1 :: Data.Grammar.TopicMarking) ->
                 case ds of wild {
                   Data.Grammar.NoTopMark
                   -> case ds1 of wild1 {
                        Data.Grammar.NoTopMark -> GHC.Types.True
                        Data.Grammar.OblTopMark -> GHC.Types.False }
                   Data.Grammar.OblTopMark
                   -> case ds1 of wild1 {
                        Data.Grammar.NoTopMark -> GHC.Types.False
                        Data.Grammar.OblTopMark -> GHC.Types.True } }) -}
26726f546091d6e0b9a4e728fd464566
  $fEqVtoIMovement :: GHC.Classes.Eq Data.Grammar.VtoIMovement
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.VtoIMovement
                  Data.Grammar.$fEqVtoIMovement_$c==
                  Data.Grammar.$fEqVtoIMovement_$c/= -}
26726f546091d6e0b9a4e728fd464566
  $fEqVtoIMovement_$c/= ::
    Data.Grammar.VtoIMovement
    -> Data.Grammar.VtoIMovement -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.VtoIMovement)
                   (b :: Data.Grammar.VtoIMovement) ->
                 case a of wild {
                   Data.Grammar.NoVtoIMove
                   -> case b of wild1 {
                        Data.Grammar.NoVtoIMove -> GHC.Types.False
                        Data.Grammar.OblVtoIMove -> GHC.Types.True }
                   Data.Grammar.OblVtoIMove
                   -> case b of wild1 {
                        Data.Grammar.NoVtoIMove -> GHC.Types.True
                        Data.Grammar.OblVtoIMove -> GHC.Types.False } }) -}
26726f546091d6e0b9a4e728fd464566
  $fEqVtoIMovement_$c== ::
    Data.Grammar.VtoIMovement
    -> Data.Grammar.VtoIMovement -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.VtoIMovement)
                   (ds1 :: Data.Grammar.VtoIMovement) ->
                 case ds of wild {
                   Data.Grammar.NoVtoIMove
                   -> case ds1 of wild1 {
                        Data.Grammar.NoVtoIMove -> GHC.Types.True
                        Data.Grammar.OblVtoIMove -> GHC.Types.False }
                   Data.Grammar.OblVtoIMove
                   -> case ds1 of wild1 {
                        Data.Grammar.NoVtoIMove -> GHC.Types.False
                        Data.Grammar.OblVtoIMove -> GHC.Types.True } }) -}
b81b310f32810f84d11d228d1654c597
  $fEqWHMovementObligatory ::
    GHC.Classes.Eq Data.Grammar.WHMovementObligatory
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.WHMovementObligatory
                  Data.Grammar.$fEqWHMovementObligatory_$c==
                  Data.Grammar.$fEqWHMovementObligatory_$c/= -}
b81b310f32810f84d11d228d1654c597
  $fEqWHMovementObligatory_$c/= ::
    Data.Grammar.WHMovementObligatory
    -> Data.Grammar.WHMovementObligatory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Grammar.WHMovementObligatory)
                   (b :: Data.Grammar.WHMovementObligatory) ->
                 case a of wild {
                   Data.Grammar.NoWHMove
                   -> case b of wild1 {
                        Data.Grammar.NoWHMove -> GHC.Types.False
                        Data.Grammar.OblWHMove -> GHC.Types.True }
                   Data.Grammar.OblWHMove
                   -> case b of wild1 {
                        Data.Grammar.NoWHMove -> GHC.Types.True
                        Data.Grammar.OblWHMove -> GHC.Types.False } }) -}
b81b310f32810f84d11d228d1654c597
  $fEqWHMovementObligatory_$c== ::
    Data.Grammar.WHMovementObligatory
    -> Data.Grammar.WHMovementObligatory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.WHMovementObligatory)
                   (ds1 :: Data.Grammar.WHMovementObligatory) ->
                 case ds of wild {
                   Data.Grammar.NoWHMove
                   -> case ds1 of wild1 {
                        Data.Grammar.NoWHMove -> GHC.Types.True
                        Data.Grammar.OblWHMove -> GHC.Types.False }
                   Data.Grammar.OblWHMove
                   -> case ds1 of wild1 {
                        Data.Grammar.NoWHMove -> GHC.Types.False
                        Data.Grammar.OblWHMove -> GHC.Types.True } }) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping :: GHC.Read.Read Data.Grammar.AffixHopping
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.AffixHopping
                  Data.Grammar.$fReadAffixHopping_$creadsPrec
                  Data.Grammar.$fReadAffixHopping_$creadList
                  Data.Grammar.$fReadAffixHopping_$creadPrec
                  Data.Grammar.$fReadAffixHopping_$creadListPrec -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.AffixHopping] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.AffixHopping]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.AffixHopping
                   Data.Grammar.$fReadAffixHopping2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.AffixHopping>_R))
                   @ b
                   eta1) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.AffixHopping -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.AffixHopping
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.NoAffixHop) -}
40382c1c849cf27f0ec0030e4616463c
  $fReadAffixHopping11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoAffixHop"#) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.AffixHopping]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.AffixHopping
                   Data.Grammar.$fReadAffixHopping2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.AffixHopping>_R))
                   @ [Data.Grammar.AffixHopping]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.AffixHopping])) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.AffixHopping
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.AffixHopping
                   Data.Grammar.$fReadAffixHopping3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.AffixHopping>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.AffixHopping>_R)))) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.AffixHopping -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.AffixHopping
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.AffixHopping
                   Data.Grammar.$fReadAffixHopping4
                   eta
                   @ b
                   eta1) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.AffixHopping)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.AffixHopping)
                   Data.Grammar.$fReadAffixHopping9
                   Data.Grammar.$fReadAffixHopping5) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.AffixHopping)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.AffixHopping)
                   Data.Grammar.$fReadAffixHopping6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.AffixHopping))) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.AffixHopping)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadAffixHopping8,
                  Data.Grammar.$fReadAffixHopping7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.AffixHopping>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.AffixHopping>_R))))) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.AffixHopping -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.AffixHopping
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OblAffixHop) -}
d9108dd8d8bd7c8d0be5b705a1182888
  $fReadAffixHopping8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OblAffixHop"#) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.AffixHopping)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadAffixHopping11,
                  Data.Grammar.$fReadAffixHopping10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.AffixHopping>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.AffixHopping>_R))))) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.AffixHopping]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.AffixHopping]
                   Data.Grammar.$fReadAffixHopping12) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.AffixHopping]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadAffixHopping1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.AffixHopping]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.AffixHopping]>_R))) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.AffixHopping
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadAffixHopping2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.AffixHopping>_R)) -}
0ff7119050f64558eef1b9b6c65db897
  $fReadAffixHopping_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.AffixHopping
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.AffixHopping
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.AffixHopping
                       Data.Grammar.$fReadAffixHopping3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.AffixHopping>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.AffixHopping>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.AffixHopping>_R)
                      @ Data.Grammar.AffixHopping
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.AffixHopping))) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial ::
    GHC.Read.Read Data.Grammar.ComplementizerInitial
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ComplementizerInitial
                  Data.Grammar.$fReadComplementizerInitial_$creadsPrec
                  Data.Grammar.$fReadComplementizerInitial_$creadList
                  Data.Grammar.$fReadComplementizerInitial_$creadPrec
                  Data.Grammar.$fReadComplementizerInitial_$creadListPrec -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.ComplementizerInitial]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.ComplementizerInitial]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.ComplementizerInitial
                   Data.Grammar.$fReadComplementizerInitial2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.ComplementizerInitial>_R))
                   @ b
                   eta1) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ComplementizerInitial
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.ComplementizerInitial
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.CompInitial) -}
c989cae6585ab13dee4cfa61cae004ad
  $fReadComplementizerInitial11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CompInitial"#) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.ComplementizerInitial]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.ComplementizerInitial
                   Data.Grammar.$fReadComplementizerInitial2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.ComplementizerInitial>_R))
                   @ [Data.Grammar.ComplementizerInitial]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.ComplementizerInitial])) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         Data.Grammar.ComplementizerInitial
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.ComplementizerInitial
                   Data.Grammar.$fReadComplementizerInitial3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.ComplementizerInitial>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.ComplementizerInitial>_R)))) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ComplementizerInitial
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.ComplementizerInitial
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.ComplementizerInitial
                   Data.Grammar.$fReadComplementizerInitial4
                   eta
                   @ b
                   eta1) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.ComplementizerInitial)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.ComplementizerInitial)
                   Data.Grammar.$fReadComplementizerInitial9
                   Data.Grammar.$fReadComplementizerInitial5) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.ComplementizerInitial)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.ComplementizerInitial)
                   Data.Grammar.$fReadComplementizerInitial6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.ComplementizerInitial))) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.ComplementizerInitial)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadComplementizerInitial8,
                  Data.Grammar.$fReadComplementizerInitial7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.ComplementizerInitial>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.ComplementizerInitial>_R))))) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ComplementizerInitial
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.ComplementizerInitial
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.CompFinal) -}
f73956d0a54f475fc111d8988dc24e97
  $fReadComplementizerInitial8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CompFinal"#) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.ComplementizerInitial)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadComplementizerInitial11,
                  Data.Grammar.$fReadComplementizerInitial10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.ComplementizerInitial>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.ComplementizerInitial>_R))))) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial_$creadList ::
    Text.ParserCombinators.ReadP.ReadS
      [Data.Grammar.ComplementizerInitial]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.ComplementizerInitial]
                   Data.Grammar.$fReadComplementizerInitial12) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.ComplementizerInitial]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadComplementizerInitial1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.ComplementizerInitial]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.ComplementizerInitial]>_R))) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Grammar.ComplementizerInitial
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadComplementizerInitial2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.ComplementizerInitial>_R)) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fReadComplementizerInitial_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         Data.Grammar.ComplementizerInitial
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.ComplementizerInitial
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.ComplementizerInitial
                       Data.Grammar.$fReadComplementizerInitial3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.ComplementizerInitial>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.ComplementizerInitial>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.ComplementizerInitial>_R)
                      @ Data.Grammar.ComplementizerInitial
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.ComplementizerInitial))) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement :: GHC.Read.Read Data.Grammar.ItoCMovement
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ItoCMovement
                  Data.Grammar.$fReadItoCMovement_$creadsPrec
                  Data.Grammar.$fReadItoCMovement_$creadList
                  Data.Grammar.$fReadItoCMovement_$creadPrec
                  Data.Grammar.$fReadItoCMovement_$creadListPrec -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.ItoCMovement] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.ItoCMovement]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.ItoCMovement
                   Data.Grammar.$fReadItoCMovement2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.ItoCMovement>_R))
                   @ b
                   eta1) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ItoCMovement -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.ItoCMovement
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.NoItoCMove) -}
ab3a2547a93d190084de5465eb5e9b5b
  $fReadItoCMovement11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoItoCMove"#) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.ItoCMovement]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.ItoCMovement
                   Data.Grammar.$fReadItoCMovement2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.ItoCMovement>_R))
                   @ [Data.Grammar.ItoCMovement]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.ItoCMovement])) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.ItoCMovement
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.ItoCMovement
                   Data.Grammar.$fReadItoCMovement3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.ItoCMovement>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.ItoCMovement>_R)))) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ItoCMovement -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.ItoCMovement
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.ItoCMovement
                   Data.Grammar.$fReadItoCMovement4
                   eta
                   @ b
                   eta1) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.ItoCMovement)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ItoCMovement)
                   Data.Grammar.$fReadItoCMovement9
                   Data.Grammar.$fReadItoCMovement5) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.ItoCMovement)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ItoCMovement)
                   Data.Grammar.$fReadItoCMovement6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.ItoCMovement))) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ItoCMovement)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadItoCMovement8,
                  Data.Grammar.$fReadItoCMovement7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.ItoCMovement>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.ItoCMovement>_R))))) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ItoCMovement -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.ItoCMovement
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OblItoCMove) -}
cfd36e94daf8ddabddc271c729fc81c3
  $fReadItoCMovement8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OblItoCMove"#) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ItoCMovement)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadItoCMovement11,
                  Data.Grammar.$fReadItoCMovement10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.ItoCMovement>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.ItoCMovement>_R))))) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.ItoCMovement]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.ItoCMovement]
                   Data.Grammar.$fReadItoCMovement12) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.ItoCMovement]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadItoCMovement1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.ItoCMovement]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.ItoCMovement]>_R))) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ItoCMovement
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadItoCMovement2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.ItoCMovement>_R)) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fReadItoCMovement_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.ItoCMovement
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.ItoCMovement
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.ItoCMovement
                       Data.Grammar.$fReadItoCMovement3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.ItoCMovement>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.ItoCMovement>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.ItoCMovement>_R)
                      @ Data.Grammar.ItoCMovement
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.ItoCMovement))) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject :: GHC.Read.Read Data.Grammar.NullSubject
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.NullSubject
                  Data.Grammar.$fReadNullSubject_$creadsPrec
                  Data.Grammar.$fReadNullSubject_$creadList
                  Data.Grammar.$fReadNullSubject_$creadPrec
                  Data.Grammar.$fReadNullSubject_$creadListPrec -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.NullSubject] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.NullSubject]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.NullSubject
                   Data.Grammar.$fReadNullSubject2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.NullSubject>_R))
                   @ b
                   eta1) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.NullSubject -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.NullSubject
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.NoNullSub) -}
0d11d97a519994d5598cad98f3bc5c8b
  $fReadNullSubject11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoNullSub"#) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.NullSubject]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.NullSubject
                   Data.Grammar.$fReadNullSubject2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.NullSubject>_R))
                   @ [Data.Grammar.NullSubject]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.NullSubject])) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.NullSubject
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.NullSubject
                   Data.Grammar.$fReadNullSubject3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.NullSubject>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.NullSubject>_R)))) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.NullSubject -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.NullSubject
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.NullSubject
                   Data.Grammar.$fReadNullSubject4
                   eta
                   @ b
                   eta1) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullSubject)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullSubject)
                   Data.Grammar.$fReadNullSubject9
                   Data.Grammar.$fReadNullSubject5) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullSubject)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullSubject)
                   Data.Grammar.$fReadNullSubject6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.NullSubject))) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullSubject)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadNullSubject8,
                  Data.Grammar.$fReadNullSubject7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.NullSubject>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.NullSubject>_R))))) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.NullSubject -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.NullSubject
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OptNullSub) -}
66ca6252b3d8d8f06df88cf068e75cf0
  $fReadNullSubject8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OptNullSub"#) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullSubject)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadNullSubject11,
                  Data.Grammar.$fReadNullSubject10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.NullSubject>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.NullSubject>_R))))) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.NullSubject]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.NullSubject]
                   Data.Grammar.$fReadNullSubject12) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Grammar.NullSubject]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadNullSubject1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.NullSubject]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.NullSubject]>_R))) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullSubject
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadNullSubject2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.NullSubject>_R)) -}
c268ade9ae4c288b84a762a1c162513f
  $fReadNullSubject_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.NullSubject
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.NullSubject
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.NullSubject
                       Data.Grammar.$fReadNullSubject3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.NullSubject>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.NullSubject>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.NullSubject>_R)
                      @ Data.Grammar.NullSubject
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.NullSubject))) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic :: GHC.Read.Read Data.Grammar.NullTopic
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.NullTopic
                  Data.Grammar.$fReadNullTopic_$creadsPrec
                  Data.Grammar.$fReadNullTopic_$creadList
                  Data.Grammar.$fReadNullTopic_$creadPrec
                  Data.Grammar.$fReadNullTopic_$creadListPrec -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.NullTopic] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.NullTopic]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.NullTopic
                   Data.Grammar.$fReadNullTopic2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.NullTopic>_R))
                   @ b
                   eta1) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.NullTopic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.NullTopic
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.NoNullTop) -}
cc89d52fd930b02ec5ebc5d56d6c5b4d
  $fReadNullTopic11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoNullTop"#) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.NullTopic]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.NullTopic
                   Data.Grammar.$fReadNullTopic2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.NullTopic>_R))
                   @ [Data.Grammar.NullTopic]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.NullTopic])) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.NullTopic
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.NullTopic
                   Data.Grammar.$fReadNullTopic3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.NullTopic>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.NullTopic>_R)))) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.NullTopic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.NullTopic
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.NullTopic
                   Data.Grammar.$fReadNullTopic4
                   eta
                   @ b
                   eta1) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullTopic)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullTopic)
                   Data.Grammar.$fReadNullTopic9
                   Data.Grammar.$fReadNullTopic5) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullTopic)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullTopic)
                   Data.Grammar.$fReadNullTopic6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.NullTopic))) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullTopic)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadNullTopic8,
                  Data.Grammar.$fReadNullTopic7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.NullTopic>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.NullTopic>_R))))) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.NullTopic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.NullTopic
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OptNullTop) -}
3b376d3c163f652f200232cb6c74d9e8
  $fReadNullTopic8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OptNullTop"#) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullTopic)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadNullTopic11,
                  Data.Grammar.$fReadNullTopic10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.NullTopic>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.NullTopic>_R))))) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.NullTopic]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.NullTopic]
                   Data.Grammar.$fReadNullTopic12) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Grammar.NullTopic]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadNullTopic1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.NullTopic]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.NullTopic]>_R))) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.NullTopic
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadNullTopic2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.NullTopic>_R)) -}
052b3f964abdaf4269e4020caa0083ce
  $fReadNullTopic_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.NullTopic
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.NullTopic
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.NullTopic
                       Data.Grammar.$fReadNullTopic3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.NullTopic>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.NullTopic>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.NullTopic>_R)
                      @ Data.Grammar.NullTopic
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.NullTopic))) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal :: GHC.Read.Read Data.Grammar.ObjectFinal
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ObjectFinal
                  Data.Grammar.$fReadObjectFinal_$creadsPrec
                  Data.Grammar.$fReadObjectFinal_$creadList
                  Data.Grammar.$fReadObjectFinal_$creadPrec
                  Data.Grammar.$fReadObjectFinal_$creadListPrec -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.ObjectFinal] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.ObjectFinal]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.ObjectFinal
                   Data.Grammar.$fReadObjectFinal2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.ObjectFinal>_R))
                   @ b
                   eta1) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ObjectFinal -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.ObjectFinal
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.ObjFinal) -}
89f516b5575d02e84bdc5a167bb28969
  $fReadObjectFinal11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ObjFinal"#) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.ObjectFinal]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.ObjectFinal
                   Data.Grammar.$fReadObjectFinal2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.ObjectFinal>_R))
                   @ [Data.Grammar.ObjectFinal]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.ObjectFinal])) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.ObjectFinal
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.ObjectFinal
                   Data.Grammar.$fReadObjectFinal3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.ObjectFinal>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.ObjectFinal>_R)))) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ObjectFinal -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.ObjectFinal
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.ObjectFinal
                   Data.Grammar.$fReadObjectFinal4
                   eta
                   @ b
                   eta1) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ObjectFinal)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ObjectFinal)
                   Data.Grammar.$fReadObjectFinal9
                   Data.Grammar.$fReadObjectFinal5) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ObjectFinal)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ObjectFinal)
                   Data.Grammar.$fReadObjectFinal6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.ObjectFinal))) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ObjectFinal)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadObjectFinal8,
                  Data.Grammar.$fReadObjectFinal7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.ObjectFinal>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.ObjectFinal>_R))))) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ObjectFinal -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.ObjectFinal
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.ObjInitial) -}
d35b9dfb7b79189992ccaf88f982563b
  $fReadObjectFinal8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ObjInitial"#) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ObjectFinal)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadObjectFinal11,
                  Data.Grammar.$fReadObjectFinal10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.ObjectFinal>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.ObjectFinal>_R))))) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.ObjectFinal]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.ObjectFinal]
                   Data.Grammar.$fReadObjectFinal12) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Grammar.ObjectFinal]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadObjectFinal1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.ObjectFinal]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.ObjectFinal]>_R))) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.ObjectFinal
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadObjectFinal2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.ObjectFinal>_R)) -}
5690ac32557ef5d251bb18590690680b
  $fReadObjectFinal_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.ObjectFinal
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.ObjectFinal
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.ObjectFinal
                       Data.Grammar.$fReadObjectFinal3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.ObjectFinal>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.ObjectFinal>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.ObjectFinal>_R)
                      @ Data.Grammar.ObjectFinal
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.ObjectFinal))) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic :: GHC.Read.Read Data.Grammar.ObligatoryTopic
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ObligatoryTopic
                  Data.Grammar.$fReadObligatoryTopic_$creadsPrec
                  Data.Grammar.$fReadObligatoryTopic_$creadList
                  Data.Grammar.$fReadObligatoryTopic_$creadPrec
                  Data.Grammar.$fReadObligatoryTopic_$creadListPrec -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.ObligatoryTopic]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.ObligatoryTopic]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.ObligatoryTopic
                   Data.Grammar.$fReadObligatoryTopic2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.ObligatoryTopic>_R))
                   @ b
                   eta1) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ObligatoryTopic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.ObligatoryTopic
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OblTopic) -}
42962cabfb80c0ed1cb77aa323a07830
  $fReadObligatoryTopic11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OblTopic"#) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.ObligatoryTopic]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.ObligatoryTopic
                   Data.Grammar.$fReadObligatoryTopic2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.ObligatoryTopic>_R))
                   @ [Data.Grammar.ObligatoryTopic]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.ObligatoryTopic])) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.ObligatoryTopic
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.ObligatoryTopic
                   Data.Grammar.$fReadObligatoryTopic3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.ObligatoryTopic>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.ObligatoryTopic>_R)))) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ObligatoryTopic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.ObligatoryTopic
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.ObligatoryTopic
                   Data.Grammar.$fReadObligatoryTopic4
                   eta
                   @ b
                   eta1) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.ObligatoryTopic)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.ObligatoryTopic)
                   Data.Grammar.$fReadObligatoryTopic9
                   Data.Grammar.$fReadObligatoryTopic5) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.ObligatoryTopic)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.ObligatoryTopic)
                   Data.Grammar.$fReadObligatoryTopic6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.ObligatoryTopic))) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.ObligatoryTopic)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadObligatoryTopic8,
                  Data.Grammar.$fReadObligatoryTopic7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.ObligatoryTopic>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.ObligatoryTopic>_R))))) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.ObligatoryTopic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.ObligatoryTopic
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OptTopic) -}
fa81fe69217a04bf417fa9fff784183b
  $fReadObligatoryTopic8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OptTopic"#) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.ObligatoryTopic)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadObligatoryTopic11,
                  Data.Grammar.$fReadObligatoryTopic10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.ObligatoryTopic>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.ObligatoryTopic>_R))))) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.ObligatoryTopic]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.ObligatoryTopic]
                   Data.Grammar.$fReadObligatoryTopic12) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.ObligatoryTopic]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadObligatoryTopic1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.ObligatoryTopic]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.ObligatoryTopic]>_R))) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Grammar.ObligatoryTopic
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadObligatoryTopic2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.ObligatoryTopic>_R)) -}
934ac344d29b59a815d4a00caa639ae9
  $fReadObligatoryTopic_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.ObligatoryTopic
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.ObligatoryTopic
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.ObligatoryTopic
                       Data.Grammar.$fReadObligatoryTopic3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.ObligatoryTopic>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.ObligatoryTopic>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.ObligatoryTopic>_R)
                      @ Data.Grammar.ObligatoryTopic
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.ObligatoryTopic))) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping :: GHC.Read.Read Data.Grammar.PiedPiping
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.PiedPiping
                  Data.Grammar.$fReadPiedPiping_$creadsPrec
                  Data.Grammar.$fReadPiedPiping_$creadList
                  Data.Grammar.$fReadPiedPiping_$creadPrec
                  Data.Grammar.$fReadPiedPiping_$creadListPrec -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.PiedPiping] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.PiedPiping]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.PiedPiping
                   Data.Grammar.$fReadPiedPiping2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.PiedPiping>_R))
                   @ b
                   eta1) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.PiedPiping -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.PiedPiping
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.PiedPipe) -}
a756b55805735aad7e9c65729cb43eb9
  $fReadPiedPiping11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PiedPipe"#) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.PiedPiping]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.PiedPiping
                   Data.Grammar.$fReadPiedPiping2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.PiedPiping>_R))
                   @ [Data.Grammar.PiedPiping]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.PiedPiping])) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.PiedPiping
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.PiedPiping
                   Data.Grammar.$fReadPiedPiping3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.PiedPiping>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.PiedPiping>_R)))) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.PiedPiping -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.PiedPiping
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.PiedPiping
                   Data.Grammar.$fReadPiedPiping4
                   eta
                   @ b
                   eta1) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.PiedPiping)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.PiedPiping)
                   Data.Grammar.$fReadPiedPiping9
                   Data.Grammar.$fReadPiedPiping5) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.PiedPiping)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.PiedPiping)
                   Data.Grammar.$fReadPiedPiping6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.PiedPiping))) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.PiedPiping)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadPiedPiping8,
                  Data.Grammar.$fReadPiedPiping7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.PiedPiping>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.PiedPiping>_R))))) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.PiedPiping -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.PiedPiping
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.PrepStrand) -}
00d9075889411c3d3a8c0cfd0039d188
  $fReadPiedPiping8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PrepStrand"#) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.PiedPiping)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadPiedPiping11,
                  Data.Grammar.$fReadPiedPiping10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.PiedPiping>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.PiedPiping>_R))))) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.PiedPiping]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.PiedPiping]
                   Data.Grammar.$fReadPiedPiping12) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Grammar.PiedPiping]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadPiedPiping1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.PiedPiping]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.PiedPiping]>_R))) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.PiedPiping
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadPiedPiping2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.PiedPiping>_R)) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fReadPiedPiping_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.PiedPiping
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.PiedPiping
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.PiedPiping
                       Data.Grammar.$fReadPiedPiping3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.PiedPiping>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.PiedPiping>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.PiedPiping>_R)
                      @ Data.Grammar.PiedPiping
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.PiedPiping))) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion ::
    GHC.Read.Read Data.Grammar.QuestionInversion
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.QuestionInversion
                  Data.Grammar.$fReadQuestionInversion_$creadsPrec
                  Data.Grammar.$fReadQuestionInversion_$creadList
                  Data.Grammar.$fReadQuestionInversion_$creadPrec
                  Data.Grammar.$fReadQuestionInversion_$creadListPrec -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.QuestionInversion]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.QuestionInversion]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.QuestionInversion
                   Data.Grammar.$fReadQuestionInversion2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.QuestionInversion>_R))
                   @ b
                   eta1) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.QuestionInversion
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.QuestionInversion
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.NoQuesInv) -}
ee9168b13242e78e132df482ef0027aa
  $fReadQuestionInversion11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoQuesInv"#) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.QuestionInversion]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.QuestionInversion
                   Data.Grammar.$fReadQuestionInversion2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.QuestionInversion>_R))
                   @ [Data.Grammar.QuestionInversion]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.QuestionInversion])) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         Data.Grammar.QuestionInversion
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.QuestionInversion
                   Data.Grammar.$fReadQuestionInversion3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.QuestionInversion>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.QuestionInversion>_R)))) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.QuestionInversion
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.QuestionInversion
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.QuestionInversion
                   Data.Grammar.$fReadQuestionInversion4
                   eta
                   @ b
                   eta1) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.QuestionInversion)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.QuestionInversion)
                   Data.Grammar.$fReadQuestionInversion9
                   Data.Grammar.$fReadQuestionInversion5) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.QuestionInversion)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.QuestionInversion)
                   Data.Grammar.$fReadQuestionInversion6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.QuestionInversion))) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.QuestionInversion)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadQuestionInversion8,
                  Data.Grammar.$fReadQuestionInversion7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.QuestionInversion>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.QuestionInversion>_R))))) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.QuestionInversion
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.QuestionInversion
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OblQuesInv) -}
bc50965efa44ef193bb51d290fab1767
  $fReadQuestionInversion8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OblQuesInv"#) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.QuestionInversion)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadQuestionInversion11,
                  Data.Grammar.$fReadQuestionInversion10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.QuestionInversion>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.QuestionInversion>_R))))) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.QuestionInversion]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.QuestionInversion]
                   Data.Grammar.$fReadQuestionInversion12) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.QuestionInversion]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadQuestionInversion1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.QuestionInversion]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.QuestionInversion]>_R))) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Grammar.QuestionInversion
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadQuestionInversion2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.QuestionInversion>_R)) -}
dee16e043daf097681c2796c283f597a
  $fReadQuestionInversion_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         Data.Grammar.QuestionInversion
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.QuestionInversion
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.QuestionInversion
                       Data.Grammar.$fReadQuestionInversion3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.QuestionInversion>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.QuestionInversion>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.QuestionInversion>_R)
                      @ Data.Grammar.QuestionInversion
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.QuestionInversion))) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial :: GHC.Read.Read Data.Grammar.SubjectInitial
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.SubjectInitial
                  Data.Grammar.$fReadSubjectInitial_$creadsPrec
                  Data.Grammar.$fReadSubjectInitial_$creadList
                  Data.Grammar.$fReadSubjectInitial_$creadPrec
                  Data.Grammar.$fReadSubjectInitial_$creadListPrec -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.SubjectInitial] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.SubjectInitial]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.SubjectInitial
                   Data.Grammar.$fReadSubjectInitial2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.SubjectInitial>_R))
                   @ b
                   eta1) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.SubjectInitial -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.SubjectInitial
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.SubInitial) -}
9e5a0fffabf9995931162d775c98225d
  $fReadSubjectInitial11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SubInitial"#) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.SubjectInitial]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.SubjectInitial
                   Data.Grammar.$fReadSubjectInitial2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.SubjectInitial>_R))
                   @ [Data.Grammar.SubjectInitial]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.SubjectInitial])) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.SubjectInitial
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.SubjectInitial
                   Data.Grammar.$fReadSubjectInitial3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.SubjectInitial>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.SubjectInitial>_R)))) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.SubjectInitial -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.SubjectInitial
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.SubjectInitial
                   Data.Grammar.$fReadSubjectInitial4
                   eta
                   @ b
                   eta1) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.SubjectInitial)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.SubjectInitial)
                   Data.Grammar.$fReadSubjectInitial9
                   Data.Grammar.$fReadSubjectInitial5) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.SubjectInitial)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.SubjectInitial)
                   Data.Grammar.$fReadSubjectInitial6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.SubjectInitial))) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.SubjectInitial)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadSubjectInitial8,
                  Data.Grammar.$fReadSubjectInitial7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.SubjectInitial>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.SubjectInitial>_R))))) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.SubjectInitial -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.SubjectInitial
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.SubFinal) -}
29689520ada1bc033d57bd4a7e2cf765
  $fReadSubjectInitial8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SubFinal"#) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.SubjectInitial)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadSubjectInitial11,
                  Data.Grammar.$fReadSubjectInitial10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.SubjectInitial>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.SubjectInitial>_R))))) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.SubjectInitial]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.SubjectInitial]
                   Data.Grammar.$fReadSubjectInitial12) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.SubjectInitial]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadSubjectInitial1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.SubjectInitial]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.SubjectInitial]>_R))) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Grammar.SubjectInitial
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadSubjectInitial2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.SubjectInitial>_R)) -}
872e11e1b82c550480a8f63d2a4025ab
  $fReadSubjectInitial_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.SubjectInitial
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.SubjectInitial
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.SubjectInitial
                       Data.Grammar.$fReadSubjectInitial3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.SubjectInitial>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.SubjectInitial>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.SubjectInitial>_R)
                      @ Data.Grammar.SubjectInitial
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.SubjectInitial))) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking :: GHC.Read.Read Data.Grammar.TopicMarking
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.TopicMarking
                  Data.Grammar.$fReadTopicMarking_$creadsPrec
                  Data.Grammar.$fReadTopicMarking_$creadList
                  Data.Grammar.$fReadTopicMarking_$creadPrec
                  Data.Grammar.$fReadTopicMarking_$creadListPrec -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.TopicMarking] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.TopicMarking]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.TopicMarking
                   Data.Grammar.$fReadTopicMarking2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.TopicMarking>_R))
                   @ b
                   eta1) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.TopicMarking -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.TopicMarking
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.NoTopMark) -}
219a3ac1a19d65dd0f45d6791db36962
  $fReadTopicMarking11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoTopMark"#) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.TopicMarking]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.TopicMarking
                   Data.Grammar.$fReadTopicMarking2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.TopicMarking>_R))
                   @ [Data.Grammar.TopicMarking]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.TopicMarking])) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.TopicMarking
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.TopicMarking
                   Data.Grammar.$fReadTopicMarking3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.TopicMarking>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.TopicMarking>_R)))) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.TopicMarking -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.TopicMarking
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.TopicMarking
                   Data.Grammar.$fReadTopicMarking4
                   eta
                   @ b
                   eta1) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.TopicMarking)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.TopicMarking)
                   Data.Grammar.$fReadTopicMarking9
                   Data.Grammar.$fReadTopicMarking5) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.TopicMarking)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.TopicMarking)
                   Data.Grammar.$fReadTopicMarking6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.TopicMarking))) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.TopicMarking)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadTopicMarking8,
                  Data.Grammar.$fReadTopicMarking7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.TopicMarking>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.TopicMarking>_R))))) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.TopicMarking -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.TopicMarking
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OblTopMark) -}
ac3a5afce441745801b105e08db53f9f
  $fReadTopicMarking8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OblTopMark"#) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.TopicMarking)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadTopicMarking11,
                  Data.Grammar.$fReadTopicMarking10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.TopicMarking>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.TopicMarking>_R))))) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.TopicMarking]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.TopicMarking]
                   Data.Grammar.$fReadTopicMarking12) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.TopicMarking]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadTopicMarking1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.TopicMarking]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.TopicMarking]>_R))) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.TopicMarking
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadTopicMarking2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.TopicMarking>_R)) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fReadTopicMarking_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.TopicMarking
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.TopicMarking
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.TopicMarking
                       Data.Grammar.$fReadTopicMarking3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.TopicMarking>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.TopicMarking>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.TopicMarking>_R)
                      @ Data.Grammar.TopicMarking
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.TopicMarking))) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement :: GHC.Read.Read Data.Grammar.VtoIMovement
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.VtoIMovement
                  Data.Grammar.$fReadVtoIMovement_$creadsPrec
                  Data.Grammar.$fReadVtoIMovement_$creadList
                  Data.Grammar.$fReadVtoIMovement_$creadPrec
                  Data.Grammar.$fReadVtoIMovement_$creadListPrec -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.VtoIMovement] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.VtoIMovement]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.VtoIMovement
                   Data.Grammar.$fReadVtoIMovement2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.VtoIMovement>_R))
                   @ b
                   eta1) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.VtoIMovement -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.VtoIMovement
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.NoVtoIMove) -}
1938535e5daee3201cbc3349271548c9
  $fReadVtoIMovement11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoVtoIMove"#) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.VtoIMovement]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.VtoIMovement
                   Data.Grammar.$fReadVtoIMovement2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.VtoIMovement>_R))
                   @ [Data.Grammar.VtoIMovement]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.VtoIMovement])) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Grammar.VtoIMovement
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.VtoIMovement
                   Data.Grammar.$fReadVtoIMovement3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.VtoIMovement>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.VtoIMovement>_R)))) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.VtoIMovement -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.VtoIMovement
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.VtoIMovement
                   Data.Grammar.$fReadVtoIMovement4
                   eta
                   @ b
                   eta1) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.VtoIMovement)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.VtoIMovement)
                   Data.Grammar.$fReadVtoIMovement9
                   Data.Grammar.$fReadVtoIMovement5) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.VtoIMovement)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.VtoIMovement)
                   Data.Grammar.$fReadVtoIMovement6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.VtoIMovement))) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.VtoIMovement)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadVtoIMovement8,
                  Data.Grammar.$fReadVtoIMovement7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.VtoIMovement>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.VtoIMovement>_R))))) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.VtoIMovement -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.VtoIMovement
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OblVtoIMove) -}
baae76a717330422a2b8b80d56267e18
  $fReadVtoIMovement8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OblVtoIMove"#) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.VtoIMovement)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadVtoIMovement11,
                  Data.Grammar.$fReadVtoIMovement10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.VtoIMovement>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.VtoIMovement>_R))))) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Grammar.VtoIMovement]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.VtoIMovement]
                   Data.Grammar.$fReadVtoIMovement12) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.VtoIMovement]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadVtoIMovement1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.VtoIMovement]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.VtoIMovement]>_R))) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Grammar.VtoIMovement
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadVtoIMovement2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.VtoIMovement>_R)) -}
26726f546091d6e0b9a4e728fd464566
  $fReadVtoIMovement_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Grammar.VtoIMovement
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.VtoIMovement
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.VtoIMovement
                       Data.Grammar.$fReadVtoIMovement3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.VtoIMovement>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.VtoIMovement>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.VtoIMovement>_R)
                      @ Data.Grammar.VtoIMovement
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.VtoIMovement))) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory ::
    GHC.Read.Read Data.Grammar.WHMovementObligatory
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.WHMovementObligatory
                  Data.Grammar.$fReadWHMovementObligatory_$creadsPrec
                  Data.Grammar.$fReadWHMovementObligatory_$creadList
                  Data.Grammar.$fReadWHMovementObligatory_$creadPrec
                  Data.Grammar.$fReadWHMovementObligatory_$creadListPrec -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Grammar.WHMovementObligatory]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Grammar.WHMovementObligatory]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Grammar.WHMovementObligatory
                   Data.Grammar.$fReadWHMovementObligatory2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.WHMovementObligatory>_R))
                   @ b
                   eta1) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.WHMovementObligatory
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.WHMovementObligatory
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.NoWHMove) -}
3841453a03409fa9fcec84e44566d807
  $fReadWHMovementObligatory11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoWHMove"#) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory12 ::
    Text.ParserCombinators.ReadP.P [Data.Grammar.WHMovementObligatory]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Grammar.WHMovementObligatory
                   Data.Grammar.$fReadWHMovementObligatory2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Grammar.WHMovementObligatory>_R))
                   @ [Data.Grammar.WHMovementObligatory]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Grammar.WHMovementObligatory])) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         Data.Grammar.WHMovementObligatory
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Grammar.WHMovementObligatory
                   Data.Grammar.$fReadWHMovementObligatory3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Grammar.WHMovementObligatory>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Grammar.WHMovementObligatory>_R)))) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.WHMovementObligatory
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Grammar.WHMovementObligatory
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Grammar.WHMovementObligatory
                   Data.Grammar.$fReadWHMovementObligatory4
                   eta
                   @ b
                   eta1) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.WHMovementObligatory)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.WHMovementObligatory)
                   Data.Grammar.$fReadWHMovementObligatory9
                   Data.Grammar.$fReadWHMovementObligatory5) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Grammar.WHMovementObligatory)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Grammar.WHMovementObligatory)
                   Data.Grammar.$fReadWHMovementObligatory6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Grammar.WHMovementObligatory))) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.WHMovementObligatory)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadWHMovementObligatory8,
                  Data.Grammar.$fReadWHMovementObligatory7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.WHMovementObligatory>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.WHMovementObligatory>_R))))) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Grammar.WHMovementObligatory
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Grammar.WHMovementObligatory
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Grammar.OblWHMove) -}
bfdceb658254cc9ef398fd43a3efcc21
  $fReadWHMovementObligatory8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OblWHMove"#) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Grammar.WHMovementObligatory)
  {- Strictness: m,
     Unfolding: ((Data.Grammar.$fReadWHMovementObligatory11,
                  Data.Grammar.$fReadWHMovementObligatory10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Grammar.WHMovementObligatory>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Grammar.WHMovementObligatory>_R))))) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory_$creadList ::
    Text.ParserCombinators.ReadP.ReadS
      [Data.Grammar.WHMovementObligatory]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Grammar.WHMovementObligatory]
                   Data.Grammar.$fReadWHMovementObligatory12) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Grammar.WHMovementObligatory]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadWHMovementObligatory1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Grammar.WHMovementObligatory]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Grammar.WHMovementObligatory]>_R))) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Grammar.WHMovementObligatory
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Grammar.$fReadWHMovementObligatory2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Grammar.WHMovementObligatory>_R)) -}
b81b310f32810f84d11d228d1654c597
  $fReadWHMovementObligatory_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         Data.Grammar.WHMovementObligatory
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Grammar.WHMovementObligatory
                   ((GHC.Read.$fReadDouble10
                       @ Data.Grammar.WHMovementObligatory
                       Data.Grammar.$fReadWHMovementObligatory3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Grammar.WHMovementObligatory>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Grammar.WHMovementObligatory>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Grammar.WHMovementObligatory>_R)
                      @ Data.Grammar.WHMovementObligatory
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Grammar.WHMovementObligatory))) -}
0ff7119050f64558eef1b9b6c65db897
  $fShowAffixHopping :: GHC.Show.Show Data.Grammar.AffixHopping
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.AffixHopping
                  Data.Grammar.$fShowAffixHopping_$cshowsPrec
                  Data.Grammar.$fShowAffixHopping_$cshow
                  Data.Grammar.$fShowAffixHopping_$cshowList -}
0ff7119050f64558eef1b9b6c65db897
  $fShowAffixHopping1 :: Data.Grammar.AffixHopping -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.AffixHopping) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.NoAffixHop
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadAffixHopping11)
                        eta
                   Data.Grammar.OblAffixHop
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadAffixHopping8)
                        eta }) -}
0ff7119050f64558eef1b9b6c65db897
  $fShowAffixHopping_$cshow ::
    Data.Grammar.AffixHopping -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.AffixHopping) ->
                 case x of wild {
                   Data.Grammar.NoAffixHop -> Data.Grammar.$fReadAffixHopping11
                   Data.Grammar.OblAffixHop -> Data.Grammar.$fReadAffixHopping8 }) -}
0ff7119050f64558eef1b9b6c65db897
  $fShowAffixHopping_$cshowList ::
    [Data.Grammar.AffixHopping] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.AffixHopping
                   Data.Grammar.$fShowAffixHopping1) -}
0ff7119050f64558eef1b9b6c65db897
  $fShowAffixHopping_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.AffixHopping -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.AffixHopping)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.NoAffixHop
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadAffixHopping11)
                        eta
                   Data.Grammar.OblAffixHop
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadAffixHopping8)
                        eta }) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowBar :: GHC.Show.Show Data.Grammar.Bar
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Bar
                  Data.Grammar.$fShowBar_$cshowsPrec
                  Data.Grammar.$fShowBar_$cshow
                  Data.Grammar.$fShowBar_$cshowList -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowBar1 :: Data.Grammar.Bar -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: Data.Grammar.Bar) ->
                 Data.Grammar.$w$cshowsPrec 0# w) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowBar_$cshow :: Data.Grammar.Bar -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.Bar) ->
                 Data.Grammar.$fShowBar_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowBar_$cshowList :: [Data.Grammar.Bar] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.Bar
                   Data.Grammar.$fShowBar1) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowBar_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.Bar -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Data.Grammar.Bar) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$cshowsPrec ww1 w1 }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fShowComplementizerInitial ::
    GHC.Show.Show Data.Grammar.ComplementizerInitial
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ComplementizerInitial
                  Data.Grammar.$fShowComplementizerInitial_$cshowsPrec
                  Data.Grammar.$fShowComplementizerInitial_$cshow
                  Data.Grammar.$fShowComplementizerInitial_$cshowList -}
7bb064b4bffb830da7136c6d5d4c2457
  $fShowComplementizerInitial1 ::
    Data.Grammar.ComplementizerInitial -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.ComplementizerInitial)
                   (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.CompInitial
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadComplementizerInitial11)
                        eta
                   Data.Grammar.CompFinal
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadComplementizerInitial8)
                        eta }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fShowComplementizerInitial_$cshow ::
    Data.Grammar.ComplementizerInitial -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.ComplementizerInitial) ->
                 case x of wild {
                   Data.Grammar.CompInitial
                   -> Data.Grammar.$fReadComplementizerInitial11
                   Data.Grammar.CompFinal
                   -> Data.Grammar.$fReadComplementizerInitial8 }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fShowComplementizerInitial_$cshowList ::
    [Data.Grammar.ComplementizerInitial] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.ComplementizerInitial
                   Data.Grammar.$fShowComplementizerInitial1) -}
7bb064b4bffb830da7136c6d5d4c2457
  $fShowComplementizerInitial_$cshowsPrec ::
    GHC.Types.Int
    -> Data.Grammar.ComplementizerInitial -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.ComplementizerInitial)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.CompInitial
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadComplementizerInitial11)
                        eta
                   Data.Grammar.CompFinal
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadComplementizerInitial8)
                        eta }) -}
68da53a8367c3a884597fdcc112c08c3
  $fShowGrammar :: GHC.Show.Show Data.Grammar.Grammar
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Grammar
                  Data.Grammar.$fShowGrammar_$cshowsPrec
                  Data.Grammar.$fShowGrammar_$cshow
                  Data.Grammar.$fShowGrammar_$cshowList -}
68da53a8367c3a884597fdcc112c08c3
  $fShowGrammar1 :: Data.Grammar.Grammar -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Data.Grammar.Grammar)
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Data.Grammar.Grammar ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ->
                 Data.Grammar.$w$cshowsPrec1
                   0#
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   w1 }) -}
68da53a8367c3a884597fdcc112c08c3
  $fShowGrammar_$cshow :: Data.Grammar.Grammar -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.Grammar) ->
                 Data.Grammar.$fShowGrammar_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
68da53a8367c3a884597fdcc112c08c3
  $fShowGrammar_$cshowList ::
    [Data.Grammar.Grammar] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.Grammar
                   Data.Grammar.$fShowGrammar1) -}
68da53a8367c3a884597fdcc112c08c3
  $fShowGrammar_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.Grammar -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Grammar.Grammar)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Data.Grammar.Grammar ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ->
                 Data.Grammar.$w$cshowsPrec1
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15
                   w2 } }) -}
e079181c6cea1e829f70da22fe08f7df
  $fShowIlloc :: GHC.Show.Show Data.Grammar.Illoc
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Illoc
                  Data.Grammar.$fShowIlloc_$cshowsPrec
                  Data.Grammar.$fShowIlloc_$cshow
                  Data.Grammar.$fShowIlloc_$cshowList -}
3629227dbca3d093f3e0c6820289c4f7
  $fShowIlloc1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Imper"#) -}
ba816d4911af1a25b1f8cc6aad06fc19
  $fShowIlloc2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Decl"#) -}
c1c2b4f69e181f22e1b00c9408b6ba68
  $fShowIlloc3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Ques"#) -}
494b422b9b95f19906e6a3c40bf1d1ff
  $fShowIlloc4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Null"#) -}
e079181c6cea1e829f70da22fe08f7df
  $fShowIlloc_$cshow :: Data.Grammar.Illoc -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.Illoc) ->
                 Data.Grammar.$fShowIlloc_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e079181c6cea1e829f70da22fe08f7df
  $fShowIlloc_$cshowList :: [Data.Grammar.Illoc] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.Illoc
                   Data.Grammar.$w$cshowsPrec2) -}
e079181c6cea1e829f70da22fe08f7df
  $fShowIlloc_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.Illoc -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Grammar.Illoc)
                   (w2 :: GHC.Base.String) ->
                 Data.Grammar.$w$cshowsPrec2 w1 w2) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fShowItoCMovement :: GHC.Show.Show Data.Grammar.ItoCMovement
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ItoCMovement
                  Data.Grammar.$fShowItoCMovement_$cshowsPrec
                  Data.Grammar.$fShowItoCMovement_$cshow
                  Data.Grammar.$fShowItoCMovement_$cshowList -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fShowItoCMovement1 :: Data.Grammar.ItoCMovement -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.ItoCMovement) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.NoItoCMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadItoCMovement11)
                        eta
                   Data.Grammar.OblItoCMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadItoCMovement8)
                        eta }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fShowItoCMovement_$cshow ::
    Data.Grammar.ItoCMovement -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.ItoCMovement) ->
                 case x of wild {
                   Data.Grammar.NoItoCMove -> Data.Grammar.$fReadItoCMovement11
                   Data.Grammar.OblItoCMove -> Data.Grammar.$fReadItoCMovement8 }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fShowItoCMovement_$cshowList ::
    [Data.Grammar.ItoCMovement] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.ItoCMovement
                   Data.Grammar.$fShowItoCMovement1) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $fShowItoCMovement_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.ItoCMovement -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.ItoCMovement)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.NoItoCMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadItoCMovement11)
                        eta
                   Data.Grammar.OblItoCMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadItoCMovement8)
                        eta }) -}
6a5bee7bd58c76567dc95d127514df54
  $fShowLeaf :: GHC.Show.Show Data.Grammar.Leaf
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Leaf
                  Data.Grammar.$fShowLeaf_$cshowsPrec
                  Data.Grammar.$fShowLeaf_$cshow
                  Data.Grammar.$fShowLeaf_$cshowList -}
6a5bee7bd58c76567dc95d127514df54
  $fShowLeaf1 :: Data.Grammar.Leaf -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: Data.Grammar.Leaf) ->
                 Data.Grammar.$w$cshowsPrec3 0# w) -}
6a5bee7bd58c76567dc95d127514df54
  $fShowLeaf_$cshow :: Data.Grammar.Leaf -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.Leaf) ->
                 Data.Grammar.$fShowLeaf_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6a5bee7bd58c76567dc95d127514df54
  $fShowLeaf_$cshowList :: [Data.Grammar.Leaf] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.Leaf
                   Data.Grammar.$fShowLeaf1) -}
6a5bee7bd58c76567dc95d127514df54
  $fShowLeaf_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.Leaf -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Data.Grammar.Leaf) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Grammar.$w$cshowsPrec3 ww1 w1 }) -}
c268ade9ae4c288b84a762a1c162513f
  $fShowNullSubject :: GHC.Show.Show Data.Grammar.NullSubject
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.NullSubject
                  Data.Grammar.$fShowNullSubject_$cshowsPrec
                  Data.Grammar.$fShowNullSubject_$cshow
                  Data.Grammar.$fShowNullSubject_$cshowList -}
c268ade9ae4c288b84a762a1c162513f
  $fShowNullSubject1 :: Data.Grammar.NullSubject -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.NullSubject) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.NoNullSub
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadNullSubject11)
                        eta
                   Data.Grammar.OptNullSub
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadNullSubject8)
                        eta }) -}
c268ade9ae4c288b84a762a1c162513f
  $fShowNullSubject_$cshow ::
    Data.Grammar.NullSubject -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.NullSubject) ->
                 case x of wild {
                   Data.Grammar.NoNullSub -> Data.Grammar.$fReadNullSubject11
                   Data.Grammar.OptNullSub -> Data.Grammar.$fReadNullSubject8 }) -}
c268ade9ae4c288b84a762a1c162513f
  $fShowNullSubject_$cshowList ::
    [Data.Grammar.NullSubject] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.NullSubject
                   Data.Grammar.$fShowNullSubject1) -}
c268ade9ae4c288b84a762a1c162513f
  $fShowNullSubject_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.NullSubject -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.NullSubject)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.NoNullSub
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadNullSubject11)
                        eta
                   Data.Grammar.OptNullSub
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadNullSubject8)
                        eta }) -}
052b3f964abdaf4269e4020caa0083ce
  $fShowNullTopic :: GHC.Show.Show Data.Grammar.NullTopic
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.NullTopic
                  Data.Grammar.$fShowNullTopic_$cshowsPrec
                  Data.Grammar.$fShowNullTopic_$cshow
                  Data.Grammar.$fShowNullTopic_$cshowList -}
052b3f964abdaf4269e4020caa0083ce
  $fShowNullTopic1 :: Data.Grammar.NullTopic -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.NullTopic) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.NoNullTop
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadNullTopic11)
                        eta
                   Data.Grammar.OptNullTop
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadNullTopic8)
                        eta }) -}
052b3f964abdaf4269e4020caa0083ce
  $fShowNullTopic_$cshow :: Data.Grammar.NullTopic -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.NullTopic) ->
                 case x of wild {
                   Data.Grammar.NoNullTop -> Data.Grammar.$fReadNullTopic11
                   Data.Grammar.OptNullTop -> Data.Grammar.$fReadNullTopic8 }) -}
052b3f964abdaf4269e4020caa0083ce
  $fShowNullTopic_$cshowList ::
    [Data.Grammar.NullTopic] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.NullTopic
                   Data.Grammar.$fShowNullTopic1) -}
052b3f964abdaf4269e4020caa0083ce
  $fShowNullTopic_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.NullTopic -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.NullTopic)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.NoNullTop
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadNullTopic11)
                        eta
                   Data.Grammar.OptNullTop
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadNullTopic8)
                        eta }) -}
5690ac32557ef5d251bb18590690680b
  $fShowObjectFinal :: GHC.Show.Show Data.Grammar.ObjectFinal
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ObjectFinal
                  Data.Grammar.$fShowObjectFinal_$cshowsPrec
                  Data.Grammar.$fShowObjectFinal_$cshow
                  Data.Grammar.$fShowObjectFinal_$cshowList -}
5690ac32557ef5d251bb18590690680b
  $fShowObjectFinal1 :: Data.Grammar.ObjectFinal -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.ObjectFinal) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.ObjFinal
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadObjectFinal11)
                        eta
                   Data.Grammar.ObjInitial
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadObjectFinal8)
                        eta }) -}
5690ac32557ef5d251bb18590690680b
  $fShowObjectFinal_$cshow ::
    Data.Grammar.ObjectFinal -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.ObjectFinal) ->
                 case x of wild {
                   Data.Grammar.ObjFinal -> Data.Grammar.$fReadObjectFinal11
                   Data.Grammar.ObjInitial -> Data.Grammar.$fReadObjectFinal8 }) -}
5690ac32557ef5d251bb18590690680b
  $fShowObjectFinal_$cshowList ::
    [Data.Grammar.ObjectFinal] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.ObjectFinal
                   Data.Grammar.$fShowObjectFinal1) -}
5690ac32557ef5d251bb18590690680b
  $fShowObjectFinal_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.ObjectFinal -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.ObjectFinal)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.ObjFinal
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadObjectFinal11)
                        eta
                   Data.Grammar.ObjInitial
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadObjectFinal8)
                        eta }) -}
934ac344d29b59a815d4a00caa639ae9
  $fShowObligatoryTopic :: GHC.Show.Show Data.Grammar.ObligatoryTopic
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.ObligatoryTopic
                  Data.Grammar.$fShowObligatoryTopic_$cshowsPrec
                  Data.Grammar.$fShowObligatoryTopic_$cshow
                  Data.Grammar.$fShowObligatoryTopic_$cshowList -}
934ac344d29b59a815d4a00caa639ae9
  $fShowObligatoryTopic1 ::
    Data.Grammar.ObligatoryTopic -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.ObligatoryTopic) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.OblTopic
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadObligatoryTopic11)
                        eta
                   Data.Grammar.OptTopic
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadObligatoryTopic8)
                        eta }) -}
934ac344d29b59a815d4a00caa639ae9
  $fShowObligatoryTopic_$cshow ::
    Data.Grammar.ObligatoryTopic -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.ObligatoryTopic) ->
                 case x of wild {
                   Data.Grammar.OblTopic -> Data.Grammar.$fReadObligatoryTopic11
                   Data.Grammar.OptTopic -> Data.Grammar.$fReadObligatoryTopic8 }) -}
934ac344d29b59a815d4a00caa639ae9
  $fShowObligatoryTopic_$cshowList ::
    [Data.Grammar.ObligatoryTopic] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.ObligatoryTopic
                   Data.Grammar.$fShowObligatoryTopic1) -}
934ac344d29b59a815d4a00caa639ae9
  $fShowObligatoryTopic_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.ObligatoryTopic -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.ObligatoryTopic)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.OblTopic
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadObligatoryTopic11)
                        eta
                   Data.Grammar.OptTopic
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadObligatoryTopic8)
                        eta }) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowPhrase :: GHC.Show.Show Data.Grammar.Phrase
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.Phrase
                  Data.Grammar.$fShowPhrase_$cshowsPrec
                  Data.Grammar.$fShowPhrase_$cshow
                  Data.Grammar.$fShowPhrase_$cshowList -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowPhrase1 :: Data.Grammar.Phrase -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (Data.Grammar.$fShowPhrase_$cshowsPrec
                   Data.Grammar.$fShowPhrase2) -}
4964131c78a647a08b5e918b877a36f7
  $fShowPhrase2 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0#) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowPhrase_$cshow :: Data.Grammar.Phrase -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.Phrase) ->
                 Data.Grammar.$fShowPhrase_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowPhrase_$cshowList :: [Data.Grammar.Phrase] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.Phrase
                   Data.Grammar.$fShowPhrase1) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $fShowPhrase_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.Phrase -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U> -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fShowPiedPiping :: GHC.Show.Show Data.Grammar.PiedPiping
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.PiedPiping
                  Data.Grammar.$fShowPiedPiping_$cshowsPrec
                  Data.Grammar.$fShowPiedPiping_$cshow
                  Data.Grammar.$fShowPiedPiping_$cshowList -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fShowPiedPiping1 :: Data.Grammar.PiedPiping -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.PiedPiping) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.PiedPipe
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadPiedPiping11)
                        eta
                   Data.Grammar.PrepStrand
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadPiedPiping8)
                        eta }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fShowPiedPiping_$cshow ::
    Data.Grammar.PiedPiping -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.PiedPiping) ->
                 case x of wild {
                   Data.Grammar.PiedPipe -> Data.Grammar.$fReadPiedPiping11
                   Data.Grammar.PrepStrand -> Data.Grammar.$fReadPiedPiping8 }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fShowPiedPiping_$cshowList ::
    [Data.Grammar.PiedPiping] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.PiedPiping
                   Data.Grammar.$fShowPiedPiping1) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $fShowPiedPiping_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.PiedPiping -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.PiedPiping)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.PiedPipe
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadPiedPiping11)
                        eta
                   Data.Grammar.PrepStrand
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadPiedPiping8)
                        eta }) -}
dee16e043daf097681c2796c283f597a
  $fShowQuestionInversion ::
    GHC.Show.Show Data.Grammar.QuestionInversion
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.QuestionInversion
                  Data.Grammar.$fShowQuestionInversion_$cshowsPrec
                  Data.Grammar.$fShowQuestionInversion_$cshow
                  Data.Grammar.$fShowQuestionInversion_$cshowList -}
dee16e043daf097681c2796c283f597a
  $fShowQuestionInversion1 ::
    Data.Grammar.QuestionInversion -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.QuestionInversion)
                   (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.NoQuesInv
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadQuestionInversion11)
                        eta
                   Data.Grammar.OblQuesInv
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadQuestionInversion8)
                        eta }) -}
dee16e043daf097681c2796c283f597a
  $fShowQuestionInversion_$cshow ::
    Data.Grammar.QuestionInversion -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.QuestionInversion) ->
                 case x of wild {
                   Data.Grammar.NoQuesInv -> Data.Grammar.$fReadQuestionInversion11
                   Data.Grammar.OblQuesInv
                   -> Data.Grammar.$fReadQuestionInversion8 }) -}
dee16e043daf097681c2796c283f597a
  $fShowQuestionInversion_$cshowList ::
    [Data.Grammar.QuestionInversion] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.QuestionInversion
                   Data.Grammar.$fShowQuestionInversion1) -}
dee16e043daf097681c2796c283f597a
  $fShowQuestionInversion_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.QuestionInversion -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.QuestionInversion)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.NoQuesInv
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadQuestionInversion11)
                        eta
                   Data.Grammar.OblQuesInv
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadQuestionInversion8)
                        eta }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fShowSubjectInitial :: GHC.Show.Show Data.Grammar.SubjectInitial
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.SubjectInitial
                  Data.Grammar.$fShowSubjectInitial_$cshowsPrec
                  Data.Grammar.$fShowSubjectInitial_$cshow
                  Data.Grammar.$fShowSubjectInitial_$cshowList -}
872e11e1b82c550480a8f63d2a4025ab
  $fShowSubjectInitial1 ::
    Data.Grammar.SubjectInitial -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.SubjectInitial) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.SubInitial
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadSubjectInitial11)
                        eta
                   Data.Grammar.SubFinal
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadSubjectInitial8)
                        eta }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fShowSubjectInitial_$cshow ::
    Data.Grammar.SubjectInitial -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.SubjectInitial) ->
                 case x of wild {
                   Data.Grammar.SubInitial -> Data.Grammar.$fReadSubjectInitial11
                   Data.Grammar.SubFinal -> Data.Grammar.$fReadSubjectInitial8 }) -}
872e11e1b82c550480a8f63d2a4025ab
  $fShowSubjectInitial_$cshowList ::
    [Data.Grammar.SubjectInitial] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.SubjectInitial
                   Data.Grammar.$fShowSubjectInitial1) -}
872e11e1b82c550480a8f63d2a4025ab
  $fShowSubjectInitial_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.SubjectInitial -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.SubjectInitial)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.SubInitial
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadSubjectInitial11)
                        eta
                   Data.Grammar.SubFinal
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadSubjectInitial8)
                        eta }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fShowTopicMarking :: GHC.Show.Show Data.Grammar.TopicMarking
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.TopicMarking
                  Data.Grammar.$fShowTopicMarking_$cshowsPrec
                  Data.Grammar.$fShowTopicMarking_$cshow
                  Data.Grammar.$fShowTopicMarking_$cshowList -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fShowTopicMarking1 :: Data.Grammar.TopicMarking -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.TopicMarking) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.NoTopMark
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadTopicMarking11)
                        eta
                   Data.Grammar.OblTopMark
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadTopicMarking8)
                        eta }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fShowTopicMarking_$cshow ::
    Data.Grammar.TopicMarking -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.TopicMarking) ->
                 case x of wild {
                   Data.Grammar.NoTopMark -> Data.Grammar.$fReadTopicMarking11
                   Data.Grammar.OblTopMark -> Data.Grammar.$fReadTopicMarking8 }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fShowTopicMarking_$cshowList ::
    [Data.Grammar.TopicMarking] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.TopicMarking
                   Data.Grammar.$fShowTopicMarking1) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $fShowTopicMarking_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.TopicMarking -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.TopicMarking)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.NoTopMark
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadTopicMarking11)
                        eta
                   Data.Grammar.OblTopMark
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadTopicMarking8)
                        eta }) -}
26726f546091d6e0b9a4e728fd464566
  $fShowVtoIMovement :: GHC.Show.Show Data.Grammar.VtoIMovement
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.VtoIMovement
                  Data.Grammar.$fShowVtoIMovement_$cshowsPrec
                  Data.Grammar.$fShowVtoIMovement_$cshow
                  Data.Grammar.$fShowVtoIMovement_$cshowList -}
26726f546091d6e0b9a4e728fd464566
  $fShowVtoIMovement1 :: Data.Grammar.VtoIMovement -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.VtoIMovement) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.NoVtoIMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadVtoIMovement11)
                        eta
                   Data.Grammar.OblVtoIMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadVtoIMovement8)
                        eta }) -}
26726f546091d6e0b9a4e728fd464566
  $fShowVtoIMovement_$cshow ::
    Data.Grammar.VtoIMovement -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.VtoIMovement) ->
                 case x of wild {
                   Data.Grammar.NoVtoIMove -> Data.Grammar.$fReadVtoIMovement11
                   Data.Grammar.OblVtoIMove -> Data.Grammar.$fReadVtoIMovement8 }) -}
26726f546091d6e0b9a4e728fd464566
  $fShowVtoIMovement_$cshowList ::
    [Data.Grammar.VtoIMovement] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.VtoIMovement
                   Data.Grammar.$fShowVtoIMovement1) -}
26726f546091d6e0b9a4e728fd464566
  $fShowVtoIMovement_$cshowsPrec ::
    GHC.Types.Int -> Data.Grammar.VtoIMovement -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.VtoIMovement)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.NoVtoIMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadVtoIMovement11)
                        eta
                   Data.Grammar.OblVtoIMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadVtoIMovement8)
                        eta }) -}
b81b310f32810f84d11d228d1654c597
  $fShowWHMovementObligatory ::
    GHC.Show.Show Data.Grammar.WHMovementObligatory
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Grammar.WHMovementObligatory
                  Data.Grammar.$fShowWHMovementObligatory_$cshowsPrec
                  Data.Grammar.$fShowWHMovementObligatory_$cshow
                  Data.Grammar.$fShowWHMovementObligatory_$cshowList -}
b81b310f32810f84d11d228d1654c597
  $fShowWHMovementObligatory1 ::
    Data.Grammar.WHMovementObligatory -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Grammar.WHMovementObligatory)
                   (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Data.Grammar.NoWHMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadWHMovementObligatory11)
                        eta
                   Data.Grammar.OblWHMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadWHMovementObligatory8)
                        eta }) -}
b81b310f32810f84d11d228d1654c597
  $fShowWHMovementObligatory_$cshow ::
    Data.Grammar.WHMovementObligatory -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Grammar.WHMovementObligatory) ->
                 case x of wild {
                   Data.Grammar.NoWHMove -> Data.Grammar.$fReadWHMovementObligatory11
                   Data.Grammar.OblWHMove
                   -> Data.Grammar.$fReadWHMovementObligatory8 }) -}
b81b310f32810f84d11d228d1654c597
  $fShowWHMovementObligatory_$cshowList ::
    [Data.Grammar.WHMovementObligatory] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Grammar.WHMovementObligatory
                   Data.Grammar.$fShowWHMovementObligatory1) -}
b81b310f32810f84d11d228d1654c597
  $fShowWHMovementObligatory_$cshowsPrec ::
    GHC.Types.Int
    -> Data.Grammar.WHMovementObligatory -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Grammar.WHMovementObligatory)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Grammar.NoWHMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadWHMovementObligatory11)
                        eta
                   Data.Grammar.OblWHMove
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c1 :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c1
                           n
                           Data.Grammar.$fReadWHMovementObligatory8)
                        eta }) -}
2834a1d024146fe94e16f6891eff5207
  $s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Mood)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Mood)
                  Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==10
                  (Data.Inflection.$fEqExpress_$c/=
                     @ Data.Inflection.Mood
                     Data.Inflection.$fEqMood) -}
6cf5e1920f064413f98048c3a0bdfe93
  $s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress1 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Tense)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Tense)
                  Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==1
                  (Data.Inflection.$fEqExpress_$c/=
                     @ Data.Inflection.Tense
                     Data.Inflection.$fEqTense) -}
b6fe14a5f4d261e053f8f359d0de39f7
  $s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress2 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Case)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Case)
                  Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==2
                  (Data.Inflection.$fEqExpress_$c/=
                     @ Data.Inflection.Case
                     Data.Inflection.$fEqCase) -}
9f499d3471d4d197381e95002d48fa2c
  $s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==1 ::
    Data.Inflection.Express Data.Inflection.Tense
    -> Data.Inflection.Express Data.Inflection.Tense -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Tense)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Tense) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqTense_$c== a1 b1 } }) -}
c4451bc58b323745f271492e7071b2b9
  $s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==10 ::
    Data.Inflection.Express Data.Inflection.Mood
    -> Data.Inflection.Express Data.Inflection.Mood -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Mood)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Mood) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqMood_$c== a1 b1 } }) -}
b441c815f62d211f1a4f84877fbbd952
  $s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==2 ::
    Data.Inflection.Express Data.Inflection.Case
    -> Data.Inflection.Express Data.Inflection.Case -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Case)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Case) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqCase_$c== a1 b1 } }) -}
fd20502c0bc30589f0215bd8a59d5b89
  $tc'CompFinal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12204937747853990380##
                   5091299842711223325##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'CompFinal1) -}
88bba47db2ba6773c2e3a473767c98e7
  $tc'CompFinal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CompFinal"#) -}
f187931664a864777ed40f35d79ccf1c
  $tc'CompInitial :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5382601520225656120##
                   15138034778287508169##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'CompInitial1) -}
17cf0fbeb339ac9d63defcb5d80a2734
  $tc'CompInitial1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CompInitial"#) -}
0376b07c799e94420af17e15d032b60e
  $tc'Decl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6900311172797791472##
                   10452070074553138768##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'Decl1) -}
234a0edbb98bc4606b01b5855cd6084d
  $tc'Decl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Decl"#) -}
8bcf52be56212b995867ea7760b841e1
  $tc'Grammar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14033394928977352716##
                   10117825421186219377##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'Grammar1) -}
b838053e10434066894aea250550e434
  $tc'Grammar1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Grammar"#) -}
b19553186313e3608f4d5dff246ff1c0
  $tc'Imper :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1959442082306192077##
                   6617787042756965309##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'Imper1) -}
5c4a28d20bf8fae9386bfc13bca02c68
  $tc'Imper1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Imper"#) -}
f809993cca3a32d11ece6e912ee49247
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10371690205425339586##
                   14258078283929080376##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'Leaf1) -}
8d635d5fe13e6b15b7a7468a0f97886b
  $tc'Leaf1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Leaf"#) -}
2aa4f2736afd703c846867e04b33e101
  $tc'LeafInfl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16643463807448607563##
                   15902401914461175995##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'LeafInfl1) -}
e4584ffaa35966d14887a3f28cb4bf43
  $tc'LeafInfl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LeafInfl"#) -}
92e283d2fd28dfb2590db60ba46ddd48
  $tc'LeafNull :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9446360473211957755##
                   18289797102101300601##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'LeafNull1) -}
a42fdb64223f087b5a3973e07253e218
  $tc'LeafNull1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LeafNull"#) -}
a3ce3d6ef254b41736e509ef30a28b84
  $tc'NoAffixHop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16546095828307538236##
                   1445026784402242283##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'NoAffixHop1) -}
e041979046eafa6f087bc2bdacf67bd1
  $tc'NoAffixHop1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoAffixHop"#) -}
e4dee404f095ec93fec244eb8daffef2
  $tc'NoItoCMove :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17321029981249828952##
                   9105450720436700176##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'NoItoCMove1) -}
1891109e6a6f9ecda3c9ce740453cb3c
  $tc'NoItoCMove1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoItoCMove"#) -}
e924697248132796ec5e8c6a77649288
  $tc'NoNullSub :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3125741757024237948##
                   15275109844506182558##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'NoNullSub1) -}
68494b5dbfeb2d85c76d65fddb3fe356
  $tc'NoNullSub1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoNullSub"#) -}
0df7eb2447d3b8a2c6fc58d9bfdb9626
  $tc'NoNullTop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18391540888483300065##
                   5427007506002022214##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'NoNullTop1) -}
994ab62b7237d48c5f87d91d47cbff5d
  $tc'NoNullTop1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoNullTop"#) -}
1921cb277402d729e4e0f01c18c524bd
  $tc'NoQuesInv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6645550361023029378##
                   12562406684992827980##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'NoQuesInv1) -}
22c1651a7090770e7f8bf8b18dfffb13
  $tc'NoQuesInv1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoQuesInv"#) -}
6ce3fbca2eab92a5169baf17f1a8efe6
  $tc'NoTopMark :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4269149819591946605##
                   15201239900062237792##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'NoTopMark1) -}
995cd1d8193f0a1ca566392f74d60240
  $tc'NoTopMark1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoTopMark"#) -}
5934a8dbd999487aec5e6603bf33ab3e
  $tc'NoVtoIMove :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7108561392709244423##
                   16341223918610525877##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'NoVtoIMove1) -}
3aa0b2d600d6e7b45f63d9e538a67031
  $tc'NoVtoIMove1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoVtoIMove"#) -}
6e031486d73dbdf32b5fad01a2cfcbe7
  $tc'NoWHMove :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10866978834336643910##
                   15468341166748584498##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'NoWHMove1) -}
b13b2655fbf8320ab59d9468199dce25
  $tc'NoWHMove1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoWHMove"#) -}
2922e85f9ea3f70c2bce3abe94de83f8
  $tc'Null :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12176642606344786894##
                   5386320565983612927##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'Null1) -}
1c33d8c8fd5f30d246401401ee57da15
  $tc'Null1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Null"#) -}
2ad426745af3fb54c2b2d7124bd94ed7
  $tc'ObjFinal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7173074723704780169##
                   12555777594737888830##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'ObjFinal1) -}
119fbe73c7de3af33fb4b9bc7838aaf5
  $tc'ObjFinal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ObjFinal"#) -}
c6ff9c9f3d14bc36a1aa8e6b901e6058
  $tc'ObjInitial :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13707311404073266594##
                   11547475871290358694##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'ObjInitial1) -}
3ec0b3538c1068c6a5c17b488e11a2f3
  $tc'ObjInitial1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ObjInitial"#) -}
cc37e5a832a57d9176e16b2b6a1de3ea
  $tc'OblAffixHop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4507543937288221733##
                   9589486540072792813##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OblAffixHop1) -}
9288c551f55416453c10a07998676e36
  $tc'OblAffixHop1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OblAffixHop"#) -}
d3889d32e448ea29ef5859ec88fec907
  $tc'OblItoCMove :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10118776780433601603##
                   7275374535614300599##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OblItoCMove1) -}
46059401a1c453210d7344b0f0e40d60
  $tc'OblItoCMove1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OblItoCMove"#) -}
d23593ce0b8fc5b3a3859e4d20677e50
  $tc'OblQuesInv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6813704733476621323##
                   4143623069716182762##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OblQuesInv1) -}
1b11f171d750948bc78e8dde0e35e766
  $tc'OblQuesInv1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OblQuesInv"#) -}
59cd5fa05fbd17fa5c37ab8c9c594cd6
  $tc'OblTopMark :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17761258702351877099##
                   7217246990477465708##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OblTopMark1) -}
67012f78b31a9e0210fa806a970b3c9e
  $tc'OblTopMark1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OblTopMark"#) -}
b2c8289dda8570df73c82432fafa61cb
  $tc'OblTopic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14199851570748259788##
                   2577802471086613680##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OblTopic1) -}
add315703a6f3e2f1dd98cd8f151c1e9
  $tc'OblTopic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OblTopic"#) -}
d3647ae9e473eaf06741978a45705bbc
  $tc'OblVtoIMove :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11738439528924838571##
                   12908033937346965007##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OblVtoIMove1) -}
28b13ac9752d3ef6f637276f793b4869
  $tc'OblVtoIMove1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OblVtoIMove"#) -}
fc686abbf82f0a99dd0b0d79cd666763
  $tc'OblWHMove :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3550483597695494791##
                   1077659096558785163##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OblWHMove1) -}
b40cd021d3d5a8acaed9359a9d73334e
  $tc'OblWHMove1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OblWHMove"#) -}
267339525eeb8a8b6ab7ca5e26f91834
  $tc'OptNullSub :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5761228509203374562##
                   4173129612650129330##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OptNullSub1) -}
9f2c812a1b2245f10d5266b57db6edcf
  $tc'OptNullSub1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OptNullSub"#) -}
ef043a7d995b4c32a8a693a6169bb9d6
  $tc'OptNullTop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4794465842480887103##
                   11890719315890462647##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OptNullTop1) -}
c0fab43e8326dd3e4619db062e03070c
  $tc'OptNullTop1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OptNullTop"#) -}
5ff7b86a14b6b5a2e85c72d6d818c598
  $tc'OptTopic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16443478477601825444##
                   7623115458982324489##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'OptTopic1) -}
95203f90f574f076e173855578858f09
  $tc'OptTopic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OptTopic"#) -}
b7b9a90a69d8b1e94188b3bd1cca98a3
  $tc'PiedPipe :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1162346865874741442##
                   17676584899281074092##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'PiedPipe1) -}
77404ca6bd50ed0a443d0f26ae182a91
  $tc'PiedPipe1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PiedPipe"#) -}
690bd2e7c287f944ce4738d71f104dc4
  $tc'PrepStrand :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7440825360465375758##
                   16801701763677112165##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'PrepStrand1) -}
bf7a1f3f8b4d1216eb5b5eda74bd6fb2
  $tc'PrepStrand1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PrepStrand"#) -}
66dd54fefc69fff38c576919fc6faa30
  $tc'Ques :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7288264843488794362##
                   1759491734685293172##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'Ques1) -}
71ce3e2445ecacb4dd84a332f940db29
  $tc'Ques1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Ques"#) -}
324056bdfb4186f484f44606e9e3c690
  $tc'SubFinal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10199155439949606030##
                   12890790483769647502##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'SubFinal1) -}
044b897ecd0d4c044c89c70505c34fb8
  $tc'SubFinal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SubFinal"#) -}
4733ba8c77525d6d1fe46e8c782f5f31
  $tc'SubInitial :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10765096858531958524##
                   14485998245731142658##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'SubInitial1) -}
5767b25268b1d34c0dc0990b4bfc0988
  $tc'SubInitial1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SubInitial"#) -}
94281836acb3169a1c2c4111ad97ced2
  $tc'XBarA :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7595574367956552381##
                   9685913043081652130##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'XBarA1) -}
1c6e0dd5bd9c123ad462399484df660e
  $tc'XBarA1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'XBarA"#) -}
1f9afb63a4f0f922a1b8505c8b4e3ad5
  $tc'XBarC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15732406057534032699##
                   8625099656059377124##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'XBarC1) -}
a23433db1aab55cd5500364919f81f6f
  $tc'XBarC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'XBarC"#) -}
6e41136bc4a81b8e8f39f0a5b0e51aa7
  $tc'XP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13636040184900196096##
                   3198902448025010489##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'XP1) -}
171398e0d2b07873ae8182d307d1682f
  $tc'XP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'XP"#) -}
442d1f6feab55277a51d56904295636e
  $tc'XPNull :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10950772554696605783##
                   10685866399504827209##
                   Data.Grammar.$trModule
                   Data.Grammar.$tc'XPNull1) -}
816dd614b61be27d16b7ca9026ff6832
  $tc'XPNull1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'XPNull"#) -}
635ae4fede80247263e6897902105b19
  $tcAffixHopping :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16935941159890833872##
                   17252802912423556722##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcAffixHopping1) -}
eab1d40ac0d219bb6972f408a1e27ddf
  $tcAffixHopping1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AffixHopping"#) -}
5b145a06c43967a7363eeb2e3dd4f3cb
  $tcBar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12108936514836328297##
                   10663074465244284998##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcBar1) -}
da0c20fbb3a75e1821260ac5be4dc739
  $tcBar1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Bar"#) -}
c5d0e48c19400c28b0f2f259001f7d98
  $tcComplementizerInitial :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1253908669474776687##
                   14292051820527351730##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcComplementizerInitial1) -}
8d86ae14dc3abdb940c37366f5c3d123
  $tcComplementizerInitial1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ComplementizerInitial"#) -}
e1e8707691f203471e732483ce7fb5d9
  $tcGrammar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16337920391164984066##
                   3530538169436063555##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcGrammar1) -}
777bca3d7e7c7761cc4be045e181f430
  $tcGrammar1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Grammar"#) -}
1598266f2e8db1df9404612a52c8d041
  $tcIlloc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   48511251262696883##
                   17709274254302271617##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcIlloc1) -}
6cb31849b5337ef82eb30b63c5e824c7
  $tcIlloc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Illoc"#) -}
f0603d35e2f23d7ba2589607ccadeed4
  $tcItoCMovement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5171163774819496796##
                   15144565455905286610##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcItoCMovement1) -}
6c160f0ef632d0e855adbc85fe9fc3ca
  $tcItoCMovement1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ItoCMovement"#) -}
a7af74cd4bf731f24c088655f5bbe0b0
  $tcLeaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9511875082949652315##
                   3459998853856967646##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcLeaf1) -}
b6f5a9c9a5fdce04baae8357b45bd311
  $tcLeaf1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Leaf"#) -}
38981d6350aa3a4c064213945c9a6fe5
  $tcNullSubject :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8070950411128889686##
                   15465277752384943197##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcNullSubject1) -}
957016333c23da7cdc7dcf31704827eb
  $tcNullSubject1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "NullSubject"#) -}
fd54257f2e5b16e08dcddc566da48e5e
  $tcNullTopic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2629413556476632856##
                   3467914037259407107##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcNullTopic1) -}
4c488b65b031e5c6c17dc904e39253d5
  $tcNullTopic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "NullTopic"#) -}
1be343220198135d15fcc1c59b1c249e
  $tcObjectFinal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4621924265800579507##
                   3254235736973666270##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcObjectFinal1) -}
508b6f551a78c907de6985778363dc73
  $tcObjectFinal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ObjectFinal"#) -}
62474ca61ec0a21f52a066b22437aa8e
  $tcObligatoryTopic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8788887767404747396##
                   5324361791682811115##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcObligatoryTopic1) -}
4b684cf0c4933dc7af2d7311b82b5c50
  $tcObligatoryTopic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ObligatoryTopic"#) -}
35ac8b424785e87f766d589064d778ed
  $tcPhrase :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12853168501977514532##
                   14483733261392838036##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcPhrase1) -}
d02fe4eb81caa6280fd047cad638e44c
  $tcPhrase1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Phrase"#) -}
dc914892457fb0eb1d22bdf6ea43d12e
  $tcPiedPiping :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13480725781214579160##
                   399180477638478542##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcPiedPiping1) -}
d65a752ee5ed985291411656551e4e74
  $tcPiedPiping1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "PiedPiping"#) -}
2e958c1ad557a5f68240efed08a52666
  $tcQuestionInversion :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1927790607534124285##
                   7078529088570983924##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcQuestionInversion1) -}
ae58b25621198f5c5a9a6130c98076ec
  $tcQuestionInversion1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "QuestionInversion"#) -}
93b8b7d1cfaf8804c005fba07acd081b
  $tcSubjectInitial :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   362340872408905489##
                   134694937576994731##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcSubjectInitial1) -}
9c6367af581179b4fa821a1bb9dbe55c
  $tcSubjectInitial1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SubjectInitial"#) -}
822d1088757045cb8710950074381167
  $tcTopicMarking :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13728752368595693495##
                   7012962707705209686##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcTopicMarking1) -}
475420ba623e967b7206f678aabcbea2
  $tcTopicMarking1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TopicMarking"#) -}
49a3f2d886f698da31d46dd05c7b5c6d
  $tcVtoIMovement :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8852392052682335452##
                   4558997569054539344##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcVtoIMovement1) -}
fbadd570d2dd53e1c13452edb5cce7ab
  $tcVtoIMovement1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "VtoIMovement"#) -}
8ac1672dd624b4f2d4b3513fc059f6df
  $tcWHMovementObligatory :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11816823150234591763##
                   5625042436636582788##
                   Data.Grammar.$trModule
                   Data.Grammar.$tcWHMovementObligatory1) -}
0cfecc5f7b0620fadf517a2dc18e9ca0
  $tcWHMovementObligatory1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "WHMovementObligatory"#) -}
aa358f4111da8e7429af7461d3d400aa
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Grammar.$trModule2
                   Data.Grammar.$trModule1) -}
9baccba1e0c259bf36a820370e9de19d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Data.Grammar"#) -}
45789b8baad37b3cb1d6a82adcdc215e
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "con-lang-gen-0.0.0.1-JpecSLrjfNmG1CUMEdSr39"#) -}
d6598f8664fde92fcfbb5ae52ff0b346
  $w$cshowsPrec ::
    GHC.Prim.Int# -> Data.Grammar.Bar -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
0d265d257079b0827b3f75aadb8c806c
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Data.Grammar.SubjectInitial
    -> Data.Grammar.ObjectFinal
    -> Data.Grammar.ComplementizerInitial
    -> Data.Grammar.VtoIMovement
    -> Data.Grammar.AffixHopping
    -> Data.Grammar.NullSubject
    -> Data.Grammar.ObligatoryTopic
    -> Data.Grammar.NullTopic
    -> Data.Grammar.TopicMarking
    -> Data.Grammar.ItoCMovement
    -> Data.Grammar.WHMovementObligatory
    -> Data.Grammar.PiedPiping
    -> Data.Grammar.QuestionInversion
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 15,
     Strictness: <S,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0] -}
e079181c6cea1e829f70da22fe08f7df
  $w$cshowsPrec2 ::
    Data.Grammar.Illoc -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Grammar.Illoc) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Grammar.Null
                   -> GHC.Base.++ @ GHC.Types.Char Data.Grammar.$fShowIlloc4 w1
                   Data.Grammar.Ques
                   -> GHC.Base.++ @ GHC.Types.Char Data.Grammar.$fShowIlloc3 w1
                   Data.Grammar.Decl
                   -> GHC.Base.++ @ GHC.Types.Char Data.Grammar.$fShowIlloc2 w1
                   Data.Grammar.Imper
                   -> GHC.Base.++ @ GHC.Types.Char Data.Grammar.$fShowIlloc1 w1 }) -}
6a5bee7bd58c76567dc95d127514df54
  $w$cshowsPrec3 ::
    GHC.Prim.Int# -> Data.Grammar.Leaf -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [0] -}
0ff7119050f64558eef1b9b6c65db897
  $w$ctoEnum :: GHC.Prim.Int# -> Data.Grammar.AffixHopping
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumAffixHopping1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumAffixHopping1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.AffixHopping ww } }) -}
7bb064b4bffb830da7136c6d5d4c2457
  $w$ctoEnum1 :: GHC.Prim.Int# -> Data.Grammar.ComplementizerInitial
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumComplementizerInitial1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumComplementizerInitial1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum#
                             @ Data.Grammar.ComplementizerInitial
                             ww } }) -}
872e11e1b82c550480a8f63d2a4025ab
  $w$ctoEnum10 :: GHC.Prim.Int# -> Data.Grammar.SubjectInitial
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumSubjectInitial1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumSubjectInitial1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.SubjectInitial ww } }) -}
a9a25ae4e38a6e1434a8bb1dfbea28b6
  $w$ctoEnum11 :: GHC.Prim.Int# -> Data.Grammar.TopicMarking
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumTopicMarking1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumTopicMarking1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.TopicMarking ww } }) -}
26726f546091d6e0b9a4e728fd464566
  $w$ctoEnum12 :: GHC.Prim.Int# -> Data.Grammar.VtoIMovement
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumVtoIMovement1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumVtoIMovement1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.VtoIMovement ww } }) -}
b81b310f32810f84d11d228d1654c597
  $w$ctoEnum13 :: GHC.Prim.Int# -> Data.Grammar.WHMovementObligatory
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumWHMovementObligatory1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumWHMovementObligatory1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum#
                             @ Data.Grammar.WHMovementObligatory
                             ww } }) -}
e079181c6cea1e829f70da22fe08f7df
  $w$ctoEnum2 :: GHC.Prim.Int# -> Data.Grammar.Illoc
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumIlloc5 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 3#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumIlloc5 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.Illoc ww } }) -}
cbddba4252cc4aa21ee5ba8ddf36dc91
  $w$ctoEnum3 :: GHC.Prim.Int# -> Data.Grammar.ItoCMovement
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumItoCMovement1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumItoCMovement1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.ItoCMovement ww } }) -}
c268ade9ae4c288b84a762a1c162513f
  $w$ctoEnum4 :: GHC.Prim.Int# -> Data.Grammar.NullSubject
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumNullSubject1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumNullSubject1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.NullSubject ww } }) -}
052b3f964abdaf4269e4020caa0083ce
  $w$ctoEnum5 :: GHC.Prim.Int# -> Data.Grammar.NullTopic
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumNullTopic1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumNullTopic1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.NullTopic ww } }) -}
5690ac32557ef5d251bb18590690680b
  $w$ctoEnum6 :: GHC.Prim.Int# -> Data.Grammar.ObjectFinal
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumObjectFinal1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumObjectFinal1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.ObjectFinal ww } }) -}
934ac344d29b59a815d4a00caa639ae9
  $w$ctoEnum7 :: GHC.Prim.Int# -> Data.Grammar.ObligatoryTopic
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumObligatoryTopic1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumObligatoryTopic1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.ObligatoryTopic ww } }) -}
efd6ae426d6ff2280c8ec984c80efbcf
  $w$ctoEnum8 :: GHC.Prim.Int# -> Data.Grammar.PiedPiping
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumPiedPiping1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumPiedPiping1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.PiedPiping ww } }) -}
dee16e043daf097681c2796c283f597a
  $w$ctoEnum9 :: GHC.Prim.Int# -> Data.Grammar.QuestionInversion
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Grammar.$fEnumQuestionInversion1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1#) of wild1 {
                        GHC.Types.False -> Data.Grammar.$fEnumQuestionInversion1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Grammar.QuestionInversion ww } }) -}
0ff7119050f64558eef1b9b6c65db897
  data AffixHopping = NoAffixHop | OblAffixHop
d6598f8664fde92fcfbb5ae52ff0b346
  data Bar
    = XBarA {barLC :: Data.Inflection.LexCat,
             barIl :: Data.Grammar.Illoc,
             adjunct :: Data.Grammar.Phrase,
             barBar :: Data.Grammar.Bar}
    | XBarC {barLC :: Data.Inflection.LexCat,
             barIl :: Data.Grammar.Illoc,
             leaf :: Data.Grammar.Leaf,
             compliment :: Data.Grammar.Phrase}
7bb064b4bffb830da7136c6d5d4c2457
  data ComplementizerInitial = CompInitial | CompFinal
68da53a8367c3a884597fdcc112c08c3
  data Grammar
    = Grammar {getSI :: Data.Grammar.SubjectInitial,
               getOF :: Data.Grammar.ObjectFinal,
               getCI :: Data.Grammar.ComplementizerInitial,
               getVtoI :: Data.Grammar.VtoIMovement,
               getAH :: Data.Grammar.AffixHopping,
               getNS :: Data.Grammar.NullSubject,
               getObT :: Data.Grammar.ObligatoryTopic,
               getNT :: Data.Grammar.NullTopic,
               getTM :: Data.Grammar.TopicMarking,
               getItoC :: Data.Grammar.ItoCMovement,
               getWHM :: Data.Grammar.WHMovementObligatory,
               getPP :: Data.Grammar.PiedPiping,
               getQI :: Data.Grammar.QuestionInversion}
e079181c6cea1e829f70da22fe08f7df
  data Illoc = Null | Ques | Decl | Imper
cbddba4252cc4aa21ee5ba8ddf36dc91
  data ItoCMovement = NoItoCMove | OblItoCMove
6a5bee7bd58c76567dc95d127514df54
  data Leaf
    = LeafNull Data.Grammar.Illoc
    | LeafInfl {leafLC :: Data.Inflection.LexCat,
                leafInfl :: (Data.Inflection.Express Data.Inflection.Gender,
                             Data.Inflection.Express Data.Inflection.Animacy,
                             Data.Inflection.Express Data.Inflection.Case,
                             Data.Inflection.Express Data.Inflection.Number,
                             Data.Inflection.Express Data.Inflection.Definiteness,
                             Data.Inflection.Express Data.Inflection.Specificity,
                             Data.Inflection.Express Data.Inflection.Topic,
                             Data.Inflection.Express Data.Inflection.Person,
                             Data.Inflection.Express Data.Inflection.Honorific,
                             Data.Inflection.Express Data.Inflection.Polarity,
                             Data.Inflection.Express Data.Inflection.Tense,
                             Data.Inflection.Express Data.Inflection.Aspect,
                             Data.Inflection.Express Data.Inflection.Mood,
                             Data.Inflection.Express Data.Inflection.Voice,
                             Data.Inflection.Express Data.Inflection.Evidentiality,
                             Data.Inflection.Express Data.Inflection.Transitivity,
                             Data.Inflection.Express Data.Inflection.Volition)}
    | Leaf {leafLC :: Data.Inflection.LexCat,
            leafIl :: Data.Grammar.Illoc,
            leafStr :: GHC.Base.String}
c268ade9ae4c288b84a762a1c162513f
  data NullSubject = NoNullSub | OptNullSub
052b3f964abdaf4269e4020caa0083ce
  data NullTopic = NoNullTop | OptNullTop
5690ac32557ef5d251bb18590690680b
  data ObjectFinal = ObjFinal | ObjInitial
934ac344d29b59a815d4a00caa639ae9
  data ObligatoryTopic = OblTopic | OptTopic
d6598f8664fde92fcfbb5ae52ff0b346
  data Phrase
    = XPNull
    | XP {phraseLC :: Data.Inflection.LexCat,
          phraseIl :: Data.Grammar.Illoc,
          specifier :: Data.Grammar.Phrase,
          phraseBar :: Data.Grammar.Bar}
efd6ae426d6ff2280c8ec984c80efbcf
  data PiedPiping = PiedPipe | PrepStrand
dee16e043daf097681c2796c283f597a
  data QuestionInversion = NoQuesInv | OblQuesInv
872e11e1b82c550480a8f63d2a4025ab
  data SubjectInitial = SubInitial | SubFinal
a9a25ae4e38a6e1434a8bb1dfbea28b6
  data TopicMarking = NoTopMark | OblTopMark
26726f546091d6e0b9a4e728fd464566
  data VtoIMovement = NoVtoIMove | OblVtoIMove
b81b310f32810f84d11d228d1654c597
  data WHMovementObligatory = NoWHMove | OblWHMove
fd4032fcbdbd307fd612670ec29ac906
  adjunct :: Data.Grammar.Bar -> Data.Grammar.Phrase
  RecSel Left Data.Grammar.Bar
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Bar) ->
                 case ds of wild {
                   Data.Grammar.XBarA ds1 ds2 ds3 ds4 -> ds3
                   Data.Grammar.XBarC ipv ipv1 ipv2 ipv3
                   -> Data.Grammar.adjunct1 }) -}
a5dc53c925b25ec7d77ef5a65552d8f0
  adjunct1 :: Data.Grammar.Phrase
  {- Strictness: x -}
b5fd087b8dc31eeb289662232506df2c
  barBar :: Data.Grammar.Bar -> Data.Grammar.Bar
  RecSel Left Data.Grammar.Bar
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Bar) ->
                 case ds of wild {
                   Data.Grammar.XBarA ds1 ds2 ds3 ds4 -> ds4
                   Data.Grammar.XBarC ipv ipv1 ipv2 ipv3 -> Data.Grammar.barBar1 }) -}
a1b99201bcbe4a629d0b73fb8b2bc182
  barBar1 :: Data.Grammar.Bar
  {- Strictness: x -}
4f41cc8115e34b6d201b2b0fafd2eac1
  barIl :: Data.Grammar.Bar -> Data.Grammar.Illoc
  RecSel Left Data.Grammar.Bar
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Bar) ->
                 case ds of wild {
                   Data.Grammar.XBarA ds1 ds2 ds3 ds4 -> ds2
                   Data.Grammar.XBarC ds1 ds2 ds3 ds4 -> ds2 }) -}
30c21ac428a3d8e432cd8445a25a1fcc
  barLC :: Data.Grammar.Bar -> Data.Inflection.LexCat
  RecSel Left Data.Grammar.Bar
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Bar) ->
                 case ds of wild {
                   Data.Grammar.XBarA ds1 ds2 ds3 ds4 -> ds1
                   Data.Grammar.XBarC ds1 ds2 ds3 ds4 -> ds1 }) -}
17795146fe77d14630cdb7855c2f6800
  compliment :: Data.Grammar.Bar -> Data.Grammar.Phrase
  RecSel Left Data.Grammar.Bar
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Bar) ->
                 case ds of wild {
                   Data.Grammar.XBarA ipv ipv1 ipv2 ipv3 -> Data.Grammar.compliment1
                   Data.Grammar.XBarC ds1 ds2 ds3 ds4 -> ds4 }) -}
d91b5e92169f2287a74b6a68cf78169c
  compliment1 :: Data.Grammar.Phrase
  {- Strictness: x -}
2d0135b87ac47337b6ed880d3b48fbb6
  getAH :: Data.Grammar.Grammar -> Data.Grammar.AffixHopping
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLLLLLLL),1*U(A,A,A,A,1*U,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds5 }) -}
3885c78a3b07666759f3643fcf6d685a
  getCI :: Data.Grammar.Grammar -> Data.Grammar.ComplementizerInitial
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLLLLLLL),1*U(A,A,1*U,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds3 }) -}
fbfbf8898e9a0b005046a981ef32665b
  getItoC :: Data.Grammar.Grammar -> Data.Grammar.ItoCMovement
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLSLLL),1*U(A,A,A,A,A,A,A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds10 }) -}
5ace7242e3fd12dd7ce89b8271567bba
  getNS :: Data.Grammar.Grammar -> Data.Grammar.NullSubject
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLLLLLLL),1*U(A,A,A,A,A,1*U,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds6 }) -}
1d62b9f6419545e46407d8f060bfa642
  getNT :: Data.Grammar.Grammar -> Data.Grammar.NullTopic
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLSLLLLL),1*U(A,A,A,A,A,A,A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds8 }) -}
3fe3e3cdb1a0b39813789fa5505a82d4
  getOF :: Data.Grammar.Grammar -> Data.Grammar.ObjectFinal
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLLLLLLL),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds2 }) -}
8a7fb917930fd9fb95839b394e8fd730
  getObT :: Data.Grammar.Grammar -> Data.Grammar.ObligatoryTopic
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSLLLLLL),1*U(A,A,A,A,A,A,1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds7 }) -}
5651e223e74f5218cd1912a852db0bac
  getPP :: Data.Grammar.Grammar -> Data.Grammar.PiedPiping
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLSL),1*U(A,A,A,A,A,A,A,A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds12 }) -}
98c4530938835022684c3b1835bc9bda
  getQI :: Data.Grammar.Grammar -> Data.Grammar.QuestionInversion
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLLS),1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds13 }) -}
dc7b4eea0cd953b314198897bcb551cb
  getSI :: Data.Grammar.Grammar -> Data.Grammar.SubjectInitial
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds1 }) -}
41d1b78b8e92ee0f77091dd966f644d5
  getTM :: Data.Grammar.Grammar -> Data.Grammar.TopicMarking
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLSLLLL),1*U(A,A,A,A,A,A,A,A,1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds9 }) -}
2364008b1f2376105701f22a725e6c68
  getVtoI :: Data.Grammar.Grammar -> Data.Grammar.VtoIMovement
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLLLLLLL),1*U(A,A,A,1*U,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds4 }) -}
6b32cb2a663fd02b2295e14eea0808b4
  getWHM :: Data.Grammar.Grammar -> Data.Grammar.WHMovementObligatory
  RecSel Left Data.Grammar.Grammar
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLSLL),1*U(A,A,A,A,A,A,A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Grammar) ->
                 case ds of wild { Data.Grammar.Grammar ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ->
                 ds11 }) -}
70d57c6ede5349de863f1b8283f04f90
  leaf :: Data.Grammar.Bar -> Data.Grammar.Leaf
  RecSel Left Data.Grammar.Bar
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Bar) ->
                 case ds of wild {
                   Data.Grammar.XBarA ipv ipv1 ipv2 ipv3 -> Data.Grammar.leaf1
                   Data.Grammar.XBarC ds1 ds2 ds3 ds4 -> ds3 }) -}
0f5afccbb7b7ad520c56cd6d981d85bb
  leaf1 :: Data.Grammar.Leaf
  {- Strictness: x -}
4581f73285953624f3534e477265ff2b
  leafIl :: Data.Grammar.Leaf -> Data.Grammar.Illoc
  RecSel Left Data.Grammar.Leaf
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Leaf) ->
                 case ds of wild {
                   DEFAULT -> Data.Grammar.leafIl1
                   Data.Grammar.Leaf ds1 ds2 ds3 -> ds2 }) -}
0df2381930a2f005fe8cfe1b4c190a20
  leafIl1 :: Data.Grammar.Illoc
  {- Strictness: x -}
809cbf26c63c3b98667c5853572791e1
  leafInfl ::
    Data.Grammar.Leaf
    -> (Data.Inflection.Express Data.Inflection.Gender,
        Data.Inflection.Express Data.Inflection.Animacy,
        Data.Inflection.Express Data.Inflection.Case,
        Data.Inflection.Express Data.Inflection.Number,
        Data.Inflection.Express Data.Inflection.Definiteness,
        Data.Inflection.Express Data.Inflection.Specificity,
        Data.Inflection.Express Data.Inflection.Topic,
        Data.Inflection.Express Data.Inflection.Person,
        Data.Inflection.Express Data.Inflection.Honorific,
        Data.Inflection.Express Data.Inflection.Polarity,
        Data.Inflection.Express Data.Inflection.Tense,
        Data.Inflection.Express Data.Inflection.Aspect,
        Data.Inflection.Express Data.Inflection.Mood,
        Data.Inflection.Express Data.Inflection.Voice,
        Data.Inflection.Express Data.Inflection.Evidentiality,
        Data.Inflection.Express Data.Inflection.Transitivity,
        Data.Inflection.Express Data.Inflection.Volition)
  RecSel Left Data.Grammar.Leaf
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Leaf) ->
                 case ds of wild {
                   DEFAULT -> Data.Grammar.leafInfl1
                   Data.Grammar.LeafInfl ds1 ds2 -> ds2 }) -}
faddc385d7e43906e1b481546f1b3f62
  leafInfl1 ::
    (Data.Inflection.Express Data.Inflection.Gender,
     Data.Inflection.Express Data.Inflection.Animacy,
     Data.Inflection.Express Data.Inflection.Case,
     Data.Inflection.Express Data.Inflection.Number,
     Data.Inflection.Express Data.Inflection.Definiteness,
     Data.Inflection.Express Data.Inflection.Specificity,
     Data.Inflection.Express Data.Inflection.Topic,
     Data.Inflection.Express Data.Inflection.Person,
     Data.Inflection.Express Data.Inflection.Honorific,
     Data.Inflection.Express Data.Inflection.Polarity,
     Data.Inflection.Express Data.Inflection.Tense,
     Data.Inflection.Express Data.Inflection.Aspect,
     Data.Inflection.Express Data.Inflection.Mood,
     Data.Inflection.Express Data.Inflection.Voice,
     Data.Inflection.Express Data.Inflection.Evidentiality,
     Data.Inflection.Express Data.Inflection.Transitivity,
     Data.Inflection.Express Data.Inflection.Volition)
  {- Strictness: x -}
b20e0d2110c3fdccd584fd59278b3c03
  leafLC :: Data.Grammar.Leaf -> Data.Inflection.LexCat
  RecSel Left Data.Grammar.Leaf
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Leaf) ->
                 case ds of wild {
                   Data.Grammar.LeafNull ipv -> Data.Grammar.leafLC1
                   Data.Grammar.LeafInfl ds1 ds2 -> ds1
                   Data.Grammar.Leaf ds1 ds2 ds3 -> ds1 }) -}
85680abae324115ed10b55921a83cfb2
  leafLC1 :: Data.Inflection.LexCat
  {- Strictness: x -}
1f6775729ed2e3db6ff89e6edf55ed0b
  leafStr :: Data.Grammar.Leaf -> GHC.Base.String
  RecSel Left Data.Grammar.Leaf
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Leaf) ->
                 case ds of wild {
                   DEFAULT -> Data.Grammar.leafStr1
                   Data.Grammar.Leaf ds1 ds2 ds3 -> ds3 }) -}
3818c7deaa9bebf2f4abe967b0971aba
  leafStr1 :: GHC.Base.String
  {- Strictness: x -}
80fa359c599844b6f883818300fcca39
  phraseBar :: Data.Grammar.Phrase -> Data.Grammar.Bar
  RecSel Left Data.Grammar.Phrase
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Phrase) ->
                 case ds of wild {
                   Data.Grammar.XPNull -> Data.Grammar.phraseBar1
                   Data.Grammar.XP ds1 ds2 ds3 ds4 -> ds4 }) -}
117faedc1917924ecbd9a43407c1f878
  phraseBar1 :: Data.Grammar.Bar
  {- Strictness: x -}
56f352acccb9b6d22a88a33021eb05d6
  phraseIl :: Data.Grammar.Phrase -> Data.Grammar.Illoc
  RecSel Left Data.Grammar.Phrase
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Phrase) ->
                 case ds of wild {
                   Data.Grammar.XPNull -> Data.Grammar.phraseIl1
                   Data.Grammar.XP ds1 ds2 ds3 ds4 -> ds2 }) -}
772159631076a38922777d59f7245dbf
  phraseIl1 :: Data.Grammar.Illoc
  {- Strictness: x -}
5f30b9a899c826703669fc9822dd3f24
  phraseLC :: Data.Grammar.Phrase -> Data.Inflection.LexCat
  RecSel Left Data.Grammar.Phrase
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Phrase) ->
                 case ds of wild {
                   Data.Grammar.XPNull -> Data.Grammar.phraseLC1
                   Data.Grammar.XP ds1 ds2 ds3 ds4 -> ds1 }) -}
0255259a849995bcf793dfbb9d3dd82d
  phraseLC1 :: Data.Inflection.LexCat
  {- Strictness: x -}
d7ec8364e14067f4f8a798f16ef502cf
  specifier :: Data.Grammar.Phrase -> Data.Grammar.Phrase
  RecSel Left Data.Grammar.Phrase
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Grammar.Phrase) ->
                 case ds of wild {
                   Data.Grammar.XPNull -> Data.Grammar.specifier1
                   Data.Grammar.XP ds1 ds2 ds3 ds4 -> ds3 }) -}
412aace1fbce127f1807c96eec751f2e
  specifier1 :: Data.Grammar.Phrase
  {- Strictness: x -}
instance [safe] GHC.Enum.Enum [Data.Grammar.AffixHopping]
  = Data.Grammar.$fEnumAffixHopping
instance [safe] GHC.Enum.Enum [Data.Grammar.ComplementizerInitial]
  = Data.Grammar.$fEnumComplementizerInitial
instance [safe] GHC.Enum.Enum [Data.Grammar.Illoc]
  = Data.Grammar.$fEnumIlloc
instance [safe] GHC.Enum.Enum [Data.Grammar.ItoCMovement]
  = Data.Grammar.$fEnumItoCMovement
instance [safe] GHC.Enum.Enum [Data.Grammar.NullSubject]
  = Data.Grammar.$fEnumNullSubject
instance [safe] GHC.Enum.Enum [Data.Grammar.NullTopic]
  = Data.Grammar.$fEnumNullTopic
instance [safe] GHC.Enum.Enum [Data.Grammar.ObjectFinal]
  = Data.Grammar.$fEnumObjectFinal
instance [safe] GHC.Enum.Enum [Data.Grammar.ObligatoryTopic]
  = Data.Grammar.$fEnumObligatoryTopic
instance [safe] GHC.Enum.Enum [Data.Grammar.PiedPiping]
  = Data.Grammar.$fEnumPiedPiping
instance [safe] GHC.Enum.Enum [Data.Grammar.QuestionInversion]
  = Data.Grammar.$fEnumQuestionInversion
instance [safe] GHC.Enum.Enum [Data.Grammar.SubjectInitial]
  = Data.Grammar.$fEnumSubjectInitial
instance [safe] GHC.Enum.Enum [Data.Grammar.TopicMarking]
  = Data.Grammar.$fEnumTopicMarking
instance [safe] GHC.Enum.Enum [Data.Grammar.VtoIMovement]
  = Data.Grammar.$fEnumVtoIMovement
instance [safe] GHC.Enum.Enum [Data.Grammar.WHMovementObligatory]
  = Data.Grammar.$fEnumWHMovementObligatory
instance [safe] GHC.Classes.Eq [Data.Grammar.AffixHopping]
  = Data.Grammar.$fEqAffixHopping
instance [safe] GHC.Classes.Eq [Data.Grammar.Bar]
  = Data.Grammar.$fEqBar
instance [safe] GHC.Classes.Eq [Data.Grammar.ComplementizerInitial]
  = Data.Grammar.$fEqComplementizerInitial
instance [safe] GHC.Classes.Eq [Data.Grammar.Illoc]
  = Data.Grammar.$fEqIlloc
instance [safe] GHC.Classes.Eq [Data.Grammar.ItoCMovement]
  = Data.Grammar.$fEqItoCMovement
instance [safe] GHC.Classes.Eq [Data.Grammar.Leaf]
  = Data.Grammar.$fEqLeaf
instance [safe] GHC.Classes.Eq [Data.Grammar.NullSubject]
  = Data.Grammar.$fEqNullSubject
instance [safe] GHC.Classes.Eq [Data.Grammar.NullTopic]
  = Data.Grammar.$fEqNullTopic
instance [safe] GHC.Classes.Eq [Data.Grammar.ObjectFinal]
  = Data.Grammar.$fEqObjectFinal
instance [safe] GHC.Classes.Eq [Data.Grammar.ObligatoryTopic]
  = Data.Grammar.$fEqObligatoryTopic
instance [safe] GHC.Classes.Eq [Data.Grammar.Phrase]
  = Data.Grammar.$fEqPhrase
instance [safe] GHC.Classes.Eq [Data.Grammar.PiedPiping]
  = Data.Grammar.$fEqPiedPiping
instance [safe] GHC.Classes.Eq [Data.Grammar.QuestionInversion]
  = Data.Grammar.$fEqQuestionInversion
instance [safe] GHC.Classes.Eq [Data.Grammar.SubjectInitial]
  = Data.Grammar.$fEqSubjectInitial
instance [safe] GHC.Classes.Eq [Data.Grammar.TopicMarking]
  = Data.Grammar.$fEqTopicMarking
instance [safe] GHC.Classes.Eq [Data.Grammar.VtoIMovement]
  = Data.Grammar.$fEqVtoIMovement
instance [safe] GHC.Classes.Eq [Data.Grammar.WHMovementObligatory]
  = Data.Grammar.$fEqWHMovementObligatory
instance [safe] GHC.Read.Read [Data.Grammar.AffixHopping]
  = Data.Grammar.$fReadAffixHopping
instance [safe] GHC.Read.Read [Data.Grammar.ComplementizerInitial]
  = Data.Grammar.$fReadComplementizerInitial
instance [safe] GHC.Read.Read [Data.Grammar.ItoCMovement]
  = Data.Grammar.$fReadItoCMovement
instance [safe] GHC.Read.Read [Data.Grammar.NullSubject]
  = Data.Grammar.$fReadNullSubject
instance [safe] GHC.Read.Read [Data.Grammar.NullTopic]
  = Data.Grammar.$fReadNullTopic
instance [safe] GHC.Read.Read [Data.Grammar.ObjectFinal]
  = Data.Grammar.$fReadObjectFinal
instance [safe] GHC.Read.Read [Data.Grammar.ObligatoryTopic]
  = Data.Grammar.$fReadObligatoryTopic
instance [safe] GHC.Read.Read [Data.Grammar.PiedPiping]
  = Data.Grammar.$fReadPiedPiping
instance [safe] GHC.Read.Read [Data.Grammar.QuestionInversion]
  = Data.Grammar.$fReadQuestionInversion
instance [safe] GHC.Read.Read [Data.Grammar.SubjectInitial]
  = Data.Grammar.$fReadSubjectInitial
instance [safe] GHC.Read.Read [Data.Grammar.TopicMarking]
  = Data.Grammar.$fReadTopicMarking
instance [safe] GHC.Read.Read [Data.Grammar.VtoIMovement]
  = Data.Grammar.$fReadVtoIMovement
instance [safe] GHC.Read.Read [Data.Grammar.WHMovementObligatory]
  = Data.Grammar.$fReadWHMovementObligatory
instance [safe] GHC.Show.Show [Data.Grammar.AffixHopping]
  = Data.Grammar.$fShowAffixHopping
instance [safe] GHC.Show.Show [Data.Grammar.Bar]
  = Data.Grammar.$fShowBar
instance [safe] GHC.Show.Show [Data.Grammar.ComplementizerInitial]
  = Data.Grammar.$fShowComplementizerInitial
instance [safe] GHC.Show.Show [Data.Grammar.Grammar]
  = Data.Grammar.$fShowGrammar
instance [safe] GHC.Show.Show [Data.Grammar.Illoc]
  = Data.Grammar.$fShowIlloc
instance [safe] GHC.Show.Show [Data.Grammar.ItoCMovement]
  = Data.Grammar.$fShowItoCMovement
instance [safe] GHC.Show.Show [Data.Grammar.Leaf]
  = Data.Grammar.$fShowLeaf
instance [safe] GHC.Show.Show [Data.Grammar.NullSubject]
  = Data.Grammar.$fShowNullSubject
instance [safe] GHC.Show.Show [Data.Grammar.NullTopic]
  = Data.Grammar.$fShowNullTopic
instance [safe] GHC.Show.Show [Data.Grammar.ObjectFinal]
  = Data.Grammar.$fShowObjectFinal
instance [safe] GHC.Show.Show [Data.Grammar.ObligatoryTopic]
  = Data.Grammar.$fShowObligatoryTopic
instance [safe] GHC.Show.Show [Data.Grammar.Phrase]
  = Data.Grammar.$fShowPhrase
instance [safe] GHC.Show.Show [Data.Grammar.PiedPiping]
  = Data.Grammar.$fShowPiedPiping
instance [safe] GHC.Show.Show [Data.Grammar.QuestionInversion]
  = Data.Grammar.$fShowQuestionInversion
instance [safe] GHC.Show.Show [Data.Grammar.SubjectInitial]
  = Data.Grammar.$fShowSubjectInitial
instance [safe] GHC.Show.Show [Data.Grammar.TopicMarking]
  = Data.Grammar.$fShowTopicMarking
instance [safe] GHC.Show.Show [Data.Grammar.VtoIMovement]
  = Data.Grammar.$fShowVtoIMovement
instance [safe] GHC.Show.Show [Data.Grammar.WHMovementObligatory]
  = Data.Grammar.$fShowWHMovementObligatory
"SPEC/Data.Grammar $fEqExpress @ Case" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                  Data.Inflection.Case)
  Data.Inflection.$fEqExpress @ Data.Inflection.Case $dEq
  = Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress2
"SPEC/Data.Grammar $fEqExpress @ Mood" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                  Data.Inflection.Mood)
  Data.Inflection.$fEqExpress @ Data.Inflection.Mood $dEq
  = Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress
"SPEC/Data.Grammar $fEqExpress @ Tense" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                   Data.Inflection.Tense)
  Data.Inflection.$fEqExpress @ Data.Inflection.Tense $dEq
  = Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress1
"SPEC/Data.Grammar $fEqExpress_$c==10 @ Case" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                         Data.Inflection.Case)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Case $dEq
  = Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==2
"SPEC/Data.Grammar $fEqExpress_$c==10 @ Mood" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                         Data.Inflection.Mood)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Mood $dEq
  = Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==10
"SPEC/Data.Grammar $fEqExpress_$c==10 @ Tense" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                          Data.Inflection.Tense)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Tense $dEq
  = Data.Grammar.$s$fEq(,,,,,,,,,,,,,,,,)_$c==_$s$fEqExpress_$c==1
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

