
==================== FINAL INTERFACE ====================
2016-12-21 17:41:30.042468 UTC

interface con-lang-gen-0.0.0.1-JpecSLrjfNmG1CUMEdSr39:Data.Inflection [orphan module] 8001
  interface hash: 9bbde0583e8e575a243287f9342f97bb
  ABI hash: f266f0dbc95b0bc603741fea34af6d4b
  export-list hash: 3959414e78500c5c160744df7b5d22d7
  orphan hash: 866a054724bb80d6eba9f9ea6e1c94c5
  flag hash: 522edd5e9a36b33433e704b46b664894
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Inflection.Animacy{Data.Inflection.AN Data.Inflection.HUM Data.Inflection.INAN Data.Inflection.NHUM Data.Inflection.UANI Data.Inflection.ZO}
  Data.Inflection.Aspect{Data.Inflection.CONT Data.Inflection.HAB Data.Inflection.IPFV Data.Inflection.NNPROG Data.Inflection.NPROG Data.Inflection.PFV Data.Inflection.PROG Data.Inflection.UASP}
  Data.Inflection.Case{Data.Inflection.ABE Data.Inflection.ABL Data.Inflection.ABS Data.Inflection.ABS2 Data.Inflection.ABS3 Data.Inflection.ACC Data.Inflection.ADP Data.Inflection.BEN Data.Inflection.CAUS Data.Inflection.COMIT Data.Inflection.COMP Data.Inflection.DAT Data.Inflection.DIR Data.Inflection.DISTR Data.Inflection.DRT1 Data.Inflection.DRT2 Data.Inflection.DTR Data.Inflection.EQU Data.Inflection.ERG Data.Inflection.ERG2 Data.Inflection.GEN Data.Inflection.IDEN Data.Inflection.INDIR Data.Inflection.INS Data.Inflection.INSCOMIT Data.Inflection.INTR Data.Inflection.LAT Data.Inflection.LOC Data.Inflection.MTR Data.Inflection.NOM Data.Inflection.NOM2 Data.Inflection.OBJ Data.Inflection.OBL1 Data.Inflection.OBL2 Data.Inflection.OBL3 Data.Inflection.OBL4 Data.Inflection.OBL5 Data.Inflection.OBL6 Data.Inflection.ORN Data.Inflection.PART Data.Inflection.PEG Data.Inflection.POSS Data.Inflection.POST Data.Inflection.PREP Data.Inflection.PRIM Data.Inflection.SEC Data.Inflection.TR Data.Inflection.UCAS Data.Inflection.VOC}
  Data.Inflection.Definiteness{Data.Inflection.DEF Data.Inflection.INDF Data.Inflection.UDEF}
  Data.Inflection.Evidentiality{Data.Inflection.ASS Data.Inflection.AUD Data.Inflection.EXP Data.Inflection.HSY Data.Inflection.INFER Data.Inflection.NVIS Data.Inflection.QUO Data.Inflection.REP Data.Inflection.UEVI Data.Inflection.VIS}
  Data.Inflection.Express{Data.Inflection.Express Data.Inflection.NoExpress getExp}
  Data.Inflection.Gender{Data.Inflection.COM Data.Inflection.F Data.Inflection.M Data.Inflection.N Data.Inflection.UGEN}
  Data.Inflection.Honorific{Data.Inflection.FAM Data.Inflection.FORM Data.Inflection.NEU Data.Inflection.UHON}
  Data.Inflection.InflectionSystem{Data.Inflection.InflectionSystem aniSys aspSys casSys defSys eviSys genSys honSys mooSys numSys perSys polSys speSys tenSys topSys traSys voiSys volSys}
  Data.Inflection.LexCat{Data.Inflection.Adj Data.Inflection.Adpo Data.Inflection.Adv Data.Inflection.Comp Data.Inflection.Det Data.Inflection.Infl Data.Inflection.Noun Data.Inflection.Obj Data.Inflection.Pron Data.Inflection.Subj Data.Inflection.Verb}
  Data.Inflection.Manifest{Data.Inflection.Manifest Data.Inflection.NoManifest}
  Data.Inflection.ManifestSystem{Data.Inflection.ManifestSystem manSysCombos manSysLC manSysType}
  Data.Inflection.ManifestType{Data.Inflection.Particle Data.Inflection.Prefix Data.Inflection.Suffix}
  Data.Inflection.Mood{Data.Inflection.COND Data.Inflection.DEO Data.Inflection.EPIS Data.Inflection.IMP Data.Inflection.IND Data.Inflection.IRR Data.Inflection.JUS Data.Inflection.OPT Data.Inflection.POT Data.Inflection.SBJV Data.Inflection.UMOO}
  Data.Inflection.Number{Data.Inflection.DU Data.Inflection.PA Data.Inflection.PL Data.Inflection.SG Data.Inflection.TRI Data.Inflection.UNUM}
  Data.Inflection.Person{Data.Inflection.FIRST Data.Inflection.FSTEXCL Data.Inflection.FSTINCL Data.Inflection.SECOND Data.Inflection.THIRD Data.Inflection.THRDOBV Data.Inflection.THRDPROX Data.Inflection.UPER}
  Data.Inflection.Polarity{Data.Inflection.AFF Data.Inflection.NEG Data.Inflection.UPOL}
  Data.Inflection.Specificity{Data.Inflection.NSPEC Data.Inflection.SPEC Data.Inflection.USPE}
  Data.Inflection.Tense{Data.Inflection.AFUT Data.Inflection.AFUT1 Data.Inflection.AFUT2 Data.Inflection.AFUT3 Data.Inflection.APRS Data.Inflection.APST Data.Inflection.FUT Data.Inflection.FUTPER Data.Inflection.PFUT Data.Inflection.PPRS Data.Inflection.PPST Data.Inflection.PPST1 Data.Inflection.PPST2 Data.Inflection.PPST3 Data.Inflection.PRS Data.Inflection.PRSPER Data.Inflection.PST Data.Inflection.PSTPER Data.Inflection.UTEN}
  Data.Inflection.Topic{Data.Inflection.NTOP Data.Inflection.TOP Data.Inflection.UTOP}
  Data.Inflection.Transitivity{Data.Inflection.DITRANS Data.Inflection.MTRANS Data.Inflection.NTRANS Data.Inflection.TRANS Data.Inflection.UTRA}
  Data.Inflection.Voice{Data.Inflection.ACTIVE Data.Inflection.MIDDLE Data.Inflection.PASSIVE Data.Inflection.UVOI}
  Data.Inflection.Volition{Data.Inflection.NVOL Data.Inflection.UVOL Data.Inflection.VOL}
module dependencies: Data.Other Data.Phoneme
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Enum fdf7ac3e1b0be0a4a37257601bddad14
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Read 817c914615ac8e308afc0c675fb3f671
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  base-4.9.0.0:Text.ParserCombinators.ReadPrec 9512e2f4b227f507f87a150887202aed
import  -/  base-4.9.0.0:Text.Read.Lex fe3dd7b823826bf6870140c5363f9596
import  -/  Data.Other ca3d75b7f17df1a823d9bed122472296
  exports: a3d527128309076dcf1ad037267b56af
import  -/  Data.Phoneme 8d8abfca47f36976b4a493acc97ddf5b
  exports: cf7e229a8d1eca731bf27cf39a54d5d4
  Morpheme b30fcf8c1909ae0b282e12f97a52fc6c
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat :: GHC.Enum.Enum Data.Inflection.LexCat
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.LexCat
                  Data.Inflection.$fEnumLexCat_$csucc
                  Data.Inflection.$fEnumLexCat_$cpred
                  Data.Inflection.$fEnumLexCat_$ctoEnum
                  Data.Inflection.$fEnumLexCat_$cfromEnum
                  Data.Inflection.$fEnumLexCat_$cenumFrom
                  Data.Inflection.$fEnumLexCat_$cenumFromThen
                  Data.Inflection.$fEnumLexCat_$cenumFromTo
                  Data.Inflection.$fEnumLexCat_$cenumFromThenTo -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat1 :: GHC.Prim.Int# -> Data.Inflection.LexCat
  {- Arity: 1, Strictness: <L,U>x -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat2 :: Data.Inflection.LexCat
  {- Strictness: x -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat3 :: Data.Inflection.LexCat
  {- Strictness: x -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_$cenumFrom ::
    Data.Inflection.LexCat -> [Data.Inflection.LexCat]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.LexCat) ->
                 let {
                   x0 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ Data.Inflection.LexCat a
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 10#) of wild {
                   GHC.Types.False -> Data.Inflection.$fEnumLexCat_go x0
                   GHC.Types.True -> GHC.Types.[] @ Data.Inflection.LexCat }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_$cenumFromThen ::
    Data.Inflection.LexCat
    -> Data.Inflection.LexCat -> [Data.Inflection.LexCat]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.LexCat)
                   (b :: Data.Inflection.LexCat) ->
                 let {
                   a# :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ Data.Inflection.LexCat a
                 } in
                 let {
                   b# :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ Data.Inflection.LexCat b
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Inflection.LexCat]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (y :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [Data.Inflection.LexCat]
                            Data.Inflection.$fEnumLexCat_c1
                            (GHC.Types.[] @ Data.Inflection.LexCat)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [Data.Inflection.LexCat]
                            Data.Inflection.$fEnumLexCat_c1
                            (GHC.Types.[] @ Data.Inflection.LexCat)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 10# GHC.Types.True -> $j 0# }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_$cenumFromThenTo ::
    Data.Inflection.LexCat
    -> Data.Inflection.LexCat
    -> Data.Inflection.LexCat
    -> [Data.Inflection.LexCat]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Inflection.LexCat)
                   (x2 :: Data.Inflection.LexCat)
                   (y :: Data.Inflection.LexCat) ->
                 let {
                   x4 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ Data.Inflection.LexCat x1
                 } in
                 let {
                   x5 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ Data.Inflection.LexCat x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x5 x4) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [Data.Inflection.LexCat]
                        Data.Inflection.$fEnumLexCat_c
                        (GHC.Types.[] @ Data.Inflection.LexCat)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Data.Inflection.LexCat y)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [Data.Inflection.LexCat]
                        Data.Inflection.$fEnumLexCat_c
                        (GHC.Types.[] @ Data.Inflection.LexCat)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Data.Inflection.LexCat y) }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_$cenumFromTo ::
    Data.Inflection.LexCat
    -> Data.Inflection.LexCat -> [Data.Inflection.LexCat]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.LexCat)
                   (y :: Data.Inflection.LexCat) ->
                 let {
                   x0 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ Data.Inflection.LexCat x
                 } in
                 let {
                   y1 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ Data.Inflection.LexCat y
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go1 :: GHC.Prim.Int# -> [Data.Inflection.LexCat]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Prim.Int#) ->
                          GHC.Types.:
                            @ Data.Inflection.LexCat
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x1 0#) of wild1 {
                               GHC.Types.False -> Data.Inflection.$fEnumLexCat1 x1
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x1 10#) of wild2 {
                                    GHC.Types.False -> Data.Inflection.$fEnumLexCat1 x1
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ Data.Inflection.LexCat x1 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x1 y1) of wild1 {
                               GHC.Types.False -> go1 (GHC.Prim.+# x1 1#)
                               GHC.Types.True -> GHC.Types.[] @ Data.Inflection.LexCat })
                      } in
                      go1 x0
                   GHC.Types.True -> GHC.Types.[] @ Data.Inflection.LexCat }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_$cfromEnum :: Data.Inflection.LexCat -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Inflection.LexCat) ->
                 case a of x1 { DEFAULT ->
                 GHC.Types.I#
                   (GHC.Prim.dataToTag# @ Data.Inflection.LexCat x1) }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_$cpred ::
    Data.Inflection.LexCat -> Data.Inflection.LexCat
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Inflection.LexCat) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Data.Inflection.LexCat x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum#
                        @ Data.Inflection.LexCat
                        (GHC.Prim.+# wild -1#)
                   0# -> Data.Inflection.$fEnumLexCat2 } }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_$csucc ::
    Data.Inflection.LexCat -> Data.Inflection.LexCat
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Inflection.LexCat) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Data.Inflection.LexCat x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum#
                        @ Data.Inflection.LexCat
                        (GHC.Prim.+# wild 1#)
                   10# -> Data.Inflection.$fEnumLexCat3 } }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_$ctoEnum :: GHC.Types.Int -> Data.Inflection.LexCat
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Inflection.$w$ctoEnum ww1 }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_c ::
    GHC.Types.Int
    -> [Data.Inflection.LexCat] -> [Data.Inflection.LexCat]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Inflection.LexCat]) ->
                 GHC.Types.:
                   @ Data.Inflection.LexCat
                   (Data.Inflection.$fEnumLexCat_$ctoEnum x)
                   ys) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_c1 ::
    GHC.Types.Int
    -> [Data.Inflection.LexCat] -> [Data.Inflection.LexCat]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Inflection.LexCat]) ->
                 GHC.Types.:
                   @ Data.Inflection.LexCat
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Inflection.LexCat a })
                   ys) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEnumLexCat_go :: GHC.Prim.Int# -> [Data.Inflection.LexCat]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
0948560cb4521a73f205c9331d36ba1c
  $fEq(,,,,,,,,,,,,,,,,) ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c,
     GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f,
     GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i,
     GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l,
     GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o,
     GHC.Classes.Eq p, GHC.Classes.Eq q) =>
    GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
  DFunId
  {- Arity: 17, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      @ d
                      @ e
                      @ f
                      @ g
                      @ h
                      @ i
                      @ j
                      @ k
                      @ l
                      @ m
                      @ n
                      @ o
                      @ p
                      @ q
                      ($dEq :: GHC.Classes.Eq a)
                      ($dEq1 :: GHC.Classes.Eq b)
                      ($dEq2 :: GHC.Classes.Eq c)
                      ($dEq3 :: GHC.Classes.Eq d)
                      ($dEq4 :: GHC.Classes.Eq e)
                      ($dEq5 :: GHC.Classes.Eq f)
                      ($dEq6 :: GHC.Classes.Eq g)
                      ($dEq7 :: GHC.Classes.Eq h)
                      ($dEq8 :: GHC.Classes.Eq i)
                      ($dEq9 :: GHC.Classes.Eq j)
                      ($dEq10 :: GHC.Classes.Eq k)
                      ($dEq11 :: GHC.Classes.Eq l)
                      ($dEq12 :: GHC.Classes.Eq m)
                      ($dEq13 :: GHC.Classes.Eq n)
                      ($dEq14 :: GHC.Classes.Eq o)
                      ($dEq15 :: GHC.Classes.Eq p)
                      ($dEq16 :: GHC.Classes.Eq q).
                  @ (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
                  (Data.Inflection.$fEq(,,,,,,,,,,,,,,,,)_$c==
                     @ a
                     @ b
                     @ c
                     @ d
                     @ e
                     @ f
                     @ g
                     @ h
                     @ i
                     @ j
                     @ k
                     @ l
                     @ m
                     @ n
                     @ o
                     @ p
                     @ q
                     $dEq
                     $dEq1
                     $dEq2
                     $dEq3
                     $dEq4
                     $dEq5
                     $dEq6
                     $dEq7
                     $dEq8
                     $dEq9
                     $dEq10
                     $dEq11
                     $dEq12
                     $dEq13
                     $dEq14
                     $dEq15
                     $dEq16)
                  (Data.Inflection.$fEq(,,,,,,,,,,,,,,,,)_$c/=
                     @ a
                     @ b
                     @ c
                     @ d
                     @ e
                     @ f
                     @ g
                     @ h
                     @ i
                     @ j
                     @ k
                     @ l
                     @ m
                     @ n
                     @ o
                     @ p
                     @ q
                     $dEq
                     $dEq1
                     $dEq2
                     $dEq3
                     $dEq4
                     $dEq5
                     $dEq6
                     $dEq7
                     $dEq8
                     $dEq9
                     $dEq10
                     $dEq11
                     $dEq12
                     $dEq13
                     $dEq14
                     $dEq15
                     $dEq16) -}
8f94de47b551e639e4e44a817e56afdd
  $fEq(,,,,,,,,,,,,,,,,)_$c/= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c,
     GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f,
     GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i,
     GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l,
     GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o,
     GHC.Classes.Eq p, GHC.Classes.Eq q) =>
    (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
    -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
    -> GHC.Types.Bool
  {- Arity: 19, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (19, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ f
                   @ g
                   @ h
                   @ i
                   @ j
                   @ k
                   @ l
                   @ m
                   @ n
                   @ o
                   @ p
                   @ q
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   ($dEq2 :: GHC.Classes.Eq c)
                   ($dEq3 :: GHC.Classes.Eq d)
                   ($dEq4 :: GHC.Classes.Eq e)
                   ($dEq5 :: GHC.Classes.Eq f)
                   ($dEq6 :: GHC.Classes.Eq g)
                   ($dEq7 :: GHC.Classes.Eq h)
                   ($dEq8 :: GHC.Classes.Eq i)
                   ($dEq9 :: GHC.Classes.Eq j)
                   ($dEq10 :: GHC.Classes.Eq k)
                   ($dEq11 :: GHC.Classes.Eq l)
                   ($dEq12 :: GHC.Classes.Eq m)
                   ($dEq13 :: GHC.Classes.Eq n)
                   ($dEq14 :: GHC.Classes.Eq o)
                   ($dEq15 :: GHC.Classes.Eq p)
                   ($dEq16 :: GHC.Classes.Eq q)
                   (a1 :: (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q))
                   (b1 :: (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)) ->
                 case Data.Inflection.$fEq(,,,,,,,,,,,,,,,,)_$c==
                        @ a
                        @ b
                        @ c
                        @ d
                        @ e
                        @ f
                        @ g
                        @ h
                        @ i
                        @ j
                        @ k
                        @ l
                        @ m
                        @ n
                        @ o
                        @ p
                        @ q
                        $dEq
                        $dEq1
                        $dEq2
                        $dEq3
                        $dEq4
                        $dEq5
                        $dEq6
                        $dEq7
                        $dEq8
                        $dEq9
                        $dEq10
                        $dEq11
                        $dEq12
                        $dEq13
                        $dEq14
                        $dEq15
                        $dEq16
                        a1
                        b1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a546998da68e6aaaf7475f0531ee3ad0
  $fEq(,,,,,,,,,,,,,,,,)_$c== ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c,
     GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f,
     GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i,
     GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l,
     GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o,
     GHC.Classes.Eq p, GHC.Classes.Eq q) =>
    (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
    -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
    -> GHC.Types.Bool
  {- Arity: 19, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><S,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (19, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ f
                   @ g
                   @ h
                   @ i
                   @ j
                   @ k
                   @ l
                   @ m
                   @ n
                   @ o
                   @ p
                   @ q
                   (w :: GHC.Classes.Eq a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: GHC.Classes.Eq c)
                   (w3 :: GHC.Classes.Eq d)
                   (w4 :: GHC.Classes.Eq e)
                   (w5 :: GHC.Classes.Eq f)
                   (w6 :: GHC.Classes.Eq g)
                   (w7 :: GHC.Classes.Eq h)
                   (w8 :: GHC.Classes.Eq i)
                   (w9 :: GHC.Classes.Eq j)
                   (w10 :: GHC.Classes.Eq k)
                   (w11 :: GHC.Classes.Eq l)
                   (w12 :: GHC.Classes.Eq m)
                   (w13 :: GHC.Classes.Eq n)
                   (w14 :: GHC.Classes.Eq o)
                   (w15 :: GHC.Classes.Eq p)
                   (w16 :: GHC.Classes.Eq q)
                   (w17 :: (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q))
                   (w18 :: (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)) ->
                 case w17 of ww { (,,,,,,,,,,,,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ->
                 case w18 of ww18 { (,,,,,,,,,,,,,,,,) ww19 ww20 ww21 ww22 ww23 ww24 ww25 ww26 ww27 ww28 ww29 ww30 ww31 ww32 ww33 ww34 ww35 ->
                 Data.Inflection.$w$c==
                   @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ f
                   @ g
                   @ h
                   @ i
                   @ j
                   @ k
                   @ l
                   @ m
                   @ n
                   @ o
                   @ p
                   @ q
                   w
                   w1
                   w2
                   w3
                   w4
                   w5
                   w6
                   w7
                   w8
                   w9
                   w10
                   w11
                   w12
                   w13
                   w14
                   w15
                   w16
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17
                   ww19
                   ww20
                   ww21
                   ww22
                   ww23
                   ww24
                   ww25
                   ww26
                   ww27
                   ww28
                   ww29
                   ww30
                   ww31
                   ww32
                   ww33
                   ww34
                   ww35 } }) -}
1f555085a72acd0be7c2a6de830d5d03
  $fEqAnimacy :: GHC.Classes.Eq Data.Inflection.Animacy
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Animacy
                  Data.Inflection.$fEqAnimacy_$c==
                  Data.Inflection.$fEqAnimacy_$c/= -}
1f555085a72acd0be7c2a6de830d5d03
  $fEqAnimacy_$c/= ::
    Data.Inflection.Animacy
    -> Data.Inflection.Animacy -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Animacy)
                   (b :: Data.Inflection.Animacy) ->
                 case a of wild {
                   Data.Inflection.UANI
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UANI -> GHC.Types.False }
                   Data.Inflection.AN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.AN -> GHC.Types.False }
                   Data.Inflection.HUM
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.HUM -> GHC.Types.False }
                   Data.Inflection.NHUM
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.NHUM -> GHC.Types.False }
                   Data.Inflection.ZO
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.ZO -> GHC.Types.False }
                   Data.Inflection.INAN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.INAN -> GHC.Types.False } }) -}
1f555085a72acd0be7c2a6de830d5d03
  $fEqAnimacy_$c== ::
    Data.Inflection.Animacy
    -> Data.Inflection.Animacy -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Animacy)
                   (ds1 :: Data.Inflection.Animacy) ->
                 case ds of wild {
                   Data.Inflection.UANI
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UANI -> GHC.Types.True }
                   Data.Inflection.AN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.AN -> GHC.Types.True }
                   Data.Inflection.HUM
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.HUM -> GHC.Types.True }
                   Data.Inflection.NHUM
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.NHUM -> GHC.Types.True }
                   Data.Inflection.ZO
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.ZO -> GHC.Types.True }
                   Data.Inflection.INAN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.INAN -> GHC.Types.True } }) -}
73f9fcce4a2a405b233176b51f525cb2
  $fEqAspect :: GHC.Classes.Eq Data.Inflection.Aspect
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Aspect
                  Data.Inflection.$fEqAspect_$c==
                  Data.Inflection.$fEqAspect_$c/= -}
73f9fcce4a2a405b233176b51f525cb2
  $fEqAspect_$c/= ::
    Data.Inflection.Aspect -> Data.Inflection.Aspect -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Aspect)
                   (b :: Data.Inflection.Aspect) ->
                 case a of wild {
                   Data.Inflection.UASP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UASP -> GHC.Types.False }
                   Data.Inflection.NNPROG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.NNPROG -> GHC.Types.False }
                   Data.Inflection.PFV
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.PFV -> GHC.Types.False }
                   Data.Inflection.IPFV
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.IPFV -> GHC.Types.False }
                   Data.Inflection.HAB
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.HAB -> GHC.Types.False }
                   Data.Inflection.CONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.CONT -> GHC.Types.False }
                   Data.Inflection.NPROG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.NPROG -> GHC.Types.False }
                   Data.Inflection.PROG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.PROG -> GHC.Types.False } }) -}
73f9fcce4a2a405b233176b51f525cb2
  $fEqAspect_$c== ::
    Data.Inflection.Aspect -> Data.Inflection.Aspect -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Aspect)
                   (ds1 :: Data.Inflection.Aspect) ->
                 case ds of wild {
                   Data.Inflection.UASP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UASP -> GHC.Types.True }
                   Data.Inflection.NNPROG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.NNPROG -> GHC.Types.True }
                   Data.Inflection.PFV
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.PFV -> GHC.Types.True }
                   Data.Inflection.IPFV
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.IPFV -> GHC.Types.True }
                   Data.Inflection.HAB
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.HAB -> GHC.Types.True }
                   Data.Inflection.CONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.CONT -> GHC.Types.True }
                   Data.Inflection.NPROG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.NPROG -> GHC.Types.True }
                   Data.Inflection.PROG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.PROG -> GHC.Types.True } }) -}
476440af125c1822cd0b767cc8ac9f95
  $fEqCase :: GHC.Classes.Eq Data.Inflection.Case
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Case
                  Data.Inflection.$fEqCase_$c==
                  Data.Inflection.$fEqCase_$c/= -}
476440af125c1822cd0b767cc8ac9f95
  $fEqCase_$c/= ::
    Data.Inflection.Case -> Data.Inflection.Case -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Case) (b :: Data.Inflection.Case) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Data.Inflection.Case x1)
                           (GHC.Prim.dataToTag# @ Data.Inflection.Case x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
476440af125c1822cd0b767cc8ac9f95
  $fEqCase_$c== ::
    Data.Inflection.Case -> Data.Inflection.Case -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Case) (b :: Data.Inflection.Case) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ Data.Inflection.Case x1)
                      (GHC.Prim.dataToTag# @ Data.Inflection.Case x2)) } }) -}
1de448f2aa68251f2e0f9da9901aa214
  $fEqDefiniteness :: GHC.Classes.Eq Data.Inflection.Definiteness
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Definiteness
                  Data.Inflection.$fEqDefiniteness_$c==
                  Data.Inflection.$fEqDefiniteness_$c/= -}
1de448f2aa68251f2e0f9da9901aa214
  $fEqDefiniteness_$c/= ::
    Data.Inflection.Definiteness
    -> Data.Inflection.Definiteness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Definiteness)
                   (b :: Data.Inflection.Definiteness) ->
                 case a of wild {
                   Data.Inflection.UDEF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UDEF -> GHC.Types.False }
                   Data.Inflection.DEF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.DEF -> GHC.Types.False }
                   Data.Inflection.INDF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.INDF -> GHC.Types.False } }) -}
1de448f2aa68251f2e0f9da9901aa214
  $fEqDefiniteness_$c== ::
    Data.Inflection.Definiteness
    -> Data.Inflection.Definiteness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Definiteness)
                   (ds1 :: Data.Inflection.Definiteness) ->
                 case ds of wild {
                   Data.Inflection.UDEF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UDEF -> GHC.Types.True }
                   Data.Inflection.DEF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.DEF -> GHC.Types.True }
                   Data.Inflection.INDF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.INDF -> GHC.Types.True } }) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fEqEvidentiality :: GHC.Classes.Eq Data.Inflection.Evidentiality
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Evidentiality
                  Data.Inflection.$fEqEvidentiality_$c==
                  Data.Inflection.$fEqEvidentiality_$c/= -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fEqEvidentiality_$c/= ::
    Data.Inflection.Evidentiality
    -> Data.Inflection.Evidentiality -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Evidentiality)
                   (b :: Data.Inflection.Evidentiality) ->
                 case a of wild {
                   Data.Inflection.UEVI
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UEVI -> GHC.Types.False }
                   Data.Inflection.EXP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.EXP -> GHC.Types.False }
                   Data.Inflection.VIS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.VIS -> GHC.Types.False }
                   Data.Inflection.NVIS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.NVIS -> GHC.Types.False }
                   Data.Inflection.AUD
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.AUD -> GHC.Types.False }
                   Data.Inflection.INFER
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.INFER -> GHC.Types.False }
                   Data.Inflection.REP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.REP -> GHC.Types.False }
                   Data.Inflection.HSY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.HSY -> GHC.Types.False }
                   Data.Inflection.QUO
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.QUO -> GHC.Types.False }
                   Data.Inflection.ASS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.ASS -> GHC.Types.False } }) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fEqEvidentiality_$c== ::
    Data.Inflection.Evidentiality
    -> Data.Inflection.Evidentiality -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Evidentiality)
                   (ds1 :: Data.Inflection.Evidentiality) ->
                 case ds of wild {
                   Data.Inflection.UEVI
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UEVI -> GHC.Types.True }
                   Data.Inflection.EXP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.EXP -> GHC.Types.True }
                   Data.Inflection.VIS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.VIS -> GHC.Types.True }
                   Data.Inflection.NVIS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.NVIS -> GHC.Types.True }
                   Data.Inflection.AUD
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.AUD -> GHC.Types.True }
                   Data.Inflection.INFER
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.INFER -> GHC.Types.True }
                   Data.Inflection.REP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.REP -> GHC.Types.True }
                   Data.Inflection.HSY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.HSY -> GHC.Types.True }
                   Data.Inflection.QUO
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.QUO -> GHC.Types.True }
                   Data.Inflection.ASS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.ASS -> GHC.Types.True } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Data.Inflection.Express a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Data.Inflection.Express a)
                  (Data.Inflection.$fEqExpress_$c==10 @ a $dEq)
                  (Data.Inflection.$fEqExpress_$c/= @ a $dEq) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$c/= ::
    GHC.Classes.Eq a =>
    Data.Inflection.Express a
    -> Data.Inflection.Express a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Data.Inflection.Express a)
                   (b :: Data.Inflection.Express a) ->
                 case a1 of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a2
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case GHC.Classes.== @ a $dEq a2 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
8099e7e810494d6db288b5ee6338a850
  $fEqExpress_$c== ::
    Data.Inflection.Gender -> Data.Inflection.Gender -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Gender)
                   (ds1 :: Data.Inflection.Gender) ->
                 case ds of wild {
                   Data.Inflection.UGEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UGEN -> GHC.Types.True }
                   Data.Inflection.M
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.M -> GHC.Types.True }
                   Data.Inflection.F
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.F -> GHC.Types.True }
                   Data.Inflection.COM
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.COM -> GHC.Types.True }
                   Data.Inflection.N
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.N -> GHC.Types.True } }) -}
7465cc747c74e065f91b84b3f135a27f
  $fEqExpress_$c==1 ::
    Data.Inflection.Number -> Data.Inflection.Number -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Number)
                   (ds1 :: Data.Inflection.Number) ->
                 case ds of wild {
                   Data.Inflection.UNUM
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UNUM -> GHC.Types.True }
                   Data.Inflection.SG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.SG -> GHC.Types.True }
                   Data.Inflection.DU
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.DU -> GHC.Types.True }
                   Data.Inflection.TRI
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.TRI -> GHC.Types.True }
                   Data.Inflection.PA
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.PA -> GHC.Types.True }
                   Data.Inflection.PL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.PL -> GHC.Types.True } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$c==10 ::
    GHC.Classes.Eq a =>
    Data.Inflection.Express a
    -> Data.Inflection.Express a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: Data.Inflection.Express a)
                   (ds1 :: Data.Inflection.Express a) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1 -> GHC.Classes.== @ a $dEq a1 b1 } }) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fEqExpress_$c==2 ::
    Data.Inflection.Specificity
    -> Data.Inflection.Specificity -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Specificity)
                   (ds1 :: Data.Inflection.Specificity) ->
                 case ds of wild {
                   Data.Inflection.USPE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.USPE -> GHC.Types.True }
                   Data.Inflection.SPEC
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.SPEC -> GHC.Types.True }
                   Data.Inflection.NSPEC
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.NSPEC -> GHC.Types.True } }) -}
f6776b7675319519d06c9aea2dc03bf9
  $fEqExpress_$c==3 ::
    Data.Inflection.Topic -> Data.Inflection.Topic -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Topic) (ds1 :: Data.Inflection.Topic) ->
                 case ds of wild {
                   Data.Inflection.UTOP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UTOP -> GHC.Types.True }
                   Data.Inflection.TOP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.TOP -> GHC.Types.True }
                   Data.Inflection.NTOP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.NTOP -> GHC.Types.True } }) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fEqExpress_$c==4 ::
    Data.Inflection.Person -> Data.Inflection.Person -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Person)
                   (ds1 :: Data.Inflection.Person) ->
                 case ds of wild {
                   Data.Inflection.UPER
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UPER -> GHC.Types.True }
                   Data.Inflection.FIRST
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.FIRST -> GHC.Types.True }
                   Data.Inflection.FSTINCL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.FSTINCL -> GHC.Types.True }
                   Data.Inflection.FSTEXCL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.FSTEXCL -> GHC.Types.True }
                   Data.Inflection.SECOND
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.SECOND -> GHC.Types.True }
                   Data.Inflection.THIRD
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.THIRD -> GHC.Types.True }
                   Data.Inflection.THRDPROX
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.THRDPROX -> GHC.Types.True }
                   Data.Inflection.THRDOBV
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.THRDOBV -> GHC.Types.True } }) -}
fb068a739b47969783c008d0c5ccdfb8
  $fEqExpress_$c==5 ::
    Data.Inflection.Honorific
    -> Data.Inflection.Honorific -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Honorific)
                   (ds1 :: Data.Inflection.Honorific) ->
                 case ds of wild {
                   Data.Inflection.UHON
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UHON -> GHC.Types.True }
                   Data.Inflection.FAM
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.FAM -> GHC.Types.True }
                   Data.Inflection.NEU
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.NEU -> GHC.Types.True }
                   Data.Inflection.FORM
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.FORM -> GHC.Types.True } }) -}
1c2c61816b840e25aed576544ed551f7
  $fEqExpress_$c==6 ::
    Data.Inflection.Polarity
    -> Data.Inflection.Polarity -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Polarity)
                   (ds1 :: Data.Inflection.Polarity) ->
                 case ds of wild {
                   Data.Inflection.UPOL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UPOL -> GHC.Types.True }
                   Data.Inflection.AFF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.AFF -> GHC.Types.True }
                   Data.Inflection.NEG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.NEG -> GHC.Types.True } }) -}
82e4499831c335865b73c47901c341b5
  $fEqExpress_$c==7 ::
    Data.Inflection.Voice -> Data.Inflection.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Voice)
                   (ds1 :: Data.Inflection.Voice) ->
                 case ds of wild {
                   Data.Inflection.UVOI
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UVOI -> GHC.Types.True }
                   Data.Inflection.ACTIVE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.ACTIVE -> GHC.Types.True }
                   Data.Inflection.MIDDLE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.MIDDLE -> GHC.Types.True }
                   Data.Inflection.PASSIVE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.PASSIVE -> GHC.Types.True } }) -}
7302fbe55b71c04bf146a8a39e883cde
  $fEqExpress_$c==8 ::
    Data.Inflection.Transitivity
    -> Data.Inflection.Transitivity -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Transitivity)
                   (ds1 :: Data.Inflection.Transitivity) ->
                 case ds of wild {
                   Data.Inflection.UTRA
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UTRA -> GHC.Types.True }
                   Data.Inflection.NTRANS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.NTRANS -> GHC.Types.True }
                   Data.Inflection.TRANS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.TRANS -> GHC.Types.True }
                   Data.Inflection.MTRANS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.MTRANS -> GHC.Types.True }
                   Data.Inflection.DITRANS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.DITRANS -> GHC.Types.True } }) -}
637cf4191464029f30da46ab81b77985
  $fEqExpress_$c==9 ::
    Data.Inflection.Volition
    -> Data.Inflection.Volition -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Volition)
                   (ds1 :: Data.Inflection.Volition) ->
                 case ds of wild {
                   Data.Inflection.UVOL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.UVOL -> GHC.Types.True }
                   Data.Inflection.VOL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Inflection.VOL -> GHC.Types.True }
                   Data.Inflection.NVOL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.NVOL -> GHC.Types.True } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/= ::
    Data.Inflection.Express Data.Inflection.Gender
    -> Data.Inflection.Express Data.Inflection.Gender -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express Data.Inflection.Gender)
                   (b :: Data.Inflection.Express Data.Inflection.Gender) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UGEN
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UGEN -> GHC.Types.False }
                             Data.Inflection.M
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.M -> GHC.Types.False }
                             Data.Inflection.F
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.F -> GHC.Types.False }
                             Data.Inflection.COM
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.COM -> GHC.Types.False }
                             Data.Inflection.N
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.N -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=1 ::
    Data.Inflection.Express Data.Inflection.Animacy
    -> Data.Inflection.Express Data.Inflection.Animacy
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express
                           Data.Inflection.Animacy)
                   (b :: Data.Inflection.Express Data.Inflection.Animacy) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UANI
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UANI -> GHC.Types.False }
                             Data.Inflection.AN
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.AN -> GHC.Types.False }
                             Data.Inflection.HUM
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.HUM -> GHC.Types.False }
                             Data.Inflection.NHUM
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NHUM -> GHC.Types.False }
                             Data.Inflection.ZO
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.ZO -> GHC.Types.False }
                             Data.Inflection.INAN
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.INAN -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=10 ::
    Data.Inflection.Express Data.Inflection.Voice
    -> Data.Inflection.Express Data.Inflection.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express Data.Inflection.Voice)
                   (b :: Data.Inflection.Express Data.Inflection.Voice) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UVOI
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UVOI -> GHC.Types.False }
                             Data.Inflection.ACTIVE
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.ACTIVE -> GHC.Types.False }
                             Data.Inflection.MIDDLE
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.MIDDLE -> GHC.Types.False }
                             Data.Inflection.PASSIVE
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.PASSIVE -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=11 ::
    Data.Inflection.Express Data.Inflection.Evidentiality
    -> Data.Inflection.Express Data.Inflection.Evidentiality
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express
                           Data.Inflection.Evidentiality)
                   (b :: Data.Inflection.Express Data.Inflection.Evidentiality) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UEVI
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UEVI -> GHC.Types.False }
                             Data.Inflection.EXP
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.EXP -> GHC.Types.False }
                             Data.Inflection.VIS
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.VIS -> GHC.Types.False }
                             Data.Inflection.NVIS
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NVIS -> GHC.Types.False }
                             Data.Inflection.AUD
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.AUD -> GHC.Types.False }
                             Data.Inflection.INFER
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.INFER -> GHC.Types.False }
                             Data.Inflection.REP
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.REP -> GHC.Types.False }
                             Data.Inflection.HSY
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.HSY -> GHC.Types.False }
                             Data.Inflection.QUO
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.QUO -> GHC.Types.False }
                             Data.Inflection.ASS
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.ASS -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=12 ::
    Data.Inflection.Express Data.Inflection.Transitivity
    -> Data.Inflection.Express Data.Inflection.Transitivity
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express
                           Data.Inflection.Transitivity)
                   (b :: Data.Inflection.Express Data.Inflection.Transitivity) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UTRA
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UTRA -> GHC.Types.False }
                             Data.Inflection.NTRANS
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NTRANS -> GHC.Types.False }
                             Data.Inflection.TRANS
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.TRANS -> GHC.Types.False }
                             Data.Inflection.MTRANS
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.MTRANS -> GHC.Types.False }
                             Data.Inflection.DITRANS
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.DITRANS -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=13 ::
    Data.Inflection.Express Data.Inflection.Volition
    -> Data.Inflection.Express Data.Inflection.Volition
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express
                           Data.Inflection.Volition)
                   (b :: Data.Inflection.Express Data.Inflection.Volition) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UVOL
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UVOL -> GHC.Types.False }
                             Data.Inflection.VOL
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.VOL -> GHC.Types.False }
                             Data.Inflection.NVOL
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NVOL -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=2 ::
    Data.Inflection.Express Data.Inflection.Number
    -> Data.Inflection.Express Data.Inflection.Number -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express Data.Inflection.Number)
                   (b :: Data.Inflection.Express Data.Inflection.Number) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UNUM
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UNUM -> GHC.Types.False }
                             Data.Inflection.SG
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.SG -> GHC.Types.False }
                             Data.Inflection.DU
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.DU -> GHC.Types.False }
                             Data.Inflection.TRI
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.TRI -> GHC.Types.False }
                             Data.Inflection.PA
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.PA -> GHC.Types.False }
                             Data.Inflection.PL
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.PL -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=3 ::
    Data.Inflection.Express Data.Inflection.Definiteness
    -> Data.Inflection.Express Data.Inflection.Definiteness
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express
                           Data.Inflection.Definiteness)
                   (b :: Data.Inflection.Express Data.Inflection.Definiteness) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UDEF
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UDEF -> GHC.Types.False }
                             Data.Inflection.DEF
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.DEF -> GHC.Types.False }
                             Data.Inflection.INDF
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.INDF -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=4 ::
    Data.Inflection.Express Data.Inflection.Specificity
    -> Data.Inflection.Express Data.Inflection.Specificity
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express
                           Data.Inflection.Specificity)
                   (b :: Data.Inflection.Express Data.Inflection.Specificity) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.USPE
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.USPE -> GHC.Types.False }
                             Data.Inflection.SPEC
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.SPEC -> GHC.Types.False }
                             Data.Inflection.NSPEC
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NSPEC -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=5 ::
    Data.Inflection.Express Data.Inflection.Topic
    -> Data.Inflection.Express Data.Inflection.Topic -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express Data.Inflection.Topic)
                   (b :: Data.Inflection.Express Data.Inflection.Topic) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UTOP
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UTOP -> GHC.Types.False }
                             Data.Inflection.TOP
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.TOP -> GHC.Types.False }
                             Data.Inflection.NTOP
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NTOP -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=6 ::
    Data.Inflection.Express Data.Inflection.Person
    -> Data.Inflection.Express Data.Inflection.Person -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express Data.Inflection.Person)
                   (b :: Data.Inflection.Express Data.Inflection.Person) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UPER
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UPER -> GHC.Types.False }
                             Data.Inflection.FIRST
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.FIRST -> GHC.Types.False }
                             Data.Inflection.FSTINCL
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.FSTINCL -> GHC.Types.False }
                             Data.Inflection.FSTEXCL
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.FSTEXCL -> GHC.Types.False }
                             Data.Inflection.SECOND
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.SECOND -> GHC.Types.False }
                             Data.Inflection.THIRD
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.THIRD -> GHC.Types.False }
                             Data.Inflection.THRDPROX
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.THRDPROX -> GHC.Types.False }
                             Data.Inflection.THRDOBV
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.THRDOBV -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=7 ::
    Data.Inflection.Express Data.Inflection.Honorific
    -> Data.Inflection.Express Data.Inflection.Honorific
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express
                           Data.Inflection.Honorific)
                   (b :: Data.Inflection.Express Data.Inflection.Honorific) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UHON
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UHON -> GHC.Types.False }
                             Data.Inflection.FAM
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.FAM -> GHC.Types.False }
                             Data.Inflection.NEU
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.NEU -> GHC.Types.False }
                             Data.Inflection.FORM
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.FORM -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=8 ::
    Data.Inflection.Express Data.Inflection.Polarity
    -> Data.Inflection.Express Data.Inflection.Polarity
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express
                           Data.Inflection.Polarity)
                   (b :: Data.Inflection.Express Data.Inflection.Polarity) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UPOL
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UPOL -> GHC.Types.False }
                             Data.Inflection.AFF
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.AFF -> GHC.Types.False }
                             Data.Inflection.NEG
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NEG -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c/=9 ::
    Data.Inflection.Express Data.Inflection.Aspect
    -> Data.Inflection.Express Data.Inflection.Aspect -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Express Data.Inflection.Aspect)
                   (b :: Data.Inflection.Express Data.Inflection.Aspect) ->
                 case a of wild {
                   Data.Inflection.NoExpress
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express ipv -> GHC.Types.True }
                   Data.Inflection.Express a1
                   -> case b of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express b1
                        -> case a1 of wild2 {
                             Data.Inflection.UASP
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.UASP -> GHC.Types.False }
                             Data.Inflection.NNPROG
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NNPROG -> GHC.Types.False }
                             Data.Inflection.PFV
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.PFV -> GHC.Types.False }
                             Data.Inflection.IPFV
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.IPFV -> GHC.Types.False }
                             Data.Inflection.HAB
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True Data.Inflection.HAB -> GHC.Types.False }
                             Data.Inflection.CONT
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.CONT -> GHC.Types.False }
                             Data.Inflection.NPROG
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.NPROG -> GHC.Types.False }
                             Data.Inflection.PROG
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.True
                                  Data.Inflection.PROG -> GHC.Types.False } } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c== ::
    Data.Inflection.Express Data.Inflection.Gender
    -> Data.Inflection.Express Data.Inflection.Gender -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Gender)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Gender) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c== a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==1 ::
    Data.Inflection.Express Data.Inflection.Animacy
    -> Data.Inflection.Express Data.Inflection.Animacy
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Animacy)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Animacy) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqAnimacy_$c== a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==10 ::
    Data.Inflection.Express Data.Inflection.Voice
    -> Data.Inflection.Express Data.Inflection.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Voice)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Voice) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==7 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==11 ::
    Data.Inflection.Express Data.Inflection.Evidentiality
    -> Data.Inflection.Express Data.Inflection.Evidentiality
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Evidentiality)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Evidentiality) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqEvidentiality_$c== a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==12 ::
    Data.Inflection.Express Data.Inflection.Transitivity
    -> Data.Inflection.Express Data.Inflection.Transitivity
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Transitivity)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Transitivity) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==8 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==13 ::
    Data.Inflection.Express Data.Inflection.Volition
    -> Data.Inflection.Express Data.Inflection.Volition
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Volition)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Volition) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==9 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==2 ::
    Data.Inflection.Express Data.Inflection.Number
    -> Data.Inflection.Express Data.Inflection.Number -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Number)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Number) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==1 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==3 ::
    Data.Inflection.Express Data.Inflection.Definiteness
    -> Data.Inflection.Express Data.Inflection.Definiteness
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Definiteness)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Definiteness) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqDefiniteness_$c== a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==4 ::
    Data.Inflection.Express Data.Inflection.Specificity
    -> Data.Inflection.Express Data.Inflection.Specificity
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Specificity)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Specificity) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==2 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==5 ::
    Data.Inflection.Express Data.Inflection.Topic
    -> Data.Inflection.Express Data.Inflection.Topic -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Topic)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Topic) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==3 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==6 ::
    Data.Inflection.Express Data.Inflection.Person
    -> Data.Inflection.Express Data.Inflection.Person -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Person)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Person) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==4 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==7 ::
    Data.Inflection.Express Data.Inflection.Honorific
    -> Data.Inflection.Express Data.Inflection.Honorific
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Honorific)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Honorific) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==5 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==8 ::
    Data.Inflection.Express Data.Inflection.Polarity
    -> Data.Inflection.Express Data.Inflection.Polarity
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Polarity)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Polarity) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqExpress_$c==6 a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$c==9 ::
    Data.Inflection.Express Data.Inflection.Aspect
    -> Data.Inflection.Express Data.Inflection.Aspect -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.Express Data.Inflection.Aspect)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Aspect) ->
                 case ds of wild {
                   Data.Inflection.NoExpress
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.True
                        Data.Inflection.Express ipv -> GHC.Types.False }
                   Data.Inflection.Express a1
                   -> case ds1 of wild1 {
                        Data.Inflection.NoExpress -> GHC.Types.False
                        Data.Inflection.Express b1
                        -> Data.Inflection.$fEqAspect_$c== a1 b1 } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Gender)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Gender)
                  Data.Inflection.$fEqExpress_$s$c==
                  Data.Inflection.$fEqExpress_$s$c/= -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress1 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Animacy)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Animacy)
                  Data.Inflection.$fEqExpress_$s$c==1
                  Data.Inflection.$fEqExpress_$s$c/=1 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress10 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Voice)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Voice)
                  Data.Inflection.$fEqExpress_$s$c==10
                  Data.Inflection.$fEqExpress_$s$c/=10 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress11 ::
    GHC.Classes.Eq
      (Data.Inflection.Express Data.Inflection.Evidentiality)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Evidentiality)
                  Data.Inflection.$fEqExpress_$s$c==11
                  Data.Inflection.$fEqExpress_$s$c/=11 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress12 ::
    GHC.Classes.Eq
      (Data.Inflection.Express Data.Inflection.Transitivity)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Transitivity)
                  Data.Inflection.$fEqExpress_$s$c==12
                  Data.Inflection.$fEqExpress_$s$c/=12 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress13 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Volition)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Volition)
                  Data.Inflection.$fEqExpress_$s$c==13
                  Data.Inflection.$fEqExpress_$s$c/=13 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress2 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Number)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Number)
                  Data.Inflection.$fEqExpress_$s$c==2
                  Data.Inflection.$fEqExpress_$s$c/=2 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress3 ::
    GHC.Classes.Eq
      (Data.Inflection.Express Data.Inflection.Definiteness)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Definiteness)
                  Data.Inflection.$fEqExpress_$s$c==3
                  Data.Inflection.$fEqExpress_$s$c/=3 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress4 ::
    GHC.Classes.Eq
      (Data.Inflection.Express Data.Inflection.Specificity)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Specificity)
                  Data.Inflection.$fEqExpress_$s$c==4
                  Data.Inflection.$fEqExpress_$s$c/=4 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress5 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Topic)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Topic)
                  Data.Inflection.$fEqExpress_$s$c==5
                  Data.Inflection.$fEqExpress_$s$c/=5 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress6 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Person)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Person)
                  Data.Inflection.$fEqExpress_$s$c==6
                  Data.Inflection.$fEqExpress_$s$c/=6 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress7 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Honorific)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Honorific)
                  Data.Inflection.$fEqExpress_$s$c==7
                  Data.Inflection.$fEqExpress_$s$c/=7 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress8 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Polarity)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Polarity)
                  Data.Inflection.$fEqExpress_$s$c==8
                  Data.Inflection.$fEqExpress_$s$c/=8 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fEqExpress_$s$fEqExpress9 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Aspect)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Aspect)
                  Data.Inflection.$fEqExpress_$s$c==9
                  Data.Inflection.$fEqExpress_$s$c/=9 -}
8099e7e810494d6db288b5ee6338a850
  $fEqGender :: GHC.Classes.Eq Data.Inflection.Gender
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Gender
                  Data.Inflection.$fEqExpress_$c==
                  Data.Inflection.$fEqGender_$c/= -}
8099e7e810494d6db288b5ee6338a850
  $fEqGender_$c/= ::
    Data.Inflection.Gender -> Data.Inflection.Gender -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Gender)
                   (b :: Data.Inflection.Gender) ->
                 case a of wild {
                   Data.Inflection.UGEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UGEN -> GHC.Types.False }
                   Data.Inflection.M
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.M -> GHC.Types.False }
                   Data.Inflection.F
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.F -> GHC.Types.False }
                   Data.Inflection.COM
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.COM -> GHC.Types.False }
                   Data.Inflection.N
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.N -> GHC.Types.False } }) -}
fb068a739b47969783c008d0c5ccdfb8
  $fEqHonorific :: GHC.Classes.Eq Data.Inflection.Honorific
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Honorific
                  Data.Inflection.$fEqExpress_$c==5
                  Data.Inflection.$fEqHonorific_$c/= -}
fb068a739b47969783c008d0c5ccdfb8
  $fEqHonorific_$c/= ::
    Data.Inflection.Honorific
    -> Data.Inflection.Honorific -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Honorific)
                   (b :: Data.Inflection.Honorific) ->
                 case a of wild {
                   Data.Inflection.UHON
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UHON -> GHC.Types.False }
                   Data.Inflection.FAM
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.FAM -> GHC.Types.False }
                   Data.Inflection.NEU
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.NEU -> GHC.Types.False }
                   Data.Inflection.FORM
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.FORM -> GHC.Types.False } }) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fEqInflectionSystem ::
    GHC.Classes.Eq Data.Inflection.InflectionSystem
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.InflectionSystem
                  Data.Inflection.$fEqInflectionSystem_$c==
                  Data.Inflection.$fEqInflectionSystem_$c/= -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fEqInflectionSystem_$c/= ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.InflectionSystem -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLLLLLLLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)><S(SLLLLLLLLLLLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.InflectionSystem)
                   (b :: Data.Inflection.InflectionSystem) ->
                 case Data.Inflection.$fEqInflectionSystem_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fEqInflectionSystem_$c== ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.InflectionSystem -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLLLLLLLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)><S(SLLLLLLLLLLLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Data.Inflection.InflectionSystem)
                   (w1 :: Data.Inflection.InflectionSystem) ->
                 case w of ww { Data.Inflection.InflectionSystem ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ->
                 case w1 of ww18 { Data.Inflection.InflectionSystem ww19 ww20 ww21 ww22 ww23 ww24 ww25 ww26 ww27 ww28 ww29 ww30 ww31 ww32 ww33 ww34 ww35 ->
                 Data.Inflection.$w$c==1
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17
                   ww19
                   ww20
                   ww21
                   ww22
                   ww23
                   ww24
                   ww25
                   ww26
                   ww27
                   ww28
                   ww29
                   ww30
                   ww31
                   ww32
                   ww33
                   ww34
                   ww35 } }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEqLexCat :: GHC.Classes.Eq Data.Inflection.LexCat
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.LexCat
                  Data.Inflection.$fEqLexCat_$c==
                  Data.Inflection.$fEqLexCat_$c/= -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEqLexCat_$c/= ::
    Data.Inflection.LexCat -> Data.Inflection.LexCat -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.LexCat) (b :: Data.Inflection.LexCat) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Data.Inflection.LexCat x1)
                           (GHC.Prim.dataToTag# @ Data.Inflection.LexCat x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fEqLexCat_$c== ::
    Data.Inflection.LexCat -> Data.Inflection.LexCat -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.LexCat) (b :: Data.Inflection.LexCat) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ Data.Inflection.LexCat x1)
                      (GHC.Prim.dataToTag# @ Data.Inflection.LexCat x2)) } }) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fEqManifest ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Data.Inflection.Manifest a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Data.Inflection.Manifest a)
                  (Data.Inflection.$fEqManifest_$c== @ a $dEq)
                  (Data.Inflection.$fEqManifest_$c/= @ a $dEq) -}
bbcb171ae6dead0cd5095e2d02b10d22
  $fEqManifestSystem :: GHC.Classes.Eq Data.Inflection.ManifestSystem
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.ManifestSystem
                  Data.Inflection.$fEqManifestSystem_$c==
                  Data.Inflection.$fEqManifestSystem_$c/= -}
1df7f79288596e9571c6fc2c566dec18
  $fEqManifestSystem1 ::
    GHC.Classes.Eq
      (Data.Inflection.Express Data.Inflection.Gender,
       Data.Inflection.Express Data.Inflection.Animacy,
       Data.Inflection.Express Data.Inflection.Case,
       Data.Inflection.Express Data.Inflection.Number,
       Data.Inflection.Express Data.Inflection.Definiteness,
       Data.Inflection.Express Data.Inflection.Specificity,
       Data.Inflection.Express Data.Inflection.Topic,
       Data.Inflection.Express Data.Inflection.Person,
       Data.Inflection.Express Data.Inflection.Honorific,
       Data.Inflection.Express Data.Inflection.Polarity,
       Data.Inflection.Express Data.Inflection.Tense,
       Data.Inflection.Express Data.Inflection.Aspect,
       Data.Inflection.Express Data.Inflection.Mood,
       Data.Inflection.Express Data.Inflection.Voice,
       Data.Inflection.Express Data.Inflection.Evidentiality,
       Data.Inflection.Express Data.Inflection.Transitivity,
       Data.Inflection.Express Data.Inflection.Volition)
  {- Unfolding: (Data.Inflection.$fEq(,,,,,,,,,,,,,,,,)
                   @ (Data.Inflection.Express Data.Inflection.Gender)
                   @ (Data.Inflection.Express Data.Inflection.Animacy)
                   @ (Data.Inflection.Express Data.Inflection.Case)
                   @ (Data.Inflection.Express Data.Inflection.Number)
                   @ (Data.Inflection.Express Data.Inflection.Definiteness)
                   @ (Data.Inflection.Express Data.Inflection.Specificity)
                   @ (Data.Inflection.Express Data.Inflection.Topic)
                   @ (Data.Inflection.Express Data.Inflection.Person)
                   @ (Data.Inflection.Express Data.Inflection.Honorific)
                   @ (Data.Inflection.Express Data.Inflection.Polarity)
                   @ (Data.Inflection.Express Data.Inflection.Tense)
                   @ (Data.Inflection.Express Data.Inflection.Aspect)
                   @ (Data.Inflection.Express Data.Inflection.Mood)
                   @ (Data.Inflection.Express Data.Inflection.Voice)
                   @ (Data.Inflection.Express Data.Inflection.Evidentiality)
                   @ (Data.Inflection.Express Data.Inflection.Transitivity)
                   @ (Data.Inflection.Express Data.Inflection.Volition)
                   Data.Inflection.$fEqExpress_$s$fEqExpress
                   Data.Inflection.$fEqExpress_$s$fEqExpress1
                   Data.Inflection.$fEqManifestSystem4
                   Data.Inflection.$fEqExpress_$s$fEqExpress2
                   Data.Inflection.$fEqExpress_$s$fEqExpress3
                   Data.Inflection.$fEqExpress_$s$fEqExpress4
                   Data.Inflection.$fEqExpress_$s$fEqExpress5
                   Data.Inflection.$fEqExpress_$s$fEqExpress6
                   Data.Inflection.$fEqExpress_$s$fEqExpress7
                   Data.Inflection.$fEqExpress_$s$fEqExpress8
                   Data.Inflection.$fEqManifestSystem3
                   Data.Inflection.$fEqExpress_$s$fEqExpress9
                   Data.Inflection.$fEqManifestSystem2
                   Data.Inflection.$fEqExpress_$s$fEqExpress10
                   Data.Inflection.$fEqExpress_$s$fEqExpress11
                   Data.Inflection.$fEqExpress_$s$fEqExpress12
                   Data.Inflection.$fEqExpress_$s$fEqExpress13) -}
7faa349150ca92423a0ee2b62aa8e3c3
  $fEqManifestSystem2 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Mood)
  {- Unfolding: (Data.Inflection.$fEqExpress
                   @ Data.Inflection.Mood
                   Data.Inflection.$fEqMood) -}
c0943d099321e401d35b742916d3dc4d
  $fEqManifestSystem3 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Tense)
  {- Unfolding: (Data.Inflection.$fEqExpress
                   @ Data.Inflection.Tense
                   Data.Inflection.$fEqTense) -}
0eea3bd1a169969049150d1b7ca9d2d3
  $fEqManifestSystem4 ::
    GHC.Classes.Eq (Data.Inflection.Express Data.Inflection.Case)
  {- Unfolding: (Data.Inflection.$fEqExpress
                   @ Data.Inflection.Case
                   Data.Inflection.$fEqCase) -}
bbcb171ae6dead0cd5095e2d02b10d22
  $fEqManifestSystem_$c/= ::
    Data.Inflection.ManifestSystem
    -> Data.Inflection.ManifestSystem -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.ManifestSystem)
                   (b :: Data.Inflection.ManifestSystem) ->
                 case Data.Inflection.$fEqManifestSystem_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
bbcb171ae6dead0cd5095e2d02b10d22
  $fEqManifestSystem_$c== ::
    Data.Inflection.ManifestSystem
    -> Data.Inflection.ManifestSystem -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Data.Inflection.ManifestSystem)
                   (w1 :: Data.Inflection.ManifestSystem) ->
                 case w of ww { Data.Inflection.ManifestSystem ww1 ww2 ww3 ->
                 case w1 of ww4 { Data.Inflection.ManifestSystem ww5 ww6 ww7 ->
                 Data.Inflection.$w$c==2 ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
f30cf9e394d21779e0775adacf984856
  $fEqManifestSystem_$s$fEq(,) ::
    GHC.Classes.Eq
      (Data.Phoneme.Morpheme,
       (Data.Inflection.Express Data.Inflection.Gender,
        Data.Inflection.Express Data.Inflection.Animacy,
        Data.Inflection.Express Data.Inflection.Case,
        Data.Inflection.Express Data.Inflection.Number,
        Data.Inflection.Express Data.Inflection.Definiteness,
        Data.Inflection.Express Data.Inflection.Specificity,
        Data.Inflection.Express Data.Inflection.Topic,
        Data.Inflection.Express Data.Inflection.Person,
        Data.Inflection.Express Data.Inflection.Honorific,
        Data.Inflection.Express Data.Inflection.Polarity,
        Data.Inflection.Express Data.Inflection.Tense,
        Data.Inflection.Express Data.Inflection.Aspect,
        Data.Inflection.Express Data.Inflection.Mood,
        Data.Inflection.Express Data.Inflection.Voice,
        Data.Inflection.Express Data.Inflection.Evidentiality,
        Data.Inflection.Express Data.Inflection.Transitivity,
        Data.Inflection.Express Data.Inflection.Volition))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Phoneme.Morpheme,
                     (Data.Inflection.Express Data.Inflection.Gender,
                      Data.Inflection.Express Data.Inflection.Animacy,
                      Data.Inflection.Express Data.Inflection.Case,
                      Data.Inflection.Express Data.Inflection.Number,
                      Data.Inflection.Express Data.Inflection.Definiteness,
                      Data.Inflection.Express Data.Inflection.Specificity,
                      Data.Inflection.Express Data.Inflection.Topic,
                      Data.Inflection.Express Data.Inflection.Person,
                      Data.Inflection.Express Data.Inflection.Honorific,
                      Data.Inflection.Express Data.Inflection.Polarity,
                      Data.Inflection.Express Data.Inflection.Tense,
                      Data.Inflection.Express Data.Inflection.Aspect,
                      Data.Inflection.Express Data.Inflection.Mood,
                      Data.Inflection.Express Data.Inflection.Voice,
                      Data.Inflection.Express Data.Inflection.Evidentiality,
                      Data.Inflection.Express Data.Inflection.Transitivity,
                      Data.Inflection.Express Data.Inflection.Volition))
                  (GHC.Classes.$fEq(,)_$c==
                     @ Data.Phoneme.Morpheme
                     @ (Data.Inflection.Express Data.Inflection.Gender,
                        Data.Inflection.Express Data.Inflection.Animacy,
                        Data.Inflection.Express Data.Inflection.Case,
                        Data.Inflection.Express Data.Inflection.Number,
                        Data.Inflection.Express Data.Inflection.Definiteness,
                        Data.Inflection.Express Data.Inflection.Specificity,
                        Data.Inflection.Express Data.Inflection.Topic,
                        Data.Inflection.Express Data.Inflection.Person,
                        Data.Inflection.Express Data.Inflection.Honorific,
                        Data.Inflection.Express Data.Inflection.Polarity,
                        Data.Inflection.Express Data.Inflection.Tense,
                        Data.Inflection.Express Data.Inflection.Aspect,
                        Data.Inflection.Express Data.Inflection.Mood,
                        Data.Inflection.Express Data.Inflection.Voice,
                        Data.Inflection.Express Data.Inflection.Evidentiality,
                        Data.Inflection.Express Data.Inflection.Transitivity,
                        Data.Inflection.Express Data.Inflection.Volition)
                     Data.Phoneme.$fEqMorpheme
                     Data.Inflection.$fEqManifestSystem1)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ Data.Phoneme.Morpheme
                     @ (Data.Inflection.Express Data.Inflection.Gender,
                        Data.Inflection.Express Data.Inflection.Animacy,
                        Data.Inflection.Express Data.Inflection.Case,
                        Data.Inflection.Express Data.Inflection.Number,
                        Data.Inflection.Express Data.Inflection.Definiteness,
                        Data.Inflection.Express Data.Inflection.Specificity,
                        Data.Inflection.Express Data.Inflection.Topic,
                        Data.Inflection.Express Data.Inflection.Person,
                        Data.Inflection.Express Data.Inflection.Honorific,
                        Data.Inflection.Express Data.Inflection.Polarity,
                        Data.Inflection.Express Data.Inflection.Tense,
                        Data.Inflection.Express Data.Inflection.Aspect,
                        Data.Inflection.Express Data.Inflection.Mood,
                        Data.Inflection.Express Data.Inflection.Voice,
                        Data.Inflection.Express Data.Inflection.Evidentiality,
                        Data.Inflection.Express Data.Inflection.Transitivity,
                        Data.Inflection.Express Data.Inflection.Volition)
                     Data.Phoneme.$fEqMorpheme
                     Data.Inflection.$fEqManifestSystem1) -}
e80d8f471552e307f8ce67ea59e61dde
  $fEqManifestType :: GHC.Classes.Eq Data.Inflection.ManifestType
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.ManifestType
                  Data.Inflection.$fEqManifestType_$c==
                  Data.Inflection.$fEqManifestType_$c/= -}
e80d8f471552e307f8ce67ea59e61dde
  $fEqManifestType_$c/= ::
    Data.Inflection.ManifestType
    -> Data.Inflection.ManifestType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.ManifestType)
                   (b :: Data.Inflection.ManifestType) ->
                 case a of wild {
                   Data.Inflection.Particle
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.Particle -> GHC.Types.False }
                   Data.Inflection.Prefix
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.Prefix -> GHC.Types.False }
                   Data.Inflection.Suffix
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.Suffix -> GHC.Types.False } }) -}
e80d8f471552e307f8ce67ea59e61dde
  $fEqManifestType_$c== ::
    Data.Inflection.ManifestType
    -> Data.Inflection.ManifestType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Inflection.ManifestType)
                   (ds1 :: Data.Inflection.ManifestType) ->
                 case ds of wild {
                   Data.Inflection.Particle
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.Particle -> GHC.Types.True }
                   Data.Inflection.Prefix
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.Prefix -> GHC.Types.True }
                   Data.Inflection.Suffix
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Inflection.Suffix -> GHC.Types.True } }) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fEqManifest_$c/= ::
    GHC.Classes.Eq a =>
    Data.Inflection.Manifest a
    -> Data.Inflection.Manifest a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (a1 :: Data.Inflection.Manifest a)
                   (b :: Data.Inflection.Manifest a) ->
                 case a1 of wild {
                   Data.Inflection.NoManifest
                   -> case b of wild1 {
                        Data.Inflection.NoManifest -> GHC.Types.False
                        Data.Inflection.Manifest ipv ipv1 -> GHC.Types.True }
                   Data.Inflection.Manifest a2 a3
                   -> case b of wild1 {
                        Data.Inflection.NoManifest -> GHC.Types.True
                        Data.Inflection.Manifest b1 b2
                        -> case GHC.Classes.$fEq[]_$c==
                                  @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                     GHC.Types.Int)
                                  Data.Inflection.$fEqManifest_$s$fEq(,,)
                                  a2
                                  b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True
                             -> case GHC.Classes.== @ a $dEq a3 b2 of wild3 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True -> GHC.Types.False } } } }) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fEqManifest_$c== ::
    GHC.Classes.Eq a =>
    Data.Inflection.Manifest a
    -> Data.Inflection.Manifest a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: Data.Inflection.Manifest a)
                   (ds1 :: Data.Inflection.Manifest a) ->
                 case ds of wild {
                   Data.Inflection.NoManifest
                   -> case ds1 of wild1 {
                        Data.Inflection.NoManifest -> GHC.Types.True
                        Data.Inflection.Manifest ipv ipv1 -> GHC.Types.False }
                   Data.Inflection.Manifest a1 a2
                   -> case ds1 of wild1 {
                        Data.Inflection.NoManifest -> GHC.Types.False
                        Data.Inflection.Manifest b1 b2
                        -> case GHC.Classes.$fEq[]_$c==
                                  @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                     GHC.Types.Int)
                                  Data.Inflection.$fEqManifest_$s$fEq(,,)
                                  a1
                                  b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ a $dEq a2 b2 } } }) -}
4d38882dcfdbdd368febbc0658635096
  $fEqManifest_$s$c==16 ::
    Data.Inflection.Manifest [Data.Inflection.Volition]
    -> Data.Inflection.Manifest [Data.Inflection.Volition]
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Inflection.Manifest
                            [Data.Inflection.Volition])
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Volition]) ->
                 case ds of wild {
                   Data.Inflection.NoManifest
                   -> case ds1 of wild1 {
                        Data.Inflection.NoManifest -> GHC.Types.True
                        Data.Inflection.Manifest ipv ipv1 -> GHC.Types.False }
                   Data.Inflection.Manifest a1 a2
                   -> case ds1 of wild1 {
                        Data.Inflection.NoManifest -> GHC.Types.False
                        Data.Inflection.Manifest b1 b2
                        -> case GHC.Classes.$fEq[]_$c==
                                  @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                     GHC.Types.Int)
                                  Data.Inflection.$fEqManifest_$s$fEq(,,)
                                  a1
                                  b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Classes.$fEq[]_$c==
                                  @ Data.Inflection.Volition
                                  Data.Inflection.$fEqVolition
                                  a2
                                  b2 } } }) -}
809cd484a1624a63c35a5396ce35eee2
  $fEqManifest_$s$fEq(,,) ::
    GHC.Classes.Eq
      (Data.Inflection.LexCat, Data.Inflection.ManifestType,
       GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                     GHC.Types.Int)
                  (GHC.Classes.$fEq(,,)_$c==
                     @ Data.Inflection.LexCat
                     @ Data.Inflection.ManifestType
                     @ GHC.Types.Int
                     Data.Inflection.$fEqLexCat
                     Data.Inflection.$fEqManifestType
                     GHC.Classes.$fEqInt)
                  Data.Inflection.$fEqManifest_$s$fEq(,,)_$c/= -}
39c1e0a67598f73b811f48fb67d33745
  $fEqManifest_$s$fEq(,,)_$c/= ::
    (Data.Inflection.LexCat, Data.Inflection.ManifestType,
     GHC.Types.Int)
    -> (Data.Inflection.LexCat, Data.Inflection.ManifestType,
        GHC.Types.Int)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U(U))><S(SLL),1*U(1*U,1*U,1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                           GHC.Types.Int))
                   (b1 :: (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                           GHC.Types.Int)) ->
                 case GHC.Classes.$fEq(,,)_$c==
                        @ Data.Inflection.LexCat
                        @ Data.Inflection.ManifestType
                        @ GHC.Types.Int
                        Data.Inflection.$fEqLexCat
                        Data.Inflection.$fEqManifestType
                        GHC.Classes.$fEqInt
                        a1
                        b1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fEqMood :: GHC.Classes.Eq Data.Inflection.Mood
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Mood
                  Data.Inflection.$fEqMood_$c==
                  Data.Inflection.$fEqMood_$c/= -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fEqMood_$c/= ::
    Data.Inflection.Mood -> Data.Inflection.Mood -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Mood) (b :: Data.Inflection.Mood) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Data.Inflection.Mood x1)
                           (GHC.Prim.dataToTag# @ Data.Inflection.Mood x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fEqMood_$c== ::
    Data.Inflection.Mood -> Data.Inflection.Mood -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Mood) (b :: Data.Inflection.Mood) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ Data.Inflection.Mood x1)
                      (GHC.Prim.dataToTag# @ Data.Inflection.Mood x2)) } }) -}
7465cc747c74e065f91b84b3f135a27f
  $fEqNumber :: GHC.Classes.Eq Data.Inflection.Number
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Number
                  Data.Inflection.$fEqExpress_$c==1
                  Data.Inflection.$fEqNumber_$c/= -}
7465cc747c74e065f91b84b3f135a27f
  $fEqNumber_$c/= ::
    Data.Inflection.Number -> Data.Inflection.Number -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Number)
                   (b :: Data.Inflection.Number) ->
                 case a of wild {
                   Data.Inflection.UNUM
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UNUM -> GHC.Types.False }
                   Data.Inflection.SG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.SG -> GHC.Types.False }
                   Data.Inflection.DU
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.DU -> GHC.Types.False }
                   Data.Inflection.TRI
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.TRI -> GHC.Types.False }
                   Data.Inflection.PA
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.PA -> GHC.Types.False }
                   Data.Inflection.PL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.PL -> GHC.Types.False } }) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fEqPerson :: GHC.Classes.Eq Data.Inflection.Person
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Person
                  Data.Inflection.$fEqExpress_$c==4
                  Data.Inflection.$fEqPerson_$c/= -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fEqPerson_$c/= ::
    Data.Inflection.Person -> Data.Inflection.Person -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Person)
                   (b :: Data.Inflection.Person) ->
                 case a of wild {
                   Data.Inflection.UPER
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UPER -> GHC.Types.False }
                   Data.Inflection.FIRST
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.FIRST -> GHC.Types.False }
                   Data.Inflection.FSTINCL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.FSTINCL -> GHC.Types.False }
                   Data.Inflection.FSTEXCL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.FSTEXCL -> GHC.Types.False }
                   Data.Inflection.SECOND
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.SECOND -> GHC.Types.False }
                   Data.Inflection.THIRD
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.THIRD -> GHC.Types.False }
                   Data.Inflection.THRDPROX
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.THRDPROX -> GHC.Types.False }
                   Data.Inflection.THRDOBV
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.THRDOBV -> GHC.Types.False } }) -}
1c2c61816b840e25aed576544ed551f7
  $fEqPolarity :: GHC.Classes.Eq Data.Inflection.Polarity
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Polarity
                  Data.Inflection.$fEqExpress_$c==6
                  Data.Inflection.$fEqPolarity_$c/= -}
1c2c61816b840e25aed576544ed551f7
  $fEqPolarity_$c/= ::
    Data.Inflection.Polarity
    -> Data.Inflection.Polarity -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Polarity)
                   (b :: Data.Inflection.Polarity) ->
                 case a of wild {
                   Data.Inflection.UPOL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UPOL -> GHC.Types.False }
                   Data.Inflection.AFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.AFF -> GHC.Types.False }
                   Data.Inflection.NEG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.NEG -> GHC.Types.False } }) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fEqSpecificity :: GHC.Classes.Eq Data.Inflection.Specificity
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Specificity
                  Data.Inflection.$fEqExpress_$c==2
                  Data.Inflection.$fEqSpecificity_$c/= -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fEqSpecificity_$c/= ::
    Data.Inflection.Specificity
    -> Data.Inflection.Specificity -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Specificity)
                   (b :: Data.Inflection.Specificity) ->
                 case a of wild {
                   Data.Inflection.USPE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.USPE -> GHC.Types.False }
                   Data.Inflection.SPEC
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.SPEC -> GHC.Types.False }
                   Data.Inflection.NSPEC
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.NSPEC -> GHC.Types.False } }) -}
66acf52fe96ad50a10594fa2d12d699d
  $fEqTense :: GHC.Classes.Eq Data.Inflection.Tense
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Tense
                  Data.Inflection.$fEqTense_$c==
                  Data.Inflection.$fEqTense_$c/= -}
66acf52fe96ad50a10594fa2d12d699d
  $fEqTense_$c/= ::
    Data.Inflection.Tense -> Data.Inflection.Tense -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Tense) (b :: Data.Inflection.Tense) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Data.Inflection.Tense x1)
                           (GHC.Prim.dataToTag# @ Data.Inflection.Tense x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
66acf52fe96ad50a10594fa2d12d699d
  $fEqTense_$c== ::
    Data.Inflection.Tense -> Data.Inflection.Tense -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Tense) (b :: Data.Inflection.Tense) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ Data.Inflection.Tense x1)
                      (GHC.Prim.dataToTag# @ Data.Inflection.Tense x2)) } }) -}
f6776b7675319519d06c9aea2dc03bf9
  $fEqTopic :: GHC.Classes.Eq Data.Inflection.Topic
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Topic
                  Data.Inflection.$fEqExpress_$c==3
                  Data.Inflection.$fEqTopic_$c/= -}
f6776b7675319519d06c9aea2dc03bf9
  $fEqTopic_$c/= ::
    Data.Inflection.Topic -> Data.Inflection.Topic -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Topic) (b :: Data.Inflection.Topic) ->
                 case a of wild {
                   Data.Inflection.UTOP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UTOP -> GHC.Types.False }
                   Data.Inflection.TOP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.TOP -> GHC.Types.False }
                   Data.Inflection.NTOP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.NTOP -> GHC.Types.False } }) -}
7302fbe55b71c04bf146a8a39e883cde
  $fEqTransitivity :: GHC.Classes.Eq Data.Inflection.Transitivity
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Transitivity
                  Data.Inflection.$fEqExpress_$c==8
                  Data.Inflection.$fEqTransitivity_$c/= -}
7302fbe55b71c04bf146a8a39e883cde
  $fEqTransitivity_$c/= ::
    Data.Inflection.Transitivity
    -> Data.Inflection.Transitivity -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Transitivity)
                   (b :: Data.Inflection.Transitivity) ->
                 case a of wild {
                   Data.Inflection.UTRA
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UTRA -> GHC.Types.False }
                   Data.Inflection.NTRANS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.NTRANS -> GHC.Types.False }
                   Data.Inflection.TRANS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.TRANS -> GHC.Types.False }
                   Data.Inflection.MTRANS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.MTRANS -> GHC.Types.False }
                   Data.Inflection.DITRANS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.DITRANS -> GHC.Types.False } }) -}
82e4499831c335865b73c47901c341b5
  $fEqVoice :: GHC.Classes.Eq Data.Inflection.Voice
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Voice
                  Data.Inflection.$fEqExpress_$c==7
                  Data.Inflection.$fEqVoice_$c/= -}
82e4499831c335865b73c47901c341b5
  $fEqVoice_$c/= ::
    Data.Inflection.Voice -> Data.Inflection.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Inflection.Voice)
                   (b :: Data.Inflection.Voice) ->
                 case a of wild {
                   Data.Inflection.UVOI
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UVOI -> GHC.Types.False }
                   Data.Inflection.ACTIVE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.ACTIVE -> GHC.Types.False }
                   Data.Inflection.MIDDLE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.MIDDLE -> GHC.Types.False }
                   Data.Inflection.PASSIVE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.PASSIVE -> GHC.Types.False } }) -}
637cf4191464029f30da46ab81b77985
  $fEqVolition :: GHC.Classes.Eq Data.Inflection.Volition
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Volition
                  Data.Inflection.$fEqExpress_$c==9
                  Data.Inflection.$fEqVolition_$c/= -}
637cf4191464029f30da46ab81b77985
  $fEqVolition_$c/= ::
    Data.Inflection.Volition
    -> Data.Inflection.Volition -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Inflection.Volition)
                   (b :: Data.Inflection.Volition) ->
                 case a of wild {
                   Data.Inflection.UVOL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.UVOL -> GHC.Types.False }
                   Data.Inflection.VOL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Inflection.VOL -> GHC.Types.False }
                   Data.Inflection.NVOL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Inflection.NVOL -> GHC.Types.False } }) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy :: GHC.Read.Read Data.Inflection.Animacy
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Animacy
                  Data.Inflection.$fReadAnimacy_$creadsPrec
                  Data.Inflection.$fReadAnimacy_$creadList
                  Data.Inflection.$fReadAnimacy_$creadPrec
                  Data.Inflection.$fReadAnimacy_$creadListPrec -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Animacy] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Animacy]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Animacy
                   Data.Inflection.$fReadAnimacy2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Animacy>_R))
                   @ b
                   eta1) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAnimacy12,
                  Data.Inflection.$fReadAnimacy11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Animacy>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Animacy>_R))))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Animacy -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Animacy
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.INAN) -}
0545e900905cebdf5a1df26cabc644ab
  $fReadAnimacy12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INAN"#) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAnimacy15,
                  Data.Inflection.$fReadAnimacy14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Animacy>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Animacy>_R))))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Animacy -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Animacy
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ZO) -}
a23ca397ffc012894348e291915856b4
  $fReadAnimacy15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ZO"#) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy16 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAnimacy18,
                  Data.Inflection.$fReadAnimacy17
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Animacy>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Animacy>_R))))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy17 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Animacy -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Animacy
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NHUM) -}
1b4bf66648a9ee51170175654366fce0
  $fReadAnimacy18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NHUM"#) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy19 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAnimacy21,
                  Data.Inflection.$fReadAnimacy20
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Animacy>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Animacy>_R))))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Animacy
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Animacy
                   Data.Inflection.$fReadAnimacy3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Animacy>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Animacy>_R)))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy20 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Animacy -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Animacy
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.HUM) -}
23f5a0403e8d2bd0fc2b75851bd0638c
  $fReadAnimacy21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HUM"#) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy22 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAnimacy24,
                  Data.Inflection.$fReadAnimacy23
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Animacy>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Animacy>_R))))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy23 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Animacy -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Animacy
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.AN) -}
2fbb4c7bfeb3d1feea7d12f275e977d3
  $fReadAnimacy24 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AN"#) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy25 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAnimacy27,
                  Data.Inflection.$fReadAnimacy26
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Animacy>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Animacy>_R))))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy26 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Animacy -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Animacy
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UANI) -}
dc7a6c414712bbde111c747bc46ab590
  $fReadAnimacy27 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UANI"#) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy28 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Animacy]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Animacy
                   Data.Inflection.$fReadAnimacy2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Animacy>_R))
                   @ [Data.Inflection.Animacy]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Animacy])) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Animacy -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Animacy
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Animacy
                   Data.Inflection.$fReadAnimacy4
                   eta
                   @ b
                   eta1) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
                   Data.Inflection.$fReadAnimacy25
                   Data.Inflection.$fReadAnimacy5) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
                   Data.Inflection.$fReadAnimacy22
                   Data.Inflection.$fReadAnimacy6) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
                   Data.Inflection.$fReadAnimacy19
                   Data.Inflection.$fReadAnimacy7) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
                   Data.Inflection.$fReadAnimacy16
                   Data.Inflection.$fReadAnimacy8) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
                   Data.Inflection.$fReadAnimacy13
                   Data.Inflection.$fReadAnimacy9) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy)
                   Data.Inflection.$fReadAnimacy10
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Animacy))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Animacy]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Animacy]
                   Data.Inflection.$fReadAnimacy28) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Animacy]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadAnimacy1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Animacy]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Animacy]>_R))) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Animacy
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadAnimacy2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Animacy>_R)) -}
1f555085a72acd0be7c2a6de830d5d03
  $fReadAnimacy_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Animacy
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Animacy
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Animacy
                       Data.Inflection.$fReadAnimacy3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Animacy>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Animacy>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Animacy>_R)
                      @ Data.Inflection.Animacy
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Animacy))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect :: GHC.Read.Read Data.Inflection.Aspect
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Aspect
                  Data.Inflection.$fReadAspect_$creadsPrec
                  Data.Inflection.$fReadAspect_$creadList
                  Data.Inflection.$fReadAspect_$creadPrec
                  Data.Inflection.$fReadAspect_$creadListPrec -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Aspect] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Aspect]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Aspect
                   Data.Inflection.$fReadAspect2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Aspect>_R))
                   @ b
                   eta1) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
                   Data.Inflection.$fReadAspect15
                   Data.Inflection.$fReadAspect11) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
                   Data.Inflection.$fReadAspect12
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Aspect))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAspect14,
                  Data.Inflection.$fReadAspect13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Aspect>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Aspect>_R))))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Aspect
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PROG) -}
4a1a1ac9e7877f9c9550e9da0251f5a8
  $fReadAspect14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PROG"#) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAspect17,
                  Data.Inflection.$fReadAspect16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Aspect>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Aspect>_R))))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Aspect
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NPROG) -}
6980731210ed7b7b0acff65022d605ce
  $fReadAspect17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NPROG"#) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAspect20,
                  Data.Inflection.$fReadAspect19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Aspect>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Aspect>_R))))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Aspect
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.CONT) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Aspect
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Aspect
                   Data.Inflection.$fReadAspect3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Aspect>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Aspect>_R)))) -}
48c8d4b29e8f5a21cdab7ac96abccb1f
  $fReadAspect20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CONT"#) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAspect23,
                  Data.Inflection.$fReadAspect22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Aspect>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Aspect>_R))))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Aspect
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.HAB) -}
4fb98275668ec2931f2de4ea777ea202
  $fReadAspect23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HAB"#) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect24 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAspect26,
                  Data.Inflection.$fReadAspect25
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Aspect>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Aspect>_R))))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect25 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Aspect
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.IPFV) -}
ccf2e1da4c0a1e61425aec405ed095e8
  $fReadAspect26 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IPFV"#) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect27 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAspect29,
                  Data.Inflection.$fReadAspect28
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Aspect>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Aspect>_R))))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect28 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Aspect
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PFV) -}
f5c00d80e7754895e9340b36d4f2e977
  $fReadAspect29 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PFV"#) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Aspect
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Aspect
                   Data.Inflection.$fReadAspect4
                   eta
                   @ b
                   eta1) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect30 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAspect32,
                  Data.Inflection.$fReadAspect31
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Aspect>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Aspect>_R))))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect31 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Aspect
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NNPROG) -}
15bb5415085f3f7c08261adbb19d8660
  $fReadAspect32 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NNPROG"#) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect33 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadAspect35,
                  Data.Inflection.$fReadAspect34
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Aspect>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Aspect>_R))))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect34 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Aspect -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Aspect
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UASP) -}
9cea662896aee720d19ee02e8e15b3e3
  $fReadAspect35 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UASP"#) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect36 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Aspect]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Aspect
                   Data.Inflection.$fReadAspect2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Aspect>_R))
                   @ [Data.Inflection.Aspect]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Aspect])) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
                   Data.Inflection.$fReadAspect33
                   Data.Inflection.$fReadAspect5) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
                   Data.Inflection.$fReadAspect30
                   Data.Inflection.$fReadAspect6) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
                   Data.Inflection.$fReadAspect27
                   Data.Inflection.$fReadAspect7) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
                   Data.Inflection.$fReadAspect24
                   Data.Inflection.$fReadAspect8) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
                   Data.Inflection.$fReadAspect21
                   Data.Inflection.$fReadAspect9) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect)
                   Data.Inflection.$fReadAspect18
                   Data.Inflection.$fReadAspect10) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Aspect]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Aspect]
                   Data.Inflection.$fReadAspect36) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Aspect]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadAspect1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Aspect]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Aspect]>_R))) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Aspect
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadAspect2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Aspect>_R)) -}
73f9fcce4a2a405b233176b51f525cb2
  $fReadAspect_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Aspect
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Aspect
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Aspect
                       Data.Inflection.$fReadAspect3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Aspect>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Aspect>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Aspect>_R)
                      @ Data.Inflection.Aspect
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Aspect))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase :: GHC.Read.Read Data.Inflection.Case
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Case
                  Data.Inflection.$fReadCase_$creadsPrec
                  Data.Inflection.$fReadCase_$creadList
                  Data.Inflection.$fReadCase_$creadPrec
                  Data.Inflection.$fReadCase_$creadListPrec -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Case] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Case]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Case
                   Data.Inflection.$fReadCase2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Case>_R))
                   @ b
                   eta1) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase179
                   Data.Inflection.$fReadCase11) -}
2679dfa1625fcfc461e39dcdfe3a8a11
  $fReadCase100 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "COMP"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase101 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase103,
                  Data.Inflection.$fReadCase102
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase102 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ABL) -}
a3300479b9c7cffbada129b9afddfc5c
  $fReadCase103 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ABL"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase104 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase106,
                  Data.Inflection.$fReadCase105
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase105 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.LOC) -}
2b267d866d6704fbd37a711e46070247
  $fReadCase106 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LOC"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase107 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase109,
                  Data.Inflection.$fReadCase108
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase108 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.LAT) -}
54b5e7c092edd535483fc6bd1c69262d
  $fReadCase109 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAT"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase176
                   Data.Inflection.$fReadCase12) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase110 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase112,
                  Data.Inflection.$fReadCase111
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase111 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.POST) -}
953821dac29861e2e012ff73227fe211
  $fReadCase112 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POST"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase113 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase115,
                  Data.Inflection.$fReadCase114
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase114 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PREP) -}
282affbcce8a69b91c5d690ce6dcb81c
  $fReadCase115 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PREP"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase116 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase118,
                  Data.Inflection.$fReadCase117
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase117 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ADP) -}
180bed4f9d5476c14c9272f8b3d5a686
  $fReadCase118 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ADP"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase119 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase121,
                  Data.Inflection.$fReadCase120
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase173
                   Data.Inflection.$fReadCase13) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase120 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.OBL6) -}
4677d9317f40a6878c59b1a98758e5fd
  $fReadCase121 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OBL6"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase122 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase124,
                  Data.Inflection.$fReadCase123
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase123 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.OBL5) -}
246184968efb0d6ad00e9eb915d8f206
  $fReadCase124 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OBL5"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase125 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase127,
                  Data.Inflection.$fReadCase126
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase126 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.OBL4) -}
8dd48c196269d6af954e7460126d0e3a
  $fReadCase127 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OBL4"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase128 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase130,
                  Data.Inflection.$fReadCase129
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase129 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.OBL3) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase170
                   Data.Inflection.$fReadCase14) -}
e9eab990701eeb5faedabb93dc1dfed0
  $fReadCase130 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OBL3"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase131 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase133,
                  Data.Inflection.$fReadCase132
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase132 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.OBL2) -}
f19cf534bd072741443757a70e76be6c
  $fReadCase133 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OBL2"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase134 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase136,
                  Data.Inflection.$fReadCase135
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase135 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.OBL1) -}
237c8103b551792b1740033199d3ca1e
  $fReadCase136 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OBL1"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase137 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase139,
                  Data.Inflection.$fReadCase138
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase138 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DRT2) -}
90e7cc51ed2a37f04c8ea937ba9ac07f
  $fReadCase139 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DRT2"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase167
                   Data.Inflection.$fReadCase15) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase140 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase142,
                  Data.Inflection.$fReadCase141
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase141 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.TR) -}
98957c4e778c10f740a8fbef4244b449
  $fReadCase142 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TR"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase143 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase145,
                  Data.Inflection.$fReadCase144
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase144 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DRT1) -}
5fdac265b675572cd701578100bb36aa
  $fReadCase145 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DRT1"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase146 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase148,
                  Data.Inflection.$fReadCase147
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase147 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.OBJ) -}
6b974a1c8998c57fb20dcb5c151cc50e
  $fReadCase148 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OBJ"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase149 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase151,
                  Data.Inflection.$fReadCase150
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase164
                   Data.Inflection.$fReadCase16) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase150 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DTR) -}
5c2667f1b00819f2a94a0d28accdf5ea
  $fReadCase151 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DTR"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase152 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase154,
                  Data.Inflection.$fReadCase153
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase153 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ABS3) -}
2f9bd0d76aa067ea7656482c860a7e4e
  $fReadCase154 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ABS3"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase155 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase157,
                  Data.Inflection.$fReadCase156
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase156 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ABS2) -}
65a36c2e26ff859881634705360e2484
  $fReadCase157 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ABS2"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase158 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase160,
                  Data.Inflection.$fReadCase159
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase159 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NOM2) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase161
                   Data.Inflection.$fReadCase17) -}
f54e2d6cbc34d5ee0935cd1e276f280f
  $fReadCase160 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NOM2"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase161 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase163,
                  Data.Inflection.$fReadCase162
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase162 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ERG2) -}
ad6682132deaacc0a73e81ef8b6b46c7
  $fReadCase163 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ERG2"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase164 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase166,
                  Data.Inflection.$fReadCase165
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase165 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PRIM) -}
8c929b0544dfee3c67a9f53f6cf9cfb2
  $fReadCase166 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PRIM"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase167 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase169,
                  Data.Inflection.$fReadCase168
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase168 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DIR) -}
af66a768df987eb29c7f6d7802c64aa7
  $fReadCase169 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DIR"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase17 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase158
                   Data.Inflection.$fReadCase18) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase170 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase172,
                  Data.Inflection.$fReadCase171
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase171 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.MTR) -}
2575afc49d2cf0f5b6e9b95650cc248c
  $fReadCase172 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MTR"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase173 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase175,
                  Data.Inflection.$fReadCase174
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase174 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ABS) -}
d1d0e97c278a33144f2a403e86e06de8
  $fReadCase175 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ABS"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase176 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase178,
                  Data.Inflection.$fReadCase177
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase177 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NOM) -}
941f7e95b198536c34ee4c30e40b4b73
  $fReadCase178 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NOM"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase179 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase181,
                  Data.Inflection.$fReadCase180
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase18 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase155
                   Data.Inflection.$fReadCase19) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase180 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.SEC) -}
68c1bd2e3ffb63955c8130c0d4e5ea4c
  $fReadCase181 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SEC"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase182 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase184,
                  Data.Inflection.$fReadCase183
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase183 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.INDIR) -}
3d2d10468f5b4b71940063ddf4331d48
  $fReadCase184 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INDIR"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase185 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase187,
                  Data.Inflection.$fReadCase186
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase186 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PEG) -}
c9353a17fa699a01fe304a62da96239d
  $fReadCase187 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PEG"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase188 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase190,
                  Data.Inflection.$fReadCase189
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase189 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ERG) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase19 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase152
                   Data.Inflection.$fReadCase20) -}
78b602ce5bb40c42862c7fb3294555ba
  $fReadCase190 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ERG"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase191 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase193,
                  Data.Inflection.$fReadCase192
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase192 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ACC) -}
834d69707762b6a3d9d744690b41a517
  $fReadCase193 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACC"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase194 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase196,
                  Data.Inflection.$fReadCase195
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase195 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.INTR) -}
d052558a7e75c2c97542bff9dfe68d04
  $fReadCase196 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INTR"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase197 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase199,
                  Data.Inflection.$fReadCase198
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase198 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UCAS) -}
a0ba45729185e4508674c2f94dae3a9f
  $fReadCase199 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UCAS"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Case
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Case
                   Data.Inflection.$fReadCase3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Case>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Case>_R)))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase20 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase149
                   Data.Inflection.$fReadCase21) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase200 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Case]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Case
                   Data.Inflection.$fReadCase2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Case>_R))
                   @ [Data.Inflection.Case]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Case])) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase146
                   Data.Inflection.$fReadCase22) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase22 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase143
                   Data.Inflection.$fReadCase23) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase23 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase140
                   Data.Inflection.$fReadCase24) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase24 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase137
                   Data.Inflection.$fReadCase25) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase25 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase134
                   Data.Inflection.$fReadCase26) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase26 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase131
                   Data.Inflection.$fReadCase27) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase27 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase128
                   Data.Inflection.$fReadCase28) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase28 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase125
                   Data.Inflection.$fReadCase29) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase29 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase122
                   Data.Inflection.$fReadCase30) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Case
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Case
                   Data.Inflection.$fReadCase4
                   eta
                   @ b
                   eta1) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase30 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase119
                   Data.Inflection.$fReadCase31) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase31 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase116
                   Data.Inflection.$fReadCase32) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase32 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase113
                   Data.Inflection.$fReadCase33) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase33 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase110
                   Data.Inflection.$fReadCase34) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase34 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase107
                   Data.Inflection.$fReadCase35) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase35 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase104
                   Data.Inflection.$fReadCase36) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase36 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase101
                   Data.Inflection.$fReadCase37) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase37 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase98
                   Data.Inflection.$fReadCase38) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase38 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase95
                   Data.Inflection.$fReadCase39) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase39 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase92
                   Data.Inflection.$fReadCase40) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase197
                   Data.Inflection.$fReadCase5) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase40 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase89
                   Data.Inflection.$fReadCase41) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase41 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase86
                   Data.Inflection.$fReadCase42) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase42 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase83
                   Data.Inflection.$fReadCase43) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase43 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase80
                   Data.Inflection.$fReadCase44) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase44 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase77
                   Data.Inflection.$fReadCase45) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase45 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase74
                   Data.Inflection.$fReadCase46) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase46 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase71
                   Data.Inflection.$fReadCase47) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase47 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase68
                   Data.Inflection.$fReadCase48) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase48 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase65
                   Data.Inflection.$fReadCase49) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase49 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase62
                   Data.Inflection.$fReadCase50) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase194
                   Data.Inflection.$fReadCase6) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase50 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase59
                   Data.Inflection.$fReadCase51) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase51 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase56
                   Data.Inflection.$fReadCase52) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase52 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase53
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase55,
                  Data.Inflection.$fReadCase54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.VOC) -}
0c4bab5f6e69f0ee57b683c075a34d1b
  $fReadCase55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOC"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase56 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase58,
                  Data.Inflection.$fReadCase57
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase57 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PART) -}
19c141f8a35018465429647a3de6ff58
  $fReadCase58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PART"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase59 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase61,
                  Data.Inflection.$fReadCase60
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase191
                   Data.Inflection.$fReadCase7) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase60 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.POSS) -}
caba41830bdf8d0ac85851b22bc26029
  $fReadCase61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POSS"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase62 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase64,
                  Data.Inflection.$fReadCase63
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase63 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.GEN) -}
58a2e22a69b4a00a550c483baac50c7b
  $fReadCase64 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GEN"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase65 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase67,
                  Data.Inflection.$fReadCase66
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase66 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DISTR) -}
cd4a6dc3fe3d73157a9c63563a63308e
  $fReadCase67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DISTR"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase68 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase70,
                  Data.Inflection.$fReadCase69
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase69 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.CAUS) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase188
                   Data.Inflection.$fReadCase8) -}
a91eebd4ebfad55663153c7d29cb353c
  $fReadCase70 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CAUS"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase71 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase73,
                  Data.Inflection.$fReadCase72
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase72 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.BEN) -}
761ede26a596b44d18b737bf72d939ca
  $fReadCase73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BEN"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase74 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase76,
                  Data.Inflection.$fReadCase75
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase75 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ORN) -}
ca1bc63c20987e0c117c34983692ddfe
  $fReadCase76 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ORN"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase77 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase79,
                  Data.Inflection.$fReadCase78
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase78 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.INSCOMIT) -}
cff5b35acb7c0c34653012c8d9b36ace
  $fReadCase79 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INSCOMIT"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase185
                   Data.Inflection.$fReadCase9) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase80 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase82,
                  Data.Inflection.$fReadCase81
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase81 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.COMIT) -}
cb759cc3a1290eebc73b97d88ad50c27
  $fReadCase82 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "COMIT"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase83 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase85,
                  Data.Inflection.$fReadCase84
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase84 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.INS) -}
58c6520a2aaa8489e37fe9829075972e
  $fReadCase85 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INS"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase86 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase88,
                  Data.Inflection.$fReadCase87
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase87 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DAT) -}
be1af4b0d187b42887f42eae24d997aa
  $fReadCase88 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DAT"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase89 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase91,
                  Data.Inflection.$fReadCase90
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
                   Data.Inflection.$fReadCase182
                   Data.Inflection.$fReadCase10) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase90 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ABE) -}
44ad7db31b270c4abffb0f1ed5bdfa7b
  $fReadCase91 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ABE"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase92 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase94,
                  Data.Inflection.$fReadCase93
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase93 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.IDEN) -}
a2d99c928321d7b5ca3d5be9a95b7de7
  $fReadCase94 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IDEN"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase95 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase97,
                  Data.Inflection.$fReadCase96
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase96 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.EQU) -}
33f0851d5f37485129af39c51af0eaba
  $fReadCase97 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EQU"#) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase98 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadCase100,
                  Data.Inflection.$fReadCase99
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Case>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Case>_R))))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase99 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Case -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Case
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.COMP) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Case]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Case]
                   Data.Inflection.$fReadCase200) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Case]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadCase1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Case]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Case]>_R))) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Case
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadCase2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Case>_R)) -}
476440af125c1822cd0b767cc8ac9f95
  $fReadCase_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Case
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Case
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Case
                       Data.Inflection.$fReadCase3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Case>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Case>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Inflection.Case>_R)
                      @ Data.Inflection.Case
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Case))) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness :: GHC.Read.Read Data.Inflection.Definiteness
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Definiteness
                  Data.Inflection.$fReadDefiniteness_$creadsPrec
                  Data.Inflection.$fReadDefiniteness_$creadList
                  Data.Inflection.$fReadDefiniteness_$creadPrec
                  Data.Inflection.$fReadDefiniteness_$creadListPrec -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Definiteness]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Definiteness]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Definiteness
                   Data.Inflection.$fReadDefiniteness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Definiteness>_R))
                   @ b
                   eta1) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Definiteness)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadDefiniteness12,
                  Data.Inflection.$fReadDefiniteness11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Definiteness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Definiteness>_R))))) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Definiteness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Definiteness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DEF) -}
7c4c6f6d09fae5509721ee10acea06e4
  $fReadDefiniteness12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DEF"#) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Definiteness)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadDefiniteness15,
                  Data.Inflection.$fReadDefiniteness14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Definiteness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Definiteness>_R))))) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Definiteness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Definiteness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UDEF) -}
edb0167ee3e4633a6f687457359959f4
  $fReadDefiniteness15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UDEF"#) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness16 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Definiteness]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Definiteness
                   Data.Inflection.$fReadDefiniteness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Definiteness>_R))
                   @ [Data.Inflection.Definiteness]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Definiteness])) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Definiteness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Definiteness
                   Data.Inflection.$fReadDefiniteness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Definiteness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Definiteness>_R)))) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Definiteness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Definiteness
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Definiteness
                   Data.Inflection.$fReadDefiniteness4
                   eta
                   @ b
                   eta1) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Definiteness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Definiteness)
                   Data.Inflection.$fReadDefiniteness13
                   Data.Inflection.$fReadDefiniteness5) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Definiteness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Definiteness)
                   Data.Inflection.$fReadDefiniteness10
                   Data.Inflection.$fReadDefiniteness6) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Definiteness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Definiteness)
                   Data.Inflection.$fReadDefiniteness7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Definiteness))) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Definiteness)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadDefiniteness9,
                  Data.Inflection.$fReadDefiniteness8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Definiteness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Definiteness>_R))))) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Definiteness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Definiteness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.INDF) -}
a3f1f5c5fdcc4fbf2bc7b02dc904f0b4
  $fReadDefiniteness9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INDF"#) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Definiteness]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Definiteness]
                   Data.Inflection.$fReadDefiniteness16) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.Definiteness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadDefiniteness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Definiteness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Definiteness]>_R))) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Inflection.Definiteness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadDefiniteness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Definiteness>_R)) -}
1de448f2aa68251f2e0f9da9901aa214
  $fReadDefiniteness_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Definiteness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Definiteness
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Definiteness
                       Data.Inflection.$fReadDefiniteness3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Definiteness>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Definiteness>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Definiteness>_R)
                      @ Data.Inflection.Definiteness
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Definiteness))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality :: GHC.Read.Read Data.Inflection.Evidentiality
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Evidentiality
                  Data.Inflection.$fReadEvidentiality_$creadsPrec
                  Data.Inflection.$fReadEvidentiality_$creadList
                  Data.Inflection.$fReadEvidentiality_$creadPrec
                  Data.Inflection.$fReadEvidentiality_$creadListPrec -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Evidentiality]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Evidentiality]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Evidentiality
                   Data.Inflection.$fReadEvidentiality2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Evidentiality>_R))
                   @ b
                   eta1) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality23
                   Data.Inflection.$fReadEvidentiality11) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality20
                   Data.Inflection.$fReadEvidentiality12) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality17
                   Data.Inflection.$fReadEvidentiality13) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality14
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Evidentiality))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality16,
                  Data.Inflection.$fReadEvidentiality15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ASS) -}
66b8ccf808d80a57ebcba44c62ce0078
  $fReadEvidentiality16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ASS"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality19,
                  Data.Inflection.$fReadEvidentiality18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.QUO) -}
f7a5ecaa9f686292e47427002535e6e0
  $fReadEvidentiality19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "QUO"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Evidentiality
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Evidentiality
                   Data.Inflection.$fReadEvidentiality3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Evidentiality>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Evidentiality>_R)))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality22,
                  Data.Inflection.$fReadEvidentiality21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.HSY) -}
c0af073403bd075603d4d465e1dc53f6
  $fReadEvidentiality22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HSY"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality25,
                  Data.Inflection.$fReadEvidentiality24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.REP) -}
3acf41b4c0caf42b8e0c138adc01b06c
  $fReadEvidentiality25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "REP"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality28,
                  Data.Inflection.$fReadEvidentiality27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.INFER) -}
8cae1db3b6935cb73a10a6b47680b36e
  $fReadEvidentiality28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INFER"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality31,
                  Data.Inflection.$fReadEvidentiality30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Evidentiality
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Evidentiality
                   Data.Inflection.$fReadEvidentiality4
                   eta
                   @ b
                   eta1) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.AUD) -}
e8e99c98e19ebf335596736af1cf4f1f
  $fReadEvidentiality31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AUD"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality34,
                  Data.Inflection.$fReadEvidentiality33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NVIS) -}
dbd2242b22e8122ca8ca7bc84c7ab248
  $fReadEvidentiality34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NVIS"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality37,
                  Data.Inflection.$fReadEvidentiality36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.VIS) -}
dc148aa9b843775903e8b1427bdf6faf
  $fReadEvidentiality37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VIS"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality40,
                  Data.Inflection.$fReadEvidentiality39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.EXP) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality41
                   Data.Inflection.$fReadEvidentiality5) -}
9655eb48715d67915bd03091b5f4f66b
  $fReadEvidentiality40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EXP"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Evidentiality)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadEvidentiality43,
                  Data.Inflection.$fReadEvidentiality42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Evidentiality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Evidentiality>_R))))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Evidentiality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Evidentiality
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UEVI) -}
da0b4e7ddf1c2326cb93ac921d71ce54
  $fReadEvidentiality43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UEVI"#) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality44 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Evidentiality]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Evidentiality
                   Data.Inflection.$fReadEvidentiality2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Evidentiality>_R))
                   @ [Data.Inflection.Evidentiality]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Evidentiality])) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality38
                   Data.Inflection.$fReadEvidentiality6) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality35
                   Data.Inflection.$fReadEvidentiality7) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality32
                   Data.Inflection.$fReadEvidentiality8) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality29
                   Data.Inflection.$fReadEvidentiality9) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Evidentiality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Evidentiality)
                   Data.Inflection.$fReadEvidentiality26
                   Data.Inflection.$fReadEvidentiality10) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Evidentiality]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Evidentiality]
                   Data.Inflection.$fReadEvidentiality44) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.Evidentiality]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadEvidentiality1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Evidentiality]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Evidentiality]>_R))) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Inflection.Evidentiality
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadEvidentiality2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Evidentiality>_R)) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fReadEvidentiality_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Evidentiality
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Evidentiality
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Evidentiality
                       Data.Inflection.$fReadEvidentiality3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Evidentiality>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Evidentiality>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Evidentiality>_R)
                      @ Data.Inflection.Evidentiality
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Evidentiality))) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fReadExpress ::
    GHC.Read.Read a => GHC.Read.Read (Data.Inflection.Express a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dRead :: GHC.Read.Read a).
                  @ (Data.Inflection.Express a)
                  (Data.Inflection.$fReadExpress_$creadsPrec @ a $dRead)
                  (Data.Inflection.$fReadExpress_$creadList @ a $dRead)
                  (Data.Inflection.$fReadExpress_$creadPrec @ a $dRead)
                  (Data.Inflection.$fReadExpress_$creadListPrec @ a $dRead) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fReadExpress1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Express a] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dRead :: GHC.Read.Read a)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Express a]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ (Data.Inflection.Express a)
                   (Data.Inflection.$fReadExpress2 @ a $dRead)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Express a>_R))
                   @ b
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fReadExpress2 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP (Data.Inflection.Express a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U> -}
215fe38755b3229d5abb86dd2bfcfba2
  $fReadExpress_$creadList ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Express a]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Express a]
                   (GHC.Read.$wlist
                      @ (Data.Inflection.Express a)
                      (Data.Inflection.$fReadExpress2 @ a $dRead)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                <Data.Inflection.Express a>_R))
                      @ [Data.Inflection.Express a]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Data.Inflection.Express a]))) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fReadExpress_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.Express a]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadExpress1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Read.Read a>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                         <[Data.Inflection.Express a]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                    <[Data.Inflection.Express a]>_R))) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fReadExpress_$creadPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      (Data.Inflection.Express a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadExpress2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Read.Read a>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <Data.Inflection.Express a>_R)) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fReadExpress_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (Data.Inflection.Express a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Data.Inflection.Express a)
                   ((Data.Inflection.$fReadExpress2 @ a $dRead eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Express a>_R)
                      @ (Data.Inflection.Express a)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Data.Inflection.Express a)))) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender :: GHC.Read.Read Data.Inflection.Gender
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Gender
                  Data.Inflection.$fReadGender_$creadsPrec
                  Data.Inflection.$fReadGender_$creadList
                  Data.Inflection.$fReadGender_$creadPrec
                  Data.Inflection.$fReadGender_$creadListPrec -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Gender] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Gender]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Gender
                   Data.Inflection.$fReadGender2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Gender>_R))
                   @ b
                   eta1) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Gender -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Gender
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.N) -}
18044777e30bc1241a76aca4b9479f4f
  $fReadGender11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "N"#) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadGender14,
                  Data.Inflection.$fReadGender13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Gender>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Gender>_R))))) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Gender -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Gender
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.COM) -}
0a73ca8be217d160c3424c7bb19f61c5
  $fReadGender14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "COM"#) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadGender17,
                  Data.Inflection.$fReadGender16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Gender>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Gender>_R))))) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Gender -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Gender
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.F) -}
1fe20e5b6e2861e8d7d506a49033f4bf
  $fReadGender17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "F"#) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadGender20,
                  Data.Inflection.$fReadGender19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Gender>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Gender>_R))))) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Gender -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Gender
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.M) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Gender
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Gender
                   Data.Inflection.$fReadGender3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Gender>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Gender>_R)))) -}
28144fad1da41b15f0649067dafe5a2d
  $fReadGender20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "M"#) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadGender23,
                  Data.Inflection.$fReadGender22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Gender>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Gender>_R))))) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Gender -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Gender
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UGEN) -}
caea6ddf6941c0ee64bf9f0fb6e6567f
  $fReadGender23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UGEN"#) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender24 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Gender]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Gender
                   Data.Inflection.$fReadGender2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Gender>_R))
                   @ [Data.Inflection.Gender]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Gender])) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Gender -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Gender
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Gender
                   Data.Inflection.$fReadGender4
                   eta
                   @ b
                   eta1) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
                   Data.Inflection.$fReadGender21
                   Data.Inflection.$fReadGender5) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
                   Data.Inflection.$fReadGender18
                   Data.Inflection.$fReadGender6) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
                   Data.Inflection.$fReadGender15
                   Data.Inflection.$fReadGender7) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
                   Data.Inflection.$fReadGender12
                   Data.Inflection.$fReadGender8) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
                   Data.Inflection.$fReadGender9
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Gender))) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadGender11,
                  Data.Inflection.$fReadGender10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Gender>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Gender>_R))))) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Gender]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Gender]
                   Data.Inflection.$fReadGender24) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Gender]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadGender1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Gender]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Gender]>_R))) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Gender
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadGender2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Gender>_R)) -}
8099e7e810494d6db288b5ee6338a850
  $fReadGender_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Gender
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Gender
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Gender
                       Data.Inflection.$fReadGender3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Gender>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Gender>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Gender>_R)
                      @ Data.Inflection.Gender
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Gender))) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific :: GHC.Read.Read Data.Inflection.Honorific
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Honorific
                  Data.Inflection.$fReadHonorific_$creadsPrec
                  Data.Inflection.$fReadHonorific_$creadList
                  Data.Inflection.$fReadHonorific_$creadPrec
                  Data.Inflection.$fReadHonorific_$creadListPrec -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Honorific] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Honorific]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Honorific
                   Data.Inflection.$fReadHonorific2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Honorific>_R))
                   @ b
                   eta1) -}
ae3c36f347204cc6007d654040b4c81f
  $fReadHonorific10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FORM"#) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadHonorific13,
                  Data.Inflection.$fReadHonorific12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Honorific>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Honorific>_R))))) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Honorific -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Honorific
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NEU) -}
6369172dbefd5491957af9130edd1799
  $fReadHonorific13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEU"#) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadHonorific16,
                  Data.Inflection.$fReadHonorific15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Honorific>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Honorific>_R))))) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Honorific -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Honorific
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.FAM) -}
cc4b12d75606e212a3fdbf0d84667c02
  $fReadHonorific16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FAM"#) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadHonorific19,
                  Data.Inflection.$fReadHonorific18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Honorific>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Honorific>_R))))) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Honorific -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Honorific
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UHON) -}
57639292c3e44718924e1b166f33b840
  $fReadHonorific19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UHON"#) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Honorific
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Honorific
                   Data.Inflection.$fReadHonorific3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Honorific>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Honorific>_R)))) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific20 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Honorific]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Honorific
                   Data.Inflection.$fReadHonorific2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Honorific>_R))
                   @ [Data.Inflection.Honorific]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Honorific])) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Honorific -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Honorific
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Honorific
                   Data.Inflection.$fReadHonorific4
                   eta
                   @ b
                   eta1) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Honorific)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific)
                   Data.Inflection.$fReadHonorific17
                   Data.Inflection.$fReadHonorific5) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Honorific)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific)
                   Data.Inflection.$fReadHonorific14
                   Data.Inflection.$fReadHonorific6) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Honorific)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific)
                   Data.Inflection.$fReadHonorific11
                   Data.Inflection.$fReadHonorific7) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Honorific)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific)
                   Data.Inflection.$fReadHonorific8
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Honorific))) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific8 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadHonorific10,
                  Data.Inflection.$fReadHonorific9
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Honorific>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Honorific>_R))))) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific9 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Honorific -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Honorific
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.FORM) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Honorific]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Honorific]
                   Data.Inflection.$fReadHonorific20) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.Honorific]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadHonorific1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Honorific]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Honorific]>_R))) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Honorific
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadHonorific2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Honorific>_R)) -}
fb068a739b47969783c008d0c5ccdfb8
  $fReadHonorific_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Honorific
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Honorific
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Honorific
                       Data.Inflection.$fReadHonorific3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Honorific>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Honorific>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Honorific>_R)
                      @ Data.Inflection.Honorific
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Honorific))) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem ::
    GHC.Read.Read Data.Inflection.InflectionSystem
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.InflectionSystem
                  Data.Inflection.$fReadInflectionSystem_$creadsPrec
                  Data.Inflection.$fReadInflectionSystem_$creadList
                  Data.Inflection.$fReadInflectionSystem_$creadPrec
                  Data.Inflection.$fReadInflectionSystem_$creadListPrec -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.InflectionSystem]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.InflectionSystem]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.InflectionSystem
                   Data.Inflection.$fReadInflectionSystem2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.InflectionSystem>_R))
                   @ b
                   eta1) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         Data.Inflection.InflectionSystem
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.InflectionSystem
                   Data.Inflection.$fReadInflectionSystem3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.InflectionSystem>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.InflectionSystem>_R)))) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.InflectionSystem
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Data.Inflection.InflectionSystem
                          -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Inflection.$w$creadPrec ww1 @ b w1 }) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem4 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.InflectionSystem]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.InflectionSystem
                   Data.Inflection.$fReadInflectionSystem2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.InflectionSystem>_R))
                   @ [Data.Inflection.InflectionSystem]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.InflectionSystem])) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem_$creadList ::
    Text.ParserCombinators.ReadP.ReadS
      [Data.Inflection.InflectionSystem]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.InflectionSystem]
                   Data.Inflection.$fReadInflectionSystem4) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.InflectionSystem]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadInflectionSystem1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.InflectionSystem]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.InflectionSystem]>_R))) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Inflection.InflectionSystem
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadInflectionSystem2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.InflectionSystem>_R)) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fReadInflectionSystem_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         Data.Inflection.InflectionSystem
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.InflectionSystem
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.InflectionSystem
                       Data.Inflection.$fReadInflectionSystem3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.InflectionSystem>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.InflectionSystem>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.InflectionSystem>_R)
                      @ Data.Inflection.InflectionSystem
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.InflectionSystem))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat :: GHC.Read.Read Data.Inflection.LexCat
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.LexCat
                  Data.Inflection.$fReadLexCat_$creadsPrec
                  Data.Inflection.$fReadLexCat_$creadList
                  Data.Inflection.$fReadLexCat_$creadPrec
                  Data.Inflection.$fReadLexCat_$creadListPrec -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.LexCat] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.LexCat]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.LexCat
                   Data.Inflection.$fReadLexCat2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.LexCat>_R))
                   @ b
                   eta1) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat27
                   Data.Inflection.$fReadLexCat11) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat24
                   Data.Inflection.$fReadLexCat12) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat21
                   Data.Inflection.$fReadLexCat13) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat18
                   Data.Inflection.$fReadLexCat14) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat15
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.LexCat))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat17,
                  Data.Inflection.$fReadLexCat16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Pron) -}
3ed0f74a55fd08f80677ed1d5502c644
  $fReadLexCat17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Pron"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat20,
                  Data.Inflection.$fReadLexCat19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Subj) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.LexCat
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.LexCat
                   Data.Inflection.$fReadLexCat3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.LexCat>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.LexCat>_R)))) -}
c2e7cca2ec767d7351a754e020246962
  $fReadLexCat20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Subj"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat23,
                  Data.Inflection.$fReadLexCat22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Obj) -}
c9008738a5964cccf304c58ca17b1f1b
  $fReadLexCat23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Obj"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat24 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat26,
                  Data.Inflection.$fReadLexCat25
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat25 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Adv) -}
b33e334ee57f14e1e1b42c44c999dcb4
  $fReadLexCat26 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Adv"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat27 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat29,
                  Data.Inflection.$fReadLexCat28
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat28 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Adj) -}
c2722adac40cfa9488d933c442874e98
  $fReadLexCat29 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Adj"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.LexCat
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.LexCat
                   Data.Inflection.$fReadLexCat4
                   eta
                   @ b
                   eta1) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat30 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat32,
                  Data.Inflection.$fReadLexCat31
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat31 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Adpo) -}
dda7fa70597d8163cdc06de2319bc537
  $fReadLexCat32 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Adpo"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat33 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat35,
                  Data.Inflection.$fReadLexCat34
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat34 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Noun) -}
c50ae84a8855bc92a8e15cfa780e73a8
  $fReadLexCat35 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Noun"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat36 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat38,
                  Data.Inflection.$fReadLexCat37
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat37 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Det) -}
d680cccbfc277789c50705e1c43b59d9
  $fReadLexCat38 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Det"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat39 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat41,
                  Data.Inflection.$fReadLexCat40
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat45
                   Data.Inflection.$fReadLexCat5) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat40 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Verb) -}
5825e20bb1f3ccf0d960afff76abbd27
  $fReadLexCat41 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Verb"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat42 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat44,
                  Data.Inflection.$fReadLexCat43
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat43 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Infl) -}
c022daf96be5b5f4f47da12278ce0c5c
  $fReadLexCat44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Infl"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat45 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadLexCat47,
                  Data.Inflection.$fReadLexCat46
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.LexCat>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.LexCat>_R))))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat46 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.LexCat -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.LexCat
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Comp) -}
67a89abaa28aeb4b777e5de4b0c1dbe4
  $fReadLexCat47 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Comp"#) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat48 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.LexCat]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.LexCat
                   Data.Inflection.$fReadLexCat2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.LexCat>_R))
                   @ [Data.Inflection.LexCat]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.LexCat])) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat42
                   Data.Inflection.$fReadLexCat6) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat39
                   Data.Inflection.$fReadLexCat7) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat36
                   Data.Inflection.$fReadLexCat8) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat33
                   Data.Inflection.$fReadLexCat9) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat)
                   Data.Inflection.$fReadLexCat30
                   Data.Inflection.$fReadLexCat10) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.LexCat]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.LexCat]
                   Data.Inflection.$fReadLexCat48) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.LexCat]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadLexCat1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.LexCat]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.LexCat]>_R))) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.LexCat
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadLexCat2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.LexCat>_R)) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fReadLexCat_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.LexCat
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.LexCat
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.LexCat
                       Data.Inflection.$fReadLexCat3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.LexCat>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.LexCat>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.LexCat>_R)
                      @ Data.Inflection.LexCat
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.LexCat))) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fReadManifest ::
    GHC.Read.Read a => GHC.Read.Read (Data.Inflection.Manifest a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dRead :: GHC.Read.Read a).
                  @ (Data.Inflection.Manifest a)
                  (Data.Inflection.$fReadManifest_$creadsPrec @ a $dRead)
                  (Data.Inflection.$fReadManifest_$creadList @ a $dRead)
                  (Data.Inflection.$fReadManifest_$creadPrec @ a $dRead)
                  (Data.Inflection.$fReadManifest_$creadListPrec @ a $dRead) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fReadManifest1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Manifest a] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dRead :: GHC.Read.Read a)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Manifest a]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ (Data.Inflection.Manifest a)
                   (Data.Inflection.$fReadManifest2 @ a $dRead)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Manifest a>_R))
                   @ b
                   eta1) -}
5d6ac7ca94bf690a629fdbd93549d3c0
  $fReadManifest10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Animacy]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Animacy]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Animacy])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Animacy
                                      Data.Inflection.$fReadAnimacy2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Animacy>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Animacy]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Animacy]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest100 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Person
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.FSTEXCL) -}
6e6f7e6fff5ae62eefd21f922d1e732d
  $fReadManifest101 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FSTEXCL"#) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest102 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest104,
                  Data.Inflection.$fReadManifest103
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Person>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Person>_R))))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest103 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Person
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.FSTINCL) -}
e19b9d7a1261eebc3eea7994b4250cb5
  $fReadManifest104 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FSTINCL"#) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest105 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest107,
                  Data.Inflection.$fReadManifest106
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Person>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Person>_R))))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest106 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Person
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.FIRST) -}
cda246e5b45f6026ef44847607d42283
  $fReadManifest107 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FIRST"#) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest108 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest110,
                  Data.Inflection.$fReadManifest109
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Person>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Person>_R))))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest109 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Person
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UPER) -}
355fc04df1c3b1fc72fe018820468369
  $fReadManifest110 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UPER"#) -}
084a3a30d286da026e3d74615ef915d2
  $fReadManifest112 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Honorific]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Honorific]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Honorific])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Honorific
                                      Data.Inflection.$fReadHonorific2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Honorific>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Honorific]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Honorific]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
fe1e1506a3c855137baa57c26271e6e7
  $fReadManifest114 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Polarity]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Polarity]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Polarity])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Polarity
                                      Data.Inflection.$fReadManifest115
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Polarity>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Polarity]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Polarity]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest115 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Polarity
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Polarity
                   Data.Inflection.$fReadManifest116
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Polarity>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Polarity>_R)))) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest116 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Polarity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Polarity
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Polarity
                   Data.Inflection.$fReadManifest117
                   eta
                   @ b
                   eta1) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest117 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)
                   Data.Inflection.$fReadManifest126
                   Data.Inflection.$fReadManifest118) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest118 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)
                   Data.Inflection.$fReadManifest123
                   Data.Inflection.$fReadManifest119) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest119 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)
                   Data.Inflection.$fReadManifest120
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Polarity))) -}
bdb199bc8e7da6eac4fd0da76ff234e8
  $fReadManifest12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Case]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Case]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Case])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Case
                                      Data.Inflection.$fReadCase2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Case>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Case]) ->
                                       eta
                                         (Data.Inflection.Manifest @ [Data.Inflection.Case] a1 a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest120 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest122,
                  Data.Inflection.$fReadManifest121
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Polarity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Polarity>_R))))) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest121 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Polarity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Polarity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NEG) -}
32783b6d786a1ed39ec5e7c9d00cd813
  $fReadManifest122 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEG"#) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest123 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest125,
                  Data.Inflection.$fReadManifest124
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Polarity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Polarity>_R))))) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest124 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Polarity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Polarity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.AFF) -}
f4a07550b01713cc0f4d0275b42a86c2
  $fReadManifest125 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFF"#) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest126 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest128,
                  Data.Inflection.$fReadManifest127
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Polarity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Polarity>_R))))) -}
1c2c61816b840e25aed576544ed551f7
  $fReadManifest127 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Polarity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Polarity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UPOL) -}
5b891c4d04f768d4e0fc3ed705b2c629
  $fReadManifest128 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UPOL"#) -}
db3b74ee0297a7f544d4652dbac08dd6
  $fReadManifest130 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Tense]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Tense]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Tense])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Tense
                                      Data.Inflection.$fReadManifest131
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Tense>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Tense]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Tense]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest131 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Tense
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Tense
                   Data.Inflection.$fReadManifest132
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Tense>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Tense>_R)))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest132 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Tense
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Tense
                   Data.Inflection.$fReadManifest133
                   eta
                   @ b
                   eta1) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest133 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest206
                   Data.Inflection.$fReadManifest134) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest134 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest203
                   Data.Inflection.$fReadManifest135) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest135 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest200
                   Data.Inflection.$fReadManifest136) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest136 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest197
                   Data.Inflection.$fReadManifest137) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest137 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest194
                   Data.Inflection.$fReadManifest138) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest138 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest191
                   Data.Inflection.$fReadManifest139) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest139 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest188
                   Data.Inflection.$fReadManifest140) -}
af3a17cadaee87a31a8d5666222bb6fa
  $fReadManifest14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Number]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Number]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Number])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Number
                                      Data.Inflection.$fReadManifest15
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Number>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Number]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Number]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest140 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest185
                   Data.Inflection.$fReadManifest141) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest141 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest182
                   Data.Inflection.$fReadManifest142) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest142 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest179
                   Data.Inflection.$fReadManifest143) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest143 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest176
                   Data.Inflection.$fReadManifest144) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest144 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest173
                   Data.Inflection.$fReadManifest145) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest145 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest170
                   Data.Inflection.$fReadManifest146) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest146 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest167
                   Data.Inflection.$fReadManifest147) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest147 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest164
                   Data.Inflection.$fReadManifest148) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest148 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest161
                   Data.Inflection.$fReadManifest149) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest149 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest158
                   Data.Inflection.$fReadManifest150) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Number
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Number
                   Data.Inflection.$fReadManifest16
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Number>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Number>_R)))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest150 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest155
                   Data.Inflection.$fReadManifest151) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest151 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
                   Data.Inflection.$fReadManifest152
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Tense))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest152 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest154,
                  Data.Inflection.$fReadManifest153
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest153 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.FUTPER) -}
a27240551c082c355057f6bc04602180
  $fReadManifest154 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FUTPER"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest155 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest157,
                  Data.Inflection.$fReadManifest156
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest156 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PRSPER) -}
60e17d9733b5ef7cc37708cb904fac04
  $fReadManifest157 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PRSPER"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest158 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest160,
                  Data.Inflection.$fReadManifest159
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest159 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PSTPER) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Number -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Number
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Number
                   Data.Inflection.$fReadManifest17
                   eta
                   @ b
                   eta1) -}
d85c29796fe69ad9661911cfc9d678e5
  $fReadManifest160 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PSTPER"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest161 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest163,
                  Data.Inflection.$fReadManifest162
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest162 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PPST3) -}
f0e01e939f3e1531ce78dde6832c8251
  $fReadManifest163 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PPST3"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest164 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest166,
                  Data.Inflection.$fReadManifest165
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest165 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PPST2) -}
53d755e0112b02b151fe0290963ee4bb
  $fReadManifest166 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PPST2"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest167 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest169,
                  Data.Inflection.$fReadManifest168
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest168 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PPST1) -}
fc115c461b5f60c801adcc525b414add
  $fReadManifest169 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PPST1"#) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest17 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
                   Data.Inflection.$fReadManifest38
                   Data.Inflection.$fReadManifest18) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest170 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest172,
                  Data.Inflection.$fReadManifest171
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest171 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PPST) -}
c9627b0fa8fff5b9bd533b7fd3e386ba
  $fReadManifest172 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PPST"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest173 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest175,
                  Data.Inflection.$fReadManifest174
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest174 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PFUT) -}
c1fb29d058f3a4c1509e0e7563e170d9
  $fReadManifest175 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PFUT"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest176 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest178,
                  Data.Inflection.$fReadManifest177
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest177 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PPRS) -}
b5f6561bd74f81b74bec36d986ad7cfa
  $fReadManifest178 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PPRS"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest179 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest181,
                  Data.Inflection.$fReadManifest180
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest18 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
                   Data.Inflection.$fReadManifest35
                   Data.Inflection.$fReadManifest19) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest180 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.AFUT3) -}
e246aad7d53dcb0b14cea22ab2907771
  $fReadManifest181 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFUT3"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest182 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest184,
                  Data.Inflection.$fReadManifest183
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest183 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.AFUT2) -}
19e61e871106c9d7b947b2ad546d8025
  $fReadManifest184 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFUT2"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest185 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest187,
                  Data.Inflection.$fReadManifest186
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest186 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.AFUT1) -}
3039b64eba418d72d7a45ece042c359a
  $fReadManifest187 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFUT1"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest188 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest190,
                  Data.Inflection.$fReadManifest189
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest189 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.AFUT) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest19 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
                   Data.Inflection.$fReadManifest32
                   Data.Inflection.$fReadManifest20) -}
68723ce41538f206b983ae1ec3a950ea
  $fReadManifest190 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFUT"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest191 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest193,
                  Data.Inflection.$fReadManifest192
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest192 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.APST) -}
8cbd33a33cac84684a4b558cf71b6e31
  $fReadManifest193 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "APST"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest194 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest196,
                  Data.Inflection.$fReadManifest195
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest195 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.APRS) -}
f8f28151fb97d6b312014a26f70a04cf
  $fReadManifest196 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "APRS"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest197 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest199,
                  Data.Inflection.$fReadManifest198
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest198 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.FUT) -}
fdb54223a301e0425c06056d181e36cf
  $fReadManifest199 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FUT"#) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fReadManifest2 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP (Data.Inflection.Manifest a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: (\ @ a
                   ($dRead :: GHC.Read.Read a)
                   (eta :: Text.ParserCombinators.ReadPrec.Prec) ->
                 let {
                   ds :: Text.ParserCombinators.ReadPrec.ReadPrec a
                   = GHC.Read.readPrec @ a $dRead
                 } in
                 GHC.Read.$fReadDouble10
                   @ (Data.Inflection.Manifest a)
                   (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                      @ b
                      (eta1 :: Data.Inflection.Manifest a
                               -> Text.ParserCombinators.ReadP.P b) ->
                    let {
                      lvl129 :: Text.ParserCombinators.ReadP.P b
                      = let {
                          lvl130 :: Text.ParserCombinators.ReadP.P b
                          = eta1 (Data.Inflection.NoManifest @ a)
                        } in
                        Text.Read.Lex.expect2
                          @ b
                          (\ (a1 :: Text.Read.Lex.Lexeme) ->
                           case a1 of wild {
                             DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                             Text.Read.Lex.Ident a2
                             -> case GHC.Base.eqString
                                       a2
                                       Data.Inflection.$fReadManifest6 of wild1 {
                                  GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                  GHC.Types.True -> lvl130 } })
                    } in
                    let {
                      k :: () -> Text.ParserCombinators.ReadP.P b
                        {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                           Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                      = \ (w4 :: ()) -> lvl129
                    } in
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                      @ b
                      (Text.ParserCombinators.ReadP.Look
                         @ b
                         (\ (a1 :: GHC.Base.String) ->
                          (Text.ParserCombinators.ReadP.skipSpaces_skip a1)
                            `cast`
                          (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                            @ b
                            k))
                      (case n of wild { GHC.Types.I# x ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.<=# x 10#) of wild2 {
                         GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                         GHC.Types.True
                         -> let {
                              lvl130 :: Text.ParserCombinators.ReadP.P b
                              = let {
                                  lvl131 :: Text.ParserCombinators.ReadP.P b
                                  = GHC.Read.$wlist
                                      @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                         GHC.Types.Int)
                                      Data.Inflection.$fReadManifest5
                                        `cast`
                                      (Trans
                                           (<Text.ParserCombinators.ReadPrec.Prec>_R
                                            ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                          <(Data.Inflection.LexCat,
                                                            Data.Inflection.ManifestType,
                                                            GHC.Types.Int)>_R))
                                           (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     <(Data.Inflection.LexCat,
                                                       Data.Inflection.ManifestType,
                                                       GHC.Types.Int)>_R)))
                                      @ b
                                      (\ (a1 :: [(Data.Inflection.LexCat,
                                                  Data.Inflection.ManifestType, GHC.Types.Int)]) ->
                                       (ds
                                          `cast`
                                        (Text.ParserCombinators.ReadPrec.N:ReadPrec[0] <a>_R)
                                          Data.Inflection.$fReadManifest4)
                                         `cast`
                                       (Text.ParserCombinators.ReadP.N:ReadP[0] <a>_R)
                                         @ b
                                         (\ (a2 :: a) -> eta1 (Data.Inflection.Manifest @ a a1 a2)))
                                } in
                                Text.Read.Lex.expect2
                                  @ b
                                  (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                   case a1 of wild1 {
                                     DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                     Text.Read.Lex.Ident a2
                                     -> case GHC.Base.eqString
                                               a2
                                               Data.Inflection.$fReadManifest3 of wild3 {
                                          GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                          GHC.Types.True -> lvl131 } })
                            } in
                            let {
                              k1 :: () -> Text.ParserCombinators.ReadP.P b
                                {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                   Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                              = \ (w4 :: ()) -> lvl130
                            } in
                            Text.ParserCombinators.ReadP.Look
                              @ b
                              (\ (a1 :: GHC.Base.String) ->
                               (Text.ParserCombinators.ReadP.skipSpaces_skip a1)
                                 `cast`
                               (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                                 @ b
                                 k1) } }))
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Manifest a>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Manifest a>_R)))
                   eta) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest20 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
                   Data.Inflection.$fReadManifest29
                   Data.Inflection.$fReadManifest21) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest200 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest202,
                  Data.Inflection.$fReadManifest201
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest201 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PRS) -}
0fd8fadeaf623e51db663d465d5edef1
  $fReadManifest202 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PRS"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest203 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest205,
                  Data.Inflection.$fReadManifest204
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest204 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PST) -}
42a66318873cd7caee8673465b7252b8
  $fReadManifest205 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PST"#) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest206 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest208,
                  Data.Inflection.$fReadManifest207
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Tense>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Tense>_R))))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadManifest207 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Tense -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Tense
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UTEN) -}
3486eee417f972b104e46885700718e2
  $fReadManifest208 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UTEN"#) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
                   Data.Inflection.$fReadManifest26
                   Data.Inflection.$fReadManifest22) -}
0f8e0a667084b141f23efdda4d618df5
  $fReadManifest210 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Aspect]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Aspect]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Aspect])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Aspect
                                      Data.Inflection.$fReadAspect2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Aspect>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Aspect]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Aspect]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
eed1e23aaf5f9264ef44bbcfba2802ec
  $fReadManifest212 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Mood]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Mood]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Mood])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Mood
                                      Data.Inflection.$fReadManifest213
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Mood>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Mood]) ->
                                       eta
                                         (Data.Inflection.Manifest @ [Data.Inflection.Mood] a1 a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest213 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Mood
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Mood
                   Data.Inflection.$fReadManifest214
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Mood>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Mood>_R)))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest214 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Mood
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Mood
                   Data.Inflection.$fReadManifest215
                   eta
                   @ b
                   eta1) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest215 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest256
                   Data.Inflection.$fReadManifest216) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest216 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest253
                   Data.Inflection.$fReadManifest217) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest217 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest250
                   Data.Inflection.$fReadManifest218) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest218 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest247
                   Data.Inflection.$fReadManifest219) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest219 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest244
                   Data.Inflection.$fReadManifest220) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest22 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
                   Data.Inflection.$fReadManifest23
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Number))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest220 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest241
                   Data.Inflection.$fReadManifest221) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest221 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest238
                   Data.Inflection.$fReadManifest222) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest222 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest235
                   Data.Inflection.$fReadManifest223) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest223 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest232
                   Data.Inflection.$fReadManifest224) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest224 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest229
                   Data.Inflection.$fReadManifest225) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest225 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
                   Data.Inflection.$fReadManifest226
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest226 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest228,
                  Data.Inflection.$fReadManifest227
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest227 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.COND) -}
1700e7f4658043f5d5d93ecd56ca9227
  $fReadManifest228 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "COND"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest229 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest231,
                  Data.Inflection.$fReadManifest230
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest25,
                  Data.Inflection.$fReadManifest24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Number>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Number>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest230 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.POT) -}
9ce6f9e745ae28e7ed8e53aa9655a3b0
  $fReadManifest231 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POT"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest232 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest234,
                  Data.Inflection.$fReadManifest233
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest233 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.SBJV) -}
8b1f0662fba00784d35af8adea0b421c
  $fReadManifest234 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SBJV"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest235 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest237,
                  Data.Inflection.$fReadManifest236
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest236 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.EPIS) -}
d1ac5327e05765c210873e35a7439513
  $fReadManifest237 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIS"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest238 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest240,
                  Data.Inflection.$fReadManifest239
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest239 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.OPT) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Number -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Number
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PL) -}
aeb212133a4af3ed1350431428c6ca44
  $fReadManifest240 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPT"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest241 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest243,
                  Data.Inflection.$fReadManifest242
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest242 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.JUS) -}
0d113d33ab2b3b0e52144bd3903dab24
  $fReadManifest243 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "JUS"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest244 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest246,
                  Data.Inflection.$fReadManifest245
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest245 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.IMP) -}
71d4dc50275616ddab2fe17a87b3133f
  $fReadManifest246 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IMP"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest247 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest249,
                  Data.Inflection.$fReadManifest248
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest248 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DEO) -}
c13ad9c23c2f05b587995ad1baaf6005
  $fReadManifest249 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DEO"#) -}
acd8d0333fa5b2ab942e324e17d1fe91
  $fReadManifest25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PL"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest250 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest252,
                  Data.Inflection.$fReadManifest251
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest251 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.IRR) -}
19dab2b47743aded320cdf1a6bda37c8
  $fReadManifest252 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IRR"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest253 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest255,
                  Data.Inflection.$fReadManifest254
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest254 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.IND) -}
f74b4e234f45b3be3cddaa6d444ffa83
  $fReadManifest255 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IND"#) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest256 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest258,
                  Data.Inflection.$fReadManifest257
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Mood>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Mood>_R))))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadManifest257 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Mood -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Mood
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UMOO) -}
4e74c0826e7ebc185c648ab60b6d6bdf
  $fReadManifest258 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UMOO"#) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest28,
                  Data.Inflection.$fReadManifest27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Number>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Number>_R))))) -}
f1f208b046a0ebb1af361d297276e605
  $fReadManifest260 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Voice]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Voice]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Voice])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Voice
                                      Data.Inflection.$fReadManifest261
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Voice>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Voice]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Voice]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest261 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Voice
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Voice
                   Data.Inflection.$fReadManifest262
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Voice>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Voice>_R)))) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest262 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Voice
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Voice
                   Data.Inflection.$fReadManifest263
                   eta
                   @ b
                   eta1) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest263 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)
                   Data.Inflection.$fReadManifest276
                   Data.Inflection.$fReadManifest264) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest264 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)
                   Data.Inflection.$fReadManifest273
                   Data.Inflection.$fReadManifest265) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest265 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)
                   Data.Inflection.$fReadManifest270
                   Data.Inflection.$fReadManifest266) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest266 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)
                   Data.Inflection.$fReadManifest267
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Voice))) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest267 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest269,
                  Data.Inflection.$fReadManifest268
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Voice>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Voice>_R))))) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest268 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Voice
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PASSIVE) -}
2e07b6d647a95be5a2e99e3bc87687e5
  $fReadManifest269 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PASSIVE"#) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Number -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Number
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.PA) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest270 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest272,
                  Data.Inflection.$fReadManifest271
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Voice>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Voice>_R))))) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest271 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Voice
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.MIDDLE) -}
4118cfc972203fb184b9a9ab14965019
  $fReadManifest272 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MIDDLE"#) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest273 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest275,
                  Data.Inflection.$fReadManifest274
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Voice>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Voice>_R))))) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest274 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Voice
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.ACTIVE) -}
5475a62f6c52930479f17dafbb9576c9
  $fReadManifest275 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACTIVE"#) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest276 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest278,
                  Data.Inflection.$fReadManifest277
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Voice>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Voice>_R))))) -}
82e4499831c335865b73c47901c341b5
  $fReadManifest277 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Voice
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UVOI) -}
f398b970f2d50a7f714b02dad57e87c5
  $fReadManifest278 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVOI"#) -}
650f4263720b98a99c4637c47f2e14fc
  $fReadManifest28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PA"#) -}
c7654f896698484489b14755541d772a
  $fReadManifest280 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Evidentiality]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Evidentiality]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta
                           (Data.Inflection.NoManifest @ [Data.Inflection.Evidentiality])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Evidentiality
                                      Data.Inflection.$fReadEvidentiality2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Evidentiality>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Evidentiality]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Evidentiality]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
a080360fe429606ba3701e72c7867774
  $fReadManifest282 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Transitivity]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Transitivity]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Transitivity])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Transitivity
                                      Data.Inflection.$fReadManifest283
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Transitivity>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Transitivity]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Transitivity]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest283 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Transitivity
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Transitivity
                   Data.Inflection.$fReadManifest284
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Transitivity>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Transitivity>_R)))) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest284 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Transitivity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Transitivity
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Transitivity
                   Data.Inflection.$fReadManifest285
                   eta
                   @ b
                   eta1) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest285 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Transitivity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Transitivity)
                   Data.Inflection.$fReadManifest302
                   Data.Inflection.$fReadManifest286) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest286 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Transitivity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Transitivity)
                   Data.Inflection.$fReadManifest299
                   Data.Inflection.$fReadManifest287) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest287 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Transitivity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Transitivity)
                   Data.Inflection.$fReadManifest296
                   Data.Inflection.$fReadManifest288) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest288 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Transitivity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Transitivity)
                   Data.Inflection.$fReadManifest293
                   Data.Inflection.$fReadManifest289) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest289 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Transitivity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Transitivity)
                   Data.Inflection.$fReadManifest290
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Transitivity))) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest31,
                  Data.Inflection.$fReadManifest30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Number>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Number>_R))))) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest290 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Transitivity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest292,
                  Data.Inflection.$fReadManifest291
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Transitivity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Transitivity>_R))))) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest291 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Transitivity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Transitivity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DITRANS) -}
b6e2e2a7554f4550060ccf363dae36e2
  $fReadManifest292 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DITRANS"#) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest293 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Transitivity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest295,
                  Data.Inflection.$fReadManifest294
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Transitivity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Transitivity>_R))))) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest294 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Transitivity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Transitivity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.MTRANS) -}
27e9786b167915beadff43023f56b994
  $fReadManifest295 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MTRANS"#) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest296 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Transitivity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest298,
                  Data.Inflection.$fReadManifest297
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Transitivity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Transitivity>_R))))) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest297 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Transitivity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Transitivity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.TRANS) -}
f0309d628dec29495b49d81501ecc9f4
  $fReadManifest298 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRANS"#) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest299 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Transitivity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest301,
                  Data.Inflection.$fReadManifest300
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Transitivity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Transitivity>_R))))) -}
f1092ec9db8644a898e3911f8d14bd43
  $fReadManifest3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Manifest"#) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Number -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Number
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.TRI) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest300 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Transitivity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Transitivity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NTRANS) -}
945b7819f46487a4ecc0fe075ff2e41d
  $fReadManifest301 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NTRANS"#) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest302 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Transitivity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest304,
                  Data.Inflection.$fReadManifest303
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Transitivity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Transitivity>_R))))) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadManifest303 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Transitivity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Transitivity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UTRA) -}
e6a5f4864ff5fc30816a071a26bba099
  $fReadManifest304 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UTRA"#) -}
e96091fad9afd4fe8f1cf4e23ea4b0c6
  $fReadManifest306 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Volition]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Volition]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Volition])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Volition
                                      Data.Inflection.$fReadManifest307
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Volition>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Volition]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Volition]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest307 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Volition
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Volition
                   Data.Inflection.$fReadManifest308
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Volition>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Volition>_R)))) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest308 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Volition -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Volition
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Volition
                   Data.Inflection.$fReadManifest309
                   eta
                   @ b
                   eta1) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest309 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)
                   Data.Inflection.$fReadManifest318
                   Data.Inflection.$fReadManifest310) -}
1cebafe8d430c0729cfa48cea1b888e9
  $fReadManifest31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRI"#) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest310 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)
                   Data.Inflection.$fReadManifest315
                   Data.Inflection.$fReadManifest311) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest311 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)
                   Data.Inflection.$fReadManifest312
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Volition))) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest312 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest314,
                  Data.Inflection.$fReadManifest313
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Volition>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Volition>_R))))) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest313 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Volition -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Volition
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NVOL) -}
70ae5520c9e66df05bc688aad0649d3b
  $fReadManifest314 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NVOL"#) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest315 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest317,
                  Data.Inflection.$fReadManifest316
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Volition>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Volition>_R))))) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest316 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Volition -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Volition
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.VOL) -}
7c3d422540d43fb250ac47de30d96ee8
  $fReadManifest317 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOL"#) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest318 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest320,
                  Data.Inflection.$fReadManifest319
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Volition>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Volition>_R))))) -}
637cf4191464029f30da46ab81b77985
  $fReadManifest319 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Volition -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Volition
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UVOL) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest34,
                  Data.Inflection.$fReadManifest33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Number>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Number>_R))))) -}
3dcec0b4420e1c57885af08e603cb472
  $fReadManifest320 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVOL"#) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Number -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Number
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.DU) -}
72229791fa5867b4cf57d6389ddd5a09
  $fReadManifest34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DU"#) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest37,
                  Data.Inflection.$fReadManifest36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Number>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Number>_R))))) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Number -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Number
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.SG) -}
42c4b60a26b65a3d0eb70cf4e251980e
  $fReadManifest37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SG"#) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest40,
                  Data.Inflection.$fReadManifest39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Number>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Number>_R))))) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadManifest39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Number -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Number
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UNUM) -}
c56c531b0d43e0189562f97cc08599ad
  $fReadManifest4 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 11#) -}
337ad84d32266eeb14dd3eb50d225c33
  $fReadManifest40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UNUM"#) -}
b570743f6c8e6788e39c631c75e86d25
  $fReadManifest42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Definiteness]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Definiteness]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Definiteness])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Definiteness
                                      Data.Inflection.$fReadDefiniteness2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Definiteness>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Definiteness]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Definiteness]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
420a876a52edbef6bcb6caf5282393c4
  $fReadManifest44 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Specificity]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Specificity]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Specificity])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Specificity
                                      Data.Inflection.$fReadManifest45
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Specificity>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Specificity]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Specificity]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Specificity
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Specificity
                   Data.Inflection.$fReadManifest46
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Specificity>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Specificity>_R)))) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest46 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Specificity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Specificity
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Specificity
                   Data.Inflection.$fReadManifest47
                   eta
                   @ b
                   eta1) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest47 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Specificity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Specificity)
                   Data.Inflection.$fReadManifest56
                   Data.Inflection.$fReadManifest48) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest48 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Specificity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Specificity)
                   Data.Inflection.$fReadManifest53
                   Data.Inflection.$fReadManifest49) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest49 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.Specificity)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.Specificity)
                   Data.Inflection.$fReadManifest50
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Specificity))) -}
f0aa1ac18513e3359950b78f83936e93
  $fReadManifest5 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b1.
       ((Data.Inflection.LexCat, Data.Inflection.ManifestType,
         GHC.Types.Int)
        -> Text.ParserCombinators.ReadP.P b1)
       -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 2,
     Unfolding: (\ (w3 :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b1
                   (w4 :: (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                           GHC.Types.Int)
                          -> Text.ParserCombinators.ReadP.P b1)[OneShot] ->
                 GHC.Read.$w$creadPrec1
                   @ Data.Inflection.LexCat
                   @ Data.Inflection.ManifestType
                   @ GHC.Types.Int
                   Data.Inflection.$fReadLexCat
                   Data.Inflection.$fReadManifestType
                   GHC.Read.$fReadInt
                   @ b1
                   w4) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest50 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Specificity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest52,
                  Data.Inflection.$fReadManifest51
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Specificity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Specificity>_R))))) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest51 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Specificity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Specificity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NSPEC) -}
d7271c1ab78b1135e3f5bbf9e4d36b2a
  $fReadManifest52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NSPEC"#) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Specificity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest55,
                  Data.Inflection.$fReadManifest54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Specificity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Specificity>_R))))) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Specificity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Specificity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.SPEC) -}
3a7579bd6cf028e5bb464bad07268794
  $fReadManifest55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SPEC"#) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest56 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.Specificity)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest58,
                  Data.Inflection.$fReadManifest57
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Specificity>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Specificity>_R))))) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadManifest57 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Specificity -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Specificity
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.USPE) -}
77f4d62bd0f6eb308e16c7e4f670b52f
  $fReadManifest58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "USPE"#) -}
6c676ddd7e29c1f86add5943e9a0d03d
  $fReadManifest6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoManifest"#) -}
2e2dbde0f03eda7ab5330541bab4b1a5
  $fReadManifest60 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Topic]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Topic]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Topic])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Topic
                                      Data.Inflection.$fReadManifest61
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Topic>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Topic]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Topic]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest61 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Topic
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Topic
                   Data.Inflection.$fReadManifest62
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Topic>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Topic>_R)))) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest62 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Topic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Topic
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Topic
                   Data.Inflection.$fReadManifest63
                   eta
                   @ b
                   eta1) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest63 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)
                   Data.Inflection.$fReadManifest72
                   Data.Inflection.$fReadManifest64) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest64 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)
                   Data.Inflection.$fReadManifest69
                   Data.Inflection.$fReadManifest65) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest65 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)
                   Data.Inflection.$fReadManifest66
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Topic))) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest66 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest68,
                  Data.Inflection.$fReadManifest67
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Topic>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Topic>_R))))) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest67 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Topic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Topic
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.NTOP) -}
013e90b951f9d2fa8883850d56725987
  $fReadManifest68 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NTOP"#) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest69 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest71,
                  Data.Inflection.$fReadManifest70
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Topic>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Topic>_R))))) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest70 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Topic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Topic
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.TOP) -}
d132e0187d6251b9482561757c1ae339
  $fReadManifest71 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TOP"#) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest72 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest74,
                  Data.Inflection.$fReadManifest73
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Topic>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Topic>_R))))) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadManifest73 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Topic -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Topic
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.UTOP) -}
60bc095557ed472c313995a66eaadbba
  $fReadManifest74 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UTOP"#) -}
8d3f613a7244e2757448464012b0807d
  $fReadManifest76 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Person]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Person]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Person])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Person
                                      Data.Inflection.$fReadManifest77
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Person>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Person]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Person]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest77 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.Person
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.Person
                   Data.Inflection.$fReadManifest78
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.Person>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.Person>_R)))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest78 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.Person
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.Person
                   Data.Inflection.$fReadManifest79
                   eta
                   @ b
                   eta1) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest79 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
                   Data.Inflection.$fReadManifest108
                   Data.Inflection.$fReadManifest80) -}
12b6d78cc1ffdabbc968cc6a6e89192e
  $fReadManifest8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Manifest [Data.Inflection.Gender]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Manifest [Data.Inflection.Gender]
                           -> Text.ParserCombinators.ReadP.P b) ->
                 let {
                   lvl129 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = eta (Data.Inflection.NoManifest @ [Data.Inflection.Gender])
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString
                                    a2
                                    Data.Inflection.$fReadManifest6 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl130 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl129) -}
                   = \ (w4 :: ()) -> lvl129
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ (a :: GHC.Base.String) ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                         `cast`
                       (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10#) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl130 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = GHC.Read.$wlist
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fReadManifest5
                                     `cast`
                                   (Trans
                                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                                       <(Data.Inflection.LexCat,
                                                         Data.Inflection.ManifestType,
                                                         GHC.Types.Int)>_R))
                                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                  <(Data.Inflection.LexCat,
                                                    Data.Inflection.ManifestType,
                                                    GHC.Types.Int)>_R)))
                                   @ b
                                   (\ (a1 :: [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                               GHC.Types.Int)]) ->
                                    GHC.Read.$wlist
                                      @ Data.Inflection.Gender
                                      Data.Inflection.$fReadGender2
                                        `cast`
                                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                <Data.Inflection.Gender>_R))
                                      @ b
                                      (\ (a2 :: [Data.Inflection.Gender]) ->
                                       eta
                                         (Data.Inflection.Manifest
                                            @ [Data.Inflection.Gender]
                                            a1
                                            a2)))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ (a1 :: Text.Read.Lex.Lexeme) ->
                                case a1 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a2
                                  -> case GHC.Base.eqString
                                            a2
                                            Data.Inflection.$fReadManifest3 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl131 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl130) -}
                           = \ (w4 :: ()) -> lvl130
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ (a :: GHC.Base.String) ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                              `cast`
                            (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest80 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
                   Data.Inflection.$fReadManifest105
                   Data.Inflection.$fReadManifest81) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest81 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
                   Data.Inflection.$fReadManifest102
                   Data.Inflection.$fReadManifest82) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest82 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
                   Data.Inflection.$fReadManifest99
                   Data.Inflection.$fReadManifest83) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest83 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
                   Data.Inflection.$fReadManifest96
                   Data.Inflection.$fReadManifest84) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest84 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
                   Data.Inflection.$fReadManifest93
                   Data.Inflection.$fReadManifest85) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest85 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
                   Data.Inflection.$fReadManifest90
                   Data.Inflection.$fReadManifest86) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest86 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
                   Data.Inflection.$fReadManifest87
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.Person))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest87 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest89,
                  Data.Inflection.$fReadManifest88
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Person>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Person>_R))))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest88 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Person
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.THRDOBV) -}
98ce27a6ea3e0b3cafc025a7e91529ca
  $fReadManifest89 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "THRDOBV"#) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest90 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest92,
                  Data.Inflection.$fReadManifest91
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Person>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Person>_R))))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest91 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Person
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.THRDPROX) -}
6ad12defbda3ef2218fa013a2d938522
  $fReadManifest92 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "THRDPROX"#) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest93 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest95,
                  Data.Inflection.$fReadManifest94
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Person>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Person>_R))))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest94 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Person
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.THIRD) -}
67b794eb0e417eeb33a58fa1fe60c856
  $fReadManifest95 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "THIRD"#) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest96 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest98,
                  Data.Inflection.$fReadManifest97
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Person>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Person>_R))))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest97 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.Person -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.Person
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.SECOND) -}
b89d13005391ea3240f2ad0e17cc9b2a
  $fReadManifest98 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SECOND"#) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadManifest99 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifest101,
                  Data.Inflection.$fReadManifest100
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.Person>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.Person>_R))))) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType :: GHC.Read.Read Data.Inflection.ManifestType
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.ManifestType
                  Data.Inflection.$fReadManifestType_$creadsPrec
                  Data.Inflection.$fReadManifestType_$creadList
                  Data.Inflection.$fReadManifestType_$creadPrec
                  Data.Inflection.$fReadManifestType_$creadListPrec -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.ManifestType]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.ManifestType]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.ManifestType
                   Data.Inflection.$fReadManifestType2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.ManifestType>_R))
                   @ b
                   eta1) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.ManifestType)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifestType12,
                  Data.Inflection.$fReadManifestType11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.ManifestType>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.ManifestType>_R))))) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.ManifestType -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.ManifestType
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Prefix) -}
9548ad1626e8fb84f38114b6f44bcc92
  $fReadManifestType12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Prefix"#) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.ManifestType)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifestType15,
                  Data.Inflection.$fReadManifestType14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.ManifestType>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.ManifestType>_R))))) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.ManifestType -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.ManifestType
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Particle) -}
a06ef964a742c877145c4116e132aa0b
  $fReadManifestType15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Particle"#) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType16 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.ManifestType]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.ManifestType
                   Data.Inflection.$fReadManifestType2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.ManifestType>_R))
                   @ [Data.Inflection.ManifestType]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.ManifestType])) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Inflection.ManifestType
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Inflection.ManifestType
                   Data.Inflection.$fReadManifestType3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Inflection.ManifestType>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Inflection.ManifestType>_R)))) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.ManifestType -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Inflection.ManifestType
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Inflection.ManifestType
                   Data.Inflection.$fReadManifestType4
                   eta
                   @ b
                   eta1) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.ManifestType)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.ManifestType)
                   Data.Inflection.$fReadManifestType13
                   Data.Inflection.$fReadManifestType5) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.ManifestType)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.ManifestType)
                   Data.Inflection.$fReadManifestType10
                   Data.Inflection.$fReadManifestType6) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        Data.Inflection.ManifestType)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        Data.Inflection.ManifestType)
                   Data.Inflection.$fReadManifestType7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Inflection.ManifestType))) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       Data.Inflection.ManifestType)
  {- Strictness: m,
     Unfolding: ((Data.Inflection.$fReadManifestType9,
                  Data.Inflection.$fReadManifestType8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Inflection.ManifestType>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Inflection.ManifestType>_R))))) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Inflection.ManifestType -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Inflection.ManifestType
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Inflection.Suffix) -}
82efac95697aa3c32b45bc5f5f167de3
  $fReadManifestType9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Suffix"#) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.ManifestType]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.ManifestType]
                   Data.Inflection.$fReadManifestType16) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.ManifestType]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifestType1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.ManifestType]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.ManifestType]>_R))) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Inflection.ManifestType
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifestType2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.ManifestType>_R)) -}
e80d8f471552e307f8ce67ea59e61dde
  $fReadManifestType_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.ManifestType
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.ManifestType
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.ManifestType
                       Data.Inflection.$fReadManifestType3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.ManifestType>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.ManifestType>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.ManifestType>_R)
                      @ Data.Inflection.ManifestType
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.ManifestType))) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fReadManifest_$creadList ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Manifest a]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) ->
                 Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Manifest a]
                   (GHC.Read.$wlist
                      @ (Data.Inflection.Manifest a)
                      (Data.Inflection.$fReadManifest2 @ a $dRead)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                <Data.Inflection.Manifest a>_R))
                      @ [Data.Inflection.Manifest a]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ [Data.Inflection.Manifest a]))) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fReadManifest_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.Manifest a]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Read.Read a>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                         <[Data.Inflection.Manifest a]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                    <[Data.Inflection.Manifest a]>_R))) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fReadManifest_$creadPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      (Data.Inflection.Manifest a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Read.Read a>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <Data.Inflection.Manifest a>_R)) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fReadManifest_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (Data.Inflection.Manifest a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dRead :: GHC.Read.Read a) (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ (Data.Inflection.Manifest a)
                   ((Data.Inflection.$fReadManifest2 @ a $dRead eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Manifest a>_R)
                      @ (Data.Inflection.Manifest a)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ (Data.Inflection.Manifest a)))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadMood :: GHC.Read.Read Data.Inflection.Mood
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Mood
                  Data.Inflection.$fReadMood_$creadsPrec
                  Data.Inflection.$fReadMood_$creadList
                  Data.Inflection.$fReadMood_$creadPrec
                  Data.Inflection.$fReadMood_$creadListPrec -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadMood1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Mood] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Mood]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Mood
                   Data.Inflection.$fReadManifest213
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Mood>_R))
                   @ b
                   eta1) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadMood2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Mood]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Mood
                   Data.Inflection.$fReadManifest213
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Mood>_R))
                   @ [Data.Inflection.Mood]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Mood])) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadMood_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Mood]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Mood]
                   Data.Inflection.$fReadMood2) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadMood_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Mood]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadMood1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Mood]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Mood]>_R))) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadMood_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Mood
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest213
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Mood>_R)) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fReadMood_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Mood
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Mood
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Mood
                       Data.Inflection.$fReadManifest214
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Mood>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Mood>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Inflection.Mood>_R)
                      @ Data.Inflection.Mood
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Mood))) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadNumber :: GHC.Read.Read Data.Inflection.Number
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Number
                  Data.Inflection.$fReadNumber_$creadsPrec
                  Data.Inflection.$fReadNumber_$creadList
                  Data.Inflection.$fReadNumber_$creadPrec
                  Data.Inflection.$fReadNumber_$creadListPrec -}
7465cc747c74e065f91b84b3f135a27f
  $fReadNumber1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Number] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Number]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Number
                   Data.Inflection.$fReadManifest15
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Number>_R))
                   @ b
                   eta1) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadNumber2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Number]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Number
                   Data.Inflection.$fReadManifest15
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Number>_R))
                   @ [Data.Inflection.Number]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Number])) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadNumber_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Number]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Number]
                   Data.Inflection.$fReadNumber2) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadNumber_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Number]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadNumber1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Number]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Number]>_R))) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadNumber_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Number
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest15
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Number>_R)) -}
7465cc747c74e065f91b84b3f135a27f
  $fReadNumber_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Number
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Number
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Number
                       Data.Inflection.$fReadManifest16
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Number>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Number>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Number>_R)
                      @ Data.Inflection.Number
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Number))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadPerson :: GHC.Read.Read Data.Inflection.Person
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Person
                  Data.Inflection.$fReadPerson_$creadsPrec
                  Data.Inflection.$fReadPerson_$creadList
                  Data.Inflection.$fReadPerson_$creadPrec
                  Data.Inflection.$fReadPerson_$creadListPrec -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadPerson1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Person] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Person]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Person
                   Data.Inflection.$fReadManifest77
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Person>_R))
                   @ b
                   eta1) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadPerson2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Person]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Person
                   Data.Inflection.$fReadManifest77
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Person>_R))
                   @ [Data.Inflection.Person]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Person])) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadPerson_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Person]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Person]
                   Data.Inflection.$fReadPerson2) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadPerson_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Person]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadPerson1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Person]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Person]>_R))) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadPerson_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Person
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest77
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Person>_R)) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fReadPerson_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Person
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Person
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Person
                       Data.Inflection.$fReadManifest78
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Person>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Person>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Person>_R)
                      @ Data.Inflection.Person
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Person))) -}
1c2c61816b840e25aed576544ed551f7
  $fReadPolarity :: GHC.Read.Read Data.Inflection.Polarity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Polarity
                  Data.Inflection.$fReadPolarity_$creadsPrec
                  Data.Inflection.$fReadPolarity_$creadList
                  Data.Inflection.$fReadPolarity_$creadPrec
                  Data.Inflection.$fReadPolarity_$creadListPrec -}
1c2c61816b840e25aed576544ed551f7
  $fReadPolarity1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Polarity] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Polarity]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Polarity
                   Data.Inflection.$fReadManifest115
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Polarity>_R))
                   @ b
                   eta1) -}
1c2c61816b840e25aed576544ed551f7
  $fReadPolarity2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Polarity]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Polarity
                   Data.Inflection.$fReadManifest115
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Polarity>_R))
                   @ [Data.Inflection.Polarity]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Polarity])) -}
1c2c61816b840e25aed576544ed551f7
  $fReadPolarity_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Polarity]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Polarity]
                   Data.Inflection.$fReadPolarity2) -}
1c2c61816b840e25aed576544ed551f7
  $fReadPolarity_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Polarity]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadPolarity1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Polarity]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Polarity]>_R))) -}
1c2c61816b840e25aed576544ed551f7
  $fReadPolarity_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Polarity
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest115
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Polarity>_R)) -}
1c2c61816b840e25aed576544ed551f7
  $fReadPolarity_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Polarity
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Polarity
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Polarity
                       Data.Inflection.$fReadManifest116
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Polarity>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Polarity>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Polarity>_R)
                      @ Data.Inflection.Polarity
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Polarity))) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadSpecificity :: GHC.Read.Read Data.Inflection.Specificity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Specificity
                  Data.Inflection.$fReadSpecificity_$creadsPrec
                  Data.Inflection.$fReadSpecificity_$creadList
                  Data.Inflection.$fReadSpecificity_$creadPrec
                  Data.Inflection.$fReadSpecificity_$creadListPrec -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadSpecificity1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Specificity] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Specificity]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Specificity
                   Data.Inflection.$fReadManifest45
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Specificity>_R))
                   @ b
                   eta1) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadSpecificity2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Specificity]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Specificity
                   Data.Inflection.$fReadManifest45
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Specificity>_R))
                   @ [Data.Inflection.Specificity]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Specificity])) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadSpecificity_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Specificity]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Specificity]
                   Data.Inflection.$fReadSpecificity2) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadSpecificity_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.Specificity]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadSpecificity1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Specificity]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Specificity]>_R))) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadSpecificity_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Inflection.Specificity
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest45
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Specificity>_R)) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fReadSpecificity_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Specificity
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Specificity
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Specificity
                       Data.Inflection.$fReadManifest46
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Specificity>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Specificity>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Specificity>_R)
                      @ Data.Inflection.Specificity
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Specificity))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadTense :: GHC.Read.Read Data.Inflection.Tense
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Tense
                  Data.Inflection.$fReadTense_$creadsPrec
                  Data.Inflection.$fReadTense_$creadList
                  Data.Inflection.$fReadTense_$creadPrec
                  Data.Inflection.$fReadTense_$creadListPrec -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadTense1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Tense] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Tense]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Tense
                   Data.Inflection.$fReadManifest131
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Tense>_R))
                   @ b
                   eta1) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadTense2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Tense]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Tense
                   Data.Inflection.$fReadManifest131
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Tense>_R))
                   @ [Data.Inflection.Tense]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Tense])) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadTense_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Tense]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Tense]
                   Data.Inflection.$fReadTense2) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadTense_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Tense]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadTense1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Tense]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Tense]>_R))) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadTense_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Tense
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest131
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Tense>_R)) -}
66acf52fe96ad50a10594fa2d12d699d
  $fReadTense_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Tense
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Tense
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Tense
                       Data.Inflection.$fReadManifest132
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Tense>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Tense>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Inflection.Tense>_R)
                      @ Data.Inflection.Tense
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Tense))) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadTopic :: GHC.Read.Read Data.Inflection.Topic
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Topic
                  Data.Inflection.$fReadTopic_$creadsPrec
                  Data.Inflection.$fReadTopic_$creadList
                  Data.Inflection.$fReadTopic_$creadPrec
                  Data.Inflection.$fReadTopic_$creadListPrec -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadTopic1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Topic] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Topic]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Topic
                   Data.Inflection.$fReadManifest61
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Topic>_R))
                   @ b
                   eta1) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadTopic2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Topic]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Topic
                   Data.Inflection.$fReadManifest61
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Topic>_R))
                   @ [Data.Inflection.Topic]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Topic])) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadTopic_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Topic]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Topic]
                   Data.Inflection.$fReadTopic2) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadTopic_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Topic]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadTopic1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Topic]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Topic]>_R))) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadTopic_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Topic
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest61
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Topic>_R)) -}
f6776b7675319519d06c9aea2dc03bf9
  $fReadTopic_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Topic
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Topic
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Topic
                       Data.Inflection.$fReadManifest62
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Topic>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Topic>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Inflection.Topic>_R)
                      @ Data.Inflection.Topic
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Topic))) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadTransitivity :: GHC.Read.Read Data.Inflection.Transitivity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Transitivity
                  Data.Inflection.$fReadTransitivity_$creadsPrec
                  Data.Inflection.$fReadTransitivity_$creadList
                  Data.Inflection.$fReadTransitivity_$creadPrec
                  Data.Inflection.$fReadTransitivity_$creadListPrec -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadTransitivity1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Transitivity]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Transitivity]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Transitivity
                   Data.Inflection.$fReadManifest283
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Transitivity>_R))
                   @ b
                   eta1) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadTransitivity2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Transitivity]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Transitivity
                   Data.Inflection.$fReadManifest283
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Transitivity>_R))
                   @ [Data.Inflection.Transitivity]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Transitivity])) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadTransitivity_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Transitivity]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Transitivity]
                   Data.Inflection.$fReadTransitivity2) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadTransitivity_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [Data.Inflection.Transitivity]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadTransitivity1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Transitivity]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Transitivity]>_R))) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadTransitivity_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      Data.Inflection.Transitivity
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest283
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Transitivity>_R)) -}
7302fbe55b71c04bf146a8a39e883cde
  $fReadTransitivity_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Transitivity
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Transitivity
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Transitivity
                       Data.Inflection.$fReadManifest284
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Transitivity>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Transitivity>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Transitivity>_R)
                      @ Data.Inflection.Transitivity
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Transitivity))) -}
82e4499831c335865b73c47901c341b5
  $fReadVoice :: GHC.Read.Read Data.Inflection.Voice
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Voice
                  Data.Inflection.$fReadVoice_$creadsPrec
                  Data.Inflection.$fReadVoice_$creadList
                  Data.Inflection.$fReadVoice_$creadPrec
                  Data.Inflection.$fReadVoice_$creadListPrec -}
82e4499831c335865b73c47901c341b5
  $fReadVoice1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Voice] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Voice]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Voice
                   Data.Inflection.$fReadManifest261
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Voice>_R))
                   @ b
                   eta1) -}
82e4499831c335865b73c47901c341b5
  $fReadVoice2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Voice]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Voice
                   Data.Inflection.$fReadManifest261
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Voice>_R))
                   @ [Data.Inflection.Voice]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Voice])) -}
82e4499831c335865b73c47901c341b5
  $fReadVoice_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Voice]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Voice]
                   Data.Inflection.$fReadVoice2) -}
82e4499831c335865b73c47901c341b5
  $fReadVoice_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Voice]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadVoice1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Voice]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Voice]>_R))) -}
82e4499831c335865b73c47901c341b5
  $fReadVoice_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Voice
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest261
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Voice>_R)) -}
82e4499831c335865b73c47901c341b5
  $fReadVoice_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Voice
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Voice
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Voice
                       Data.Inflection.$fReadManifest262
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Voice>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Voice>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Inflection.Voice>_R)
                      @ Data.Inflection.Voice
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Voice))) -}
637cf4191464029f30da46ab81b77985
  $fReadVolition :: GHC.Read.Read Data.Inflection.Volition
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Volition
                  Data.Inflection.$fReadVolition_$creadsPrec
                  Data.Inflection.$fReadVolition_$creadList
                  Data.Inflection.$fReadVolition_$creadPrec
                  Data.Inflection.$fReadVolition_$creadListPrec -}
637cf4191464029f30da46ab81b77985
  $fReadVolition1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Inflection.Volition] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Inflection.Volition]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Inflection.Volition
                   Data.Inflection.$fReadManifest307
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Volition>_R))
                   @ b
                   eta1) -}
637cf4191464029f30da46ab81b77985
  $fReadVolition2 ::
    Text.ParserCombinators.ReadP.P [Data.Inflection.Volition]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Inflection.Volition
                   Data.Inflection.$fReadManifest307
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Inflection.Volition>_R))
                   @ [Data.Inflection.Volition]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Inflection.Volition])) -}
637cf4191464029f30da46ab81b77985
  $fReadVolition_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Inflection.Volition]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Inflection.Volition]
                   Data.Inflection.$fReadVolition2) -}
637cf4191464029f30da46ab81b77985
  $fReadVolition_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Inflection.Volition]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadVolition1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Inflection.Volition]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Inflection.Volition]>_R))) -}
637cf4191464029f30da46ab81b77985
  $fReadVolition_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Inflection.Volition
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Inflection.$fReadManifest307
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Inflection.Volition>_R)) -}
637cf4191464029f30da46ab81b77985
  $fReadVolition_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Inflection.Volition
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Inflection.Volition
                   ((GHC.Read.$fReadDouble10
                       @ Data.Inflection.Volition
                       Data.Inflection.$fReadManifest308
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Inflection.Volition>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Inflection.Volition>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Inflection.Volition>_R)
                      @ Data.Inflection.Volition
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Inflection.Volition))) -}
4df618e6edf4c1efb2375dc0cf8c5175
  $fShow(,,,,,,,,,,,,,,,,) ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g,
     GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k,
     GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n, GHC.Show.Show o,
     GHC.Show.Show p, GHC.Show.Show q) =>
    GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
  DFunId
  {- Arity: 17,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      @ d
                      @ e
                      @ f
                      @ g
                      @ h
                      @ i
                      @ j
                      @ k
                      @ l
                      @ m
                      @ n
                      @ o
                      @ p
                      @ q
                      ($dShow :: GHC.Show.Show a)
                      ($dShow1 :: GHC.Show.Show b)
                      ($dShow2 :: GHC.Show.Show c)
                      ($dShow3 :: GHC.Show.Show d)
                      ($dShow4 :: GHC.Show.Show e)
                      ($dShow5 :: GHC.Show.Show f)
                      ($dShow6 :: GHC.Show.Show g)
                      ($dShow7 :: GHC.Show.Show h)
                      ($dShow8 :: GHC.Show.Show i)
                      ($dShow9 :: GHC.Show.Show j)
                      ($dShow10 :: GHC.Show.Show k)
                      ($dShow11 :: GHC.Show.Show l)
                      ($dShow12 :: GHC.Show.Show m)
                      ($dShow13 :: GHC.Show.Show n)
                      ($dShow14 :: GHC.Show.Show o)
                      ($dShow15 :: GHC.Show.Show p)
                      ($dShow16 :: GHC.Show.Show q).
                  @ (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
                  (Data.Inflection.$fShow(,,,,,,,,,,,,,,,,)_$cshowsPrec
                     @ a
                     @ b
                     @ c
                     @ d
                     @ e
                     @ f
                     @ g
                     @ h
                     @ i
                     @ j
                     @ k
                     @ l
                     @ m
                     @ n
                     @ o
                     @ p
                     @ q
                     $dShow
                     $dShow1
                     $dShow2
                     $dShow3
                     $dShow4
                     $dShow5
                     $dShow6
                     $dShow7
                     $dShow8
                     $dShow9
                     $dShow10
                     $dShow11
                     $dShow12
                     $dShow13
                     $dShow14
                     $dShow15
                     $dShow16)
                  (Data.Inflection.$fShow(,,,,,,,,,,,,,,,,)_$cshow
                     @ a
                     @ b
                     @ c
                     @ d
                     @ e
                     @ f
                     @ g
                     @ h
                     @ i
                     @ j
                     @ k
                     @ l
                     @ m
                     @ n
                     @ o
                     @ p
                     @ q
                     $dShow
                     $dShow1
                     $dShow2
                     $dShow3
                     $dShow4
                     $dShow5
                     $dShow6
                     $dShow7
                     $dShow8
                     $dShow9
                     $dShow10
                     $dShow11
                     $dShow12
                     $dShow13
                     $dShow14
                     $dShow15
                     $dShow16)
                  (Data.Inflection.$fShow(,,,,,,,,,,,,,,,,)_$cshowList
                     @ a
                     @ b
                     @ c
                     @ d
                     @ e
                     @ f
                     @ g
                     @ h
                     @ i
                     @ j
                     @ k
                     @ l
                     @ m
                     @ n
                     @ o
                     @ p
                     @ q
                     $dShow
                     $dShow1
                     $dShow2
                     $dShow3
                     $dShow4
                     $dShow5
                     $dShow6
                     $dShow7
                     $dShow8
                     $dShow9
                     $dShow10
                     $dShow11
                     $dShow12
                     $dShow13
                     $dShow14
                     $dShow15
                     $dShow16) -}
87335b0f07d667439af225d79bf03442
  $fShow(,,,,,,,,,,,,,,,,)_$cshow ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g,
     GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k,
     GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n, GHC.Show.Show o,
     GHC.Show.Show p, GHC.Show.Show q) =>
    (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
    -> GHC.Base.String
  {- Arity: 18,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (18, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ f
                   @ g
                   @ h
                   @ i
                   @ j
                   @ k
                   @ l
                   @ m
                   @ n
                   @ o
                   @ p
                   @ q
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   ($dShow2 :: GHC.Show.Show c)
                   ($dShow3 :: GHC.Show.Show d)
                   ($dShow4 :: GHC.Show.Show e)
                   ($dShow5 :: GHC.Show.Show f)
                   ($dShow6 :: GHC.Show.Show g)
                   ($dShow7 :: GHC.Show.Show h)
                   ($dShow8 :: GHC.Show.Show i)
                   ($dShow9 :: GHC.Show.Show j)
                   ($dShow10 :: GHC.Show.Show k)
                   ($dShow11 :: GHC.Show.Show l)
                   ($dShow12 :: GHC.Show.Show m)
                   ($dShow13 :: GHC.Show.Show n)
                   ($dShow14 :: GHC.Show.Show o)
                   ($dShow15 :: GHC.Show.Show p)
                   ($dShow16 :: GHC.Show.Show q)
                   (x :: (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)) ->
                 Data.Inflection.$fShow(,,,,,,,,,,,,,,,,)_$cshowsPrec
                   @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ f
                   @ g
                   @ h
                   @ i
                   @ j
                   @ k
                   @ l
                   @ m
                   @ n
                   @ o
                   @ p
                   @ q
                   $dShow
                   $dShow1
                   $dShow2
                   $dShow3
                   $dShow4
                   $dShow5
                   $dShow6
                   $dShow7
                   $dShow8
                   $dShow9
                   $dShow10
                   $dShow11
                   $dShow12
                   $dShow13
                   $dShow14
                   $dShow15
                   $dShow16
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
966a46529b3ac0b5331015a1b29dbc0a
  $fShow(,,,,,,,,,,,,,,,,)_$cshowList ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g,
     GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k,
     GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n, GHC.Show.Show o,
     GHC.Show.Show p, GHC.Show.Show q) =>
    [(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)]
    -> GHC.Show.ShowS
  {- Arity: 19,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (19, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ f
                   @ g
                   @ h
                   @ i
                   @ j
                   @ k
                   @ l
                   @ m
                   @ n
                   @ o
                   @ p
                   @ q
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   ($dShow2 :: GHC.Show.Show c)
                   ($dShow3 :: GHC.Show.Show d)
                   ($dShow4 :: GHC.Show.Show e)
                   ($dShow5 :: GHC.Show.Show f)
                   ($dShow6 :: GHC.Show.Show g)
                   ($dShow7 :: GHC.Show.Show h)
                   ($dShow8 :: GHC.Show.Show i)
                   ($dShow9 :: GHC.Show.Show j)
                   ($dShow10 :: GHC.Show.Show k)
                   ($dShow11 :: GHC.Show.Show l)
                   ($dShow12 :: GHC.Show.Show m)
                   ($dShow13 :: GHC.Show.Show n)
                   ($dShow14 :: GHC.Show.Show o)
                   ($dShow15 :: GHC.Show.Show p)
                   ($dShow16 :: GHC.Show.Show q)
                   (ls :: [(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
                   (Data.Inflection.$fShow(,,,,,,,,,,,,,,,,)_$cshowsPrec
                      @ a
                      @ b
                      @ c
                      @ d
                      @ e
                      @ f
                      @ g
                      @ h
                      @ i
                      @ j
                      @ k
                      @ l
                      @ m
                      @ n
                      @ o
                      @ p
                      @ q
                      $dShow
                      $dShow1
                      $dShow2
                      $dShow3
                      $dShow4
                      $dShow5
                      $dShow6
                      $dShow7
                      $dShow8
                      $dShow9
                      $dShow10
                      $dShow11
                      $dShow12
                      $dShow13
                      $dShow14
                      $dShow15
                      $dShow16
                      GHC.Show.shows22)
                   ls
                   s) -}
e46339ce805cab5a039915b69f3fa972
  $fShow(,,,,,,,,,,,,,,,,)_$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g,
     GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k,
     GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n, GHC.Show.Show o,
     GHC.Show.Show p, GHC.Show.Show q) =>
    GHC.Types.Int
    -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
    -> GHC.Show.ShowS
  {- Arity: 19,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,A><S,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (19, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ f
                   @ g
                   @ h
                   @ i
                   @ j
                   @ k
                   @ l
                   @ m
                   @ n
                   @ o
                   @ p
                   @ q
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show c)
                   (w3 :: GHC.Show.Show d)
                   (w4 :: GHC.Show.Show e)
                   (w5 :: GHC.Show.Show f)
                   (w6 :: GHC.Show.Show g)
                   (w7 :: GHC.Show.Show h)
                   (w8 :: GHC.Show.Show i)
                   (w9 :: GHC.Show.Show j)
                   (w10 :: GHC.Show.Show k)
                   (w11 :: GHC.Show.Show l)
                   (w12 :: GHC.Show.Show m)
                   (w13 :: GHC.Show.Show n)
                   (w14 :: GHC.Show.Show o)
                   (w15 :: GHC.Show.Show p)
                   (w16 :: GHC.Show.Show q)
                   (w17 :: GHC.Types.Int)
                   (w18 :: (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)) ->
                 case w18 of ww { (,,,,,,,,,,,,,,,,) ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ->
                 Data.Inflection.$w$cshowsPrec
                   @ a
                   @ b
                   @ c
                   @ d
                   @ e
                   @ f
                   @ g
                   @ h
                   @ i
                   @ j
                   @ k
                   @ l
                   @ m
                   @ n
                   @ o
                   @ p
                   @ q
                   w
                   w1
                   w2
                   w3
                   w4
                   w5
                   w6
                   w7
                   w8
                   w9
                   w10
                   w11
                   w12
                   w13
                   w14
                   w15
                   w16
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17 }) -}
1f555085a72acd0be7c2a6de830d5d03
  $fShowAnimacy :: GHC.Show.Show Data.Inflection.Animacy
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Animacy
                  Data.Inflection.$fShowAnimacy_$cshowsPrec
                  Data.Inflection.$fShowAnimacy_$cshow
                  Data.Inflection.$fShowAnimacy_$cshowList -}
1f555085a72acd0be7c2a6de830d5d03
  $fShowAnimacy_$cshow :: Data.Inflection.Animacy -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Animacy) ->
                 Data.Inflection.$fShowAnimacy_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1f555085a72acd0be7c2a6de830d5d03
  $fShowAnimacy_$cshowList ::
    [Data.Inflection.Animacy] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Animacy
                   Data.Inflection.$w$cshowsPrec1) -}
1f555085a72acd0be7c2a6de830d5d03
  $fShowAnimacy_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Animacy -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Animacy)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec1 w1 w2) -}
73f9fcce4a2a405b233176b51f525cb2
  $fShowAspect :: GHC.Show.Show Data.Inflection.Aspect
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Aspect
                  Data.Inflection.$fShowAspect_$cshowsPrec
                  Data.Inflection.$fShowAspect_$cshow
                  Data.Inflection.$fShowAspect_$cshowList -}
73f9fcce4a2a405b233176b51f525cb2
  $fShowAspect_$cshow :: Data.Inflection.Aspect -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Aspect) ->
                 Data.Inflection.$fShowAspect_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
73f9fcce4a2a405b233176b51f525cb2
  $fShowAspect_$cshowList ::
    [Data.Inflection.Aspect] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Aspect
                   Data.Inflection.$w$cshowsPrec2) -}
73f9fcce4a2a405b233176b51f525cb2
  $fShowAspect_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Aspect -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Aspect)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec2 w1 w2) -}
476440af125c1822cd0b767cc8ac9f95
  $fShowCase :: GHC.Show.Show Data.Inflection.Case
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Case
                  Data.Inflection.$fShowCase_$cshowsPrec
                  Data.Inflection.$fShowCase_$cshow
                  Data.Inflection.$fShowCase_$cshowList -}
476440af125c1822cd0b767cc8ac9f95
  $fShowCase_$cshow :: Data.Inflection.Case -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Case) ->
                 Data.Inflection.$fShowCase_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
476440af125c1822cd0b767cc8ac9f95
  $fShowCase_$cshowList :: [Data.Inflection.Case] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Case
                   Data.Inflection.$w$cshowsPrec3) -}
476440af125c1822cd0b767cc8ac9f95
  $fShowCase_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Case -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Case)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec3 w1 w2) -}
1de448f2aa68251f2e0f9da9901aa214
  $fShowDefiniteness :: GHC.Show.Show Data.Inflection.Definiteness
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Definiteness
                  Data.Inflection.$fShowDefiniteness_$cshowsPrec
                  Data.Inflection.$fShowDefiniteness_$cshow
                  Data.Inflection.$fShowDefiniteness_$cshowList -}
1de448f2aa68251f2e0f9da9901aa214
  $fShowDefiniteness_$cshow ::
    Data.Inflection.Definiteness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Definiteness) ->
                 case x of wild {
                   Data.Inflection.UDEF -> Data.Inflection.$fReadDefiniteness15
                   Data.Inflection.DEF -> Data.Inflection.$fReadDefiniteness12
                   Data.Inflection.INDF -> Data.Inflection.$fReadDefiniteness9 }) -}
1de448f2aa68251f2e0f9da9901aa214
  $fShowDefiniteness_$cshowList ::
    [Data.Inflection.Definiteness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Definiteness
                   Data.Inflection.$w$cshowsPrec4) -}
1de448f2aa68251f2e0f9da9901aa214
  $fShowDefiniteness_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Definiteness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Definiteness)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec4 w1 w2) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fShowEvidentiality :: GHC.Show.Show Data.Inflection.Evidentiality
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Evidentiality
                  Data.Inflection.$fShowEvidentiality_$cshowsPrec
                  Data.Inflection.$fShowEvidentiality_$cshow
                  Data.Inflection.$fShowEvidentiality_$cshowList -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fShowEvidentiality_$cshow ::
    Data.Inflection.Evidentiality -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Evidentiality) ->
                 Data.Inflection.$fShowEvidentiality_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fShowEvidentiality_$cshowList ::
    [Data.Inflection.Evidentiality] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Evidentiality
                   Data.Inflection.$w$cshowsPrec5) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $fShowEvidentiality_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Evidentiality -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Evidentiality)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec5 w1 w2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress ::
    GHC.Show.Show a => GHC.Show.Show (Data.Inflection.Express a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Data.Inflection.Express a)
                  (Data.Inflection.$fShowExpress_$cshowsPrec @ a $dShow)
                  (Data.Inflection.$fShowExpress_$cshow @ a $dShow)
                  (Data.Inflection.$fShowExpress_$cshowList @ a $dShow) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress1 ::
    Data.Inflection.Express Data.Inflection.Gender -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress10 ::
    Data.Inflection.Express Data.Inflection.Number -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec3
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress11 ::
    Data.Inflection.Express Data.Inflection.Definiteness
    -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec4
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress12 ::
    Data.Inflection.Express Data.Inflection.Specificity
    -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec5
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress13 ::
    Data.Inflection.Express Data.Inflection.Topic -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec6
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress14 ::
    Data.Inflection.Express Data.Inflection.Person -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec7
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress15 ::
    Data.Inflection.Express Data.Inflection.Honorific -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec8
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress16 ::
    Data.Inflection.Express Data.Inflection.Polarity -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec9
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress17 ::
    Data.Inflection.Express Data.Inflection.Tense -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec10
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress18 ::
    Data.Inflection.Express Data.Inflection.Aspect -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec11
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress19 ::
    Data.Inflection.Express Data.Inflection.Mood -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec12
                   Data.Inflection.$fShowExpress2) -}
9c61cc2e5df5e84ebc0a68307694249f
  $fShowExpress2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress20 ::
    Data.Inflection.Express Data.Inflection.Voice -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec13
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress21 ::
    Data.Inflection.Express Data.Inflection.Evidentiality
    -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec14
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress22 ::
    Data.Inflection.Express Data.Inflection.Transitivity
    -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec15
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress23 ::
    Data.Inflection.Express Data.Inflection.Volition -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec16
                   Data.Inflection.$fShowExpress2) -}
fe2babce5b8a518cf90879589180bd34
  $fShowExpress24 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Data.Inflection.$fShowExpress6) -}
12380356ddc6b387bc7f179b9850f618
  $fShowExpress25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Data.Inflection.$fShowExpress6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0d4f59bcff035e0f94161a44f73de040
  $fShowExpress3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
2b5519577781f97256e0bdaaf189ff1d
  $fShowExpress4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getExp = "#) -}
30aba44b60d3111a8074737561c59b29
  $fShowExpress5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Express {"#) -}
239bb5c5092336c5d6ed24a45284c9ea
  $fShowExpress6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoExpress"#) -}
1959e4716a2c6644e07f0d50ba684e87
  $fShowExpress7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Data.Inflection.$fShowExpress3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress8 ::
    Data.Inflection.Express Data.Inflection.Animacy -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec1
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress9 ::
    Data.Inflection.Express Data.Inflection.Case -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Inflection.$fShowExpress_$s$cshowsPrec2
                   Data.Inflection.$fShowExpress2) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$cshow ::
    GHC.Show.Show a => Data.Inflection.Express a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Data.Inflection.Express a) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress25
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (GHC.Show.showsPrec
                              @ a
                              $dShow
                              Data.Inflection.$fShowExpress2
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$cshowList ::
    GHC.Show.Show a => [Data.Inflection.Express a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Data.Inflection.Express a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express a)
                   (Data.Inflection.$fShowExpress_$cshowsPrec
                      @ a
                      $dShow
                      Data.Inflection.$fShowExpress2)
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Data.Inflection.Express a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express a) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress24
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a $dShow Data.Inflection.$fShowExpress2 b1
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String) ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (f (GHC.Base.++
                                     @ GHC.Types.Char
                                     Data.Inflection.$fShowExpress3
                                     x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x1)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow ::
    Data.Inflection.Express Data.Inflection.Gender -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Gender) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec6
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow1 ::
    Data.Inflection.Express Data.Inflection.Animacy -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Animacy) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec1
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow10 ::
    Data.Inflection.Express Data.Inflection.Tense -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Tense) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec10
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow11 ::
    Data.Inflection.Express Data.Inflection.Aspect -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Aspect) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec2
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow12 ::
    Data.Inflection.Express Data.Inflection.Mood -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Mood) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec11
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow13 ::
    Data.Inflection.Express Data.Inflection.Voice -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Voice) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec12
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow14 ::
    Data.Inflection.Express Data.Inflection.Evidentiality
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Evidentiality) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec5
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow15 ::
    Data.Inflection.Express Data.Inflection.Transitivity
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Transitivity) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec13
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow16 ::
    Data.Inflection.Express Data.Inflection.Volition -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Express Data.Inflection.Volition) ->
                 Data.Inflection.$fShowExpress_$s$cshowsPrec16
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow2 ::
    Data.Inflection.Express Data.Inflection.Case -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Case) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec3
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow3 ::
    Data.Inflection.Express Data.Inflection.Number -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Number) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec7
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow4 ::
    Data.Inflection.Express Data.Inflection.Definiteness
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Express Data.Inflection.Definiteness) ->
                 Data.Inflection.$fShowExpress_$s$cshowsPrec4
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow5 ::
    Data.Inflection.Express Data.Inflection.Specificity
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Express Data.Inflection.Specificity) ->
                 Data.Inflection.$fShowExpress_$s$cshowsPrec5
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow6 ::
    Data.Inflection.Express Data.Inflection.Topic -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Express Data.Inflection.Topic) ->
                 Data.Inflection.$fShowExpress_$s$cshowsPrec6
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow7 ::
    Data.Inflection.Express Data.Inflection.Person -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Person) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec8
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow8 ::
    Data.Inflection.Express Data.Inflection.Honorific
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Data.Inflection.Express
                           Data.Inflection.Honorific) ->
                 case x of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.$fShowExpress6
                   Data.Inflection.Express b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowExpress5
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Data.Inflection.$fShowExpress4
                           (Data.Inflection.$w$cshowsPrec9
                              b1
                              Data.Inflection.$fShowExpress7)) }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshow9 ::
    Data.Inflection.Express Data.Inflection.Polarity -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Express Data.Inflection.Polarity) ->
                 Data.Inflection.$fShowExpress_$s$cshowsPrec9
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList ::
    [Data.Inflection.Express Data.Inflection.Gender] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Gender])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Gender)
                   Data.Inflection.$fShowExpress1
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList1 ::
    [Data.Inflection.Express Data.Inflection.Animacy] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Animacy])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Animacy)
                   Data.Inflection.$fShowExpress8
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList10 ::
    [Data.Inflection.Express Data.Inflection.Tense] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Tense])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Tense)
                   Data.Inflection.$fShowExpress17
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList11 ::
    [Data.Inflection.Express Data.Inflection.Aspect] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Aspect])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Aspect)
                   Data.Inflection.$fShowExpress18
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList12 ::
    [Data.Inflection.Express Data.Inflection.Mood] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Mood])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Mood)
                   Data.Inflection.$fShowExpress19
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList13 ::
    [Data.Inflection.Express Data.Inflection.Voice] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Voice])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Voice)
                   Data.Inflection.$fShowExpress20
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList14 ::
    [Data.Inflection.Express Data.Inflection.Evidentiality]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Evidentiality])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Evidentiality)
                   Data.Inflection.$fShowExpress21
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList15 ::
    [Data.Inflection.Express Data.Inflection.Transitivity]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Transitivity])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Transitivity)
                   Data.Inflection.$fShowExpress22
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList16 ::
    [Data.Inflection.Express Data.Inflection.Volition]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Volition])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Volition)
                   Data.Inflection.$fShowExpress23
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList2 ::
    [Data.Inflection.Express Data.Inflection.Case] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Case])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Case)
                   Data.Inflection.$fShowExpress9
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList3 ::
    [Data.Inflection.Express Data.Inflection.Number] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Number])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Number)
                   Data.Inflection.$fShowExpress10
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList4 ::
    [Data.Inflection.Express Data.Inflection.Definiteness]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Definiteness])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Definiteness)
                   Data.Inflection.$fShowExpress11
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList5 ::
    [Data.Inflection.Express Data.Inflection.Specificity]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Specificity])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Specificity)
                   Data.Inflection.$fShowExpress12
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList6 ::
    [Data.Inflection.Express Data.Inflection.Topic] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Topic])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Topic)
                   Data.Inflection.$fShowExpress13
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList7 ::
    [Data.Inflection.Express Data.Inflection.Person] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Person])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Person)
                   Data.Inflection.$fShowExpress14
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList8 ::
    [Data.Inflection.Express Data.Inflection.Honorific]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Honorific])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Honorific)
                   Data.Inflection.$fShowExpress15
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowList9 ::
    [Data.Inflection.Express Data.Inflection.Polarity]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [Data.Inflection.Express Data.Inflection.Polarity])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Express Data.Inflection.Polarity)
                   Data.Inflection.$fShowExpress16
                   eta
                   eta1) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Gender -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Gender)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec6
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec1 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Animacy
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Animacy)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec1
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec10 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Tense -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Tense)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec10
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec11 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Aspect -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Aspect)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec2
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec12 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Mood -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Mood)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec11
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec13 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Voice -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Voice)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec12
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec14 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Evidentiality
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Evidentiality)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec5
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec15 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Transitivity
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Transitivity)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec13
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec16 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Volition
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Volition)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (case b1 of wild2 {
                                  Data.Inflection.UVOL
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest320
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.VOL
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest317
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.NVOL
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest314
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1) }))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec2 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Case -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Case)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec3
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec3 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Number -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Number)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec7
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec4 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Definiteness
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Definiteness)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (case b1 of wild2 {
                                  Data.Inflection.UDEF
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadDefiniteness15
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.DEF
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadDefiniteness12
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.INDF
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadDefiniteness9
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1) }))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec5 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Specificity
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Specificity)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (case b1 of wild2 {
                                  Data.Inflection.USPE
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest58
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.SPEC
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest55
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.NSPEC
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest52
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1) }))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec6 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Topic -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Topic)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (case b1 of wild2 {
                                  Data.Inflection.UTOP
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest74
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.TOP
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest71
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.NTOP
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest68
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1) }))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec7 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Person -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Person)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec8
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec8 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Honorific
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Honorific)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (Data.Inflection.$w$cshowsPrec9
                                  b1
                                  (GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress3 x1)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$cshowsPrec9 ::
    GHC.Types.Int
    -> Data.Inflection.Express Data.Inflection.Polarity
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Express Data.Inflection.Polarity)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoExpress
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fShowExpress6 eta
                   Data.Inflection.Express b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Data.Inflection.$fShowExpress5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Data.Inflection.$fShowExpress4
                               (case b1 of wild2 {
                                  Data.Inflection.UPOL
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest128
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.AFF
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest125
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1)
                                  Data.Inflection.NEG
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       Data.Inflection.$fReadManifest122
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          Data.Inflection.$fShowExpress3
                                          x1) }))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta)) } } }) -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Gender)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Gender)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec
                  Data.Inflection.$fShowExpress_$s$cshow
                  Data.Inflection.$fShowExpress_$s$cshowList -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress1 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Animacy)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Animacy)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec1
                  Data.Inflection.$fShowExpress_$s$cshow1
                  Data.Inflection.$fShowExpress_$s$cshowList1 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress10 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Tense)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Tense)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec10
                  Data.Inflection.$fShowExpress_$s$cshow10
                  Data.Inflection.$fShowExpress_$s$cshowList10 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress11 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Aspect)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Aspect)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec11
                  Data.Inflection.$fShowExpress_$s$cshow11
                  Data.Inflection.$fShowExpress_$s$cshowList11 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress12 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Mood)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Mood)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec12
                  Data.Inflection.$fShowExpress_$s$cshow12
                  Data.Inflection.$fShowExpress_$s$cshowList12 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress13 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Voice)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Voice)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec13
                  Data.Inflection.$fShowExpress_$s$cshow13
                  Data.Inflection.$fShowExpress_$s$cshowList13 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress14 ::
    GHC.Show.Show
      (Data.Inflection.Express Data.Inflection.Evidentiality)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Evidentiality)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec14
                  Data.Inflection.$fShowExpress_$s$cshow14
                  Data.Inflection.$fShowExpress_$s$cshowList14 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress15 ::
    GHC.Show.Show
      (Data.Inflection.Express Data.Inflection.Transitivity)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Transitivity)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec15
                  Data.Inflection.$fShowExpress_$s$cshow15
                  Data.Inflection.$fShowExpress_$s$cshowList15 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress16 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Volition)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Volition)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec16
                  Data.Inflection.$fShowExpress_$s$cshow16
                  Data.Inflection.$fShowExpress_$s$cshowList16 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress2 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Case)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Case)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec2
                  Data.Inflection.$fShowExpress_$s$cshow2
                  Data.Inflection.$fShowExpress_$s$cshowList2 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress3 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Number)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Number)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec3
                  Data.Inflection.$fShowExpress_$s$cshow3
                  Data.Inflection.$fShowExpress_$s$cshowList3 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress4 ::
    GHC.Show.Show
      (Data.Inflection.Express Data.Inflection.Definiteness)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Definiteness)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec4
                  Data.Inflection.$fShowExpress_$s$cshow4
                  Data.Inflection.$fShowExpress_$s$cshowList4 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress5 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Specificity)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Specificity)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec5
                  Data.Inflection.$fShowExpress_$s$cshow5
                  Data.Inflection.$fShowExpress_$s$cshowList5 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress6 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Topic)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Topic)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec6
                  Data.Inflection.$fShowExpress_$s$cshow6
                  Data.Inflection.$fShowExpress_$s$cshowList6 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress7 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Person)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Person)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec7
                  Data.Inflection.$fShowExpress_$s$cshow7
                  Data.Inflection.$fShowExpress_$s$cshowList7 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress8 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Honorific)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Honorific)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec8
                  Data.Inflection.$fShowExpress_$s$cshow8
                  Data.Inflection.$fShowExpress_$s$cshowList8 -}
215fe38755b3229d5abb86dd2bfcfba2
  $fShowExpress_$s$fShowExpress9 ::
    GHC.Show.Show (Data.Inflection.Express Data.Inflection.Polarity)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Inflection.Express Data.Inflection.Polarity)
                  Data.Inflection.$fShowExpress_$s$cshowsPrec9
                  Data.Inflection.$fShowExpress_$s$cshow9
                  Data.Inflection.$fShowExpress_$s$cshowList9 -}
8099e7e810494d6db288b5ee6338a850
  $fShowGender :: GHC.Show.Show Data.Inflection.Gender
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Gender
                  Data.Inflection.$fShowGender_$cshowsPrec
                  Data.Inflection.$fShowGender_$cshow
                  Data.Inflection.$fShowGender_$cshowList -}
8099e7e810494d6db288b5ee6338a850
  $fShowGender_$cshow :: Data.Inflection.Gender -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Gender) ->
                 Data.Inflection.$fShowGender_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8099e7e810494d6db288b5ee6338a850
  $fShowGender_$cshowList ::
    [Data.Inflection.Gender] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Gender
                   Data.Inflection.$w$cshowsPrec6) -}
8099e7e810494d6db288b5ee6338a850
  $fShowGender_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Gender -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Gender)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec6 w1 w2) -}
fb068a739b47969783c008d0c5ccdfb8
  $fShowHonorific :: GHC.Show.Show Data.Inflection.Honorific
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Honorific
                  Data.Inflection.$fShowHonorific_$cshowsPrec
                  Data.Inflection.$fShowHonorific_$cshow
                  Data.Inflection.$fShowHonorific_$cshowList -}
fb068a739b47969783c008d0c5ccdfb8
  $fShowHonorific_$cshow ::
    Data.Inflection.Honorific -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Honorific) ->
                 Data.Inflection.$fShowHonorific_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
fb068a739b47969783c008d0c5ccdfb8
  $fShowHonorific_$cshowList ::
    [Data.Inflection.Honorific] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Honorific
                   Data.Inflection.$w$cshowsPrec9) -}
fb068a739b47969783c008d0c5ccdfb8
  $fShowHonorific_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Honorific -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Honorific)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec9 w1 w2) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fShowInflectionSystem ::
    GHC.Show.Show Data.Inflection.InflectionSystem
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.InflectionSystem
                  Data.Inflection.$fShowInflectionSystem_$cshowsPrec
                  Data.Inflection.$fShowInflectionSystem_$cshow
                  Data.Inflection.$fShowInflectionSystem_$cshowList -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fShowInflectionSystem1 ::
    Data.Inflection.InflectionSystem -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Data.Inflection.InflectionSystem)
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Data.Inflection.InflectionSystem ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ->
                 Data.Inflection.$w$cshowsPrec14
                   0#
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17
                   w1 }) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fShowInflectionSystem_$cshow ::
    Data.Inflection.InflectionSystem -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.InflectionSystem) ->
                 Data.Inflection.$fShowInflectionSystem_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fShowInflectionSystem_$cshowList ::
    [Data.Inflection.InflectionSystem] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.InflectionSystem
                   Data.Inflection.$fShowInflectionSystem1) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $fShowInflectionSystem_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.InflectionSystem -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.InflectionSystem)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Data.Inflection.InflectionSystem ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ->
                 Data.Inflection.$w$cshowsPrec14
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17
                   ww18
                   ww19
                   w2 } }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fShowLexCat :: GHC.Show.Show Data.Inflection.LexCat
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.LexCat
                  Data.Inflection.$fShowLexCat_$cshowsPrec
                  Data.Inflection.$fShowLexCat_$cshow
                  Data.Inflection.$fShowLexCat_$cshowList -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fShowLexCat_$cshow :: Data.Inflection.LexCat -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.LexCat) ->
                 Data.Inflection.$fShowLexCat_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fShowLexCat_$cshowList ::
    [Data.Inflection.LexCat] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.LexCat
                   Data.Inflection.$w$cshowsPrec15) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $fShowLexCat_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.LexCat -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.LexCat)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec15 w1 w2) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fShowManifest ::
    GHC.Show.Show a => GHC.Show.Show (Data.Inflection.Manifest a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Data.Inflection.Manifest a)
                  (Data.Inflection.$fShowManifest_$cshowsPrec @ a $dShow)
                  (Data.Inflection.$fShowManifest_$cshow @ a $dShow)
                  (Data.Inflection.$fShowManifest_$cshowList @ a $dShow) -}
aac29e474bd823aef2e17048fe2b0e69
  $fShowManifest1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Manifest "#) -}
4f9a20ec37c3caa969811fa73dd56952
  $fShowManifest2 ::
    (Data.Inflection.LexCat, Data.Inflection.ManifestType,
     GHC.Types.Int)
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (w4 :: (Data.Inflection.LexCat,
                           Data.Inflection.ManifestType, GHC.Types.Int))
                   (w5 :: GHC.Base.String)[OneShot] ->
                 case w4 of ww { (,,) ww1 ww2 ww3 ->
                 GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows9
                   (Data.Inflection.$w$cshowsPrec15
                      ww1
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.shows7
                         (GHC.Show.$fShow(,,)_$sgo
                            (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w5)
                            (\ (w :: GHC.Base.String) -> Data.Inflection.$w$cshowsPrec16 ww2 w)
                            (GHC.Types.:
                               @ GHC.Show.ShowS
                               (\ (w2 :: GHC.Base.String) ->
                                case ww3 of ww4 { GHC.Types.I# ww5 ->
                                case GHC.Show.$wshowSignedInt 0# ww5 w2 of ww6 { (#,#) ww7 ww8 ->
                                GHC.Types.: @ GHC.Types.Char ww7 ww8 } })
                               (GHC.Types.[] @ GHC.Show.ShowS))))) }) -}
41c69e20da3f2f4756f5f69753a412eb
  $fShowManifest3 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Data.Inflection.$fReadManifest6) -}
c9f9758fe84f0162ec8190ca4a4ab9df
  $fShowManifest4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Data.Inflection.$fReadManifest6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
bbcb171ae6dead0cd5095e2d02b10d22
  $fShowManifestSystem ::
    GHC.Show.Show Data.Inflection.ManifestSystem
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.ManifestSystem
                  Data.Inflection.$fShowManifestSystem_$cshowsPrec
                  Data.Inflection.$fShowManifestSystem_$cshow
                  Data.Inflection.$fShowManifestSystem_$cshowList -}
bbcb171ae6dead0cd5095e2d02b10d22
  $fShowManifestSystem1 ::
    Data.Inflection.ManifestSystem -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Data.Inflection.ManifestSystem)
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Data.Inflection.ManifestSystem ww1 ww2 ww3 ->
                 Data.Inflection.$w$cshowsPrec21 0# ww1 ww2 ww3 w1 }) -}
bbcb171ae6dead0cd5095e2d02b10d22
  $fShowManifestSystem_$cshow ::
    Data.Inflection.ManifestSystem -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.ManifestSystem) ->
                 Data.Inflection.$fShowManifestSystem_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
bbcb171ae6dead0cd5095e2d02b10d22
  $fShowManifestSystem_$cshowList ::
    [Data.Inflection.ManifestSystem] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.ManifestSystem
                   Data.Inflection.$fShowManifestSystem1) -}
bbcb171ae6dead0cd5095e2d02b10d22
  $fShowManifestSystem_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.ManifestSystem -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.ManifestSystem)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Data.Inflection.ManifestSystem ww3 ww4 ww5 ->
                 Data.Inflection.$w$cshowsPrec21 ww1 ww3 ww4 ww5 w2 } }) -}
e80d8f471552e307f8ce67ea59e61dde
  $fShowManifestType :: GHC.Show.Show Data.Inflection.ManifestType
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.ManifestType
                  Data.Inflection.$fShowManifestType_$cshowsPrec
                  Data.Inflection.$fShowManifestType_$cshow
                  Data.Inflection.$fShowManifestType_$cshowList -}
e80d8f471552e307f8ce67ea59e61dde
  $fShowManifestType_$cshow ::
    Data.Inflection.ManifestType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.ManifestType) ->
                 case x of wild {
                   Data.Inflection.Particle -> Data.Inflection.$fReadManifestType15
                   Data.Inflection.Prefix -> Data.Inflection.$fReadManifestType12
                   Data.Inflection.Suffix -> Data.Inflection.$fReadManifestType9 }) -}
e80d8f471552e307f8ce67ea59e61dde
  $fShowManifestType_$cshowList ::
    [Data.Inflection.ManifestType] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.ManifestType
                   Data.Inflection.$w$cshowsPrec16) -}
e80d8f471552e307f8ce67ea59e61dde
  $fShowManifestType_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.ManifestType -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.ManifestType)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec16 w1 w2) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fShowManifest_$cshow ::
    GHC.Show.Show a => Data.Inflection.Manifest a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Data.Inflection.Manifest a) ->
                 case x of wild {
                   Data.Inflection.NoManifest -> Data.Inflection.$fShowManifest4
                   Data.Inflection.Manifest b1 b2
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fShowManifest1
                        (GHC.Show.showList__
                           @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                              GHC.Types.Int)
                           Data.Inflection.$fShowManifest2
                           b1
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (GHC.Show.showsPrec
                                 @ a
                                 $dShow
                                 Data.Inflection.$fReadManifest4
                                 b2
                                 (GHC.Types.[] @ GHC.Types.Char)))) }) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fShowManifest_$cshowList ::
    GHC.Show.Show a => [Data.Inflection.Manifest a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Data.Inflection.Manifest a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Data.Inflection.Manifest a)
                   (Data.Inflection.$fShowManifest_$cshowsPrec
                      @ a
                      $dShow
                      Data.Inflection.$fShowExpress2)
                   eta
                   eta1) -}
7ddf4c335f657c49b9e10fc56a6bbdf0
  $fShowManifest_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Data.Inflection.Manifest a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest a) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest -> Data.Inflection.$fShowManifest3
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a $dShow Data.Inflection.$fReadManifest4 b2
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (GHC.Show.showList__
                                @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                   GHC.Types.Int)
                                Data.Inflection.$fShowManifest2
                                b1
                                (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x1)))
                        GHC.Types.True
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (GHC.Show.showList__
                                   @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                                      GHC.Types.Int)
                                   Data.Inflection.$fShowManifest2
                                   b1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows6
                                            x1))))) } } }) -}
601aba65187f112398fea215f5742f3c
  $fShowManifest_$s$cshowsPrec ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Gender]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Gender])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Gender
                                  Data.Inflection.$w$cshowsPrec6
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
80fcc6a38c8a6734e15323359aeed4b5
  $fShowManifest_$s$cshowsPrec1 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Animacy]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Animacy])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Animacy
                                  Data.Inflection.$w$cshowsPrec1
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
7ef6bbceb283f38b9416bcd485ebd993
  $fShowManifest_$s$cshowsPrec10 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Tense]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Tense])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Tense
                                  Data.Inflection.$w$cshowsPrec10
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
4680d625ea9c374baa6ef2cae94238a7
  $fShowManifest_$s$cshowsPrec11 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Aspect]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Aspect])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Aspect
                                  Data.Inflection.$w$cshowsPrec2
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
b31adac4250c3199c173e0d7bcf7de97
  $fShowManifest_$s$cshowsPrec12 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Mood]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Mood])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Mood
                                  Data.Inflection.$w$cshowsPrec11
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
b6422840bf314cec2ce47551fb95a9ad
  $fShowManifest_$s$cshowsPrec13 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Voice]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Voice])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Voice
                                  Data.Inflection.$w$cshowsPrec12
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
2f861e0035b7bb8ec2a2f2fbb4a89db5
  $fShowManifest_$s$cshowsPrec14 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Evidentiality]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Evidentiality])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Evidentiality
                                  Data.Inflection.$w$cshowsPrec5
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
1474e356b931f4180b11d1fc7b898a98
  $fShowManifest_$s$cshowsPrec15 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Transitivity]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Transitivity])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Transitivity
                                  Data.Inflection.$w$cshowsPrec13
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
716f08bdd0ca012d3564b4f6ef15fd3a
  $fShowManifest_$s$cshowsPrec16 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Volition]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Volition])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Volition
                                  Data.Inflection.$w$cshowsPrec20
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
27585dfb1eef37dc3a6daa7cecdab1cf
  $fShowManifest_$s$cshowsPrec2 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Case]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Case])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Case
                                  Data.Inflection.$w$cshowsPrec3
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
44e9906fd6afd5134273d4e893813def
  $fShowManifest_$s$cshowsPrec3 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Number]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Number])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Number
                                  Data.Inflection.$w$cshowsPrec7
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
910753d953bb1b689be6f623e4d0e21b
  $fShowManifest_$s$cshowsPrec4 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Definiteness]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Definiteness])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Definiteness
                                  Data.Inflection.$w$cshowsPrec4
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
40cb37e1324a9150c06cadde3f4ea551
  $fShowManifest_$s$cshowsPrec5 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Specificity]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Specificity])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Specificity
                                  Data.Inflection.$w$cshowsPrec17
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
d723e4af228ee7c69ff52444236951f1
  $fShowManifest_$s$cshowsPrec6 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Topic]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Topic])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Topic
                                  Data.Inflection.$w$cshowsPrec18
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
a4392f3a986261a6ed08024f770201ac
  $fShowManifest_$s$cshowsPrec7 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Person]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Person])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Person
                                  Data.Inflection.$w$cshowsPrec8
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
a3b942d992262eef5679ef1bb9e7c444
  $fShowManifest_$s$cshowsPrec8 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Honorific]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Honorific])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Honorific
                                  Data.Inflection.$w$cshowsPrec9
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
8cbdf101765974e4cf2c2f990a55fbf8
  $fShowManifest_$s$cshowsPrec9 ::
    GHC.Types.Int
    -> Data.Inflection.Manifest [Data.Inflection.Polarity]
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Data.Inflection.Manifest [Data.Inflection.Polarity])
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Data.Inflection.NoManifest
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest6 eta
                   Data.Inflection.Manifest b1 b2
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Show.showList__
                            @ (Data.Inflection.LexCat, Data.Inflection.ManifestType,
                               GHC.Types.Int)
                            Data.Inflection.$fShowManifest2
                            b1
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Show.showList__
                                  @ Data.Inflection.Polarity
                                  Data.Inflection.$w$cshowsPrec19
                                  b2
                                  x1))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Data.Inflection.$fShowManifest1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Data.Inflection.$fShowManifest1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 eta))) } } }) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fShowMood :: GHC.Show.Show Data.Inflection.Mood
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Mood
                  Data.Inflection.$fShowMood_$cshowsPrec
                  Data.Inflection.$fShowMood_$cshow
                  Data.Inflection.$fShowMood_$cshowList -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fShowMood_$cshow :: Data.Inflection.Mood -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Mood) ->
                 Data.Inflection.$fShowMood_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fShowMood_$cshowList :: [Data.Inflection.Mood] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Mood
                   Data.Inflection.$w$cshowsPrec11) -}
72dcb6eb4442b59226b0ba8f6714f13e
  $fShowMood_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Mood -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Mood)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec11 w1 w2) -}
7465cc747c74e065f91b84b3f135a27f
  $fShowNumber :: GHC.Show.Show Data.Inflection.Number
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Number
                  Data.Inflection.$fShowNumber_$cshowsPrec
                  Data.Inflection.$fShowNumber_$cshow
                  Data.Inflection.$fShowNumber_$cshowList -}
7465cc747c74e065f91b84b3f135a27f
  $fShowNumber_$cshow :: Data.Inflection.Number -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Number) ->
                 Data.Inflection.$fShowNumber_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7465cc747c74e065f91b84b3f135a27f
  $fShowNumber_$cshowList ::
    [Data.Inflection.Number] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Number
                   Data.Inflection.$w$cshowsPrec7) -}
7465cc747c74e065f91b84b3f135a27f
  $fShowNumber_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Number -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Number)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec7 w1 w2) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fShowPerson :: GHC.Show.Show Data.Inflection.Person
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Person
                  Data.Inflection.$fShowPerson_$cshowsPrec
                  Data.Inflection.$fShowPerson_$cshow
                  Data.Inflection.$fShowPerson_$cshowList -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fShowPerson_$cshow :: Data.Inflection.Person -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Person) ->
                 Data.Inflection.$fShowPerson_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fShowPerson_$cshowList ::
    [Data.Inflection.Person] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Person
                   Data.Inflection.$w$cshowsPrec8) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $fShowPerson_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Person -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Person)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec8 w1 w2) -}
1c2c61816b840e25aed576544ed551f7
  $fShowPolarity :: GHC.Show.Show Data.Inflection.Polarity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Polarity
                  Data.Inflection.$fShowPolarity_$cshowsPrec
                  Data.Inflection.$fShowPolarity_$cshow
                  Data.Inflection.$fShowPolarity_$cshowList -}
1c2c61816b840e25aed576544ed551f7
  $fShowPolarity_$cshow ::
    Data.Inflection.Polarity -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Polarity) ->
                 case x of wild {
                   Data.Inflection.UPOL -> Data.Inflection.$fReadManifest128
                   Data.Inflection.AFF -> Data.Inflection.$fReadManifest125
                   Data.Inflection.NEG -> Data.Inflection.$fReadManifest122 }) -}
1c2c61816b840e25aed576544ed551f7
  $fShowPolarity_$cshowList ::
    [Data.Inflection.Polarity] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Polarity
                   Data.Inflection.$w$cshowsPrec19) -}
1c2c61816b840e25aed576544ed551f7
  $fShowPolarity_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Polarity -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Polarity)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec19 w1 w2) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fShowSpecificity :: GHC.Show.Show Data.Inflection.Specificity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Specificity
                  Data.Inflection.$fShowSpecificity_$cshowsPrec
                  Data.Inflection.$fShowSpecificity_$cshow
                  Data.Inflection.$fShowSpecificity_$cshowList -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fShowSpecificity_$cshow ::
    Data.Inflection.Specificity -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Specificity) ->
                 case x of wild {
                   Data.Inflection.USPE -> Data.Inflection.$fReadManifest58
                   Data.Inflection.SPEC -> Data.Inflection.$fReadManifest55
                   Data.Inflection.NSPEC -> Data.Inflection.$fReadManifest52 }) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fShowSpecificity_$cshowList ::
    [Data.Inflection.Specificity] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Specificity
                   Data.Inflection.$w$cshowsPrec17) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $fShowSpecificity_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Specificity -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Specificity)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec17 w1 w2) -}
66acf52fe96ad50a10594fa2d12d699d
  $fShowTense :: GHC.Show.Show Data.Inflection.Tense
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Tense
                  Data.Inflection.$fShowTense_$cshowsPrec
                  Data.Inflection.$fShowTense_$cshow
                  Data.Inflection.$fShowTense_$cshowList -}
66acf52fe96ad50a10594fa2d12d699d
  $fShowTense_$cshow :: Data.Inflection.Tense -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Tense) ->
                 Data.Inflection.$fShowTense_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
66acf52fe96ad50a10594fa2d12d699d
  $fShowTense_$cshowList :: [Data.Inflection.Tense] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Tense
                   Data.Inflection.$w$cshowsPrec10) -}
66acf52fe96ad50a10594fa2d12d699d
  $fShowTense_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Tense -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Tense)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec10 w1 w2) -}
f6776b7675319519d06c9aea2dc03bf9
  $fShowTopic :: GHC.Show.Show Data.Inflection.Topic
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Topic
                  Data.Inflection.$fShowTopic_$cshowsPrec
                  Data.Inflection.$fShowTopic_$cshow
                  Data.Inflection.$fShowTopic_$cshowList -}
f6776b7675319519d06c9aea2dc03bf9
  $fShowTopic_$cshow :: Data.Inflection.Topic -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Topic) ->
                 case x of wild {
                   Data.Inflection.UTOP -> Data.Inflection.$fReadManifest74
                   Data.Inflection.TOP -> Data.Inflection.$fReadManifest71
                   Data.Inflection.NTOP -> Data.Inflection.$fReadManifest68 }) -}
f6776b7675319519d06c9aea2dc03bf9
  $fShowTopic_$cshowList :: [Data.Inflection.Topic] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Topic
                   Data.Inflection.$w$cshowsPrec18) -}
f6776b7675319519d06c9aea2dc03bf9
  $fShowTopic_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Topic -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Topic)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec18 w1 w2) -}
7302fbe55b71c04bf146a8a39e883cde
  $fShowTransitivity :: GHC.Show.Show Data.Inflection.Transitivity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Transitivity
                  Data.Inflection.$fShowTransitivity_$cshowsPrec
                  Data.Inflection.$fShowTransitivity_$cshow
                  Data.Inflection.$fShowTransitivity_$cshowList -}
7302fbe55b71c04bf146a8a39e883cde
  $fShowTransitivity_$cshow ::
    Data.Inflection.Transitivity -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Transitivity) ->
                 Data.Inflection.$fShowTransitivity_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7302fbe55b71c04bf146a8a39e883cde
  $fShowTransitivity_$cshowList ::
    [Data.Inflection.Transitivity] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Transitivity
                   Data.Inflection.$w$cshowsPrec13) -}
7302fbe55b71c04bf146a8a39e883cde
  $fShowTransitivity_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Transitivity -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Transitivity)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec13 w1 w2) -}
82e4499831c335865b73c47901c341b5
  $fShowVoice :: GHC.Show.Show Data.Inflection.Voice
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Voice
                  Data.Inflection.$fShowVoice_$cshowsPrec
                  Data.Inflection.$fShowVoice_$cshow
                  Data.Inflection.$fShowVoice_$cshowList -}
82e4499831c335865b73c47901c341b5
  $fShowVoice_$cshow :: Data.Inflection.Voice -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Voice) ->
                 Data.Inflection.$fShowVoice_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
82e4499831c335865b73c47901c341b5
  $fShowVoice_$cshowList :: [Data.Inflection.Voice] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Voice
                   Data.Inflection.$w$cshowsPrec12) -}
82e4499831c335865b73c47901c341b5
  $fShowVoice_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Voice -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Voice)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec12 w1 w2) -}
637cf4191464029f30da46ab81b77985
  $fShowVolition :: GHC.Show.Show Data.Inflection.Volition
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Inflection.Volition
                  Data.Inflection.$fShowVolition_$cshowsPrec
                  Data.Inflection.$fShowVolition_$cshow
                  Data.Inflection.$fShowVolition_$cshowList -}
637cf4191464029f30da46ab81b77985
  $fShowVolition_$cshow ::
    Data.Inflection.Volition -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Inflection.Volition) ->
                 case x of wild {
                   Data.Inflection.UVOL -> Data.Inflection.$fReadManifest320
                   Data.Inflection.VOL -> Data.Inflection.$fReadManifest317
                   Data.Inflection.NVOL -> Data.Inflection.$fReadManifest314 }) -}
637cf4191464029f30da46ab81b77985
  $fShowVolition_$cshowList ::
    [Data.Inflection.Volition] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Inflection.Volition
                   Data.Inflection.$w$cshowsPrec20) -}
637cf4191464029f30da46ab81b77985
  $fShowVolition_$cshowsPrec ::
    GHC.Types.Int -> Data.Inflection.Volition -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Inflection.Volition)
                   (w2 :: GHC.Base.String) ->
                 Data.Inflection.$w$cshowsPrec20 w1 w2) -}
68d3be253eeba6bf918b0d5372442d93
  $tc'ABE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7669956025818988620##
                   9467888188817468070##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ABE1) -}
ff0fda0f1971135bab62e365cfdd5018
  $tc'ABE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ABE"#) -}
84eb682f79418369220dafaa2497ee60
  $tc'ABL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6502567943669795091##
                   9668568667494030479##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ABL1) -}
435c0302b11d175df046d392989109c8
  $tc'ABL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ABL"#) -}
7cfbf019d72066f21e18db4b9c459346
  $tc'ABS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11477179990529781677##
                   16992454800234013396##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ABS1) -}
04d11dc502bf10bec9150dbad1fa300e
  $tc'ABS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ABS"#) -}
dab5c1fb31cf9b58697bc0c379eb1cdf
  $tc'ABS2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   800679824371166436##
                   941113310371621193##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ABS5) -}
bbbdba33432c8208d18d93e951d155ee
  $tc'ABS3 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14351226942487819845##
                   13065331721266315505##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ABS6) -}
8879d12ed759119fb2f742d0cd163691
  $tc'ABS5 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ABS2"#) -}
764b17c8c2951b8563433f66b7a95a94
  $tc'ABS6 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ABS3"#) -}
1b1b1f53552ad8952a7bc1ec338a59d9
  $tc'ACC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17801592049430855941##
                   18295153741053200901##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ACC1) -}
f1a311308668f1dbd894b9511ffd2150
  $tc'ACC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ACC"#) -}
df7da50c1dd5cc8095bdc7aa4f562d4d
  $tc'ACTIVE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2081289761744377843##
                   13776952938894040048##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ACTIVE1) -}
e8bbfc99e045fbe6ca328ac2dcbc804c
  $tc'ACTIVE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ACTIVE"#) -}
f05d8b091235a7d940934a722c8beb72
  $tc'ADP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6735355269576632237##
                   2349462882994573789##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ADP1) -}
70229a6a28a57fe9585b5e5d97d543b6
  $tc'ADP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ADP"#) -}
0f5570a6c85069382a4c83e2f20cff5b
  $tc'AFF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11052142896952260764##
                   8921304717994161245##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'AFF1) -}
1addbb03d2685637ef4b5ddb470b28ba
  $tc'AFF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AFF"#) -}
6b0994a38f352f8a9789b5a600411a42
  $tc'AFUT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11012468216947745949##
                   9588649510799381887##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'AFUT4) -}
508ac3b472cb0f93a3880770e63571d1
  $tc'AFUT1 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7867343572073496145##
                   15230120628228194648##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'AFUT5) -}
4962d55904cad1ffa4e6b34b4a0cf014
  $tc'AFUT2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13447719101938726281##
                   4357001649024004110##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'AFUT6) -}
0c8ea2f00ed4be86398b5da2dc530c01
  $tc'AFUT3 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8459908188494785328##
                   9418378973343091430##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'AFUT7) -}
f64cbd77950eed621a14c8fd081a29d0
  $tc'AFUT4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AFUT"#) -}
887e20e8bb5825bc62860658baab4426
  $tc'AFUT5 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AFUT1"#) -}
05db5c7190e8afd2a238ee496efc6687
  $tc'AFUT6 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AFUT2"#) -}
35c74a852b705f3d17114b2c04f23aa0
  $tc'AFUT7 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AFUT3"#) -}
4c23b66300eee7acc8417e76bb9d6e39
  $tc'AN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3306470520823639787##
                   4123197757683391950##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'AN1) -}
94077e124dc4149d3a546a9bf13c1f64
  $tc'AN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AN"#) -}
3a727aa2d1d8533472c9f6384283cc41
  $tc'APRS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16437994737387728681##
                   1990149066030195932##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'APRS1) -}
5656055e8343b93e6d6ff14b125b74b9
  $tc'APRS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'APRS"#) -}
f05ecbe9d909dd5528d26867b601b649
  $tc'APST :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7095532195529816636##
                   3394935016362344709##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'APST1) -}
b3deee65c2c369a8df80d0fdc10410ad
  $tc'APST1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'APST"#) -}
f99074dbaef9d80ca46edb91eba6f38e
  $tc'ASS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1195247408888881901##
                   10867915344001810765##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ASS1) -}
7e6be306ee9300f7fe333671c92addda
  $tc'ASS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ASS"#) -}
e586dddd39a649508a3dbc254793f670
  $tc'AUD :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11337103797315129758##
                   18147360375612872759##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'AUD1) -}
e1e8ed27ba74ee10ea8e3c2c5ae533cd
  $tc'AUD1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AUD"#) -}
e20ad3130c624bb0d6228eeef8c23035
  $tc'Adj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11487431295920469737##
                   4662427254733783296##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Adj1) -}
43b247429be8f8eb2a5c92d4a35f8663
  $tc'Adj1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Adj"#) -}
c34f450e503a45dde0bbbef83ce5f353
  $tc'Adpo :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   900724716707055959##
                   976804744476399624##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Adpo1) -}
26ff30434d2c9a07a7c8229f5dcfd3e1
  $tc'Adpo1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Adpo"#) -}
4f8c93f1e0fce0ca02d2fa88b02e448e
  $tc'Adv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8783674770894428405##
                   17634015244040019618##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Adv1) -}
cdce99edf9e63317cc8ad86b1d63d9fb
  $tc'Adv1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Adv"#) -}
947c72476094ae803c4a426e4d518933
  $tc'BEN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   837381544459840043##
                   629690190198714745##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'BEN1) -}
cbb742b477829f3205725fb795d60702
  $tc'BEN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BEN"#) -}
d064049f2b356ff34a33dcacff61b9f6
  $tc'CAUS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2106057577093439068##
                   12599591628707342968##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'CAUS1) -}
13f26e51ea10287dab7597b5c9d35b7a
  $tc'CAUS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CAUS"#) -}
23ad36f588a669035f3b3e0f51d78179
  $tc'COM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2297130588824967157##
                   9653413054096136740##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'COM1) -}
a2af126417b6a1b980678b562b5c7320
  $tc'COM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'COM"#) -}
54c34a228f51cd3d4fdadbc5c5db0b3d
  $tc'COMIT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4657606884748138388##
                   18069802312685599013##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'COMIT1) -}
8b082f81a3406448a77ca904688a1692
  $tc'COMIT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'COMIT"#) -}
4779de111febd2b5d7aecbee6aabba2f
  $tc'COMP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6190879737838339555##
                   14010383311781733246##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'COMP1) -}
6f3e3590ff16abef71995a9beda9987c
  $tc'COMP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'COMP"#) -}
524df84887c34bf530c3fbfd5e2ddbd6
  $tc'COND :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   594896548470295144##
                   6929135797791763687##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'COND1) -}
a1473454c777df08e48fea0c368e82f5
  $tc'COND1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'COND"#) -}
8ec7ab0f69bb402b2ddb02e8943a1dcf
  $tc'CONT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15307329837260688573##
                   8354978100598094902##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'CONT1) -}
63297441237409f9b8d977ebdd5cbfb0
  $tc'CONT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CONT"#) -}
8c6fe86b49dcdcacc8ce6cf87403d62e
  $tc'Comp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11355912159467387951##
                   2133380916811459883##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Comp1) -}
b603cd7051df0c8ac9bd68c4c2622f15
  $tc'Comp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Comp"#) -}
d9a643f0353ab700ff3714bf31bc3a96
  $tc'DAT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14020640378191204613##
                   3344837257378738424##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DAT1) -}
1466a412acff547402123efce00045b2
  $tc'DAT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DAT"#) -}
7929dae8236bd65cd6f47beccadf4b71
  $tc'DEF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9223876766039332079##
                   3771001243766193820##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DEF1) -}
b9369e18115407381702ce2814d28c9b
  $tc'DEF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DEF"#) -}
31ed482f3e8f6f20008cfbae1c911b9c
  $tc'DEO :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2496357870434791356##
                   5263773829223539303##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DEO1) -}
2cab517a38289a2ff58fffcbadca0694
  $tc'DEO1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DEO"#) -}
0a05a94a3ea2bbe7b1009f4842d62e32
  $tc'DIR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8166186260442421878##
                   16005613913310926496##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DIR1) -}
f057e777eb16bd15e6c10ed78be8c14d
  $tc'DIR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DIR"#) -}
0d2578e47addb6e07a41c7c385ad2bfb
  $tc'DISTR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7947630210338916152##
                   17156054847412918380##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DISTR1) -}
e9a8b6fc6bec42a9a42d504794249cb4
  $tc'DISTR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DISTR"#) -}
8c240dd86563b29af0d1fe4cb993d75c
  $tc'DITRANS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8667196484931502836##
                   10207307250313483992##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DITRANS1) -}
4b37835d199c7479206e9d1d70543b9e
  $tc'DITRANS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DITRANS"#) -}
695275ca1a87722ce049836e419b1c6b
  $tc'DRT1 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8441656288923090806##
                   17330575452784755049##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DRT4) -}
6b87a8883be2b2b2ee3e782da47cb102
  $tc'DRT2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10609278677034233473##
                   17946591485533659494##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DRT5) -}
6b5c73497f3d68690d809c2c999e0397
  $tc'DRT4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DRT1"#) -}
0a51deff09943ed16cd386dcc2703611
  $tc'DRT5 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DRT2"#) -}
176732ae320ec218db09503e630d1759
  $tc'DTR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   803767281138430950##
                   10487019026766576326##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DTR1) -}
c71e0d7674e41ee11b7cc25359809cab
  $tc'DTR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DTR"#) -}
3d6e225532ec28211eb03bc9c42b25e7
  $tc'DU :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2209965826980730178##
                   12480469489849213561##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'DU1) -}
a1d217d1e4a75314852dbbecd15a2709
  $tc'DU1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DU"#) -}
3bec380d356032b5183b04dc0005d28d
  $tc'Det :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14725946822110592552##
                   5366601498220402981##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Det1) -}
47a739ce33c8bc0f70be36bb9fa03cb4
  $tc'Det1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Det"#) -}
e592123c49d8b5353794a313e9592d7d
  $tc'EPIS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10249238247617715137##
                   12841984971913669298##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'EPIS1) -}
57a47307e0e49c61a921fd5af97093da
  $tc'EPIS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EPIS"#) -}
78b96f19c9a2fc877000426844b22a2a
  $tc'EQU :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10731191054675440863##
                   12729160020720227549##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'EQU1) -}
a3424aad9fb89a2d436ba06586c7b686
  $tc'EQU1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EQU"#) -}
fde36808d54a2c46c0d931f71edddb15
  $tc'ERG :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3200854538888515725##
                   17131674631106442579##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ERG1) -}
b727bd0420655d39601e58b749178068
  $tc'ERG1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ERG"#) -}
f2f406f2d9c4b133ce55e6dfcbf73b2b
  $tc'ERG2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7057527009162846682##
                   16147314588923763876##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ERG3) -}
3c469fd07f7aab4bb26b26cda00b14df
  $tc'ERG3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ERG2"#) -}
726e0e91b60cc11325f9c8b5ef074128
  $tc'EXP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6510666999693514467##
                   12689645123755493179##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'EXP1) -}
ab10fc6481d102641079c29bd5cfc20b
  $tc'EXP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EXP"#) -}
22077cb2386ac7a9d0c3ef37b38f967a
  $tc'Express :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13684153907932694118##
                   17848459972784630298##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Express1) -}
ae4e7ddf68b2e1a3b454109acc9f21d8
  $tc'Express1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Express"#) -}
5fbf3ac51362ab6f22bd2321d97e0fea
  $tc'F :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17266846756568852914##
                   15785981495514912231##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'F1) -}
931fcbea25a786f11a1cc33990cd9ed2
  $tc'F1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'F"#) -}
46c9a1565020c90f4140f7696813d4f6
  $tc'FAM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7740796300713309758##
                   9830489466481333288##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'FAM1) -}
c0f918aec48cf4ba0e57495d211ad480
  $tc'FAM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FAM"#) -}
dc26814c2f0dfb42e8b8308c377e0a1b
  $tc'FIRST :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13506661615938114808##
                   18420276774481016976##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'FIRST1) -}
2694e6fbe19527772dca0dc57f35c0ff
  $tc'FIRST1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FIRST"#) -}
c91f7d3e867eb04cfa0ff945b9fcee0f
  $tc'FORM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11237390972233918839##
                   11800895427865903894##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'FORM1) -}
de04992e43bd6b2007ad9d38820a8d92
  $tc'FORM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FORM"#) -}
2c4507eb8637cf5fe8e6631b0b33c18a
  $tc'FSTEXCL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12797704318657513406##
                   5236604950144994356##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'FSTEXCL1) -}
d7318fa4893ee3378a2c3bf91ad2667e
  $tc'FSTEXCL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FSTEXCL"#) -}
9b681396d0ec8026b94ee514833a4d1c
  $tc'FSTINCL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13459835691243598891##
                   1655896882423225477##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'FSTINCL1) -}
9387c07fad8a62e704dcdff5debd7da0
  $tc'FSTINCL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FSTINCL"#) -}
1825bdd9d38ce74dcd5a67d9a6e74529
  $tc'FUT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14534640207907470513##
                   15930971624468570445##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'FUT1) -}
c14b90e5da845c4ca20a9ba8615a2ec0
  $tc'FUT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FUT"#) -}
13487af9d0aa15fba01fe9788e8d6f58
  $tc'FUTPER :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14678976692255586265##
                   13035156465511502505##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'FUTPER1) -}
9b009e61fac599254a91720fccfbd9f2
  $tc'FUTPER1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FUTPER"#) -}
ac7389afd546b20d509bb35c65c991e3
  $tc'GEN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10821495103303229932##
                   3869961842334563612##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'GEN1) -}
1841e5eaa9b6069f587daa71439a2005
  $tc'GEN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'GEN"#) -}
812bba939ccfb8b96ea2559b9213180c
  $tc'HAB :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5567361105809729199##
                   14958697295137210216##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'HAB1) -}
5d49285cbc04fd131503ca4921705632
  $tc'HAB1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HAB"#) -}
79485f0dec03fb1e559d97db1d2b62d8
  $tc'HSY :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12561419273208866935##
                   9619712473784653440##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'HSY1) -}
110f6468680299cdac40b92132219d25
  $tc'HSY1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HSY"#) -}
ded9343c6d00b47e3e31821812e42fa9
  $tc'HUM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3080668608430568248##
                   12750015935644884305##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'HUM1) -}
24f34f160dc07065f8ddea6fdabf39c9
  $tc'HUM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HUM"#) -}
15cc73b34f4c3a4e31fb90b68fbba0ec
  $tc'IDEN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13896587111099047077##
                   8580191576724316268##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'IDEN1) -}
d560a83adebdd82d8dbc945f9a7fa9b7
  $tc'IDEN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IDEN"#) -}
4c38b18013073a3d75ea56e3afa3b8ea
  $tc'IMP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10848671473273333972##
                   2556291472856079815##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'IMP1) -}
f96a15a5e93fd6d844282d1b1c3e58a6
  $tc'IMP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IMP"#) -}
0376d4da0859687b29c46573d2c9c3f5
  $tc'INAN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12147955897791440892##
                   12838388297984723714##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'INAN1) -}
0bfefe89d5aace3e96339b3eb12e8ce1
  $tc'INAN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'INAN"#) -}
897ee94a608d39ca842060ed15dcabf7
  $tc'IND :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8522102215638444189##
                   9956700916814520689##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'IND1) -}
6929a457ab815ee5dbdcb27b3f0e7fef
  $tc'IND1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IND"#) -}
520ecf98fc1e65f112be8d3e567d1e38
  $tc'INDF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9407941019743757740##
                   154305053051977446##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'INDF1) -}
3659a3478ea8e30793d2540c292904ac
  $tc'INDF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'INDF"#) -}
00225d97b3347be7d653f00ec6e5cfed
  $tc'INDIR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10183657746099065231##
                   11755788218570359618##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'INDIR1) -}
721885f46684c9c46938d7868dc821e1
  $tc'INDIR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'INDIR"#) -}
4ecd3087cc855933bf444f13d74adea3
  $tc'INFER :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5259976848599170271##
                   15343167495045849078##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'INFER1) -}
1e0e047c35cee8dd75129285ef41fb9c
  $tc'INFER1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'INFER"#) -}
95b7bfb85a0849bfc5b16df7a02d1f77
  $tc'INS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3987315581893815140##
                   3820646687871055609##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'INS1) -}
5714fba3989b5e5de2b6b3a8f19623b9
  $tc'INS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'INS"#) -}
c30978cb2d78a8290354f402b388cf6f
  $tc'INSCOMIT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1191323318238862180##
                   7849647325060900280##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'INSCOMIT1) -}
55b15718e6ccff11e3b955f725178d27
  $tc'INSCOMIT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'INSCOMIT"#) -}
55e8c5bc01ee25751e57a4ca533ade56
  $tc'INTR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6847112706913901221##
                   17868199109954280474##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'INTR1) -}
6761619286601db253da793493232faf
  $tc'INTR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'INTR"#) -}
bfbf9bd780432ded17b0d55051dfc22a
  $tc'IPFV :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5724806721988861211##
                   15481708781828318910##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'IPFV1) -}
3fce886f38d17b15ab8e786439ca6558
  $tc'IPFV1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IPFV"#) -}
e5125a4a5a66757a616bbd82f3ed7c06
  $tc'IRR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10402097198149616792##
                   16994075665698353866##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'IRR1) -}
e1c7648b3c5b70946dbd226c99f7628c
  $tc'IRR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'IRR"#) -}
d797f266e0dfb75b3f8356d48a0ca8d2
  $tc'Infl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1788962956574944890##
                   144782217960443780##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Infl1) -}
3608b1235868c5b25ff8f54875fcdf1c
  $tc'Infl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Infl"#) -}
7443c6088431458304fcd486ec22a128
  $tc'InflectionSystem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   301279612285496794##
                   9085389026498948255##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'InflectionSystem1) -}
2fea70348cae76936c472401edc73744
  $tc'InflectionSystem1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'InflectionSystem"#) -}
ec742a3640b94f95184a548b46dfab6f
  $tc'JUS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14312544297995918243##
                   703270494938535722##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'JUS1) -}
5899a1cec7e473226cda20ad023fb641
  $tc'JUS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'JUS"#) -}
040a2e8306cd2232ca1c8879573efed6
  $tc'LAT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6302957247948555557##
                   4363113605508493870##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'LAT1) -}
3613a3a9735254d1a2b53dc5efc5570f
  $tc'LAT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LAT"#) -}
aab61d87abc4d953bd651abd970e707a
  $tc'LOC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   759220437847696133##
                   9011592907150592890##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'LOC1) -}
babe1da3c9d55e1a0c13ede785554b57
  $tc'LOC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LOC"#) -}
06f265fd1313efd4c595e856c7cbacd1
  $tc'M :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4098292749397061608##
                   8287634685341148332##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'M1) -}
40df3e7d895b037b0cf5a88452a6bf56
  $tc'M1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'M"#) -}
8188b59bc181480ef8c6018f0eedeca0
  $tc'MIDDLE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1334341744111380650##
                   17538385188894125987##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'MIDDLE1) -}
9829c8822902fba6fdce7d8fed96a288
  $tc'MIDDLE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MIDDLE"#) -}
ca00ec82683c224cf1650ccf7f4a93c3
  $tc'MTR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5113869512238255095##
                   4298810556505713679##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'MTR1) -}
98a19f22e846c51b63029732458b37c8
  $tc'MTR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MTR"#) -}
5dbd51a7c85a55925c6bf13133c315dd
  $tc'MTRANS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   641412885904691183##
                   16718929975137360686##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'MTRANS1) -}
d0438287e45e42e2415a127446490fbf
  $tc'MTRANS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MTRANS"#) -}
d9cea4bc81c0737e48cddeb8cfe4facd
  $tc'Manifest :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13990215048961467654##
                   6361105859113209837##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Manifest1) -}
a6e0acba91dfa50c06f72acf577b1976
  $tc'Manifest1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Manifest"#) -}
b769f771f7285867679f931eed538a24
  $tc'ManifestSystem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2387844289600035543##
                   10924476779428435279##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ManifestSystem1) -}
b11acc6f406541233cf2e076e508c8ea
  $tc'ManifestSystem1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ManifestSystem"#) -}
6a194f245288ea6b5a22f612bd3e64a4
  $tc'N :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   281645360580064905##
                   3081305059285684539##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'N1) -}
2a7a9a82e4d55fb98661e5331ca700e1
  $tc'N1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'N"#) -}
97a59ce9cafeebe055f9eceb662c7599
  $tc'NEG :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14744273290878973206##
                   1470818714070461125##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NEG1) -}
8242a9f755ba57e52377a84779f137cc
  $tc'NEG1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NEG"#) -}
156e83846789558873be5b3342ea69ac
  $tc'NEU :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10573477452142920877##
                   16112012905677767002##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NEU1) -}
71c27db623096d57f2a41a708fadd00c
  $tc'NEU1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NEU"#) -}
c158849f82b03941a38cacfdbc521ead
  $tc'NHUM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3019972193076862535##
                   13703502678831367908##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NHUM1) -}
52a8fbf867f871d8d7ba83b0c2796017
  $tc'NHUM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NHUM"#) -}
9d509fbf98ed68940d2dd291b723a739
  $tc'NNPROG :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15936478420703997037##
                   1632609902128717348##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NNPROG1) -}
1765c0f4ef2656b14f1193e33b59d016
  $tc'NNPROG1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NNPROG"#) -}
54a77ff995b1c6365baca862aec684e6
  $tc'NOM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12548558741361570665##
                   6512909669015894053##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NOM1) -}
fa9415f0eb39f116962079f879d44054
  $tc'NOM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NOM"#) -}
760d0c757f830ff5daddfb9a939328a3
  $tc'NOM2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2624985581201555562##
                   4434733067533588413##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NOM3) -}
44165e773a67547464ff369facadbf92
  $tc'NOM3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NOM2"#) -}
7dcbc9b35cf32db913cfb36a5cfa458a
  $tc'NPROG :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3398444779650394080##
                   5809934288629960718##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NPROG1) -}
2b814ec1a08f15ab3aaae0b92ff59870
  $tc'NPROG1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NPROG"#) -}
a08c9c93b856e5a960399d66a81ddf19
  $tc'NSPEC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9806629085864791868##
                   18441713434476858537##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NSPEC1) -}
8fe2cb5294326cbc86faf365f1dafc26
  $tc'NSPEC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NSPEC"#) -}
5021aa9965d25fe8225ac10a54fbb420
  $tc'NTOP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17572722102371712618##
                   1056700781486468186##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NTOP1) -}
8380e52bb0b6ed663a761f03775d9f4a
  $tc'NTOP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NTOP"#) -}
c20e57bfce4220819976960d20d8f348
  $tc'NTRANS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1935656223093161241##
                   15236209482234563658##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NTRANS1) -}
2cb269a71422fb1b955ef591759d7d00
  $tc'NTRANS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NTRANS"#) -}
f72a50f079ce6b49e59770e7f69930ec
  $tc'NVIS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1612489637737902010##
                   15098096300997449369##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NVIS1) -}
61e19c824c526daed131789e15570958
  $tc'NVIS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NVIS"#) -}
57e00b270c5211ad9616aea83bce3be6
  $tc'NVOL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3519564241226800359##
                   775887049199003977##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NVOL1) -}
983a2ce4eaad03b527beb1525f49663f
  $tc'NVOL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NVOL"#) -}
26ad349ab5cba1b50bb7c3c23a4874d9
  $tc'NoExpress :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6363036663729356908##
                   4698163312990212127##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NoExpress1) -}
331fc2cd3a592b1c27827a931605a3eb
  $tc'NoExpress1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoExpress"#) -}
a82c1de55d7dc2cef96a3cc450900f7d
  $tc'NoManifest :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7338677780764981560##
                   9281097884813762711##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'NoManifest1) -}
4803e2edbfef31901f50a5c1c5444abb
  $tc'NoManifest1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoManifest"#) -}
9e561ec07e4ac281141a69b12bf10a7e
  $tc'Noun :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1909297883329224193##
                   4998000956230275511##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Noun1) -}
9ebc7ebcb2ca8aea6b28a0e22d3d1de1
  $tc'Noun1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Noun"#) -}
e8153d92860f7823426c1f6220d643d1
  $tc'OBJ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15347531755871512266##
                   7206649150429814015##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'OBJ1) -}
482177f64d1411761cf6f1b4b5ff9173
  $tc'OBJ1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OBJ"#) -}
e2df769436c43e40061c5600db79b71c
  $tc'OBL1 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8369794629591963819##
                   5707928848972988464##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'OBL7) -}
5cf135ac099a866f02602953e18ef507
  $tc'OBL10 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OBL4"#) -}
addf5a161a6bb01e9dfdbe77c0ce53dd
  $tc'OBL11 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OBL5"#) -}
889f5afadd63809e99d1a96b7f42735d
  $tc'OBL12 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OBL6"#) -}
a33ea3be2efabd24cea55757b6e9168d
  $tc'OBL2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9387598485193296414##
                   16693777738645781191##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'OBL8) -}
963b458791bfdd8586d0e3fc611459c4
  $tc'OBL3 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13464589847142155275##
                   8685743180015141895##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'OBL9) -}
4588cfa63f1ccf1ed89e471510c61b41
  $tc'OBL4 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9775364517106125102##
                   3081968358058551574##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'OBL10) -}
78942a593aab9444652600519ad4ec3f
  $tc'OBL5 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14361059082333707588##
                   10186720147743288836##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'OBL11) -}
421ca6a28e8390bc168d507a370579a8
  $tc'OBL6 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15879840362862248836##
                   14236154258934545930##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'OBL12) -}
652bac9489dc827a5e9573a49ea8c853
  $tc'OBL7 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OBL1"#) -}
d88362d3eb7710c955f202474b8d43c7
  $tc'OBL8 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OBL2"#) -}
d5dc8a8769822ca9b30379be3dfb42d2
  $tc'OBL9 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OBL3"#) -}
3ed2c02a2dadf065040221bbe750ccb2
  $tc'OPT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4698617654119706392##
                   1655735597223776098##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'OPT1) -}
f8f7409b1269b59b32dea73dee4c6953
  $tc'OPT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OPT"#) -}
60b191c969b715536a5dc1206e7a9701
  $tc'ORN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6286297477963811906##
                   16812094046160772051##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ORN1) -}
a1ec56c68ed681af36c3ae36c1cc5396
  $tc'ORN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ORN"#) -}
79db0e7599495a14aed1ade2bd7ab131
  $tc'Obj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7415036421237721270##
                   7140372488489834145##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Obj1) -}
16172c90c9cef4b57a2aaab5bfc01fec
  $tc'Obj1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Obj"#) -}
cf9e72289b2ad1ab9cb1469e04dacb56
  $tc'PA :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18160194162353156906##
                   9988435085779203983##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PA1) -}
3956a05e5ec2749d7620eb5e1bd98611
  $tc'PA1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PA"#) -}
f9c195d670ee4fe73f540a963fc2923d
  $tc'PART :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15865753014406741501##
                   11649849629746178849##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PART1) -}
acff75ba379804d30dd3650e8ee65aa2
  $tc'PART1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PART"#) -}
2607fa4a17146a6be2807ee299166d51
  $tc'PASSIVE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5390617703792057825##
                   9590924475213399239##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PASSIVE1) -}
6214caf99a26b5cdfe38cefc0a199d82
  $tc'PASSIVE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PASSIVE"#) -}
8c30ac21745c678447a97008e833ff36
  $tc'PEG :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3341402485219095102##
                   515887965157448500##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PEG1) -}
42701d2117369846b729f250d5878730
  $tc'PEG1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PEG"#) -}
6e6e100444f680856847101002666346
  $tc'PFUT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18436817949197163497##
                   16314584120919672287##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PFUT1) -}
fef4a3842301735ef973c2859eb068c3
  $tc'PFUT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PFUT"#) -}
23cff9ca73d97b2cb50dfe81bd8553e5
  $tc'PFV :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4112337508813354332##
                   4017301217845267944##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PFV1) -}
d29153d9faf7b102bb47c275ed5f8057
  $tc'PFV1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PFV"#) -}
153e4cb2aa26f9d4d53a42b30e923155
  $tc'PL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7309280364727124772##
                   12476826410628514803##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PL1) -}
5577633a40e7fc25f03f6461575175db
  $tc'PL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PL"#) -}
23749929c8a218178dc9c00581c614cd
  $tc'POSS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12391535499569700720##
                   4611529191590406341##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'POSS1) -}
5262af817e05fa70f5da6773432cd227
  $tc'POSS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'POSS"#) -}
2172edaa299e0bb9a34540aed1e3f890
  $tc'POST :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18124953492090979405##
                   8806411272727006205##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'POST1) -}
9e6f78f5ef818028951ff9323356e90b
  $tc'POST1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'POST"#) -}
9704a04c3da59d242de129a0d0854463
  $tc'POT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   505817853433842889##
                   8670038556185538436##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'POT1) -}
a7f8b00f6f468246e9f0ff9b99c6c25e
  $tc'POT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'POT"#) -}
938c849f860997cf936e8394da6bd6a2
  $tc'PPRS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17973376752972176098##
                   4592430598610942531##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PPRS1) -}
50f096a0230bb712b9e5b7892a1b0d34
  $tc'PPRS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PPRS"#) -}
86650a805bcad8290d4181ef73443357
  $tc'PPST :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10730922240017735159##
                   1742390481638780603##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PPST4) -}
04a8e4181393e6740e4babe9a43e6915
  $tc'PPST1 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1031830834528046139##
                   15993733367294807115##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PPST5) -}
b375a67249d87135fe8b830c25f87fae
  $tc'PPST2 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2246991689907094417##
                   8148277873088382588##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PPST6) -}
99e28b0fbae04b96a9523a345a0c10f0
  $tc'PPST3 :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12962899327600233686##
                   4739982625117161120##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PPST7) -}
7b782c3fefbc0530c9705135cc94f19c
  $tc'PPST4 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PPST"#) -}
1be52a6cfd05920de978898a09df8b72
  $tc'PPST5 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PPST1"#) -}
808296248d01a79b892e1a689ff20967
  $tc'PPST6 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PPST2"#) -}
835e6bf006bbea866776ba29dc76cd98
  $tc'PPST7 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PPST3"#) -}
8ffda761944fdf397e49a45dd58f3e46
  $tc'PREP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   727486651018672025##
                   16182757825666073601##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PREP1) -}
376c96ead5593b6bb482624b56d32b83
  $tc'PREP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PREP"#) -}
6b23dfa2df9103b0dda28166bc5f704d
  $tc'PRIM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3381565504849570613##
                   11492598746926173212##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PRIM1) -}
8a49e40e466c322bd0449c2eb8baca88
  $tc'PRIM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PRIM"#) -}
137c6354ce22e11484bd8adf04e50beb
  $tc'PROG :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11365503248992326705##
                   5974612502259727854##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PROG1) -}
b76cef1d97147d5ae74a91597fd877a6
  $tc'PROG1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PROG"#) -}
9b14f87f9fcface4f3d0488976c90701
  $tc'PRS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1326515573306908839##
                   15674824639585327998##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PRS1) -}
d46a244b5d178cb488ffb783b02e2101
  $tc'PRS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PRS"#) -}
513f1414f2c328b8b594799c1f8e8879
  $tc'PRSPER :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18220563340969377085##
                   9403696260321761097##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PRSPER1) -}
b29920e192982c03069c357bbfdf2ffe
  $tc'PRSPER1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PRSPER"#) -}
cb7291bddc39ca0fa55d640f60dbaf1e
  $tc'PST :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7300452369570664326##
                   11743633980941366702##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PST1) -}
2bc49e03b858842208d8bb807750b17f
  $tc'PST1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PST"#) -}
bc70b2b1158d0a39514e2897c8cb0264
  $tc'PSTPER :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3858377616239289991##
                   9312463453811128868##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'PSTPER1) -}
d667953a780c67123146213bde280f96
  $tc'PSTPER1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PSTPER"#) -}
31945027ced4efebfa3fc4a0ef7969f6
  $tc'Particle :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4103802112410888025##
                   9809956980357794622##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Particle1) -}
db6d6a5e21e0359b48b6bec34587c284
  $tc'Particle1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Particle"#) -}
8179252a598800bea0e12e311217c2de
  $tc'Prefix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2833033110783363059##
                   3388495299152096932##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Prefix1) -}
5454318dcae7c32a0cd3348feb8cc8dc
  $tc'Prefix1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Prefix"#) -}
392431293e5c26340dbbfa2abe34ebea
  $tc'Pron :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10317795093064486176##
                   5480112765884230911##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Pron1) -}
11282875879b5bda3359c6b565fca2d9
  $tc'Pron1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pron"#) -}
7d2ae41e4338e47e0a6da01f621ff1de
  $tc'QUO :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7961761105756918827##
                   18246372403813652623##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'QUO1) -}
f07d0549d3f99b8db5a6b4b57a2507c8
  $tc'QUO1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'QUO"#) -}
b850e09afd13f7c373592e4eb4c80004
  $tc'REP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13202394380858481631##
                   9683667278353199485##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'REP1) -}
0b67ac5fc57397ab9ce4456dd80559ab
  $tc'REP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'REP"#) -}
40893127f86665256059856496b43714
  $tc'SBJV :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5803043145513095585##
                   17281634837129434941##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'SBJV1) -}
c6693cc7f72272997c1d721478219597
  $tc'SBJV1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SBJV"#) -}
202cc0cb5029770c3c02dac0ff372efa
  $tc'SEC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11147046008693309442##
                   4412121351517892452##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'SEC1) -}
ef55d3d407b3ddbc92c9deb498607719
  $tc'SEC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SEC"#) -}
df8b5663b1bf4ea5ac86afb32c8c760d
  $tc'SECOND :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13131431078353413086##
                   16328107308808566920##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'SECOND1) -}
36353dd07484f1773ddae013986b0f32
  $tc'SECOND1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SECOND"#) -}
58a54b00c1b17a215c56066d896531a6
  $tc'SG :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6991530495800026787##
                   10654555114776576904##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'SG1) -}
cecb02cac259497e844e3359edd0d3eb
  $tc'SG1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SG"#) -}
8c190942e2073435457d25cbde5db13d
  $tc'SPEC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15013735366271915851##
                   7045664231118530241##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'SPEC1) -}
cc8d102fcc7350c352a7694ca783e4f4
  $tc'SPEC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SPEC"#) -}
77ecad6be30612aaf7e8055b458552b5
  $tc'Subj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1494449320177793350##
                   9602569977957058671##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Subj1) -}
1a6c4be01096bfc015b926f35f373f76
  $tc'Subj1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Subj"#) -}
b282ea2b6a46f817c871d621b705d343
  $tc'Suffix :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1342698264446690872##
                   6358971879376335835##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Suffix1) -}
16175a3261f1919caad5c1b988720c24
  $tc'Suffix1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Suffix"#) -}
5a8adb3ab1d7fa73751b02cb4647411b
  $tc'THIRD :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15987411599829652701##
                   2425431887418796996##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'THIRD1) -}
f449c96d16398c4440f9385e55c57539
  $tc'THIRD1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'THIRD"#) -}
94d6c6d56e70b02316c57405e5c9cfa9
  $tc'THRDOBV :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10628518376543249299##
                   4745022671257653677##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'THRDOBV1) -}
75e964a2634587b6f5f19c14bb178de0
  $tc'THRDOBV1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'THRDOBV"#) -}
6df0c0a95767e2358cf0f369352e7f4f
  $tc'THRDPROX :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10236720917549497157##
                   17932805587977039723##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'THRDPROX1) -}
8f9f7c6a3276fd18941410b9feeb2563
  $tc'THRDPROX1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'THRDPROX"#) -}
5da865a8f53c1cefd013238e7c4e0fe0
  $tc'TOP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3200455001271564302##
                   6173369348726802327##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'TOP1) -}
3d0ce4f8bb9b5e3c104b66006ccc6380
  $tc'TOP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TOP"#) -}
bb521fcf12e23379fd802e02f01ee7aa
  $tc'TR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2149759888319058288##
                   5475391965338324263##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'TR1) -}
db9f04110ad305a3afc87fe2f2fc6f02
  $tc'TR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TR"#) -}
567d45839a8cd43bea0681973cb5e88e
  $tc'TRANS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13735317739886466838##
                   12305763227195534749##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'TRANS1) -}
d24925b0fcc071954dd21da53f951301
  $tc'TRANS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TRANS"#) -}
27a46c5f567912711daebe8a8fb82f98
  $tc'TRI :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8781698895259876331##
                   10541865046919216965##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'TRI1) -}
4ea574c99eec362525da594e7af3b174
  $tc'TRI1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TRI"#) -}
68805e34be7ef962ac9a52a8d78f25f0
  $tc'UANI :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15996999698681126959##
                   18273101638453982618##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UANI1) -}
0bd96d5b80600b39ffd61cca32dd1562
  $tc'UANI1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UANI"#) -}
6770efb9e87283132d238f3d4f39fd0c
  $tc'UASP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3398947329510693956##
                   1220169155684102948##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UASP1) -}
9a02c3925ab17d0da717baaf98dad3cd
  $tc'UASP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UASP"#) -}
fdf803c82a58434832cff1fc6f0f21ea
  $tc'UCAS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7857562622503113814##
                   5080383970291272113##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UCAS1) -}
be7a6f096c866cbfeff13b781870523a
  $tc'UCAS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UCAS"#) -}
738e17da7af09bf284cf9df9aa888fa0
  $tc'UDEF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1625314356575100771##
                   16771334406736434009##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UDEF1) -}
f117d1693b6da89ebd36aecc05a4ca5d
  $tc'UDEF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UDEF"#) -}
606681e0fb9c142dd732d6b094e492a8
  $tc'UEVI :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5626496073740515355##
                   1591276990627254614##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UEVI1) -}
e289a3b63213ae2bf5c6907cc61bb751
  $tc'UEVI1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UEVI"#) -}
09e152c80efe73f2699eef26a257bc2c
  $tc'UGEN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6934087176975282657##
                   11000807515649597273##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UGEN1) -}
afd1231205ec976dc2e775d25365e09e
  $tc'UGEN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UGEN"#) -}
bb97e5b2db2515ebcd29974d95f561f6
  $tc'UHON :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11843547918260583400##
                   17146551294091473456##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UHON1) -}
2979357cc6abd8b39ad6e0a8b1c9baed
  $tc'UHON1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UHON"#) -}
4c5ba1b4dc7308739e8af87e46192bb6
  $tc'UMOO :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5054309756190235346##
                   12000776114388975941##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UMOO1) -}
af0b51d1c4c253f343f399c7bc458c2a
  $tc'UMOO1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UMOO"#) -}
79444fc0176b53aa569f579d4c8793ea
  $tc'UNUM :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11649473181502164635##
                   10788813429338439709##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UNUM1) -}
129c5138c47b77819a9d642ac477d5cd
  $tc'UNUM1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UNUM"#) -}
05da39be049811169d72e819059158dd
  $tc'UPER :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12318369142592354237##
                   1252834919823429720##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UPER1) -}
1e944d90272c3d90b2a0d2558cdaa047
  $tc'UPER1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UPER"#) -}
9111e9b09330f1bbb9bb7bf1579e2b38
  $tc'UPOL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8950733198018503154##
                   15323612902910738187##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UPOL1) -}
99a31d9911f2f8cff1a8c995fb8608bd
  $tc'UPOL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UPOL"#) -}
bc0bf1a38b9c0e1855555b7976ae245f
  $tc'USPE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13178419261632655630##
                   6924656032889726801##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'USPE1) -}
e812c2682c647a70483b5e6c10f19183
  $tc'USPE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'USPE"#) -}
d27e269f4c089bf1ef641a4c207ae17d
  $tc'UTEN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13202177778302718638##
                   15095682574515394673##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UTEN1) -}
1986e2eafcd1c323c2890894915d9a10
  $tc'UTEN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UTEN"#) -}
d4f6366b310e3f679fb68f9b1d725aa4
  $tc'UTOP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18429411525248177984##
                   5180565537710490261##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UTOP1) -}
d61c185fd7fb046856e777b07c8e147e
  $tc'UTOP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UTOP"#) -}
34bbf0cff9e397c31be38a4461dfea1c
  $tc'UTRA :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15246916105440558397##
                   2999326452052328400##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UTRA1) -}
590dc586a733ba7cb9fc3c731dcd0f7c
  $tc'UTRA1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UTRA"#) -}
9f235a47414c4c7125324bddf4d4178b
  $tc'UVOI :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14162157893967862591##
                   2666753867073984332##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UVOI1) -}
d758079d98e88153bd645c2aad21062d
  $tc'UVOI1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UVOI"#) -}
ee918898ef64d41c0be9807d12f10d4d
  $tc'UVOL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9959185260462436814##
                   15291705716941992746##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'UVOL1) -}
d9956f720647cb0d48df56c16384cb4c
  $tc'UVOL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UVOL"#) -}
c76edd09f07956942657ce542e7c7317
  $tc'VIS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1901662061620599130##
                   1627728801715227937##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'VIS1) -}
fe326133a1396b24fe09237844969c1f
  $tc'VIS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'VIS"#) -}
38ef493c4615df54af43e6669fc81847
  $tc'VOC :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15358595108861784866##
                   5169414342840275911##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'VOC1) -}
940a36f6c9cad41fc58630b147e2fca5
  $tc'VOC1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'VOC"#) -}
371b58eeae45cd79279f5a3d060807f9
  $tc'VOL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5300575475472343470##
                   4217774614843635242##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'VOL1) -}
524ccf62f98a935d4a4f93fc1bfa9cc0
  $tc'VOL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'VOL"#) -}
68fe8895c5b275962cd3a330e27161df
  $tc'Verb :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2111726400018630544##
                   4529258178391576732##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'Verb1) -}
800e3ce1939cf036a987d6919eee2bba
  $tc'Verb1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Verb"#) -}
0d583edbe9438b737f96e0693dfd0cba
  $tc'ZO :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6080522447576373547##
                   2971300321826815486##
                   Data.Inflection.$trModule
                   Data.Inflection.$tc'ZO1) -}
60ebefa6fcf28b65e465a112f08e358c
  $tc'ZO1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ZO"#) -}
4ab2c4150871c2d162be726e442ec692
  $tcAnimacy :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11815524169924804098##
                   17439754580884356079##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcAnimacy1) -}
3d5ced8dd19a0336cdf8aded211c90be
  $tcAnimacy1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Animacy"#) -}
7b11ee3bf08b632cb619cf2cf13f79a8
  $tcAspect :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2981377270785887688##
                   16377108425141203891##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcAspect1) -}
6835a2a187db861e457032363ff1a5d7
  $tcAspect1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Aspect"#) -}
5e72476ecf5811e3f3986cbe4228c0e6
  $tcCase :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15424488793384067844##
                   15599058610706905427##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcCase1) -}
713b60181cd90ad1add7ff3ebaf3b693
  $tcCase1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Case"#) -}
84950760b5de9df2966456f1712c458b
  $tcDefiniteness :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14253193197055857566##
                   10324881246477562533##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcDefiniteness1) -}
7a852de967ad9f7e50959760cf74657a
  $tcDefiniteness1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Definiteness"#) -}
40ecb0ea3f4acd1c155266f7a35b58cc
  $tcEvidentiality :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1343843637542204426##
                   11751547748214993818##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcEvidentiality1) -}
e9df6ea2f8eff46a617077e0a5d3fee7
  $tcEvidentiality1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Evidentiality"#) -}
318f3351162dfe9a61f52aba8b1b3b6d
  $tcExpress :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9599966612186175897##
                   5949408017223284668##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcExpress1) -}
be50c3487b3e83dc0cf811b4e9bcab1c
  $tcExpress1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Express"#) -}
50448a4fbe082b84509e5f8e2f490292
  $tcGender :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7928539952409917525##
                   15673104105765119160##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcGender1) -}
aebe1e46d02daeec5473ba809c6715cb
  $tcGender1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Gender"#) -}
6498607d2f0805bb40eb48285a3d4ae6
  $tcHonorific :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2362192511653203162##
                   1321563457544205956##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcHonorific1) -}
cee77da8461b188bd585b4495de22110
  $tcHonorific1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Honorific"#) -}
09054d02fc0387c8827850a2e16f8427
  $tcInflectionSystem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15814785740621451850##
                   17770737564749785637##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcInflectionSystem1) -}
c79e24a1af226105ee93fcba8cfecec6
  $tcInflectionSystem1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "InflectionSystem"#) -}
b9754844990d9a7d557880383c7c8011
  $tcLexCat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16727493138270794351##
                   14860597270130870714##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcLexCat1) -}
e577060336b033326b711437ad29af7d
  $tcLexCat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "LexCat"#) -}
2d8645215b43dc2929f5f6c5338a735d
  $tcManifest :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9527310258711752881##
                   2772885473735696711##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcManifest1) -}
52103643681f9d93c332f8ae53e7ec50
  $tcManifest1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Manifest"#) -}
3dc413a26d1db308271f39e8abc38bd0
  $tcManifestSystem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8911090096644137062##
                   7509172319020111812##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcManifestSystem1) -}
fa7286516008dc7d6b71e96746b30035
  $tcManifestSystem1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ManifestSystem"#) -}
3c08074ebf79baa29b2b285fbb1d3f90
  $tcManifestType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13285907764369383717##
                   4990379389068853593##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcManifestType1) -}
1b78f751e298f8b39400cdc5e07bef6a
  $tcManifestType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ManifestType"#) -}
d19147d0a3ce85a429e983a5e41f13be
  $tcMood :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5982542922991620338##
                   18165351092029536251##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcMood1) -}
6b2765044f268e850d68084e8ff5da4e
  $tcMood1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Mood"#) -}
92c64c9fafb0ed9f7b01a5b2865d1b3f
  $tcNumber :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16074052451898021273##
                   3436538122157391152##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcNumber1) -}
902edc5e746d38fe87dac7baeca71848
  $tcNumber1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Number"#) -}
c5606a789e094b9bd90fa862a200d2bc
  $tcPerson :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14291798496159805161##
                   4556272167446169680##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcPerson1) -}
647af6cb178b0466ecf52d5366e26c8e
  $tcPerson1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Person"#) -}
44ac1c4164cf70625a7fdb66515f28c6
  $tcPolarity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7039168585649639710##
                   8139775840902916014##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcPolarity1) -}
2e3cf06c3f2bb238dfef397cee36f61c
  $tcPolarity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Polarity"#) -}
d3d2812c2cf214caed5b004ec175b9fc
  $tcSpecificity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   360369374982933834##
                   6386830308789054915##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcSpecificity1) -}
7e639946a32c811181f6d8e2b04479d0
  $tcSpecificity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Specificity"#) -}
53a1b70c7dd17329ce426eeb70b24bbe
  $tcTense :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15927779956203849172##
                   8982430060378051709##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcTense1) -}
26e33aae47646135c192f75c428995d7
  $tcTense1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tense"#) -}
22de594485d4cc310753c4c588e40fb6
  $tcTopic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13835942299669485272##
                   14741625116809929930##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcTopic1) -}
82134d1823f5842a32e9f6dc350747ce
  $tcTopic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Topic"#) -}
db5c06ea53b1e98ad109519dc0dcff0c
  $tcTransitivity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5148007786482315975##
                   4330320434792559670##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcTransitivity1) -}
165130e7795bdedcb2a256d7e564619b
  $tcTransitivity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Transitivity"#) -}
417a7b39a1d4e795ddd96a36e8c80ac1
  $tcVoice :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14364997956133369966##
                   8997009415513471986##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcVoice1) -}
ebed193593934d83813225681bbcd973
  $tcVoice1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Voice"#) -}
a74c4ea917a62254c1a7e1911215d4b5
  $tcVolition :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5559711379551345975##
                   5094426685734985081##
                   Data.Inflection.$trModule
                   Data.Inflection.$tcVolition1) -}
b8aa940401f6e390152f9f96fb6c361b
  $tcVolition1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Volition"#) -}
d03f47e779caf73f363e12f29911cf7f
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Inflection.$trModule2
                   Data.Inflection.$trModule1) -}
b9fa77fb77b4e271643f4c6d4ee990c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Data.Inflection"#) -}
86a04445d8b3ae8d6a40164d2a8cc94f
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "con-lang-gen-0.0.0.1-JpecSLrjfNmG1CUMEdSr39"#) -}
450fb58db3c56866dc9e78cb35fb4dc9
  $w$c== ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c,
     GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f,
     GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i,
     GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l,
     GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o,
     GHC.Classes.Eq p, GHC.Classes.Eq q) =>
    a
    -> b
    -> c
    -> d
    -> e
    -> f
    -> g
    -> h
    -> i
    -> j
    -> k
    -> l
    -> m
    -> n
    -> o
    -> p
    -> q
    -> a
    -> b
    -> c
    -> d
    -> e
    -> f
    -> g
    -> h
    -> i
    -> j
    -> k
    -> l
    -> m
    -> n
    -> o
    -> p
    -> q
    -> GHC.Types.Bool
  {- Arity: 51, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
2cf2d6140a844fc86dd0dc40043f1574
  $w$c==1 ::
    Data.Inflection.Manifest [Data.Inflection.Gender]
    -> Data.Inflection.Manifest [Data.Inflection.Animacy]
    -> Data.Inflection.Manifest [Data.Inflection.Case]
    -> Data.Inflection.Manifest [Data.Inflection.Number]
    -> Data.Inflection.Manifest [Data.Inflection.Definiteness]
    -> Data.Inflection.Manifest [Data.Inflection.Specificity]
    -> Data.Inflection.Manifest [Data.Inflection.Topic]
    -> Data.Inflection.Manifest [Data.Inflection.Person]
    -> Data.Inflection.Manifest [Data.Inflection.Honorific]
    -> Data.Inflection.Manifest [Data.Inflection.Polarity]
    -> Data.Inflection.Manifest [Data.Inflection.Tense]
    -> Data.Inflection.Manifest [Data.Inflection.Aspect]
    -> Data.Inflection.Manifest [Data.Inflection.Mood]
    -> Data.Inflection.Manifest [Data.Inflection.Voice]
    -> Data.Inflection.Manifest [Data.Inflection.Evidentiality]
    -> Data.Inflection.Manifest [Data.Inflection.Transitivity]
    -> Data.Inflection.Manifest [Data.Inflection.Volition]
    -> Data.Inflection.Manifest [Data.Inflection.Gender]
    -> Data.Inflection.Manifest [Data.Inflection.Animacy]
    -> Data.Inflection.Manifest [Data.Inflection.Case]
    -> Data.Inflection.Manifest [Data.Inflection.Number]
    -> Data.Inflection.Manifest [Data.Inflection.Definiteness]
    -> Data.Inflection.Manifest [Data.Inflection.Specificity]
    -> Data.Inflection.Manifest [Data.Inflection.Topic]
    -> Data.Inflection.Manifest [Data.Inflection.Person]
    -> Data.Inflection.Manifest [Data.Inflection.Honorific]
    -> Data.Inflection.Manifest [Data.Inflection.Polarity]
    -> Data.Inflection.Manifest [Data.Inflection.Tense]
    -> Data.Inflection.Manifest [Data.Inflection.Aspect]
    -> Data.Inflection.Manifest [Data.Inflection.Mood]
    -> Data.Inflection.Manifest [Data.Inflection.Voice]
    -> Data.Inflection.Manifest [Data.Inflection.Evidentiality]
    -> Data.Inflection.Manifest [Data.Inflection.Transitivity]
    -> Data.Inflection.Manifest [Data.Inflection.Volition]
    -> GHC.Types.Bool
  {- Arity: 34, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
cffe8cd8489fa3760b78953feb7e5a3c
  $w$c==2 ::
    Data.Inflection.LexCat
    -> Data.Inflection.ManifestType
    -> [(Data.Phoneme.Morpheme,
         (Data.Inflection.Express Data.Inflection.Gender,
          Data.Inflection.Express Data.Inflection.Animacy,
          Data.Inflection.Express Data.Inflection.Case,
          Data.Inflection.Express Data.Inflection.Number,
          Data.Inflection.Express Data.Inflection.Definiteness,
          Data.Inflection.Express Data.Inflection.Specificity,
          Data.Inflection.Express Data.Inflection.Topic,
          Data.Inflection.Express Data.Inflection.Person,
          Data.Inflection.Express Data.Inflection.Honorific,
          Data.Inflection.Express Data.Inflection.Polarity,
          Data.Inflection.Express Data.Inflection.Tense,
          Data.Inflection.Express Data.Inflection.Aspect,
          Data.Inflection.Express Data.Inflection.Mood,
          Data.Inflection.Express Data.Inflection.Voice,
          Data.Inflection.Express Data.Inflection.Evidentiality,
          Data.Inflection.Express Data.Inflection.Transitivity,
          Data.Inflection.Express Data.Inflection.Volition))]
    -> Data.Inflection.LexCat
    -> Data.Inflection.ManifestType
    -> [(Data.Phoneme.Morpheme,
         (Data.Inflection.Express Data.Inflection.Gender,
          Data.Inflection.Express Data.Inflection.Animacy,
          Data.Inflection.Express Data.Inflection.Case,
          Data.Inflection.Express Data.Inflection.Number,
          Data.Inflection.Express Data.Inflection.Definiteness,
          Data.Inflection.Express Data.Inflection.Specificity,
          Data.Inflection.Express Data.Inflection.Topic,
          Data.Inflection.Express Data.Inflection.Person,
          Data.Inflection.Express Data.Inflection.Honorific,
          Data.Inflection.Express Data.Inflection.Polarity,
          Data.Inflection.Express Data.Inflection.Tense,
          Data.Inflection.Express Data.Inflection.Aspect,
          Data.Inflection.Express Data.Inflection.Mood,
          Data.Inflection.Express Data.Inflection.Voice,
          Data.Inflection.Express Data.Inflection.Evidentiality,
          Data.Inflection.Express Data.Inflection.Transitivity,
          Data.Inflection.Express Data.Inflection.Volition))]
    -> GHC.Types.Bool
  {- Arity: 6,
     Strictness: <S,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: Data.Inflection.LexCat)
                   (ww1 :: Data.Inflection.ManifestType)
                   (ww2 :: [(Data.Phoneme.Morpheme,
                             (Data.Inflection.Express Data.Inflection.Gender,
                              Data.Inflection.Express Data.Inflection.Animacy,
                              Data.Inflection.Express Data.Inflection.Case,
                              Data.Inflection.Express Data.Inflection.Number,
                              Data.Inflection.Express Data.Inflection.Definiteness,
                              Data.Inflection.Express Data.Inflection.Specificity,
                              Data.Inflection.Express Data.Inflection.Topic,
                              Data.Inflection.Express Data.Inflection.Person,
                              Data.Inflection.Express Data.Inflection.Honorific,
                              Data.Inflection.Express Data.Inflection.Polarity,
                              Data.Inflection.Express Data.Inflection.Tense,
                              Data.Inflection.Express Data.Inflection.Aspect,
                              Data.Inflection.Express Data.Inflection.Mood,
                              Data.Inflection.Express Data.Inflection.Voice,
                              Data.Inflection.Express Data.Inflection.Evidentiality,
                              Data.Inflection.Express Data.Inflection.Transitivity,
                              Data.Inflection.Express Data.Inflection.Volition))])
                   (ww3 :: Data.Inflection.LexCat)
                   (ww4 :: Data.Inflection.ManifestType)
                   (ww5 :: [(Data.Phoneme.Morpheme,
                             (Data.Inflection.Express Data.Inflection.Gender,
                              Data.Inflection.Express Data.Inflection.Animacy,
                              Data.Inflection.Express Data.Inflection.Case,
                              Data.Inflection.Express Data.Inflection.Number,
                              Data.Inflection.Express Data.Inflection.Definiteness,
                              Data.Inflection.Express Data.Inflection.Specificity,
                              Data.Inflection.Express Data.Inflection.Topic,
                              Data.Inflection.Express Data.Inflection.Person,
                              Data.Inflection.Express Data.Inflection.Honorific,
                              Data.Inflection.Express Data.Inflection.Polarity,
                              Data.Inflection.Express Data.Inflection.Tense,
                              Data.Inflection.Express Data.Inflection.Aspect,
                              Data.Inflection.Express Data.Inflection.Mood,
                              Data.Inflection.Express Data.Inflection.Voice,
                              Data.Inflection.Express Data.Inflection.Evidentiality,
                              Data.Inflection.Express Data.Inflection.Transitivity,
                              Data.Inflection.Express Data.Inflection.Volition))]) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Data.Inflection.LexCat ww)
                           (GHC.Prim.dataToTag# @ Data.Inflection.LexCat ww3)) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 {
                        Data.Inflection.Particle
                        -> case ww4 of wild2 {
                             DEFAULT -> GHC.Types.False
                             Data.Inflection.Particle
                             -> GHC.Classes.$fEq[]_$c==
                                  @ (Data.Phoneme.Morpheme,
                                     (Data.Inflection.Express Data.Inflection.Gender,
                                      Data.Inflection.Express Data.Inflection.Animacy,
                                      Data.Inflection.Express Data.Inflection.Case,
                                      Data.Inflection.Express Data.Inflection.Number,
                                      Data.Inflection.Express Data.Inflection.Definiteness,
                                      Data.Inflection.Express Data.Inflection.Specificity,
                                      Data.Inflection.Express Data.Inflection.Topic,
                                      Data.Inflection.Express Data.Inflection.Person,
                                      Data.Inflection.Express Data.Inflection.Honorific,
                                      Data.Inflection.Express Data.Inflection.Polarity,
                                      Data.Inflection.Express Data.Inflection.Tense,
                                      Data.Inflection.Express Data.Inflection.Aspect,
                                      Data.Inflection.Express Data.Inflection.Mood,
                                      Data.Inflection.Express Data.Inflection.Voice,
                                      Data.Inflection.Express Data.Inflection.Evidentiality,
                                      Data.Inflection.Express Data.Inflection.Transitivity,
                                      Data.Inflection.Express Data.Inflection.Volition))
                                  Data.Inflection.$fEqManifestSystem_$s$fEq(,)
                                  ww2
                                  ww5 }
                        Data.Inflection.Prefix
                        -> case ww4 of wild2 {
                             DEFAULT -> GHC.Types.False
                             Data.Inflection.Prefix
                             -> GHC.Classes.$fEq[]_$c==
                                  @ (Data.Phoneme.Morpheme,
                                     (Data.Inflection.Express Data.Inflection.Gender,
                                      Data.Inflection.Express Data.Inflection.Animacy,
                                      Data.Inflection.Express Data.Inflection.Case,
                                      Data.Inflection.Express Data.Inflection.Number,
                                      Data.Inflection.Express Data.Inflection.Definiteness,
                                      Data.Inflection.Express Data.Inflection.Specificity,
                                      Data.Inflection.Express Data.Inflection.Topic,
                                      Data.Inflection.Express Data.Inflection.Person,
                                      Data.Inflection.Express Data.Inflection.Honorific,
                                      Data.Inflection.Express Data.Inflection.Polarity,
                                      Data.Inflection.Express Data.Inflection.Tense,
                                      Data.Inflection.Express Data.Inflection.Aspect,
                                      Data.Inflection.Express Data.Inflection.Mood,
                                      Data.Inflection.Express Data.Inflection.Voice,
                                      Data.Inflection.Express Data.Inflection.Evidentiality,
                                      Data.Inflection.Express Data.Inflection.Transitivity,
                                      Data.Inflection.Express Data.Inflection.Volition))
                                  Data.Inflection.$fEqManifestSystem_$s$fEq(,)
                                  ww2
                                  ww5 }
                        Data.Inflection.Suffix
                        -> case ww4 of wild2 {
                             DEFAULT -> GHC.Types.False
                             Data.Inflection.Suffix
                             -> GHC.Classes.$fEq[]_$c==
                                  @ (Data.Phoneme.Morpheme,
                                     (Data.Inflection.Express Data.Inflection.Gender,
                                      Data.Inflection.Express Data.Inflection.Animacy,
                                      Data.Inflection.Express Data.Inflection.Case,
                                      Data.Inflection.Express Data.Inflection.Number,
                                      Data.Inflection.Express Data.Inflection.Definiteness,
                                      Data.Inflection.Express Data.Inflection.Specificity,
                                      Data.Inflection.Express Data.Inflection.Topic,
                                      Data.Inflection.Express Data.Inflection.Person,
                                      Data.Inflection.Express Data.Inflection.Honorific,
                                      Data.Inflection.Express Data.Inflection.Polarity,
                                      Data.Inflection.Express Data.Inflection.Tense,
                                      Data.Inflection.Express Data.Inflection.Aspect,
                                      Data.Inflection.Express Data.Inflection.Mood,
                                      Data.Inflection.Express Data.Inflection.Voice,
                                      Data.Inflection.Express Data.Inflection.Evidentiality,
                                      Data.Inflection.Express Data.Inflection.Transitivity,
                                      Data.Inflection.Express Data.Inflection.Volition))
                                  Data.Inflection.$fEqManifestSystem_$s$fEq(,)
                                  ww2
                                  ww5 } } }) -}
4d85e0faa8b64608c6b72704c2fa6a55
  $w$creadPrec ::
    GHC.Prim.Int#
    -> forall b.
       (Data.Inflection.InflectionSystem
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0] -}
c2d5044736165ec84a37fdd69e97ae03
  $w$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g,
     GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k,
     GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n, GHC.Show.Show o,
     GHC.Show.Show p, GHC.Show.Show q) =>
    a
    -> b
    -> c
    -> d
    -> e
    -> f
    -> g
    -> h
    -> i
    -> j
    -> k
    -> l
    -> m
    -> n
    -> o
    -> p
    -> q
    -> GHC.Show.ShowS
  {- Arity: 34,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
1f555085a72acd0be7c2a6de830d5d03
  $w$cshowsPrec1 ::
    Data.Inflection.Animacy -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Animacy)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UANI
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAnimacy27 w1
                   Data.Inflection.AN
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAnimacy24 w1
                   Data.Inflection.HUM
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAnimacy21 w1
                   Data.Inflection.NHUM
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAnimacy18 w1
                   Data.Inflection.ZO
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAnimacy15 w1
                   Data.Inflection.INAN
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadAnimacy12
                        w1 }) -}
66acf52fe96ad50a10594fa2d12d699d
  $w$cshowsPrec10 ::
    Data.Inflection.Tense -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
72dcb6eb4442b59226b0ba8f6714f13e
  $w$cshowsPrec11 ::
    Data.Inflection.Mood -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Mood)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UMOO
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest258
                        w1
                   Data.Inflection.IND
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest255
                        w1
                   Data.Inflection.IRR
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest252
                        w1
                   Data.Inflection.DEO
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest249
                        w1
                   Data.Inflection.IMP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest246
                        w1
                   Data.Inflection.JUS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest243
                        w1
                   Data.Inflection.OPT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest240
                        w1
                   Data.Inflection.EPIS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest237
                        w1
                   Data.Inflection.SBJV
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest234
                        w1
                   Data.Inflection.POT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest231
                        w1
                   Data.Inflection.COND
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest228
                        w1 }) -}
82e4499831c335865b73c47901c341b5
  $w$cshowsPrec12 ::
    Data.Inflection.Voice -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Voice)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UVOI
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest278
                        w1
                   Data.Inflection.ACTIVE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest275
                        w1
                   Data.Inflection.MIDDLE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest272
                        w1
                   Data.Inflection.PASSIVE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest269
                        w1 }) -}
7302fbe55b71c04bf146a8a39e883cde
  $w$cshowsPrec13 ::
    Data.Inflection.Transitivity -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Transitivity)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UTRA
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest304
                        w1
                   Data.Inflection.NTRANS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest301
                        w1
                   Data.Inflection.TRANS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest298
                        w1
                   Data.Inflection.MTRANS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest295
                        w1
                   Data.Inflection.DITRANS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest292
                        w1 }) -}
32375bf942f142cd08807b4d8f9ef704
  $w$cshowsPrec14 ::
    GHC.Prim.Int#
    -> Data.Inflection.Manifest [Data.Inflection.Gender]
    -> Data.Inflection.Manifest [Data.Inflection.Animacy]
    -> Data.Inflection.Manifest [Data.Inflection.Case]
    -> Data.Inflection.Manifest [Data.Inflection.Number]
    -> Data.Inflection.Manifest [Data.Inflection.Definiteness]
    -> Data.Inflection.Manifest [Data.Inflection.Specificity]
    -> Data.Inflection.Manifest [Data.Inflection.Topic]
    -> Data.Inflection.Manifest [Data.Inflection.Person]
    -> Data.Inflection.Manifest [Data.Inflection.Honorific]
    -> Data.Inflection.Manifest [Data.Inflection.Polarity]
    -> Data.Inflection.Manifest [Data.Inflection.Tense]
    -> Data.Inflection.Manifest [Data.Inflection.Aspect]
    -> Data.Inflection.Manifest [Data.Inflection.Mood]
    -> Data.Inflection.Manifest [Data.Inflection.Voice]
    -> Data.Inflection.Manifest [Data.Inflection.Evidentiality]
    -> Data.Inflection.Manifest [Data.Inflection.Transitivity]
    -> Data.Inflection.Manifest [Data.Inflection.Volition]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 19,
     Strictness: <S,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0] -}
ae7b63f8f02a08f901ccdfd454a411ac
  $w$cshowsPrec15 ::
    Data.Inflection.LexCat -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.LexCat)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.Comp
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat47 w1
                   Data.Inflection.Infl
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat44 w1
                   Data.Inflection.Verb
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat41 w1
                   Data.Inflection.Det
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat38 w1
                   Data.Inflection.Noun
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat35 w1
                   Data.Inflection.Adpo
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat32 w1
                   Data.Inflection.Adj
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat29 w1
                   Data.Inflection.Adv
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat26 w1
                   Data.Inflection.Obj
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat23 w1
                   Data.Inflection.Subj
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadLexCat20 w1
                   Data.Inflection.Pron
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadLexCat17
                        w1 }) -}
e80d8f471552e307f8ce67ea59e61dde
  $w$cshowsPrec16 ::
    Data.Inflection.ManifestType -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.ManifestType)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.Particle
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifestType15
                        w1
                   Data.Inflection.Prefix
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifestType12
                        w1
                   Data.Inflection.Suffix
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifestType9
                        w1 }) -}
160b967a8965f1dbfdfeda3e8d2f734a
  $w$cshowsPrec17 ::
    Data.Inflection.Specificity -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Specificity)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.USPE
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest58 w1
                   Data.Inflection.SPEC
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest55 w1
                   Data.Inflection.NSPEC
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest52
                        w1 }) -}
f6776b7675319519d06c9aea2dc03bf9
  $w$cshowsPrec18 ::
    Data.Inflection.Topic -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Topic)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UTOP
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest74 w1
                   Data.Inflection.TOP
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest71 w1
                   Data.Inflection.NTOP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest68
                        w1 }) -}
1c2c61816b840e25aed576544ed551f7
  $w$cshowsPrec19 ::
    Data.Inflection.Polarity -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Polarity)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UPOL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest128
                        w1
                   Data.Inflection.AFF
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest125
                        w1
                   Data.Inflection.NEG
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest122
                        w1 }) -}
73f9fcce4a2a405b233176b51f525cb2
  $w$cshowsPrec2 ::
    Data.Inflection.Aspect -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Aspect)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UASP
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAspect35 w1
                   Data.Inflection.NNPROG
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAspect32 w1
                   Data.Inflection.PFV
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAspect29 w1
                   Data.Inflection.IPFV
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAspect26 w1
                   Data.Inflection.HAB
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAspect23 w1
                   Data.Inflection.CONT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAspect20 w1
                   Data.Inflection.NPROG
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadAspect17 w1
                   Data.Inflection.PROG
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadAspect14
                        w1 }) -}
637cf4191464029f30da46ab81b77985
  $w$cshowsPrec20 ::
    Data.Inflection.Volition -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Volition)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UVOL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest320
                        w1
                   Data.Inflection.VOL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest317
                        w1
                   Data.Inflection.NVOL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest314
                        w1 }) -}
53aeb8f68e4298ccd495f9c67613f931
  $w$cshowsPrec21 ::
    GHC.Prim.Int#
    -> Data.Inflection.LexCat
    -> Data.Inflection.ManifestType
    -> [(Data.Phoneme.Morpheme,
         (Data.Inflection.Express Data.Inflection.Gender,
          Data.Inflection.Express Data.Inflection.Animacy,
          Data.Inflection.Express Data.Inflection.Case,
          Data.Inflection.Express Data.Inflection.Number,
          Data.Inflection.Express Data.Inflection.Definiteness,
          Data.Inflection.Express Data.Inflection.Specificity,
          Data.Inflection.Express Data.Inflection.Topic,
          Data.Inflection.Express Data.Inflection.Person,
          Data.Inflection.Express Data.Inflection.Honorific,
          Data.Inflection.Express Data.Inflection.Polarity,
          Data.Inflection.Express Data.Inflection.Tense,
          Data.Inflection.Express Data.Inflection.Aspect,
          Data.Inflection.Express Data.Inflection.Mood,
          Data.Inflection.Express Data.Inflection.Voice,
          Data.Inflection.Express Data.Inflection.Evidentiality,
          Data.Inflection.Express Data.Inflection.Transitivity,
          Data.Inflection.Express Data.Inflection.Volition))]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <S,U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0] -}
476440af125c1822cd0b767cc8ac9f95
  $w$cshowsPrec3 ::
    Data.Inflection.Case -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
1de448f2aa68251f2e0f9da9901aa214
  $w$cshowsPrec4 ::
    Data.Inflection.Definiteness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Definiteness)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UDEF
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadDefiniteness15
                        w1
                   Data.Inflection.DEF
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadDefiniteness12
                        w1
                   Data.Inflection.INDF
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadDefiniteness9
                        w1 }) -}
18aae8850f4e0825a5c83b6a39cdd02c
  $w$cshowsPrec5 ::
    Data.Inflection.Evidentiality -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Evidentiality)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UEVI
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality43
                        w1
                   Data.Inflection.EXP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality40
                        w1
                   Data.Inflection.VIS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality37
                        w1
                   Data.Inflection.NVIS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality34
                        w1
                   Data.Inflection.AUD
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality31
                        w1
                   Data.Inflection.INFER
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality28
                        w1
                   Data.Inflection.REP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality25
                        w1
                   Data.Inflection.HSY
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality22
                        w1
                   Data.Inflection.QUO
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality19
                        w1
                   Data.Inflection.ASS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadEvidentiality16
                        w1 }) -}
8099e7e810494d6db288b5ee6338a850
  $w$cshowsPrec6 ::
    Data.Inflection.Gender -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Gender)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UGEN
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadGender23 w1
                   Data.Inflection.M
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadGender20 w1
                   Data.Inflection.F
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadGender17 w1
                   Data.Inflection.COM
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadGender14 w1
                   Data.Inflection.N
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadGender11
                        w1 }) -}
7465cc747c74e065f91b84b3f135a27f
  $w$cshowsPrec7 ::
    Data.Inflection.Number -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Number)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UNUM
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest40 w1
                   Data.Inflection.SG
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest37 w1
                   Data.Inflection.DU
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest34 w1
                   Data.Inflection.TRI
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest31 w1
                   Data.Inflection.PA
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest28 w1
                   Data.Inflection.PL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest25
                        w1 }) -}
45fed2402e7ed2b24c1d66ccdfd878c7
  $w$cshowsPrec8 ::
    Data.Inflection.Person -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Person)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UPER
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest110
                        w1
                   Data.Inflection.FIRST
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest107
                        w1
                   Data.Inflection.FSTINCL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest104
                        w1
                   Data.Inflection.FSTEXCL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest101
                        w1
                   Data.Inflection.SECOND
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest98 w1
                   Data.Inflection.THIRD
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest95 w1
                   Data.Inflection.THRDPROX
                   -> GHC.Base.++ @ GHC.Types.Char Data.Inflection.$fReadManifest92 w1
                   Data.Inflection.THRDOBV
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadManifest89
                        w1 }) -}
fb068a739b47969783c008d0c5ccdfb8
  $w$cshowsPrec9 ::
    Data.Inflection.Honorific -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Inflection.Honorific)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Inflection.UHON
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadHonorific19
                        w1
                   Data.Inflection.FAM
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadHonorific16
                        w1
                   Data.Inflection.NEU
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadHonorific13
                        w1
                   Data.Inflection.FORM
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Inflection.$fReadHonorific10
                        w1 }) -}
ae7b63f8f02a08f901ccdfd454a411ac
  $w$ctoEnum :: GHC.Prim.Int# -> Data.Inflection.LexCat
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Inflection.$fEnumLexCat1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 10#) of wild1 {
                        GHC.Types.False -> Data.Inflection.$fEnumLexCat1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Inflection.LexCat ww } }) -}
1f555085a72acd0be7c2a6de830d5d03
  data Animacy = UANI | AN | HUM | NHUM | ZO | INAN
73f9fcce4a2a405b233176b51f525cb2
  data Aspect
    = UASP | NNPROG | PFV | IPFV | HAB | CONT | NPROG | PROG
476440af125c1822cd0b767cc8ac9f95
  data Case
    = UCAS
    | INTR
    | ACC
    | ERG
    | PEG
    | INDIR
    | SEC
    | NOM
    | ABS
    | MTR
    | DIR
    | PRIM
    | ERG2
    | NOM2
    | ABS2
    | ABS3
    | DTR
    | OBJ
    | DRT1
    | TR
    | DRT2
    | OBL1
    | OBL2
    | OBL3
    | OBL4
    | OBL5
    | OBL6
    | ADP
    | PREP
    | POST
    | LAT
    | LOC
    | ABL
    | COMP
    | EQU
    | IDEN
    | ABE
    | DAT
    | INS
    | COMIT
    | INSCOMIT
    | ORN
    | BEN
    | CAUS
    | DISTR
    | GEN
    | POSS
    | PART
    | VOC
1de448f2aa68251f2e0f9da9901aa214
  data Definiteness = UDEF | DEF | INDF
18aae8850f4e0825a5c83b6a39cdd02c
  data Evidentiality
    = UEVI | EXP | VIS | NVIS | AUD | INFER | REP | HSY | QUO | ASS
215fe38755b3229d5abb86dd2bfcfba2
  data Express a = NoExpress | Express {getExp :: a}
8099e7e810494d6db288b5ee6338a850
  data Gender = UGEN | M | F | COM | N
fb068a739b47969783c008d0c5ccdfb8
  data Honorific = UHON | FAM | NEU | FORM
4d85e0faa8b64608c6b72704c2fa6a55
  data InflectionSystem
    = InflectionSystem {genSys :: Data.Inflection.Manifest
                                    [Data.Inflection.Gender],
                        aniSys :: Data.Inflection.Manifest [Data.Inflection.Animacy],
                        casSys :: Data.Inflection.Manifest [Data.Inflection.Case],
                        numSys :: Data.Inflection.Manifest [Data.Inflection.Number],
                        defSys :: Data.Inflection.Manifest [Data.Inflection.Definiteness],
                        speSys :: Data.Inflection.Manifest [Data.Inflection.Specificity],
                        topSys :: Data.Inflection.Manifest [Data.Inflection.Topic],
                        perSys :: Data.Inflection.Manifest [Data.Inflection.Person],
                        honSys :: Data.Inflection.Manifest [Data.Inflection.Honorific],
                        polSys :: Data.Inflection.Manifest [Data.Inflection.Polarity],
                        tenSys :: Data.Inflection.Manifest [Data.Inflection.Tense],
                        aspSys :: Data.Inflection.Manifest [Data.Inflection.Aspect],
                        mooSys :: Data.Inflection.Manifest [Data.Inflection.Mood],
                        voiSys :: Data.Inflection.Manifest [Data.Inflection.Voice],
                        eviSys :: Data.Inflection.Manifest [Data.Inflection.Evidentiality],
                        traSys :: Data.Inflection.Manifest [Data.Inflection.Transitivity],
                        volSys :: Data.Inflection.Manifest [Data.Inflection.Volition]}
ae7b63f8f02a08f901ccdfd454a411ac
  data LexCat
    = Comp
    | Infl
    | Verb
    | Det
    | Noun
    | Adpo
    | Adj
    | Adv
    | Obj
    | Subj
    | Pron
7ddf4c335f657c49b9e10fc56a6bbdf0
  data Manifest a
    = NoManifest
    | Manifest [(Data.Inflection.LexCat, Data.Inflection.ManifestType,
                 GHC.Types.Int)]
               a
bbcb171ae6dead0cd5095e2d02b10d22
  data ManifestSystem
    = ManifestSystem {manSysLC :: Data.Inflection.LexCat,
                      manSysType :: Data.Inflection.ManifestType,
                      manSysCombos :: [(Data.Phoneme.Morpheme,
                                        (Data.Inflection.Express Data.Inflection.Gender,
                                         Data.Inflection.Express Data.Inflection.Animacy,
                                         Data.Inflection.Express Data.Inflection.Case,
                                         Data.Inflection.Express Data.Inflection.Number,
                                         Data.Inflection.Express Data.Inflection.Definiteness,
                                         Data.Inflection.Express Data.Inflection.Specificity,
                                         Data.Inflection.Express Data.Inflection.Topic,
                                         Data.Inflection.Express Data.Inflection.Person,
                                         Data.Inflection.Express Data.Inflection.Honorific,
                                         Data.Inflection.Express Data.Inflection.Polarity,
                                         Data.Inflection.Express Data.Inflection.Tense,
                                         Data.Inflection.Express Data.Inflection.Aspect,
                                         Data.Inflection.Express Data.Inflection.Mood,
                                         Data.Inflection.Express Data.Inflection.Voice,
                                         Data.Inflection.Express Data.Inflection.Evidentiality,
                                         Data.Inflection.Express Data.Inflection.Transitivity,
                                         Data.Inflection.Express Data.Inflection.Volition))]}
e80d8f471552e307f8ce67ea59e61dde
  data ManifestType = Particle | Prefix | Suffix
72dcb6eb4442b59226b0ba8f6714f13e
  data Mood
    = UMOO
    | IND
    | IRR
    | DEO
    | IMP
    | JUS
    | OPT
    | EPIS
    | SBJV
    | POT
    | COND
7465cc747c74e065f91b84b3f135a27f
  data Number = UNUM | SG | DU | TRI | PA | PL
45fed2402e7ed2b24c1d66ccdfd878c7
  data Person
    = UPER
    | FIRST
    | FSTINCL
    | FSTEXCL
    | SECOND
    | THIRD
    | THRDPROX
    | THRDOBV
1c2c61816b840e25aed576544ed551f7
  data Polarity = UPOL | AFF | NEG
160b967a8965f1dbfdfeda3e8d2f734a
  data Specificity = USPE | SPEC | NSPEC
66acf52fe96ad50a10594fa2d12d699d
  data Tense
    = UTEN
    | PST
    | PRS
    | FUT
    | APRS
    | APST
    | AFUT
    | AFUT1
    | AFUT2
    | AFUT3
    | PPRS
    | PFUT
    | PPST
    | PPST1
    | PPST2
    | PPST3
    | PSTPER
    | PRSPER
    | FUTPER
f6776b7675319519d06c9aea2dc03bf9
  data Topic = UTOP | TOP | NTOP
7302fbe55b71c04bf146a8a39e883cde
  data Transitivity = UTRA | NTRANS | TRANS | MTRANS | DITRANS
82e4499831c335865b73c47901c341b5
  data Voice = UVOI | ACTIVE | MIDDLE | PASSIVE
637cf4191464029f30da46ab81b77985
  data Volition = UVOL | VOL | NVOL
79a2b46a74c5e9ae76d8c7634583213b
  aniSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Animacy]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLLLLLLLLLLL),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds2 }) -}
7ea174a878cf4cc3f4ccad891d2c4ce2
  aspSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Aspect]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLSLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds12 }) -}
96d7cbb903d2b6e71868d12838ba0d70
  casSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Case]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLLLLLLLLLLLL),1*U(A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds3 }) -}
dc152fde80a2e6f012cf4cad582a2732
  defSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Definiteness]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLLLLLLLLLLLL),1*U(A,A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds5 }) -}
ba916281d5929eaf21b2b4dbc19fd461
  eviSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Evidentiality]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLLLLSLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds15 }) -}
ea995e3825971508f2aef47b7550c556
  genSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Gender]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLLLLLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds1 }) -}
5dffaadcaa8e28aa1f1f53f2bc4ab044
  getExp :: Data.Inflection.Express a -> a
  RecSel Left Data.Inflection.Express
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Data.Inflection.Express a) ->
                 case ds of wild {
                   Data.Inflection.NoExpress -> Data.Inflection.getExp1 @ a
                   Data.Inflection.Express ds1 -> ds1 }) -}
577a26c9951042552631352fbf95079e
  getExp1 :: a
  {- Strictness: x -}
9dcd5fdd3f0dd4ebf99c95af86399d6d
  honSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Honorific]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLSLLLLLLLL),1*U(A,A,A,A,A,A,A,A,1*U,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds9 }) -}
3ceb0c52394cecda4a3f30b5608284fd
  manSysCombos ::
    Data.Inflection.ManifestSystem
    -> [(Data.Phoneme.Morpheme,
         (Data.Inflection.Express Data.Inflection.Gender,
          Data.Inflection.Express Data.Inflection.Animacy,
          Data.Inflection.Express Data.Inflection.Case,
          Data.Inflection.Express Data.Inflection.Number,
          Data.Inflection.Express Data.Inflection.Definiteness,
          Data.Inflection.Express Data.Inflection.Specificity,
          Data.Inflection.Express Data.Inflection.Topic,
          Data.Inflection.Express Data.Inflection.Person,
          Data.Inflection.Express Data.Inflection.Honorific,
          Data.Inflection.Express Data.Inflection.Polarity,
          Data.Inflection.Express Data.Inflection.Tense,
          Data.Inflection.Express Data.Inflection.Aspect,
          Data.Inflection.Express Data.Inflection.Mood,
          Data.Inflection.Express Data.Inflection.Voice,
          Data.Inflection.Express Data.Inflection.Evidentiality,
          Data.Inflection.Express Data.Inflection.Transitivity,
          Data.Inflection.Express Data.Inflection.Volition))]
  RecSel Left Data.Inflection.ManifestSystem
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.ManifestSystem) ->
                 case ds of wild { Data.Inflection.ManifestSystem ds1 ds2 ds3 ->
                 ds3 }) -}
10f5381bc56277c9bdc7af5d0cfcf3a5
  manSysLC ::
    Data.Inflection.ManifestSystem -> Data.Inflection.LexCat
  RecSel Left Data.Inflection.ManifestSystem
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.ManifestSystem) ->
                 case ds of wild { Data.Inflection.ManifestSystem ds1 ds2 ds3 ->
                 ds1 }) -}
65a359cba2b81708a5e98df05120eed8
  manSysType ::
    Data.Inflection.ManifestSystem -> Data.Inflection.ManifestType
  RecSel Left Data.Inflection.ManifestSystem
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.ManifestSystem) ->
                 case ds of wild { Data.Inflection.ManifestSystem ds1 ds2 ds3 ->
                 ds2 }) -}
df674e58ca0ddd582eb68a75885f07bb
  mooSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Mood]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLLSLLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds13 }) -}
6f1d055c7fee29154991fce9f0ddc2d4
  numSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Number]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLLLLLLLLLLL),1*U(A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds4 }) -}
8261318a5d413dda1b6ecd848164a496
  perSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Person]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLSLLLLLLLLL),1*U(A,A,A,A,A,A,A,1*U,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds8 }) -}
85fed7288f15cf731822518b2d41374b
  polSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Polarity]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLSLLLLLLL),1*U(A,A,A,A,A,A,A,A,A,1*U,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds10 }) -}
5917e534ba91b2cc97198856ad200b98
  speSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Specificity]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSLLLLLLLLLLL),1*U(A,A,A,A,A,1*U,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds6 }) -}
bf08155923431e8d2e27a195481f9cdb
  tenSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Tense]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLSLLLLLL),1*U(A,A,A,A,A,A,A,A,A,A,1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds11 }) -}
30e34761aee375966b983c6f27c8f9dc
  topSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Topic]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLSLLLLLLLLLL),1*U(A,A,A,A,A,A,1*U,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds7 }) -}
da6fafe1dba73683286fe8af7a6970ef
  traSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Transitivity]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLLLLLSL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds16 }) -}
1705c258669e74d07b6e1c6313b0b585
  voiSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Voice]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLLLSLLL),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds14 }) -}
bc0df6fcb6268478bd400fea067efb89
  volSys ::
    Data.Inflection.InflectionSystem
    -> Data.Inflection.Manifest [Data.Inflection.Volition]
  RecSel Left Data.Inflection.InflectionSystem
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLLLLLLS),1*U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Inflection.InflectionSystem) ->
                 case ds of wild { Data.Inflection.InflectionSystem ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 ds17 }) -}
instance [safe] GHC.Enum.Enum [Data.Inflection.LexCat]
  = Data.Inflection.$fEnumLexCat
instance [safe] GHC.Classes.Eq [(,,,,,,,,,,,,,,,,)]
  = Data.Inflection.$fEq(,,,,,,,,,,,,,,,,)
instance [safe] GHC.Classes.Eq [Data.Inflection.Animacy]
  = Data.Inflection.$fEqAnimacy
instance [safe] GHC.Classes.Eq [Data.Inflection.Aspect]
  = Data.Inflection.$fEqAspect
instance [safe] GHC.Classes.Eq [Data.Inflection.Case]
  = Data.Inflection.$fEqCase
instance [safe] GHC.Classes.Eq [Data.Inflection.Definiteness]
  = Data.Inflection.$fEqDefiniteness
instance [safe] GHC.Classes.Eq [Data.Inflection.Evidentiality]
  = Data.Inflection.$fEqEvidentiality
instance [safe] GHC.Classes.Eq [Data.Inflection.Express]
  = Data.Inflection.$fEqExpress
instance [safe] GHC.Classes.Eq [Data.Inflection.Gender]
  = Data.Inflection.$fEqGender
instance [safe] GHC.Classes.Eq [Data.Inflection.Honorific]
  = Data.Inflection.$fEqHonorific
instance [safe] GHC.Classes.Eq [Data.Inflection.InflectionSystem]
  = Data.Inflection.$fEqInflectionSystem
instance [safe] GHC.Classes.Eq [Data.Inflection.LexCat]
  = Data.Inflection.$fEqLexCat
instance [safe] GHC.Classes.Eq [Data.Inflection.Manifest]
  = Data.Inflection.$fEqManifest
instance [safe] GHC.Classes.Eq [Data.Inflection.ManifestSystem]
  = Data.Inflection.$fEqManifestSystem
instance [safe] GHC.Classes.Eq [Data.Inflection.ManifestType]
  = Data.Inflection.$fEqManifestType
instance [safe] GHC.Classes.Eq [Data.Inflection.Mood]
  = Data.Inflection.$fEqMood
instance [safe] GHC.Classes.Eq [Data.Inflection.Number]
  = Data.Inflection.$fEqNumber
instance [safe] GHC.Classes.Eq [Data.Inflection.Person]
  = Data.Inflection.$fEqPerson
instance [safe] GHC.Classes.Eq [Data.Inflection.Polarity]
  = Data.Inflection.$fEqPolarity
instance [safe] GHC.Classes.Eq [Data.Inflection.Specificity]
  = Data.Inflection.$fEqSpecificity
instance [safe] GHC.Classes.Eq [Data.Inflection.Tense]
  = Data.Inflection.$fEqTense
instance [safe] GHC.Classes.Eq [Data.Inflection.Topic]
  = Data.Inflection.$fEqTopic
instance [safe] GHC.Classes.Eq [Data.Inflection.Transitivity]
  = Data.Inflection.$fEqTransitivity
instance [safe] GHC.Classes.Eq [Data.Inflection.Voice]
  = Data.Inflection.$fEqVoice
instance [safe] GHC.Classes.Eq [Data.Inflection.Volition]
  = Data.Inflection.$fEqVolition
instance [safe] GHC.Read.Read [Data.Inflection.Animacy]
  = Data.Inflection.$fReadAnimacy
instance [safe] GHC.Read.Read [Data.Inflection.Aspect]
  = Data.Inflection.$fReadAspect
instance [safe] GHC.Read.Read [Data.Inflection.Case]
  = Data.Inflection.$fReadCase
instance [safe] GHC.Read.Read [Data.Inflection.Definiteness]
  = Data.Inflection.$fReadDefiniteness
instance [safe] GHC.Read.Read [Data.Inflection.Evidentiality]
  = Data.Inflection.$fReadEvidentiality
instance [safe] GHC.Read.Read [Data.Inflection.Express]
  = Data.Inflection.$fReadExpress
instance [safe] GHC.Read.Read [Data.Inflection.Gender]
  = Data.Inflection.$fReadGender
instance [safe] GHC.Read.Read [Data.Inflection.Honorific]
  = Data.Inflection.$fReadHonorific
instance [safe] GHC.Read.Read [Data.Inflection.InflectionSystem]
  = Data.Inflection.$fReadInflectionSystem
instance [safe] GHC.Read.Read [Data.Inflection.LexCat]
  = Data.Inflection.$fReadLexCat
instance [safe] GHC.Read.Read [Data.Inflection.Manifest]
  = Data.Inflection.$fReadManifest
instance [safe] GHC.Read.Read [Data.Inflection.ManifestType]
  = Data.Inflection.$fReadManifestType
instance [safe] GHC.Read.Read [Data.Inflection.Mood]
  = Data.Inflection.$fReadMood
instance [safe] GHC.Read.Read [Data.Inflection.Number]
  = Data.Inflection.$fReadNumber
instance [safe] GHC.Read.Read [Data.Inflection.Person]
  = Data.Inflection.$fReadPerson
instance [safe] GHC.Read.Read [Data.Inflection.Polarity]
  = Data.Inflection.$fReadPolarity
instance [safe] GHC.Read.Read [Data.Inflection.Specificity]
  = Data.Inflection.$fReadSpecificity
instance [safe] GHC.Read.Read [Data.Inflection.Tense]
  = Data.Inflection.$fReadTense
instance [safe] GHC.Read.Read [Data.Inflection.Topic]
  = Data.Inflection.$fReadTopic
instance [safe] GHC.Read.Read [Data.Inflection.Transitivity]
  = Data.Inflection.$fReadTransitivity
instance [safe] GHC.Read.Read [Data.Inflection.Voice]
  = Data.Inflection.$fReadVoice
instance [safe] GHC.Read.Read [Data.Inflection.Volition]
  = Data.Inflection.$fReadVolition
instance [safe] GHC.Show.Show [(,,,,,,,,,,,,,,,,)]
  = Data.Inflection.$fShow(,,,,,,,,,,,,,,,,)
instance [safe] GHC.Show.Show [Data.Inflection.Animacy]
  = Data.Inflection.$fShowAnimacy
instance [safe] GHC.Show.Show [Data.Inflection.Aspect]
  = Data.Inflection.$fShowAspect
instance [safe] GHC.Show.Show [Data.Inflection.Case]
  = Data.Inflection.$fShowCase
instance [safe] GHC.Show.Show [Data.Inflection.Definiteness]
  = Data.Inflection.$fShowDefiniteness
instance [safe] GHC.Show.Show [Data.Inflection.Evidentiality]
  = Data.Inflection.$fShowEvidentiality
instance [safe] GHC.Show.Show [Data.Inflection.Express]
  = Data.Inflection.$fShowExpress
instance [safe] GHC.Show.Show [Data.Inflection.Gender]
  = Data.Inflection.$fShowGender
instance [safe] GHC.Show.Show [Data.Inflection.Honorific]
  = Data.Inflection.$fShowHonorific
instance [safe] GHC.Show.Show [Data.Inflection.InflectionSystem]
  = Data.Inflection.$fShowInflectionSystem
instance [safe] GHC.Show.Show [Data.Inflection.LexCat]
  = Data.Inflection.$fShowLexCat
instance [safe] GHC.Show.Show [Data.Inflection.Manifest]
  = Data.Inflection.$fShowManifest
instance [safe] GHC.Show.Show [Data.Inflection.ManifestSystem]
  = Data.Inflection.$fShowManifestSystem
instance [safe] GHC.Show.Show [Data.Inflection.ManifestType]
  = Data.Inflection.$fShowManifestType
instance [safe] GHC.Show.Show [Data.Inflection.Mood]
  = Data.Inflection.$fShowMood
instance [safe] GHC.Show.Show [Data.Inflection.Number]
  = Data.Inflection.$fShowNumber
instance [safe] GHC.Show.Show [Data.Inflection.Person]
  = Data.Inflection.$fShowPerson
instance [safe] GHC.Show.Show [Data.Inflection.Polarity]
  = Data.Inflection.$fShowPolarity
instance [safe] GHC.Show.Show [Data.Inflection.Specificity]
  = Data.Inflection.$fShowSpecificity
instance [safe] GHC.Show.Show [Data.Inflection.Tense]
  = Data.Inflection.$fShowTense
instance [safe] GHC.Show.Show [Data.Inflection.Topic]
  = Data.Inflection.$fShowTopic
instance [safe] GHC.Show.Show [Data.Inflection.Transitivity]
  = Data.Inflection.$fShowTransitivity
instance [safe] GHC.Show.Show [Data.Inflection.Voice]
  = Data.Inflection.$fShowVoice
instance [safe] GHC.Show.Show [Data.Inflection.Volition]
  = Data.Inflection.$fShowVolition
"SPEC $c/= @ Animacy" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                 Data.Inflection.Animacy)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Animacy $dEq
  = Data.Inflection.$fEqExpress_$s$c/=1
"SPEC $c/= @ Aspect" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                Data.Inflection.Aspect)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Aspect $dEq
  = Data.Inflection.$fEqExpress_$s$c/=9
"SPEC $c/= @ Definiteness" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                      Data.Inflection.Definiteness)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Definiteness
                                   $dEq
  = Data.Inflection.$fEqExpress_$s$c/=3
"SPEC $c/= @ Evidentiality" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                       Data.Inflection.Evidentiality)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Evidentiality
                                   $dEq
  = Data.Inflection.$fEqExpress_$s$c/=11
"SPEC $c/= @ Gender" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                Data.Inflection.Gender)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Gender $dEq
  = Data.Inflection.$fEqExpress_$s$c/=
"SPEC $c/= @ Honorific" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                   Data.Inflection.Honorific)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Honorific $dEq
  = Data.Inflection.$fEqExpress_$s$c/=7
"SPEC $c/= @ Number" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                Data.Inflection.Number)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Number $dEq
  = Data.Inflection.$fEqExpress_$s$c/=2
"SPEC $c/= @ Person" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                Data.Inflection.Person)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Person $dEq
  = Data.Inflection.$fEqExpress_$s$c/=6
"SPEC $c/= @ Polarity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                  Data.Inflection.Polarity)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Polarity $dEq
  = Data.Inflection.$fEqExpress_$s$c/=8
"SPEC $c/= @ Specificity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                     Data.Inflection.Specificity)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Specificity $dEq
  = Data.Inflection.$fEqExpress_$s$c/=4
"SPEC $c/= @ Topic" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                               Data.Inflection.Topic)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Topic $dEq
  = Data.Inflection.$fEqExpress_$s$c/=5
"SPEC $c/= @ Transitivity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                      Data.Inflection.Transitivity)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Transitivity
                                   $dEq
  = Data.Inflection.$fEqExpress_$s$c/=12
"SPEC $c/= @ Voice" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                               Data.Inflection.Voice)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Voice $dEq
  = Data.Inflection.$fEqExpress_$s$c/=10
"SPEC $c/= @ Volition" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                  Data.Inflection.Volition)
  Data.Inflection.$fEqExpress_$c/= @ Data.Inflection.Volition $dEq
  = Data.Inflection.$fEqExpress_$s$c/=13
"SPEC $c== @ Animacy" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                 Data.Inflection.Animacy)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Animacy $dEq
  = Data.Inflection.$fEqExpress_$s$c==1
"SPEC $c== @ Aspect" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                Data.Inflection.Aspect)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Aspect $dEq
  = Data.Inflection.$fEqExpress_$s$c==9
"SPEC $c== @ Definiteness" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                      Data.Inflection.Definiteness)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Definiteness
                                     $dEq
  = Data.Inflection.$fEqExpress_$s$c==3
"SPEC $c== @ Evidentiality" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                       Data.Inflection.Evidentiality)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Evidentiality
                                     $dEq
  = Data.Inflection.$fEqExpress_$s$c==11
"SPEC $c== @ Gender" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                Data.Inflection.Gender)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Gender $dEq
  = Data.Inflection.$fEqExpress_$s$c==
"SPEC $c== @ Honorific" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                   Data.Inflection.Honorific)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Honorific $dEq
  = Data.Inflection.$fEqExpress_$s$c==7
"SPEC $c== @ Number" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                Data.Inflection.Number)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Number $dEq
  = Data.Inflection.$fEqExpress_$s$c==2
"SPEC $c== @ Person" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                Data.Inflection.Person)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Person $dEq
  = Data.Inflection.$fEqExpress_$s$c==6
"SPEC $c== @ Polarity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                  Data.Inflection.Polarity)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Polarity $dEq
  = Data.Inflection.$fEqExpress_$s$c==8
"SPEC $c== @ Specificity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                     Data.Inflection.Specificity)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Specificity
                                     $dEq
  = Data.Inflection.$fEqExpress_$s$c==4
"SPEC $c== @ Topic" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                               Data.Inflection.Topic)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Topic $dEq
  = Data.Inflection.$fEqExpress_$s$c==5
"SPEC $c== @ Transitivity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                      Data.Inflection.Transitivity)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Transitivity
                                     $dEq
  = Data.Inflection.$fEqExpress_$s$c==12
"SPEC $c== @ Voice" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                               Data.Inflection.Voice)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Voice $dEq
  = Data.Inflection.$fEqExpress_$s$c==10
"SPEC $c== @ Volition" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                  Data.Inflection.Volition)
  Data.Inflection.$fEqExpress_$c==10 @ Data.Inflection.Volition $dEq
  = Data.Inflection.$fEqExpress_$s$c==13
"SPEC $c== @ [Volition]" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                    [Data.Inflection.Volition])
  Data.Inflection.$fEqManifest_$c== @ [Data.Inflection.Volition] $dEq
  = Data.Inflection.$fEqManifest_$s$c==16
"SPEC $cshow @ Animacy" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                     Data.Inflection.Animacy)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Animacy
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow1
"SPEC $cshow @ Aspect" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                    Data.Inflection.Aspect)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Aspect
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow11
"SPEC $cshow @ Case" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                  Data.Inflection.Case)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Case $dShow
  = Data.Inflection.$fShowExpress_$s$cshow2
"SPEC $cshow @ Definiteness" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Data.Inflection.Definiteness)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Definiteness
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow4
"SPEC $cshow @ Evidentiality" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           Data.Inflection.Evidentiality)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Evidentiality
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow14
"SPEC $cshow @ Gender" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                    Data.Inflection.Gender)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Gender
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow
"SPEC $cshow @ Honorific" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                       Data.Inflection.Honorific)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Honorific
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow8
"SPEC $cshow @ Mood" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                  Data.Inflection.Mood)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Mood $dShow
  = Data.Inflection.$fShowExpress_$s$cshow12
"SPEC $cshow @ Number" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                    Data.Inflection.Number)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Number
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow3
"SPEC $cshow @ Person" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                    Data.Inflection.Person)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Person
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow7
"SPEC $cshow @ Polarity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                      Data.Inflection.Polarity)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Polarity
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow9
"SPEC $cshow @ Specificity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         Data.Inflection.Specificity)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Specificity
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow5
"SPEC $cshow @ Tense" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                   Data.Inflection.Tense)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Tense $dShow
  = Data.Inflection.$fShowExpress_$s$cshow10
"SPEC $cshow @ Topic" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                   Data.Inflection.Topic)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Topic $dShow
  = Data.Inflection.$fShowExpress_$s$cshow6
"SPEC $cshow @ Transitivity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Data.Inflection.Transitivity)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Transitivity
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow15
"SPEC $cshow @ Voice" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                   Data.Inflection.Voice)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Voice $dShow
  = Data.Inflection.$fShowExpress_$s$cshow13
"SPEC $cshow @ Volition" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                      Data.Inflection.Volition)
  Data.Inflection.$fShowExpress_$cshow @ Data.Inflection.Volition
                                       $dShow
  = Data.Inflection.$fShowExpress_$s$cshow16
"SPEC $cshowList @ Animacy" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         Data.Inflection.Animacy)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Animacy
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList1
"SPEC $cshowList @ Aspect" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Data.Inflection.Aspect)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Aspect
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList11
"SPEC $cshowList @ Case" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                      Data.Inflection.Case)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Case
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList2
"SPEC $cshowList @ Definiteness" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                              Data.Inflection.Definiteness)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Definiteness
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList4
"SPEC $cshowList @ Evidentiality" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                               Data.Inflection.Evidentiality)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Evidentiality
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList14
"SPEC $cshowList @ Gender" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Data.Inflection.Gender)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Gender
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList
"SPEC $cshowList @ Honorific" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           Data.Inflection.Honorific)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Honorific
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList8
"SPEC $cshowList @ Mood" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                      Data.Inflection.Mood)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Mood
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList12
"SPEC $cshowList @ Number" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Data.Inflection.Number)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Number
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList3
"SPEC $cshowList @ Person" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Data.Inflection.Person)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Person
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList7
"SPEC $cshowList @ Polarity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Data.Inflection.Polarity)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Polarity
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList9
"SPEC $cshowList @ Specificity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                             Data.Inflection.Specificity)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Specificity
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList5
"SPEC $cshowList @ Tense" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                       Data.Inflection.Tense)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Tense
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList10
"SPEC $cshowList @ Topic" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                       Data.Inflection.Topic)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Topic
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList6
"SPEC $cshowList @ Transitivity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                              Data.Inflection.Transitivity)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Transitivity
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList15
"SPEC $cshowList @ Voice" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                       Data.Inflection.Voice)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Voice
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList13
"SPEC $cshowList @ Volition" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Data.Inflection.Volition)
  Data.Inflection.$fShowExpress_$cshowList @ Data.Inflection.Volition
                                           $dShow
  = Data.Inflection.$fShowExpress_$s$cshowList16
"SPEC $cshowsPrec @ Animacy" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Data.Inflection.Animacy)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Animacy
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec1
"SPEC $cshowsPrec @ Aspect" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         Data.Inflection.Aspect)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Aspect
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec11
"SPEC $cshowsPrec @ Case" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                       Data.Inflection.Case)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Case
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec2
"SPEC $cshowsPrec @ Definiteness" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                               Data.Inflection.Definiteness)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Definiteness
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec4
"SPEC $cshowsPrec @ Evidentiality" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                Data.Inflection.Evidentiality)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Evidentiality
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec14
"SPEC $cshowsPrec @ Gender" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         Data.Inflection.Gender)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Gender
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec
"SPEC $cshowsPrec @ Honorific" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                            Data.Inflection.Honorific)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Honorific
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec8
"SPEC $cshowsPrec @ Mood" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                       Data.Inflection.Mood)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Mood
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec12
"SPEC $cshowsPrec @ Number" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         Data.Inflection.Number)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Number
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec3
"SPEC $cshowsPrec @ Person" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         Data.Inflection.Person)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Person
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec7
"SPEC $cshowsPrec @ Polarity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           Data.Inflection.Polarity)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Polarity
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec9
"SPEC $cshowsPrec @ Specificity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                              Data.Inflection.Specificity)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Specificity
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec5
"SPEC $cshowsPrec @ Tense" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Data.Inflection.Tense)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Tense
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec10
"SPEC $cshowsPrec @ Topic" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Data.Inflection.Topic)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Topic
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec6
"SPEC $cshowsPrec @ Transitivity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                               Data.Inflection.Transitivity)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Transitivity
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec15
"SPEC $cshowsPrec @ Voice" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                        Data.Inflection.Voice)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Voice
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec13
"SPEC $cshowsPrec @ Volition" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           Data.Inflection.Volition)
  Data.Inflection.$fShowExpress_$cshowsPrec @ Data.Inflection.Volition
                                            $dShow
  = Data.Inflection.$fShowExpress_$s$cshowsPrec16
"SPEC $cshowsPrec @ [Animacy]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                            [Data.Inflection.Animacy])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Animacy]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec1
"SPEC $cshowsPrec @ [Aspect]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           [Data.Inflection.Aspect])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Aspect]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec11
"SPEC $cshowsPrec @ [Case]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         [Data.Inflection.Case])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Case]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec2
"SPEC $cshowsPrec @ [Definiteness]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                 [Data.Inflection.Definiteness])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Definiteness]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec4
"SPEC $cshowsPrec @ [Evidentiality]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                  [Data.Inflection.Evidentiality])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Evidentiality]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec14
"SPEC $cshowsPrec @ [Gender]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           [Data.Inflection.Gender])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Gender]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec
"SPEC $cshowsPrec @ [Honorific]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                              [Data.Inflection.Honorific])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Honorific]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec8
"SPEC $cshowsPrec @ [Mood]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         [Data.Inflection.Mood])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Mood]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec12
"SPEC $cshowsPrec @ [Number]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           [Data.Inflection.Number])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Number]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec3
"SPEC $cshowsPrec @ [Person]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           [Data.Inflection.Person])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Person]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec7
"SPEC $cshowsPrec @ [Polarity]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                             [Data.Inflection.Polarity])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Polarity]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec9
"SPEC $cshowsPrec @ [Specificity]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                [Data.Inflection.Specificity])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Specificity]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec5
"SPEC $cshowsPrec @ [Tense]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          [Data.Inflection.Tense])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Tense]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec10
"SPEC $cshowsPrec @ [Topic]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          [Data.Inflection.Topic])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Topic]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec6
"SPEC $cshowsPrec @ [Transitivity]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                 [Data.Inflection.Transitivity])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Transitivity]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec15
"SPEC $cshowsPrec @ [Voice]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          [Data.Inflection.Voice])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Voice]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec13
"SPEC $cshowsPrec @ [Volition]" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                             [Data.Inflection.Volition])
  Data.Inflection.$fShowManifest_$cshowsPrec @ [Data.Inflection.Volition]
                                             $dShow
  = Data.Inflection.$fShowManifest_$s$cshowsPrec16
"SPEC $fEqExpress @ Animacy" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                        Data.Inflection.Animacy)
  Data.Inflection.$fEqExpress @ Data.Inflection.Animacy $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress1
"SPEC $fEqExpress @ Aspect" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                       Data.Inflection.Aspect)
  Data.Inflection.$fEqExpress @ Data.Inflection.Aspect $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress9
"SPEC $fEqExpress @ Definiteness" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                             Data.Inflection.Definiteness)
  Data.Inflection.$fEqExpress @ Data.Inflection.Definiteness $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress3
"SPEC $fEqExpress @ Evidentiality" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                              Data.Inflection.Evidentiality)
  Data.Inflection.$fEqExpress @ Data.Inflection.Evidentiality $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress11
"SPEC $fEqExpress @ Gender" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                       Data.Inflection.Gender)
  Data.Inflection.$fEqExpress @ Data.Inflection.Gender $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress
"SPEC $fEqExpress @ Honorific" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                          Data.Inflection.Honorific)
  Data.Inflection.$fEqExpress @ Data.Inflection.Honorific $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress7
"SPEC $fEqExpress @ Number" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                       Data.Inflection.Number)
  Data.Inflection.$fEqExpress @ Data.Inflection.Number $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress2
"SPEC $fEqExpress @ Person" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                       Data.Inflection.Person)
  Data.Inflection.$fEqExpress @ Data.Inflection.Person $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress6
"SPEC $fEqExpress @ Polarity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                         Data.Inflection.Polarity)
  Data.Inflection.$fEqExpress @ Data.Inflection.Polarity $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress8
"SPEC $fEqExpress @ Specificity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                            Data.Inflection.Specificity)
  Data.Inflection.$fEqExpress @ Data.Inflection.Specificity $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress4
"SPEC $fEqExpress @ Topic" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                      Data.Inflection.Topic)
  Data.Inflection.$fEqExpress @ Data.Inflection.Topic $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress5
"SPEC $fEqExpress @ Transitivity" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                             Data.Inflection.Transitivity)
  Data.Inflection.$fEqExpress @ Data.Inflection.Transitivity $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress12
"SPEC $fEqExpress @ Voice" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                      Data.Inflection.Voice)
  Data.Inflection.$fEqExpress @ Data.Inflection.Voice $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress10
"SPEC $fEqExpress @ Volition" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                         Data.Inflection.Volition)
  Data.Inflection.$fEqExpress @ Data.Inflection.Volition $dEq
  = Data.Inflection.$fEqExpress_$s$fEqExpress13
"SPEC $fShowExpress @ Animacy" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                            Data.Inflection.Animacy)
  Data.Inflection.$fShowExpress @ Data.Inflection.Animacy $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress1
"SPEC $fShowExpress @ Aspect" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           Data.Inflection.Aspect)
  Data.Inflection.$fShowExpress @ Data.Inflection.Aspect $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress11
"SPEC $fShowExpress @ Case" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         Data.Inflection.Case)
  Data.Inflection.$fShowExpress @ Data.Inflection.Case $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress2
"SPEC $fShowExpress @ Definiteness" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                 Data.Inflection.Definiteness)
  Data.Inflection.$fShowExpress @ Data.Inflection.Definiteness $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress4
"SPEC $fShowExpress @ Evidentiality" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                  Data.Inflection.Evidentiality)
  Data.Inflection.$fShowExpress @ Data.Inflection.Evidentiality
                                $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress14
"SPEC $fShowExpress @ Gender" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           Data.Inflection.Gender)
  Data.Inflection.$fShowExpress @ Data.Inflection.Gender $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress
"SPEC $fShowExpress @ Honorific" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                              Data.Inflection.Honorific)
  Data.Inflection.$fShowExpress @ Data.Inflection.Honorific $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress8
"SPEC $fShowExpress @ Mood" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                         Data.Inflection.Mood)
  Data.Inflection.$fShowExpress @ Data.Inflection.Mood $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress12
"SPEC $fShowExpress @ Number" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           Data.Inflection.Number)
  Data.Inflection.$fShowExpress @ Data.Inflection.Number $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress3
"SPEC $fShowExpress @ Person" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                           Data.Inflection.Person)
  Data.Inflection.$fShowExpress @ Data.Inflection.Person $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress7
"SPEC $fShowExpress @ Polarity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                             Data.Inflection.Polarity)
  Data.Inflection.$fShowExpress @ Data.Inflection.Polarity $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress9
"SPEC $fShowExpress @ Specificity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                Data.Inflection.Specificity)
  Data.Inflection.$fShowExpress @ Data.Inflection.Specificity $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress5
"SPEC $fShowExpress @ Tense" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Data.Inflection.Tense)
  Data.Inflection.$fShowExpress @ Data.Inflection.Tense $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress10
"SPEC $fShowExpress @ Topic" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Data.Inflection.Topic)
  Data.Inflection.$fShowExpress @ Data.Inflection.Topic $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress6
"SPEC $fShowExpress @ Transitivity" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                                 Data.Inflection.Transitivity)
  Data.Inflection.$fShowExpress @ Data.Inflection.Transitivity $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress15
"SPEC $fShowExpress @ Voice" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Data.Inflection.Voice)
  Data.Inflection.$fShowExpress @ Data.Inflection.Voice $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress13
"SPEC $fShowExpress @ Volition" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                             Data.Inflection.Volition)
  Data.Inflection.$fShowExpress @ Data.Inflection.Volition $dShow
  = Data.Inflection.$fShowExpress_$s$fShowExpress16
"SPEC/Data.Inflection $fEq(,) @ Morpheme @ (Express Gender,
                                           Express Animacy, Express Case, Express Number,
                                           Express Definiteness, Express Specificity, Express Topic,
                                           Express Person, Express Honorific, Express Polarity,
                                           Express Tense, Express Aspect, Express Mood,
                                           Express Voice, Express Evidentiality,
                                           Express Transitivity, Express Volition)" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Data.Phoneme.Morpheme)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ($dEq1 :: GHC.Classes.Eq
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Gender,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Animacy,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Case,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Number,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Definiteness,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Specificity,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Topic,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Person,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Honorific,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Polarity,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Tense,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Aspect,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Mood,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Voice,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Evidentiality,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Transitivity,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Data.Inflection.Express
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Data.Inflection.Volition))
  GHC.Classes.$fEq(,) @ Data.Phoneme.Morpheme
                      @ (Data.Inflection.Express Data.Inflection.Gender,
                         Data.Inflection.Express Data.Inflection.Animacy,
                         Data.Inflection.Express Data.Inflection.Case,
                         Data.Inflection.Express Data.Inflection.Number,
                         Data.Inflection.Express Data.Inflection.Definiteness,
                         Data.Inflection.Express Data.Inflection.Specificity,
                         Data.Inflection.Express Data.Inflection.Topic,
                         Data.Inflection.Express Data.Inflection.Person,
                         Data.Inflection.Express Data.Inflection.Honorific,
                         Data.Inflection.Express Data.Inflection.Polarity,
                         Data.Inflection.Express Data.Inflection.Tense,
                         Data.Inflection.Express Data.Inflection.Aspect,
                         Data.Inflection.Express Data.Inflection.Mood,
                         Data.Inflection.Express Data.Inflection.Voice,
                         Data.Inflection.Express Data.Inflection.Evidentiality,
                         Data.Inflection.Express Data.Inflection.Transitivity,
                         Data.Inflection.Express Data.Inflection.Volition)
                      $dEq
                      $dEq1
  = Data.Inflection.$fEqManifestSystem_$s$fEq(,)
"SPEC/Data.Inflection $fEq(,,) @ LexCat @ ManifestType @ Int" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                                         Data.Inflection.LexCat)
                                                                              ($dEq1 :: GHC.Classes.Eq
                                                                                          Data.Inflection.ManifestType)
                                                                              ($dEq2 :: GHC.Classes.Eq
                                                                                          GHC.Types.Int)
  GHC.Classes.$fEq(,,) @ Data.Inflection.LexCat
                       @ Data.Inflection.ManifestType
                       @ GHC.Types.Int
                       $dEq
                       $dEq1
                       $dEq2
  = Data.Inflection.$fEqManifest_$s$fEq(,,)
"SPEC/Data.Inflection $fEq(,,)_$c/= @ LexCat @ ManifestType @ Int" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                                              Data.Inflection.LexCat)
                                                                                   ($dEq1 :: GHC.Classes.Eq
                                                                                               Data.Inflection.ManifestType)
                                                                                   ($dEq2 :: GHC.Classes.Eq
                                                                                               GHC.Types.Int)
  GHC.Classes.$fEq(,,)_$c/= @ Data.Inflection.LexCat
                            @ Data.Inflection.ManifestType
                            @ GHC.Types.Int
                            $dEq
                            $dEq1
                            $dEq2
  = Data.Inflection.$fEqManifest_$s$fEq(,,)_$c/=
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

