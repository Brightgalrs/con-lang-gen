
==================== FINAL INTERFACE ====================
2016-12-21 17:41:23.72988 UTC

interface con-lang-gen-0.0.0.1-JpecSLrjfNmG1CUMEdSr39:Data.Phoneme 8001
  interface hash: c89a084bec5cd58427e3397bd8f8a8dc
  ABI hash: 8d8abfca47f36976b4a493acc97ddf5b
  export-list hash: cf7e229a8d1eca731bf27cf39a54d5d4
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 87177015adbaa5bcec08b7699971b9b7
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Phoneme.Backness{Data.Phoneme.BACK Data.Phoneme.CENTRAL Data.Phoneme.FRONT Data.Phoneme.NEARBACK Data.Phoneme.NEARFRONT}
  Data.Phoneme.Height{Data.Phoneme.CLOSE Data.Phoneme.CLOSEMID Data.Phoneme.MID Data.Phoneme.NEARCLOSE Data.Phoneme.NEAROPEN Data.Phoneme.OPEN Data.Phoneme.OPENMID}
  Data.Phoneme.Length{Data.Phoneme.LONG Data.Phoneme.NORMAL Data.Phoneme.SHORT}
  Data.Phoneme.Manner{Data.Phoneme.AFFRICATE Data.Phoneme.APPROXIMANT Data.Phoneme.FLAP Data.Phoneme.FRICATIVE Data.Phoneme.LAFFRICATE Data.Phoneme.LAPPROXIMANT Data.Phoneme.LFLAP Data.Phoneme.LFRICATIVE Data.Phoneme.NASAL Data.Phoneme.SAFFRICATE Data.Phoneme.SILIBANT Data.Phoneme.STOP Data.Phoneme.TRILL}
  Data.Phoneme.Morpheme{Data.Phoneme.Morpheme getPhonemes}
  Data.Phoneme.Phonation{Data.Phoneme.ASPIRATED Data.Phoneme.BREATHY Data.Phoneme.CREAKY Data.Phoneme.MODAL Data.Phoneme.SLACK Data.Phoneme.STIFF Data.Phoneme.VOICELESS}
  Data.Phoneme.Phoneme{Data.Phoneme.Blank Data.Phoneme.Consonant Data.Phoneme.Diphthong Data.Phoneme.Vowel cmanner cplace csymbol cvoice dbackness1 dbackness2 dheight1 dheight2 dlength droundedness1 droundedness2 dsymbol dtone vbackness vheight vlength vroundedness vsymbol vtone}
  Data.Phoneme.Place{Data.Phoneme.ALVEOLAR Data.Phoneme.ALVEOLOPALATAL Data.Phoneme.BILABIAL Data.Phoneme.CORONAL Data.Phoneme.DENTAL Data.Phoneme.DENTIALVEOLAR Data.Phoneme.DORSAL Data.Phoneme.EPIGLOTTAL Data.Phoneme.EPIPHARYNGEAL Data.Phoneme.GLOTTAL Data.Phoneme.LABIAL Data.Phoneme.LABIODENTAL Data.Phoneme.LARYNGEAL Data.Phoneme.PALATAL Data.Phoneme.PHARYNGEAL Data.Phoneme.POSTALVEOLAR Data.Phoneme.RETROFLEX Data.Phoneme.UVULAR Data.Phoneme.VELAR}
  Data.Phoneme.Roundedness{Data.Phoneme.DEFAULT Data.Phoneme.ROUNDED Data.Phoneme.UNROUNDED}
  Data.Phoneme.Tone{Data.Phoneme.BOTTOMT Data.Phoneme.DIPT Data.Phoneme.FALLT Data.Phoneme.HFALLT Data.Phoneme.HIGHT Data.Phoneme.HRISET Data.Phoneme.LFALLT Data.Phoneme.LOWT Data.Phoneme.LRISET Data.Phoneme.MIDT Data.Phoneme.NONET Data.Phoneme.PEAKT Data.Phoneme.RISET Data.Phoneme.TOPT}
  Data.Phoneme.Word{Data.Phoneme.Word getMorphemes}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Enum fdf7ac3e1b0be0a4a37257601bddad14
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Read 817c914615ac8e308afc0c675fb3f671
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  base-4.9.0.0:Text.ParserCombinators.ReadPrec 9512e2f4b227f507f87a150887202aed
import  -/  base-4.9.0.0:Text.Read.Lex fe3dd7b823826bf6870140c5363f9596
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
a3d34da76e787829b1272672cb3d501f
  $fBoundedBackness :: GHC.Enum.Bounded Data.Phoneme.Backness
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Backness Data.Phoneme.BACK Data.Phoneme.FRONT -}
e52daabfd4cc5d18128954ffcda031bb
  $fBoundedHeight :: GHC.Enum.Bounded Data.Phoneme.Height
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Height Data.Phoneme.CLOSE Data.Phoneme.OPEN -}
3bc911798122c419c4b3747def87cb7a
  $fBoundedLength :: GHC.Enum.Bounded Data.Phoneme.Length
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Length Data.Phoneme.SHORT Data.Phoneme.LONG -}
457727c142c08ed8e753e8053528da14
  $fBoundedManner :: GHC.Enum.Bounded Data.Phoneme.Manner
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Manner Data.Phoneme.NASAL Data.Phoneme.LFLAP -}
ff541d1764888145304960d9b00dcecd
  $fBoundedPhonation :: GHC.Enum.Bounded Data.Phoneme.Phonation
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phonation
                  Data.Phoneme.VOICELESS
                  Data.Phoneme.ASPIRATED -}
1971716d79acadd98b648de5350e6f24
  $fBoundedPlace :: GHC.Enum.Bounded Data.Phoneme.Place
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Place Data.Phoneme.LABIAL Data.Phoneme.GLOTTAL -}
974abd7cc25c83307948d0001b49f38e
  $fBoundedRoundedness :: GHC.Enum.Bounded Data.Phoneme.Roundedness
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Roundedness
                  Data.Phoneme.DEFAULT
                  Data.Phoneme.UNROUNDED -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fBoundedTone :: GHC.Enum.Bounded Data.Phoneme.Tone
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Tone Data.Phoneme.NONET Data.Phoneme.PEAKT -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness :: GHC.Enum.Enum Data.Phoneme.Backness
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Backness
                  Data.Phoneme.$fEnumBackness_$csucc
                  Data.Phoneme.$fEnumBackness_$cpred
                  Data.Phoneme.$fEnumBackness_$ctoEnum
                  Data.Phoneme.$fEnumBackness_$cfromEnum
                  Data.Phoneme.$fEnumBackness_$cenumFrom
                  Data.Phoneme.$fEnumBackness_$cenumFromThen
                  Data.Phoneme.$fEnumBackness_$cenumFromTo
                  Data.Phoneme.$fEnumBackness_$cenumFromThenTo -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness1 :: [Data.Phoneme.Backness]
  {- Unfolding: (Data.Phoneme.$fEnumBackness_go5 4#) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness2 :: [Data.Phoneme.Backness]
  {- Unfolding: (Data.Phoneme.$fEnumBackness_go6 3#) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness3 :: [Data.Phoneme.Backness]
  {- Unfolding: (Data.Phoneme.$fEnumBackness_go7 2#) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness4 :: [Data.Phoneme.Backness]
  {- Unfolding: (Data.Phoneme.$fEnumBackness_go8 1#) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness5 :: [Data.Phoneme.Backness]
  {- Unfolding: (Data.Phoneme.$fEnumBackness_go9 0#) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness6 :: GHC.Prim.Int# -> Data.Phoneme.Backness
  {- Arity: 1, Strictness: <L,U>x -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness7 :: Data.Phoneme.Backness
  {- Strictness: x -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness8 :: Data.Phoneme.Backness
  {- Strictness: x -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_$cenumFrom ::
    Data.Phoneme.Backness -> [Data.Phoneme.Backness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK -> Data.Phoneme.$fEnumBackness5
                   Data.Phoneme.NEARBACK -> Data.Phoneme.$fEnumBackness4
                   Data.Phoneme.CENTRAL -> Data.Phoneme.$fEnumBackness3
                   Data.Phoneme.NEARFRONT -> Data.Phoneme.$fEnumBackness2
                   Data.Phoneme.FRONT -> Data.Phoneme.$fEnumBackness1 }) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_$cenumFromThen ::
    Data.Phoneme.Backness
    -> Data.Phoneme.Backness -> [Data.Phoneme.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Backness)
                   (b :: Data.Phoneme.Backness) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Phoneme.Backness]
                                    Data.Phoneme.$fEnumBackness_c
                                    (GHC.Types.[] @ Data.Phoneme.Backness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Phoneme.Backness]
                                    Data.Phoneme.$fEnumBackness_c
                                    (GHC.Types.[] @ Data.Phoneme.Backness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 4# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Phoneme.BACK -> $j1 0#
                       Data.Phoneme.NEARBACK -> $j1 1#
                       Data.Phoneme.CENTRAL -> $j1 2#
                       Data.Phoneme.NEARFRONT -> $j1 3#
                       Data.Phoneme.FRONT -> $j1 4# }
                 } in
                 case a of wild {
                   Data.Phoneme.BACK -> $j 0#
                   Data.Phoneme.NEARBACK -> $j 1#
                   Data.Phoneme.CENTRAL -> $j 2#
                   Data.Phoneme.NEARFRONT -> $j 3#
                   Data.Phoneme.FRONT -> $j 4# }) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_$cenumFromThenTo ::
    Data.Phoneme.Backness
    -> Data.Phoneme.Backness
    -> Data.Phoneme.Backness
    -> [Data.Phoneme.Backness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_$cenumFromTo ::
    Data.Phoneme.Backness
    -> Data.Phoneme.Backness -> [Data.Phoneme.Backness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Backness)
                   (y :: Data.Phoneme.Backness) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Phoneme.BACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumBackness_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Backness }
                       Data.Phoneme.NEARBACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumBackness_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Backness }
                       Data.Phoneme.CENTRAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumBackness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Backness }
                       Data.Phoneme.NEARFRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumBackness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Backness }
                       Data.Phoneme.FRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumBackness_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Backness } }
                 } in
                 case x of wild {
                   Data.Phoneme.BACK -> $j 0#
                   Data.Phoneme.NEARBACK -> $j 1#
                   Data.Phoneme.CENTRAL -> $j 2#
                   Data.Phoneme.NEARFRONT -> $j 3#
                   Data.Phoneme.FRONT -> $j 4# }) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_$cfromEnum :: Data.Phoneme.Backness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Phoneme.Backness) ->
                 case w of wild {
                   Data.Phoneme.BACK -> GHC.Types.I# 0#
                   Data.Phoneme.NEARBACK -> GHC.Types.I# 1#
                   Data.Phoneme.CENTRAL -> GHC.Types.I# 2#
                   Data.Phoneme.NEARFRONT -> GHC.Types.I# 3#
                   Data.Phoneme.FRONT -> GHC.Types.I# 4# }) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_$cpred ::
    Data.Phoneme.Backness -> Data.Phoneme.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK -> Data.Phoneme.$fEnumBackness7
                   Data.Phoneme.NEARBACK -> Data.Phoneme.BACK
                   Data.Phoneme.CENTRAL -> Data.Phoneme.NEARBACK
                   Data.Phoneme.NEARFRONT -> Data.Phoneme.CENTRAL
                   Data.Phoneme.FRONT -> Data.Phoneme.NEARFRONT }) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_$csucc ::
    Data.Phoneme.Backness -> Data.Phoneme.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK -> Data.Phoneme.NEARBACK
                   Data.Phoneme.NEARBACK -> Data.Phoneme.CENTRAL
                   Data.Phoneme.CENTRAL -> Data.Phoneme.NEARFRONT
                   Data.Phoneme.NEARFRONT -> Data.Phoneme.FRONT
                   Data.Phoneme.FRONT -> Data.Phoneme.$fEnumBackness8 }) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_$ctoEnum :: GHC.Types.Int -> Data.Phoneme.Backness
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$ctoEnum ww1 }) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_c ::
    GHC.Types.Int -> [Data.Phoneme.Backness] -> [Data.Phoneme.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Backness]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Backness
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Phoneme.Backness a })
                   ys) -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go1 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go2 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go3 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go4 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go5 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go6 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go7 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go8 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEnumBackness_go9 :: GHC.Prim.Int# -> [Data.Phoneme.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight :: GHC.Enum.Enum Data.Phoneme.Height
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Height
                  Data.Phoneme.$fEnumHeight_$csucc
                  Data.Phoneme.$fEnumHeight_$cpred
                  Data.Phoneme.$fEnumHeight_$ctoEnum
                  Data.Phoneme.$fEnumHeight_$cfromEnum
                  Data.Phoneme.$fEnumHeight_$cenumFrom
                  Data.Phoneme.$fEnumHeight_$cenumFromThen
                  Data.Phoneme.$fEnumHeight_$cenumFromTo
                  Data.Phoneme.$fEnumHeight_$cenumFromThenTo -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight1 :: [Data.Phoneme.Height]
  {- Unfolding: (Data.Phoneme.$fEnumHeight_go7 6#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight10 :: Data.Phoneme.Height
  {- Strictness: x -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight2 :: [Data.Phoneme.Height]
  {- Unfolding: (Data.Phoneme.$fEnumHeight_go8 5#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight3 :: [Data.Phoneme.Height]
  {- Unfolding: (Data.Phoneme.$fEnumHeight_go9 4#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight4 :: [Data.Phoneme.Height]
  {- Unfolding: (Data.Phoneme.$fEnumHeight_go10 3#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight5 :: [Data.Phoneme.Height]
  {- Unfolding: (Data.Phoneme.$fEnumHeight_go11 2#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight6 :: [Data.Phoneme.Height]
  {- Unfolding: (Data.Phoneme.$fEnumHeight_go12 1#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight7 :: [Data.Phoneme.Height]
  {- Unfolding: (Data.Phoneme.$fEnumHeight_go13 0#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight8 :: GHC.Prim.Int# -> Data.Phoneme.Height
  {- Arity: 1, Strictness: <L,U>x -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight9 :: Data.Phoneme.Height
  {- Strictness: x -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_$cenumFrom ::
    Data.Phoneme.Height -> [Data.Phoneme.Height]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Height) ->
                 case a of wild {
                   Data.Phoneme.CLOSE -> Data.Phoneme.$fEnumHeight7
                   Data.Phoneme.NEARCLOSE -> Data.Phoneme.$fEnumHeight6
                   Data.Phoneme.CLOSEMID -> Data.Phoneme.$fEnumHeight5
                   Data.Phoneme.MID -> Data.Phoneme.$fEnumHeight4
                   Data.Phoneme.OPENMID -> Data.Phoneme.$fEnumHeight3
                   Data.Phoneme.NEAROPEN -> Data.Phoneme.$fEnumHeight2
                   Data.Phoneme.OPEN -> Data.Phoneme.$fEnumHeight1 }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_$cenumFromThen ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> [Data.Phoneme.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Height)
                   (b :: Data.Phoneme.Height) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Height]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Phoneme.Height]
                                    Data.Phoneme.$fEnumHeight_c
                                    (GHC.Types.[] @ Data.Phoneme.Height)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Phoneme.Height]
                                    Data.Phoneme.$fEnumHeight_c
                                    (GHC.Types.[] @ Data.Phoneme.Height)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Phoneme.CLOSE -> $j1 0#
                       Data.Phoneme.NEARCLOSE -> $j1 1#
                       Data.Phoneme.CLOSEMID -> $j1 2#
                       Data.Phoneme.MID -> $j1 3#
                       Data.Phoneme.OPENMID -> $j1 4#
                       Data.Phoneme.NEAROPEN -> $j1 5#
                       Data.Phoneme.OPEN -> $j1 6# }
                 } in
                 case a of wild {
                   Data.Phoneme.CLOSE -> $j 0#
                   Data.Phoneme.NEARCLOSE -> $j 1#
                   Data.Phoneme.CLOSEMID -> $j 2#
                   Data.Phoneme.MID -> $j 3#
                   Data.Phoneme.OPENMID -> $j 4#
                   Data.Phoneme.NEAROPEN -> $j 5#
                   Data.Phoneme.OPEN -> $j 6# }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_$cenumFromThenTo ::
    Data.Phoneme.Height
    -> Data.Phoneme.Height
    -> Data.Phoneme.Height
    -> [Data.Phoneme.Height]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_$cenumFromTo ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> [Data.Phoneme.Height]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Height)
                   (y :: Data.Phoneme.Height) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Height]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Phoneme.CLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumHeight_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Height }
                       Data.Phoneme.NEARCLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumHeight_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Height }
                       Data.Phoneme.CLOSEMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumHeight_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Height }
                       Data.Phoneme.MID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumHeight_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Height }
                       Data.Phoneme.OPENMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumHeight_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Height }
                       Data.Phoneme.NEAROPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumHeight_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Height }
                       Data.Phoneme.OPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumHeight_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Height } }
                 } in
                 case x of wild {
                   Data.Phoneme.CLOSE -> $j 0#
                   Data.Phoneme.NEARCLOSE -> $j 1#
                   Data.Phoneme.CLOSEMID -> $j 2#
                   Data.Phoneme.MID -> $j 3#
                   Data.Phoneme.OPENMID -> $j 4#
                   Data.Phoneme.NEAROPEN -> $j 5#
                   Data.Phoneme.OPEN -> $j 6# }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_$cfromEnum :: Data.Phoneme.Height -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Phoneme.Height) ->
                 case w of wild {
                   Data.Phoneme.CLOSE -> GHC.Types.I# 0#
                   Data.Phoneme.NEARCLOSE -> GHC.Types.I# 1#
                   Data.Phoneme.CLOSEMID -> GHC.Types.I# 2#
                   Data.Phoneme.MID -> GHC.Types.I# 3#
                   Data.Phoneme.OPENMID -> GHC.Types.I# 4#
                   Data.Phoneme.NEAROPEN -> GHC.Types.I# 5#
                   Data.Phoneme.OPEN -> GHC.Types.I# 6# }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_$cpred :: Data.Phoneme.Height -> Data.Phoneme.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Height) ->
                 case a of wild {
                   Data.Phoneme.CLOSE -> Data.Phoneme.$fEnumHeight9
                   Data.Phoneme.NEARCLOSE -> Data.Phoneme.CLOSE
                   Data.Phoneme.CLOSEMID -> Data.Phoneme.NEARCLOSE
                   Data.Phoneme.MID -> Data.Phoneme.CLOSEMID
                   Data.Phoneme.OPENMID -> Data.Phoneme.MID
                   Data.Phoneme.NEAROPEN -> Data.Phoneme.OPENMID
                   Data.Phoneme.OPEN -> Data.Phoneme.NEAROPEN }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_$csucc :: Data.Phoneme.Height -> Data.Phoneme.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Height) ->
                 case a of wild {
                   Data.Phoneme.CLOSE -> Data.Phoneme.NEARCLOSE
                   Data.Phoneme.NEARCLOSE -> Data.Phoneme.CLOSEMID
                   Data.Phoneme.CLOSEMID -> Data.Phoneme.MID
                   Data.Phoneme.MID -> Data.Phoneme.OPENMID
                   Data.Phoneme.OPENMID -> Data.Phoneme.NEAROPEN
                   Data.Phoneme.NEAROPEN -> Data.Phoneme.OPEN
                   Data.Phoneme.OPEN -> Data.Phoneme.$fEnumHeight10 }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_$ctoEnum :: GHC.Types.Int -> Data.Phoneme.Height
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$ctoEnum1 ww1 }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_c ::
    GHC.Types.Int -> [Data.Phoneme.Height] -> [Data.Phoneme.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Height]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Height
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Phoneme.Height a })
                   ys) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go1 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go10 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go11 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go12 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go13 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go2 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go3 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go4 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go5 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go6 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go7 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go8 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e52daabfd4cc5d18128954ffcda031bb
  $fEnumHeight_go9 :: GHC.Prim.Int# -> [Data.Phoneme.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength :: GHC.Enum.Enum Data.Phoneme.Length
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Length
                  Data.Phoneme.$fEnumLength_$csucc
                  Data.Phoneme.$fEnumLength_$cpred
                  Data.Phoneme.$fEnumLength_$ctoEnum
                  Data.Phoneme.$fEnumLength_$cfromEnum
                  Data.Phoneme.$fEnumLength_$cenumFrom
                  Data.Phoneme.$fEnumLength_$cenumFromThen
                  Data.Phoneme.$fEnumLength_$cenumFromTo
                  Data.Phoneme.$fEnumLength_$cenumFromThenTo -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength1 :: GHC.Prim.Int# -> Data.Phoneme.Length
  {- Arity: 1, Strictness: <L,U>x -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength2 :: [Data.Phoneme.Length]
  {- Unfolding: (Data.Phoneme.$fEnumLength_go3 2#) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength3 :: [Data.Phoneme.Length]
  {- Unfolding: (Data.Phoneme.$fEnumLength_go4 1#) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength4 :: [Data.Phoneme.Length]
  {- Unfolding: (Data.Phoneme.$fEnumLength_go5 0#) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength5 :: Data.Phoneme.Length
  {- Strictness: x -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength6 :: Data.Phoneme.Length
  {- Strictness: x -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_$cenumFrom ::
    Data.Phoneme.Length -> [Data.Phoneme.Length]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT -> Data.Phoneme.$fEnumLength4
                   Data.Phoneme.NORMAL -> Data.Phoneme.$fEnumLength3
                   Data.Phoneme.LONG -> Data.Phoneme.$fEnumLength2 }) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_$cenumFromThen ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> [Data.Phoneme.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Length)
                   (b :: Data.Phoneme.Length) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Length]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Phoneme.Length]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Phoneme.Length]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Phoneme.Length]
                                    Data.Phoneme.$fEnumLength_c1
                                    (GHC.Types.[] @ Data.Phoneme.Length)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Phoneme.Length]
                                    Data.Phoneme.$fEnumLength_c1
                                    (GHC.Types.[] @ Data.Phoneme.Length)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Phoneme.SHORT -> $j1 0#
                       Data.Phoneme.NORMAL -> $j1 1#
                       Data.Phoneme.LONG -> $j1 2# }
                 } in
                 case a of wild {
                   Data.Phoneme.SHORT -> $j 0#
                   Data.Phoneme.NORMAL -> $j 1#
                   Data.Phoneme.LONG -> $j 2# }) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_$cenumFromThenTo ::
    Data.Phoneme.Length
    -> Data.Phoneme.Length
    -> Data.Phoneme.Length
    -> [Data.Phoneme.Length]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Phoneme.Length)
                   (x2 :: Data.Phoneme.Length)
                   (y :: Data.Phoneme.Length) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Length]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Phoneme.Length]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Phoneme.SHORT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Phoneme.Length]
                                     Data.Phoneme.$fEnumLength_c
                                     (GHC.Types.[] @ Data.Phoneme.Length)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Phoneme.Length]
                                     Data.Phoneme.$fEnumLength_c
                                     (GHC.Types.[] @ Data.Phoneme.Length)
                                     x4
                                     x5
                                     0# }
                           Data.Phoneme.NORMAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Phoneme.Length]
                                     Data.Phoneme.$fEnumLength_c
                                     (GHC.Types.[] @ Data.Phoneme.Length)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Phoneme.Length]
                                     Data.Phoneme.$fEnumLength_c
                                     (GHC.Types.[] @ Data.Phoneme.Length)
                                     x4
                                     x5
                                     1# }
                           Data.Phoneme.LONG
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Phoneme.Length]
                                     Data.Phoneme.$fEnumLength_c
                                     (GHC.Types.[] @ Data.Phoneme.Length)
                                     x4
                                     x5
                                     2#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Phoneme.Length]
                                     Data.Phoneme.$fEnumLength_c
                                     (GHC.Types.[] @ Data.Phoneme.Length)
                                     x4
                                     x5
                                     2# } }
                     } in
                     case x2 of wild {
                       Data.Phoneme.SHORT -> $j1 0#
                       Data.Phoneme.NORMAL -> $j1 1#
                       Data.Phoneme.LONG -> $j1 2# }
                 } in
                 case x1 of wild {
                   Data.Phoneme.SHORT -> $j 0#
                   Data.Phoneme.NORMAL -> $j 1#
                   Data.Phoneme.LONG -> $j 2# }) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_$cenumFromTo ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> [Data.Phoneme.Length]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Length)
                   (y :: Data.Phoneme.Length) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Length]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Phoneme.SHORT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumLength_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Length }
                       Data.Phoneme.NORMAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumLength_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Length }
                       Data.Phoneme.LONG
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumLength_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Length } }
                 } in
                 case x of wild {
                   Data.Phoneme.SHORT -> $j 0#
                   Data.Phoneme.NORMAL -> $j 1#
                   Data.Phoneme.LONG -> $j 2# }) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_$cfromEnum :: Data.Phoneme.Length -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT -> GHC.Types.I# 0#
                   Data.Phoneme.NORMAL -> GHC.Types.I# 1#
                   Data.Phoneme.LONG -> GHC.Types.I# 2# }) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_$cpred :: Data.Phoneme.Length -> Data.Phoneme.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT -> Data.Phoneme.$fEnumLength5
                   Data.Phoneme.NORMAL -> Data.Phoneme.SHORT
                   Data.Phoneme.LONG -> Data.Phoneme.NORMAL }) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_$csucc :: Data.Phoneme.Length -> Data.Phoneme.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT -> Data.Phoneme.NORMAL
                   Data.Phoneme.NORMAL -> Data.Phoneme.LONG
                   Data.Phoneme.LONG -> Data.Phoneme.$fEnumLength6 }) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_$ctoEnum :: GHC.Types.Int -> Data.Phoneme.Length
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$ctoEnum2 ww1 }) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_c ::
    GHC.Types.Int -> [Data.Phoneme.Length] -> [Data.Phoneme.Length]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Length]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Length
                   (Data.Phoneme.$fEnumLength_$ctoEnum x)
                   ys) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_c1 ::
    GHC.Types.Int -> [Data.Phoneme.Length] -> [Data.Phoneme.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Length]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Length
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Phoneme.Length a })
                   ys) -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_go :: GHC.Prim.Int# -> [Data.Phoneme.Length]
  {- Arity: 1, Strictness: <L,U> -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_go1 :: GHC.Prim.Int# -> [Data.Phoneme.Length]
  {- Arity: 1, Strictness: <L,U> -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_go2 :: GHC.Prim.Int# -> [Data.Phoneme.Length]
  {- Arity: 1, Strictness: <L,U> -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_go3 :: GHC.Prim.Int# -> [Data.Phoneme.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_go4 :: GHC.Prim.Int# -> [Data.Phoneme.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
3bc911798122c419c4b3747def87cb7a
  $fEnumLength_go5 :: GHC.Prim.Int# -> [Data.Phoneme.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
457727c142c08ed8e753e8053528da14
  $fEnumManner :: GHC.Enum.Enum Data.Phoneme.Manner
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Manner
                  Data.Phoneme.$fEnumManner_$csucc
                  Data.Phoneme.$fEnumManner_$cpred
                  Data.Phoneme.$fEnumManner_$ctoEnum
                  Data.Phoneme.$fEnumManner_$cfromEnum
                  Data.Phoneme.$fEnumManner_$cenumFrom
                  Data.Phoneme.$fEnumManner_$cenumFromThen
                  Data.Phoneme.$fEnumManner_$cenumFromTo
                  Data.Phoneme.$fEnumManner_$cenumFromThenTo -}
457727c142c08ed8e753e8053528da14
  $fEnumManner1 :: GHC.Prim.Int# -> Data.Phoneme.Manner
  {- Arity: 1, Strictness: <L,U>x -}
457727c142c08ed8e753e8053528da14
  $fEnumManner2 :: Data.Phoneme.Manner
  {- Strictness: x -}
457727c142c08ed8e753e8053528da14
  $fEnumManner3 :: Data.Phoneme.Manner
  {- Strictness: x -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_$cenumFrom ::
    Data.Phoneme.Manner -> [Data.Phoneme.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Manner) ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner a
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 12#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumManner_go x0
                   GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Manner }) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_$cenumFromThen ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> [Data.Phoneme.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Manner)
                   (b :: Data.Phoneme.Manner) ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner a
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner b
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Manner]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (y :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [Data.Phoneme.Manner]
                            Data.Phoneme.$fEnumManner_c1
                            (GHC.Types.[] @ Data.Phoneme.Manner)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [Data.Phoneme.Manner]
                            Data.Phoneme.$fEnumManner_c1
                            (GHC.Types.[] @ Data.Phoneme.Manner)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 12# GHC.Types.True -> $j 0# }) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_$cenumFromThenTo ::
    Data.Phoneme.Manner
    -> Data.Phoneme.Manner
    -> Data.Phoneme.Manner
    -> [Data.Phoneme.Manner]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Phoneme.Manner)
                   (x2 :: Data.Phoneme.Manner)
                   (y :: Data.Phoneme.Manner) ->
                 let {
                   x4 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1
                 } in
                 let {
                   x5 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x5 x4) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [Data.Phoneme.Manner]
                        Data.Phoneme.$fEnumManner_c
                        (GHC.Types.[] @ Data.Phoneme.Manner)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Data.Phoneme.Manner y)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [Data.Phoneme.Manner]
                        Data.Phoneme.$fEnumManner_c
                        (GHC.Types.[] @ Data.Phoneme.Manner)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Data.Phoneme.Manner y) }) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_$cenumFromTo ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> [Data.Phoneme.Manner]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Manner)
                   (y :: Data.Phoneme.Manner) ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner x
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner y
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go25 :: GHC.Prim.Int# -> [Data.Phoneme.Manner]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Prim.Int#) ->
                          GHC.Types.:
                            @ Data.Phoneme.Manner
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x1 0#) of wild1 {
                               GHC.Types.False -> Data.Phoneme.$fEnumManner1 x1
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x1 12#) of wild2 {
                                    GHC.Types.False -> Data.Phoneme.$fEnumManner1 x1
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ Data.Phoneme.Manner x1 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x1 y1) of wild1 {
                               GHC.Types.False -> go25 (GHC.Prim.+# x1 1#)
                               GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Manner })
                      } in
                      go25 x0
                   GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Manner }) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_$cfromEnum :: Data.Phoneme.Manner -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1) }) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_$cpred :: Data.Phoneme.Manner -> Data.Phoneme.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ Data.Phoneme.Manner (GHC.Prim.+# wild -1#)
                   0# -> Data.Phoneme.$fEnumManner2 } }) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_$csucc :: Data.Phoneme.Manner -> Data.Phoneme.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ Data.Phoneme.Manner (GHC.Prim.+# wild 1#)
                   12# -> Data.Phoneme.$fEnumManner3 } }) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_$ctoEnum :: GHC.Types.Int -> Data.Phoneme.Manner
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$ctoEnum3 ww1 }) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_c ::
    GHC.Types.Int -> [Data.Phoneme.Manner] -> [Data.Phoneme.Manner]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Manner]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Manner
                   (Data.Phoneme.$fEnumManner_$ctoEnum x)
                   ys) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_c1 ::
    GHC.Types.Int -> [Data.Phoneme.Manner] -> [Data.Phoneme.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Manner]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Manner
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Phoneme.Manner a })
                   ys) -}
457727c142c08ed8e753e8053528da14
  $fEnumManner_go :: GHC.Prim.Int# -> [Data.Phoneme.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation :: GHC.Enum.Enum Data.Phoneme.Phonation
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phonation
                  Data.Phoneme.$fEnumPhonation_$csucc
                  Data.Phoneme.$fEnumPhonation_$cpred
                  Data.Phoneme.$fEnumPhonation_$ctoEnum
                  Data.Phoneme.$fEnumPhonation_$cfromEnum
                  Data.Phoneme.$fEnumPhonation_$cenumFrom
                  Data.Phoneme.$fEnumPhonation_$cenumFromThen
                  Data.Phoneme.$fEnumPhonation_$cenumFromTo
                  Data.Phoneme.$fEnumPhonation_$cenumFromThenTo -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation1 :: [Data.Phoneme.Phonation]
  {- Unfolding: (Data.Phoneme.$fEnumPhonation_go7 6#) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation10 :: Data.Phoneme.Phonation
  {- Strictness: x -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation2 :: [Data.Phoneme.Phonation]
  {- Unfolding: (Data.Phoneme.$fEnumPhonation_go8 5#) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation3 :: [Data.Phoneme.Phonation]
  {- Unfolding: (Data.Phoneme.$fEnumPhonation_go9 4#) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation4 :: [Data.Phoneme.Phonation]
  {- Unfolding: (Data.Phoneme.$fEnumPhonation_go10 3#) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation5 :: [Data.Phoneme.Phonation]
  {- Unfolding: (Data.Phoneme.$fEnumPhonation_go11 2#) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation6 :: [Data.Phoneme.Phonation]
  {- Unfolding: (Data.Phoneme.$fEnumPhonation_go12 1#) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation7 :: [Data.Phoneme.Phonation]
  {- Unfolding: (Data.Phoneme.$fEnumPhonation_go13 0#) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation8 :: GHC.Prim.Int# -> Data.Phoneme.Phonation
  {- Arity: 1, Strictness: <L,U>x -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation9 :: Data.Phoneme.Phonation
  {- Strictness: x -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_$cenumFrom ::
    Data.Phoneme.Phonation -> [Data.Phoneme.Phonation]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Phonation) ->
                 case a of wild {
                   Data.Phoneme.VOICELESS -> Data.Phoneme.$fEnumPhonation7
                   Data.Phoneme.BREATHY -> Data.Phoneme.$fEnumPhonation6
                   Data.Phoneme.SLACK -> Data.Phoneme.$fEnumPhonation5
                   Data.Phoneme.MODAL -> Data.Phoneme.$fEnumPhonation4
                   Data.Phoneme.STIFF -> Data.Phoneme.$fEnumPhonation3
                   Data.Phoneme.CREAKY -> Data.Phoneme.$fEnumPhonation2
                   Data.Phoneme.ASPIRATED -> Data.Phoneme.$fEnumPhonation1 }) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_$cenumFromThen ::
    Data.Phoneme.Phonation
    -> Data.Phoneme.Phonation -> [Data.Phoneme.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Phonation)
                   (b :: Data.Phoneme.Phonation) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Phoneme.Phonation]
                                    Data.Phoneme.$fEnumPhonation_c
                                    (GHC.Types.[] @ Data.Phoneme.Phonation)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Phoneme.Phonation]
                                    Data.Phoneme.$fEnumPhonation_c
                                    (GHC.Types.[] @ Data.Phoneme.Phonation)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Phoneme.VOICELESS -> $j1 0#
                       Data.Phoneme.BREATHY -> $j1 1#
                       Data.Phoneme.SLACK -> $j1 2#
                       Data.Phoneme.MODAL -> $j1 3#
                       Data.Phoneme.STIFF -> $j1 4#
                       Data.Phoneme.CREAKY -> $j1 5#
                       Data.Phoneme.ASPIRATED -> $j1 6# }
                 } in
                 case a of wild {
                   Data.Phoneme.VOICELESS -> $j 0#
                   Data.Phoneme.BREATHY -> $j 1#
                   Data.Phoneme.SLACK -> $j 2#
                   Data.Phoneme.MODAL -> $j 3#
                   Data.Phoneme.STIFF -> $j 4#
                   Data.Phoneme.CREAKY -> $j 5#
                   Data.Phoneme.ASPIRATED -> $j 6# }) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_$cenumFromThenTo ::
    Data.Phoneme.Phonation
    -> Data.Phoneme.Phonation
    -> Data.Phoneme.Phonation
    -> [Data.Phoneme.Phonation]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_$cenumFromTo ::
    Data.Phoneme.Phonation
    -> Data.Phoneme.Phonation -> [Data.Phoneme.Phonation]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Phonation)
                   (y :: Data.Phoneme.Phonation) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Phoneme.VOICELESS
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumPhonation_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Phonation }
                       Data.Phoneme.BREATHY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumPhonation_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Phonation }
                       Data.Phoneme.SLACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumPhonation_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Phonation }
                       Data.Phoneme.MODAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumPhonation_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Phonation }
                       Data.Phoneme.STIFF
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumPhonation_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Phonation }
                       Data.Phoneme.CREAKY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumPhonation_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Phonation }
                       Data.Phoneme.ASPIRATED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumPhonation_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Phonation } }
                 } in
                 case x of wild {
                   Data.Phoneme.VOICELESS -> $j 0#
                   Data.Phoneme.BREATHY -> $j 1#
                   Data.Phoneme.SLACK -> $j 2#
                   Data.Phoneme.MODAL -> $j 3#
                   Data.Phoneme.STIFF -> $j 4#
                   Data.Phoneme.CREAKY -> $j 5#
                   Data.Phoneme.ASPIRATED -> $j 6# }) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_$cfromEnum ::
    Data.Phoneme.Phonation -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Phoneme.Phonation) ->
                 case w of wild {
                   Data.Phoneme.VOICELESS -> GHC.Types.I# 0#
                   Data.Phoneme.BREATHY -> GHC.Types.I# 1#
                   Data.Phoneme.SLACK -> GHC.Types.I# 2#
                   Data.Phoneme.MODAL -> GHC.Types.I# 3#
                   Data.Phoneme.STIFF -> GHC.Types.I# 4#
                   Data.Phoneme.CREAKY -> GHC.Types.I# 5#
                   Data.Phoneme.ASPIRATED -> GHC.Types.I# 6# }) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_$cpred ::
    Data.Phoneme.Phonation -> Data.Phoneme.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Phonation) ->
                 case a of wild {
                   Data.Phoneme.VOICELESS -> Data.Phoneme.$fEnumPhonation9
                   Data.Phoneme.BREATHY -> Data.Phoneme.VOICELESS
                   Data.Phoneme.SLACK -> Data.Phoneme.BREATHY
                   Data.Phoneme.MODAL -> Data.Phoneme.SLACK
                   Data.Phoneme.STIFF -> Data.Phoneme.MODAL
                   Data.Phoneme.CREAKY -> Data.Phoneme.STIFF
                   Data.Phoneme.ASPIRATED -> Data.Phoneme.CREAKY }) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_$csucc ::
    Data.Phoneme.Phonation -> Data.Phoneme.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Phonation) ->
                 case a of wild {
                   Data.Phoneme.VOICELESS -> Data.Phoneme.BREATHY
                   Data.Phoneme.BREATHY -> Data.Phoneme.SLACK
                   Data.Phoneme.SLACK -> Data.Phoneme.MODAL
                   Data.Phoneme.MODAL -> Data.Phoneme.STIFF
                   Data.Phoneme.STIFF -> Data.Phoneme.CREAKY
                   Data.Phoneme.CREAKY -> Data.Phoneme.ASPIRATED
                   Data.Phoneme.ASPIRATED -> Data.Phoneme.$fEnumPhonation10 }) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_$ctoEnum :: GHC.Types.Int -> Data.Phoneme.Phonation
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$ctoEnum4 ww1 }) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_c ::
    GHC.Types.Int
    -> [Data.Phoneme.Phonation] -> [Data.Phoneme.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Phonation]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Phonation
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Phoneme.Phonation a })
                   ys) -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go1 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go10 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go11 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go12 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go13 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go2 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go3 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go4 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go5 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go6 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go7 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go8 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ff541d1764888145304960d9b00dcecd
  $fEnumPhonation_go9 :: GHC.Prim.Int# -> [Data.Phoneme.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace :: GHC.Enum.Enum Data.Phoneme.Place
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Place
                  Data.Phoneme.$fEnumPlace_$csucc
                  Data.Phoneme.$fEnumPlace_$cpred
                  Data.Phoneme.$fEnumPlace_$ctoEnum
                  Data.Phoneme.$fEnumPlace_$cfromEnum
                  Data.Phoneme.$fEnumPlace_$cenumFrom
                  Data.Phoneme.$fEnumPlace_$cenumFromThen
                  Data.Phoneme.$fEnumPlace_$cenumFromTo
                  Data.Phoneme.$fEnumPlace_$cenumFromThenTo -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace1 :: GHC.Prim.Int# -> Data.Phoneme.Place
  {- Arity: 1, Strictness: <L,U>x -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace2 :: Data.Phoneme.Place
  {- Strictness: x -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace3 :: Data.Phoneme.Place
  {- Strictness: x -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_$cenumFrom ::
    Data.Phoneme.Place -> [Data.Phoneme.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Place) ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place a
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 18#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumPlace_go x0
                   GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Place }) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_$cenumFromThen ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> [Data.Phoneme.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Place)
                   (b :: Data.Phoneme.Place) ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place a
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place b
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Place]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (y :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [Data.Phoneme.Place]
                            Data.Phoneme.$fEnumPlace_c1
                            (GHC.Types.[] @ Data.Phoneme.Place)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [Data.Phoneme.Place]
                            Data.Phoneme.$fEnumPlace_c1
                            (GHC.Types.[] @ Data.Phoneme.Place)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 18# GHC.Types.True -> $j 0# }) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_$cenumFromThenTo ::
    Data.Phoneme.Place
    -> Data.Phoneme.Place -> Data.Phoneme.Place -> [Data.Phoneme.Place]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Phoneme.Place)
                   (x2 :: Data.Phoneme.Place)
                   (y :: Data.Phoneme.Place) ->
                 let {
                   x4 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place x1
                 } in
                 let {
                   x5 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x5 x4) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [Data.Phoneme.Place]
                        Data.Phoneme.$fEnumPlace_c
                        (GHC.Types.[] @ Data.Phoneme.Place)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Data.Phoneme.Place y)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [Data.Phoneme.Place]
                        Data.Phoneme.$fEnumPlace_c
                        (GHC.Types.[] @ Data.Phoneme.Place)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Data.Phoneme.Place y) }) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_$cenumFromTo ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> [Data.Phoneme.Place]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Place)
                   (y :: Data.Phoneme.Place) ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place x
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place y
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go25 :: GHC.Prim.Int# -> [Data.Phoneme.Place]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Prim.Int#) ->
                          GHC.Types.:
                            @ Data.Phoneme.Place
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x1 0#) of wild1 {
                               GHC.Types.False -> Data.Phoneme.$fEnumPlace1 x1
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x1 18#) of wild2 {
                                    GHC.Types.False -> Data.Phoneme.$fEnumPlace1 x1
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ Data.Phoneme.Place x1 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x1 y1) of wild1 {
                               GHC.Types.False -> go25 (GHC.Prim.+# x1 1#)
                               GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Place })
                      } in
                      go25 x0
                   GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Place }) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_$cfromEnum :: Data.Phoneme.Place -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1) }) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_$cpred :: Data.Phoneme.Place -> Data.Phoneme.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Data.Phoneme.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ Data.Phoneme.Place (GHC.Prim.+# wild -1#)
                   0# -> Data.Phoneme.$fEnumPlace2 } }) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_$csucc :: Data.Phoneme.Place -> Data.Phoneme.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Data.Phoneme.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ Data.Phoneme.Place (GHC.Prim.+# wild 1#)
                   18# -> Data.Phoneme.$fEnumPlace3 } }) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_$ctoEnum :: GHC.Types.Int -> Data.Phoneme.Place
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$ctoEnum5 ww1 }) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_c ::
    GHC.Types.Int -> [Data.Phoneme.Place] -> [Data.Phoneme.Place]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Place]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Place
                   (Data.Phoneme.$fEnumPlace_$ctoEnum x)
                   ys) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_c1 ::
    GHC.Types.Int -> [Data.Phoneme.Place] -> [Data.Phoneme.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Place]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Place
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Phoneme.Place a })
                   ys) -}
1971716d79acadd98b648de5350e6f24
  $fEnumPlace_go :: GHC.Prim.Int# -> [Data.Phoneme.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness :: GHC.Enum.Enum Data.Phoneme.Roundedness
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Roundedness
                  Data.Phoneme.$fEnumRoundedness_$csucc
                  Data.Phoneme.$fEnumRoundedness_$cpred
                  Data.Phoneme.$fEnumRoundedness_$ctoEnum
                  Data.Phoneme.$fEnumRoundedness_$cfromEnum
                  Data.Phoneme.$fEnumRoundedness_$cenumFrom
                  Data.Phoneme.$fEnumRoundedness_$cenumFromThen
                  Data.Phoneme.$fEnumRoundedness_$cenumFromTo
                  Data.Phoneme.$fEnumRoundedness_$cenumFromThenTo -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness1 :: GHC.Prim.Int# -> Data.Phoneme.Roundedness
  {- Arity: 1, Strictness: <L,U>x -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness2 :: [Data.Phoneme.Roundedness]
  {- Unfolding: (Data.Phoneme.$fEnumRoundedness_go3 2#) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness3 :: [Data.Phoneme.Roundedness]
  {- Unfolding: (Data.Phoneme.$fEnumRoundedness_go4 1#) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness4 :: [Data.Phoneme.Roundedness]
  {- Unfolding: (Data.Phoneme.$fEnumRoundedness_go5 0#) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness5 :: Data.Phoneme.Roundedness
  {- Strictness: x -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness6 :: Data.Phoneme.Roundedness
  {- Strictness: x -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_$cenumFrom ::
    Data.Phoneme.Roundedness -> [Data.Phoneme.Roundedness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT -> Data.Phoneme.$fEnumRoundedness4
                   Data.Phoneme.ROUNDED -> Data.Phoneme.$fEnumRoundedness3
                   Data.Phoneme.UNROUNDED -> Data.Phoneme.$fEnumRoundedness2 }) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_$cenumFromThen ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> [Data.Phoneme.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Roundedness)
                   (b :: Data.Phoneme.Roundedness) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (b# :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (y :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [Data.Phoneme.Roundedness]
                                    Data.Phoneme.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ Data.Phoneme.Roundedness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [Data.Phoneme.Roundedness]
                                    Data.Phoneme.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ Data.Phoneme.Roundedness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2# GHC.Types.True -> $j2 0# }
                     } in
                     case b of wild {
                       Data.Phoneme.DEFAULT -> $j1 0#
                       Data.Phoneme.ROUNDED -> $j1 1#
                       Data.Phoneme.UNROUNDED -> $j1 2# }
                 } in
                 case a of wild {
                   Data.Phoneme.DEFAULT -> $j 0#
                   Data.Phoneme.ROUNDED -> $j 1#
                   Data.Phoneme.UNROUNDED -> $j 2# }) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_$cenumFromThenTo ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness
    -> [Data.Phoneme.Roundedness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Phoneme.Roundedness)
                   (x2 :: Data.Phoneme.Roundedness)
                   (y :: Data.Phoneme.Roundedness) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Data.Phoneme.DEFAULT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Phoneme.Roundedness]
                                     Data.Phoneme.$fEnumRoundedness_c
                                     (GHC.Types.[] @ Data.Phoneme.Roundedness)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Phoneme.Roundedness]
                                     Data.Phoneme.$fEnumRoundedness_c
                                     (GHC.Types.[] @ Data.Phoneme.Roundedness)
                                     x4
                                     x5
                                     0# }
                           Data.Phoneme.ROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Phoneme.Roundedness]
                                     Data.Phoneme.$fEnumRoundedness_c
                                     (GHC.Types.[] @ Data.Phoneme.Roundedness)
                                     x4
                                     x5
                                     1#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Phoneme.Roundedness]
                                     Data.Phoneme.$fEnumRoundedness_c
                                     (GHC.Types.[] @ Data.Phoneme.Roundedness)
                                     x4
                                     x5
                                     1# }
                           Data.Phoneme.UNROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Data.Phoneme.Roundedness]
                                     Data.Phoneme.$fEnumRoundedness_c
                                     (GHC.Types.[] @ Data.Phoneme.Roundedness)
                                     x4
                                     x5
                                     2#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Data.Phoneme.Roundedness]
                                     Data.Phoneme.$fEnumRoundedness_c
                                     (GHC.Types.[] @ Data.Phoneme.Roundedness)
                                     x4
                                     x5
                                     2# } }
                     } in
                     case x2 of wild {
                       Data.Phoneme.DEFAULT -> $j1 0#
                       Data.Phoneme.ROUNDED -> $j1 1#
                       Data.Phoneme.UNROUNDED -> $j1 2# }
                 } in
                 case x1 of wild {
                   Data.Phoneme.DEFAULT -> $j 0#
                   Data.Phoneme.ROUNDED -> $j 1#
                   Data.Phoneme.UNROUNDED -> $j 2# }) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_$cenumFromTo ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> [Data.Phoneme.Roundedness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Roundedness)
                   (y :: Data.Phoneme.Roundedness) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Data.Phoneme.DEFAULT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumRoundedness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Roundedness }
                       Data.Phoneme.ROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumRoundedness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Roundedness }
                       Data.Phoneme.UNROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2#) of wild1 {
                            GHC.Types.False -> Data.Phoneme.$fEnumRoundedness_go x1
                            GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Roundedness } }
                 } in
                 case x of wild {
                   Data.Phoneme.DEFAULT -> $j 0#
                   Data.Phoneme.ROUNDED -> $j 1#
                   Data.Phoneme.UNROUNDED -> $j 2# }) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_$cfromEnum ::
    Data.Phoneme.Roundedness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT -> GHC.Types.I# 0#
                   Data.Phoneme.ROUNDED -> GHC.Types.I# 1#
                   Data.Phoneme.UNROUNDED -> GHC.Types.I# 2# }) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_$cpred ::
    Data.Phoneme.Roundedness -> Data.Phoneme.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT -> Data.Phoneme.$fEnumRoundedness5
                   Data.Phoneme.ROUNDED -> Data.Phoneme.DEFAULT
                   Data.Phoneme.UNROUNDED -> Data.Phoneme.ROUNDED }) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_$csucc ::
    Data.Phoneme.Roundedness -> Data.Phoneme.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT -> Data.Phoneme.ROUNDED
                   Data.Phoneme.ROUNDED -> Data.Phoneme.UNROUNDED
                   Data.Phoneme.UNROUNDED -> Data.Phoneme.$fEnumRoundedness6 }) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_$ctoEnum ::
    GHC.Types.Int -> Data.Phoneme.Roundedness
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$ctoEnum6 ww1 }) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_c ::
    GHC.Types.Int
    -> [Data.Phoneme.Roundedness] -> [Data.Phoneme.Roundedness]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Roundedness]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Roundedness
                   (Data.Phoneme.$fEnumRoundedness_$ctoEnum x)
                   ys) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_c1 ::
    GHC.Types.Int
    -> [Data.Phoneme.Roundedness] -> [Data.Phoneme.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Roundedness]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Roundedness
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Phoneme.Roundedness a })
                   ys) -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_go :: GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_go1 ::
    GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_go2 ::
    GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_go3 ::
    GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_go4 ::
    GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
974abd7cc25c83307948d0001b49f38e
  $fEnumRoundedness_go5 ::
    GHC.Prim.Int# -> [Data.Phoneme.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone :: GHC.Enum.Enum Data.Phoneme.Tone
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Tone
                  Data.Phoneme.$fEnumTone_$csucc
                  Data.Phoneme.$fEnumTone_$cpred
                  Data.Phoneme.$fEnumTone_$ctoEnum
                  Data.Phoneme.$fEnumTone_$cfromEnum
                  Data.Phoneme.$fEnumTone_$cenumFrom
                  Data.Phoneme.$fEnumTone_$cenumFromThen
                  Data.Phoneme.$fEnumTone_$cenumFromTo
                  Data.Phoneme.$fEnumTone_$cenumFromThenTo -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone1 :: GHC.Prim.Int# -> Data.Phoneme.Tone
  {- Arity: 1, Strictness: <L,U>x -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone2 :: Data.Phoneme.Tone
  {- Strictness: x -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone3 :: Data.Phoneme.Tone
  {- Strictness: x -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_$cenumFrom :: Data.Phoneme.Tone -> [Data.Phoneme.Tone]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Tone) ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone a
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 13#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumTone_go x0
                   GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Tone }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_$cenumFromThen ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> [Data.Phoneme.Tone]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Tone) (b :: Data.Phoneme.Tone) ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone a
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone b
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [Data.Phoneme.Tone]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (y :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [Data.Phoneme.Tone]
                            Data.Phoneme.$fEnumTone_c1
                            (GHC.Types.[] @ Data.Phoneme.Tone)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [Data.Phoneme.Tone]
                            Data.Phoneme.$fEnumTone_c1
                            (GHC.Types.[] @ Data.Phoneme.Tone)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 13# GHC.Types.True -> $j 0# }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_$cenumFromThenTo ::
    Data.Phoneme.Tone
    -> Data.Phoneme.Tone -> Data.Phoneme.Tone -> [Data.Phoneme.Tone]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Data.Phoneme.Tone)
                   (x2 :: Data.Phoneme.Tone)
                   (y :: Data.Phoneme.Tone) ->
                 let {
                   x4 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1
                 } in
                 let {
                   x5 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x5 x4) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [Data.Phoneme.Tone]
                        Data.Phoneme.$fEnumTone_c
                        (GHC.Types.[] @ Data.Phoneme.Tone)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Data.Phoneme.Tone y)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [Data.Phoneme.Tone]
                        Data.Phoneme.$fEnumTone_c
                        (GHC.Types.[] @ Data.Phoneme.Tone)
                        x4
                        x5
                        (GHC.Prim.dataToTag# @ Data.Phoneme.Tone y) }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_$cenumFromTo ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> [Data.Phoneme.Tone]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Tone) (y :: Data.Phoneme.Tone) ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone x
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone y
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go25 :: GHC.Prim.Int# -> [Data.Phoneme.Tone]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Prim.Int#) ->
                          GHC.Types.:
                            @ Data.Phoneme.Tone
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x1 0#) of wild1 {
                               GHC.Types.False -> Data.Phoneme.$fEnumTone1 x1
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x1 13#) of wild2 {
                                    GHC.Types.False -> Data.Phoneme.$fEnumTone1 x1
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ Data.Phoneme.Tone x1 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x1 y1) of wild1 {
                               GHC.Types.False -> go25 (GHC.Prim.+# x1 1#)
                               GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Tone })
                      } in
                      go25 x0
                   GHC.Types.True -> GHC.Types.[] @ Data.Phoneme.Tone }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_$cfromEnum :: Data.Phoneme.Tone -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1) }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_$cpred :: Data.Phoneme.Tone -> Data.Phoneme.Tone
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ Data.Phoneme.Tone (GHC.Prim.+# wild -1#)
                   0# -> Data.Phoneme.$fEnumTone2 } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_$csucc :: Data.Phoneme.Tone -> Data.Phoneme.Tone
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (a :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ Data.Phoneme.Tone (GHC.Prim.+# wild 1#)
                   13# -> Data.Phoneme.$fEnumTone3 } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_$ctoEnum :: GHC.Types.Int -> Data.Phoneme.Tone
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$ctoEnum7 ww1 }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_c ::
    GHC.Types.Int -> [Data.Phoneme.Tone] -> [Data.Phoneme.Tone]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Tone]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Tone
                   (Data.Phoneme.$fEnumTone_$ctoEnum x)
                   ys) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_c1 ::
    GHC.Types.Int -> [Data.Phoneme.Tone] -> [Data.Phoneme.Tone]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Data.Phoneme.Tone]) ->
                 GHC.Types.:
                   @ Data.Phoneme.Tone
                   (case x of wild { GHC.Types.I# a ->
                    GHC.Prim.tagToEnum# @ Data.Phoneme.Tone a })
                   ys) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEnumTone_go :: GHC.Prim.Int# -> [Data.Phoneme.Tone]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a3d34da76e787829b1272672cb3d501f
  $fEqBackness :: GHC.Classes.Eq Data.Phoneme.Backness
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Backness
                  Data.Phoneme.$fEqBackness_$c==
                  Data.Phoneme.$fEqBackness_$c/= -}
a3d34da76e787829b1272672cb3d501f
  $fEqBackness_$c/= ::
    Data.Phoneme.Backness -> Data.Phoneme.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Backness)
                   (b :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.BACK -> GHC.Types.False }
                   Data.Phoneme.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.NEARBACK -> GHC.Types.False }
                   Data.Phoneme.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.CENTRAL -> GHC.Types.False }
                   Data.Phoneme.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.NEARFRONT -> GHC.Types.False }
                   Data.Phoneme.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.FRONT -> GHC.Types.False } }) -}
a3d34da76e787829b1272672cb3d501f
  $fEqBackness_$c== ::
    Data.Phoneme.Backness -> Data.Phoneme.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Phoneme.Backness)
                   (ds1 :: Data.Phoneme.Backness) ->
                 case ds of wild {
                   Data.Phoneme.BACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.BACK -> GHC.Types.True }
                   Data.Phoneme.NEARBACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.NEARBACK -> GHC.Types.True }
                   Data.Phoneme.CENTRAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.CENTRAL -> GHC.Types.True }
                   Data.Phoneme.NEARFRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.NEARFRONT -> GHC.Types.True }
                   Data.Phoneme.FRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.FRONT -> GHC.Types.True } }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEqHeight :: GHC.Classes.Eq Data.Phoneme.Height
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Height
                  Data.Phoneme.$fEqHeight_$c==
                  Data.Phoneme.$fEqHeight_$c/= -}
e52daabfd4cc5d18128954ffcda031bb
  $fEqHeight_$c/= ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Height)
                   (b :: Data.Phoneme.Height) ->
                 case a of wild {
                   Data.Phoneme.CLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.CLOSE -> GHC.Types.False }
                   Data.Phoneme.NEARCLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.NEARCLOSE -> GHC.Types.False }
                   Data.Phoneme.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.CLOSEMID -> GHC.Types.False }
                   Data.Phoneme.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.MID -> GHC.Types.False }
                   Data.Phoneme.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.OPENMID -> GHC.Types.False }
                   Data.Phoneme.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.NEAROPEN -> GHC.Types.False }
                   Data.Phoneme.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.OPEN -> GHC.Types.False } }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fEqHeight_$c== ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Phoneme.Height)
                   (ds1 :: Data.Phoneme.Height) ->
                 case ds of wild {
                   Data.Phoneme.CLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.CLOSE -> GHC.Types.True }
                   Data.Phoneme.NEARCLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.NEARCLOSE -> GHC.Types.True }
                   Data.Phoneme.CLOSEMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.CLOSEMID -> GHC.Types.True }
                   Data.Phoneme.MID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.MID -> GHC.Types.True }
                   Data.Phoneme.OPENMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.OPENMID -> GHC.Types.True }
                   Data.Phoneme.NEAROPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.NEAROPEN -> GHC.Types.True }
                   Data.Phoneme.OPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.OPEN -> GHC.Types.True } }) -}
3bc911798122c419c4b3747def87cb7a
  $fEqLength :: GHC.Classes.Eq Data.Phoneme.Length
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Length
                  Data.Phoneme.$fEqLength_$c==
                  Data.Phoneme.$fEqLength_$c/= -}
3bc911798122c419c4b3747def87cb7a
  $fEqLength_$c/= ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Length) (b :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.SHORT -> GHC.Types.False }
                   Data.Phoneme.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.NORMAL -> GHC.Types.False }
                   Data.Phoneme.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.LONG -> GHC.Types.False } }) -}
3bc911798122c419c4b3747def87cb7a
  $fEqLength_$c== ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Phoneme.Length) (ds1 :: Data.Phoneme.Length) ->
                 case ds of wild {
                   Data.Phoneme.SHORT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.SHORT -> GHC.Types.True }
                   Data.Phoneme.NORMAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.NORMAL -> GHC.Types.True }
                   Data.Phoneme.LONG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.LONG -> GHC.Types.True } }) -}
457727c142c08ed8e753e8053528da14
  $fEqManner :: GHC.Classes.Eq Data.Phoneme.Manner
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Manner
                  Data.Phoneme.$fEqManner_$c==
                  Data.Phoneme.$fEqManner_$c/= -}
457727c142c08ed8e753e8053528da14
  $fEqManner_$c/= ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Manner) (b :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
457727c142c08ed8e753e8053528da14
  $fEqManner_$c== ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Manner) (b :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2)) } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fEqMorpheme :: GHC.Classes.Eq Data.Phoneme.Morpheme
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Morpheme
                  Data.Phoneme.$fEqMorpheme_$c==
                  Data.Phoneme.$fEqMorpheme_$c/= -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fEqMorpheme_$c/= ::
    Data.Phoneme.Morpheme -> Data.Phoneme.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Morpheme) (b :: Data.Phoneme.Morpheme) ->
                 case a of wild { Data.Phoneme.Morpheme a1 ->
                 case b of wild1 { Data.Phoneme.Morpheme b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Data.Phoneme.Phoneme
                        Data.Phoneme.$fEqPhoneme
                        a1
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fEqMorpheme_$c== ::
    Data.Phoneme.Morpheme -> Data.Phoneme.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Phoneme.Morpheme) (ds1 :: Data.Phoneme.Morpheme) ->
                 case ds of wild { Data.Phoneme.Morpheme a1 ->
                 case ds1 of wild1 { Data.Phoneme.Morpheme b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ Data.Phoneme.Phoneme
                   Data.Phoneme.$fEqPhoneme
                   a1
                   b1 } }) -}
ff541d1764888145304960d9b00dcecd
  $fEqPhonation :: GHC.Classes.Eq Data.Phoneme.Phonation
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phonation
                  Data.Phoneme.$fEqPhonation_$c==
                  Data.Phoneme.$fEqPhonation_$c/= -}
ff541d1764888145304960d9b00dcecd
  $fEqPhonation_$c/= ::
    Data.Phoneme.Phonation -> Data.Phoneme.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Phonation)
                   (b :: Data.Phoneme.Phonation) ->
                 case a of wild {
                   Data.Phoneme.VOICELESS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.VOICELESS -> GHC.Types.False }
                   Data.Phoneme.BREATHY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.BREATHY -> GHC.Types.False }
                   Data.Phoneme.SLACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.SLACK -> GHC.Types.False }
                   Data.Phoneme.MODAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.MODAL -> GHC.Types.False }
                   Data.Phoneme.STIFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.STIFF -> GHC.Types.False }
                   Data.Phoneme.CREAKY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.CREAKY -> GHC.Types.False }
                   Data.Phoneme.ASPIRATED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.ASPIRATED -> GHC.Types.False } }) -}
ff541d1764888145304960d9b00dcecd
  $fEqPhonation_$c== ::
    Data.Phoneme.Phonation -> Data.Phoneme.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Data.Phoneme.Phonation)
                   (ds1 :: Data.Phoneme.Phonation) ->
                 case ds of wild {
                   Data.Phoneme.VOICELESS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.VOICELESS -> GHC.Types.True }
                   Data.Phoneme.BREATHY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.BREATHY -> GHC.Types.True }
                   Data.Phoneme.SLACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.SLACK -> GHC.Types.True }
                   Data.Phoneme.MODAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.MODAL -> GHC.Types.True }
                   Data.Phoneme.STIFF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.STIFF -> GHC.Types.True }
                   Data.Phoneme.CREAKY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.CREAKY -> GHC.Types.True }
                   Data.Phoneme.ASPIRATED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.ASPIRATED -> GHC.Types.True } }) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fEqPhoneme :: GHC.Classes.Eq Data.Phoneme.Phoneme
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phoneme
                  Data.Phoneme.$fEqPhoneme_$c==
                  Data.Phoneme.$fEqPhoneme_$c/= -}
83c67fc806e8317ebba4d84ed8aa040f
  $fEqPhoneme_$c/= ::
    Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Phoneme) (b :: Data.Phoneme.Phoneme) ->
                 case Data.Phoneme.$fEqPhoneme_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fEqPhoneme_$c== ::
    Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
1971716d79acadd98b648de5350e6f24
  $fEqPlace :: GHC.Classes.Eq Data.Phoneme.Place
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Place
                  Data.Phoneme.$fEqPlace_$c==
                  Data.Phoneme.$fEqPlace_$c/= -}
1971716d79acadd98b648de5350e6f24
  $fEqPlace_$c/= ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Place) (b :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Place x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
1971716d79acadd98b648de5350e6f24
  $fEqPlace_$c== ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Place) (b :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x2)) } }) -}
974abd7cc25c83307948d0001b49f38e
  $fEqRoundedness :: GHC.Classes.Eq Data.Phoneme.Roundedness
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Roundedness
                  Data.Phoneme.$fEqRoundedness_$c==
                  Data.Phoneme.$fEqRoundedness_$c/= -}
974abd7cc25c83307948d0001b49f38e
  $fEqRoundedness_$c/= ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Roundedness)
                   (b :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.DEFAULT -> GHC.Types.False }
                   Data.Phoneme.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.ROUNDED -> GHC.Types.False }
                   Data.Phoneme.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.UNROUNDED -> GHC.Types.False } }) -}
974abd7cc25c83307948d0001b49f38e
  $fEqRoundedness_$c== ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Phoneme.Roundedness)
                   (ds1 :: Data.Phoneme.Roundedness) ->
                 case ds of wild {
                   Data.Phoneme.DEFAULT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.DEFAULT -> GHC.Types.True }
                   Data.Phoneme.ROUNDED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.ROUNDED -> GHC.Types.True }
                   Data.Phoneme.UNROUNDED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.UNROUNDED -> GHC.Types.True } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEqTone :: GHC.Classes.Eq Data.Phoneme.Tone
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Tone
                  Data.Phoneme.$fEqTone_$c==
                  Data.Phoneme.$fEqTone_$c/= -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEqTone_$c/= ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Tone) (b :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fEqTone_$c== ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Tone) (b :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2)) } }) -}
7b936d811d140964313d74386435dc67
  $fEqWord :: GHC.Classes.Eq Data.Phoneme.Word
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Word
                  Data.Phoneme.$fEqWord_$c==
                  Data.Phoneme.$fEqWord_$c/= -}
7b936d811d140964313d74386435dc67
  $fEqWord_$c/= ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Word) (b :: Data.Phoneme.Word) ->
                 case a of wild { Data.Phoneme.Word a1 ->
                 case b of wild1 { Data.Phoneme.Word b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Data.Phoneme.Morpheme
                        Data.Phoneme.$fEqMorpheme
                        a1
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
7b936d811d140964313d74386435dc67
  $fEqWord_$c== ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Data.Phoneme.Word) (ds1 :: Data.Phoneme.Word) ->
                 case ds of wild { Data.Phoneme.Word a1 ->
                 case ds1 of wild1 { Data.Phoneme.Word b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ Data.Phoneme.Morpheme
                   Data.Phoneme.$fEqMorpheme
                   a1
                   b1 } }) -}
a3d34da76e787829b1272672cb3d501f
  $fOrdBackness :: GHC.Classes.Ord Data.Phoneme.Backness
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Backness
                  Data.Phoneme.$fEqBackness
                  Data.Phoneme.$fOrdBackness_$ccompare
                  Data.Phoneme.$fOrdBackness_$c<
                  Data.Phoneme.$fOrdBackness_$c<=
                  Data.Phoneme.$fOrdBackness_$c>
                  Data.Phoneme.$fOrdBackness_$c>=
                  Data.Phoneme.$fOrdBackness_$cmax
                  Data.Phoneme.$fOrdBackness_$cmin -}
a3d34da76e787829b1272672cb3d501f
  $fOrdBackness_$c< ::
    Data.Phoneme.Backness -> Data.Phoneme.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Backness)
                   (b :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK
                   -> case b of wild1 {
                        Data.Phoneme.BACK -> GHC.Types.False
                        Data.Phoneme.NEARBACK -> GHC.Types.True
                        Data.Phoneme.CENTRAL -> GHC.Types.True
                        Data.Phoneme.NEARFRONT -> GHC.Types.True
                        Data.Phoneme.FRONT -> GHC.Types.True }
                   Data.Phoneme.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.CENTRAL -> GHC.Types.True
                        Data.Phoneme.NEARFRONT -> GHC.Types.True
                        Data.Phoneme.FRONT -> GHC.Types.True }
                   Data.Phoneme.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.NEARFRONT -> GHC.Types.True
                        Data.Phoneme.FRONT -> GHC.Types.True }
                   Data.Phoneme.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.FRONT -> GHC.Types.True }
                   Data.Phoneme.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
a3d34da76e787829b1272672cb3d501f
  $fOrdBackness_$c<= ::
    Data.Phoneme.Backness -> Data.Phoneme.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Backness)
                   (b :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   Data.Phoneme.NEARBACK
                   -> case b of wild1 {
                        Data.Phoneme.BACK -> GHC.Types.False
                        Data.Phoneme.NEARBACK -> GHC.Types.True
                        Data.Phoneme.CENTRAL -> GHC.Types.True
                        Data.Phoneme.NEARFRONT -> GHC.Types.True
                        Data.Phoneme.FRONT -> GHC.Types.True }
                   Data.Phoneme.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.CENTRAL -> GHC.Types.True
                        Data.Phoneme.NEARFRONT -> GHC.Types.True
                        Data.Phoneme.FRONT -> GHC.Types.True }
                   Data.Phoneme.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.NEARFRONT -> GHC.Types.True
                        Data.Phoneme.FRONT -> GHC.Types.True }
                   Data.Phoneme.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.FRONT -> GHC.Types.True } }) -}
a3d34da76e787829b1272672cb3d501f
  $fOrdBackness_$c> ::
    Data.Phoneme.Backness -> Data.Phoneme.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Backness)
                   (b :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   Data.Phoneme.NEARBACK
                   -> case b of wild1 {
                        Data.Phoneme.BACK -> GHC.Types.True
                        Data.Phoneme.NEARBACK -> GHC.Types.False
                        Data.Phoneme.CENTRAL -> GHC.Types.False
                        Data.Phoneme.NEARFRONT -> GHC.Types.False
                        Data.Phoneme.FRONT -> GHC.Types.False }
                   Data.Phoneme.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.CENTRAL -> GHC.Types.False
                        Data.Phoneme.NEARFRONT -> GHC.Types.False
                        Data.Phoneme.FRONT -> GHC.Types.False }
                   Data.Phoneme.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.NEARFRONT -> GHC.Types.False
                        Data.Phoneme.FRONT -> GHC.Types.False }
                   Data.Phoneme.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.FRONT -> GHC.Types.False } }) -}
a3d34da76e787829b1272672cb3d501f
  $fOrdBackness_$c>= ::
    Data.Phoneme.Backness -> Data.Phoneme.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Backness)
                   (b :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK
                   -> case b of wild1 {
                        Data.Phoneme.BACK -> GHC.Types.True
                        Data.Phoneme.NEARBACK -> GHC.Types.False
                        Data.Phoneme.CENTRAL -> GHC.Types.False
                        Data.Phoneme.NEARFRONT -> GHC.Types.False
                        Data.Phoneme.FRONT -> GHC.Types.False }
                   Data.Phoneme.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.CENTRAL -> GHC.Types.False
                        Data.Phoneme.NEARFRONT -> GHC.Types.False
                        Data.Phoneme.FRONT -> GHC.Types.False }
                   Data.Phoneme.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.NEARFRONT -> GHC.Types.False
                        Data.Phoneme.FRONT -> GHC.Types.False }
                   Data.Phoneme.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.FRONT -> GHC.Types.False }
                   Data.Phoneme.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
a3d34da76e787829b1272672cb3d501f
  $fOrdBackness_$ccompare ::
    Data.Phoneme.Backness
    -> Data.Phoneme.Backness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Backness)
                   (b :: Data.Phoneme.Backness) ->
                 case a of wild {
                   Data.Phoneme.BACK
                   -> case b of wild1 {
                        Data.Phoneme.BACK -> GHC.Types.EQ
                        Data.Phoneme.NEARBACK -> GHC.Types.LT
                        Data.Phoneme.CENTRAL -> GHC.Types.LT
                        Data.Phoneme.NEARFRONT -> GHC.Types.LT
                        Data.Phoneme.FRONT -> GHC.Types.LT }
                   Data.Phoneme.NEARBACK
                   -> case b of wild1 {
                        Data.Phoneme.BACK -> GHC.Types.GT
                        Data.Phoneme.NEARBACK -> GHC.Types.EQ
                        Data.Phoneme.CENTRAL -> GHC.Types.LT
                        Data.Phoneme.NEARFRONT -> GHC.Types.LT
                        Data.Phoneme.FRONT -> GHC.Types.LT }
                   Data.Phoneme.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.CENTRAL -> GHC.Types.EQ
                        Data.Phoneme.NEARFRONT -> GHC.Types.LT
                        Data.Phoneme.FRONT -> GHC.Types.LT }
                   Data.Phoneme.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.NEARFRONT -> GHC.Types.EQ
                        Data.Phoneme.FRONT -> GHC.Types.LT }
                   Data.Phoneme.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT Data.Phoneme.FRONT -> GHC.Types.EQ } }) -}
a3d34da76e787829b1272672cb3d501f
  $fOrdBackness_$cmax ::
    Data.Phoneme.Backness
    -> Data.Phoneme.Backness -> Data.Phoneme.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Backness)
                   (y :: Data.Phoneme.Backness) ->
                 case x of wild {
                   Data.Phoneme.BACK -> y
                   Data.Phoneme.NEARBACK
                   -> case y of wild1 {
                        DEFAULT -> Data.Phoneme.NEARBACK
                        Data.Phoneme.CENTRAL -> Data.Phoneme.CENTRAL
                        Data.Phoneme.NEARFRONT -> Data.Phoneme.NEARFRONT
                        Data.Phoneme.FRONT -> Data.Phoneme.FRONT }
                   Data.Phoneme.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> Data.Phoneme.CENTRAL
                        Data.Phoneme.NEARFRONT -> Data.Phoneme.NEARFRONT
                        Data.Phoneme.FRONT -> Data.Phoneme.FRONT }
                   Data.Phoneme.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> Data.Phoneme.NEARFRONT
                        Data.Phoneme.FRONT -> Data.Phoneme.FRONT }
                   Data.Phoneme.FRONT
                   -> case y of wild1 { DEFAULT -> Data.Phoneme.FRONT } }) -}
a3d34da76e787829b1272672cb3d501f
  $fOrdBackness_$cmin ::
    Data.Phoneme.Backness
    -> Data.Phoneme.Backness -> Data.Phoneme.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Data.Phoneme.Backness)
                   (y :: Data.Phoneme.Backness) ->
                 case x of wild {
                   Data.Phoneme.BACK
                   -> case y of wild1 { DEFAULT -> Data.Phoneme.BACK }
                   Data.Phoneme.NEARBACK
                   -> case y of wild1 {
                        Data.Phoneme.BACK -> Data.Phoneme.BACK
                        Data.Phoneme.NEARBACK -> Data.Phoneme.NEARBACK
                        Data.Phoneme.CENTRAL -> Data.Phoneme.NEARBACK
                        Data.Phoneme.NEARFRONT -> Data.Phoneme.NEARBACK
                        Data.Phoneme.FRONT -> Data.Phoneme.NEARBACK }
                   Data.Phoneme.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        Data.Phoneme.CENTRAL -> Data.Phoneme.CENTRAL
                        Data.Phoneme.NEARFRONT -> Data.Phoneme.CENTRAL
                        Data.Phoneme.FRONT -> Data.Phoneme.CENTRAL }
                   Data.Phoneme.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        Data.Phoneme.NEARFRONT -> Data.Phoneme.NEARFRONT
                        Data.Phoneme.FRONT -> Data.Phoneme.NEARFRONT }
                   Data.Phoneme.FRONT -> y }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fOrdHeight :: GHC.Classes.Ord Data.Phoneme.Height
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Height
                  Data.Phoneme.$fEqHeight
                  Data.Phoneme.$fOrdHeight_$ccompare
                  Data.Phoneme.$fOrdHeight_$c<
                  Data.Phoneme.$fOrdHeight_$c<=
                  Data.Phoneme.$fOrdHeight_$c>
                  Data.Phoneme.$fOrdHeight_$c>=
                  Data.Phoneme.$fOrdHeight_$cmax
                  Data.Phoneme.$fOrdHeight_$cmin -}
e52daabfd4cc5d18128954ffcda031bb
  $fOrdHeight_$c< ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Height)
                   (b :: Data.Phoneme.Height) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       Data.Phoneme.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0#)
                       Data.Phoneme.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1#)
                       Data.Phoneme.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2#)
                       Data.Phoneme.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3#)
                       Data.Phoneme.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4#)
                       Data.Phoneme.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5#)
                       Data.Phoneme.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6#) }
                 } in
                 case a of wild {
                   Data.Phoneme.CLOSE -> $j 0#
                   Data.Phoneme.NEARCLOSE -> $j 1#
                   Data.Phoneme.CLOSEMID -> $j 2#
                   Data.Phoneme.MID -> $j 3#
                   Data.Phoneme.OPENMID -> $j 4#
                   Data.Phoneme.NEAROPEN -> $j 5#
                   Data.Phoneme.OPEN -> $j 6# }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fOrdHeight_$c<= ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Height)
                   (b :: Data.Phoneme.Height) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       Data.Phoneme.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0#)
                       Data.Phoneme.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1#)
                       Data.Phoneme.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2#)
                       Data.Phoneme.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3#)
                       Data.Phoneme.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4#)
                       Data.Phoneme.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5#)
                       Data.Phoneme.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6#) }
                 } in
                 case a of wild {
                   Data.Phoneme.CLOSE -> $j 0#
                   Data.Phoneme.NEARCLOSE -> $j 1#
                   Data.Phoneme.CLOSEMID -> $j 2#
                   Data.Phoneme.MID -> $j 3#
                   Data.Phoneme.OPENMID -> $j 4#
                   Data.Phoneme.NEAROPEN -> $j 5#
                   Data.Phoneme.OPEN -> $j 6# }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fOrdHeight_$c> ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Height)
                   (b :: Data.Phoneme.Height) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       Data.Phoneme.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0#)
                       Data.Phoneme.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1#)
                       Data.Phoneme.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2#)
                       Data.Phoneme.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3#)
                       Data.Phoneme.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4#)
                       Data.Phoneme.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5#)
                       Data.Phoneme.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6#) }
                 } in
                 case a of wild {
                   Data.Phoneme.CLOSE -> $j 0#
                   Data.Phoneme.NEARCLOSE -> $j 1#
                   Data.Phoneme.CLOSEMID -> $j 2#
                   Data.Phoneme.MID -> $j 3#
                   Data.Phoneme.OPENMID -> $j 4#
                   Data.Phoneme.NEAROPEN -> $j 5#
                   Data.Phoneme.OPEN -> $j 6# }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fOrdHeight_$c>= ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Height)
                   (b :: Data.Phoneme.Height) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       Data.Phoneme.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0#)
                       Data.Phoneme.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1#)
                       Data.Phoneme.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2#)
                       Data.Phoneme.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3#)
                       Data.Phoneme.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4#)
                       Data.Phoneme.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5#)
                       Data.Phoneme.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6#) }
                 } in
                 case a of wild {
                   Data.Phoneme.CLOSE -> $j 0#
                   Data.Phoneme.NEARCLOSE -> $j 1#
                   Data.Phoneme.CLOSEMID -> $j 2#
                   Data.Phoneme.MID -> $j 3#
                   Data.Phoneme.OPENMID -> $j 4#
                   Data.Phoneme.NEAROPEN -> $j 5#
                   Data.Phoneme.OPEN -> $j 6# }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fOrdHeight_$ccompare ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Height)
                   (b :: Data.Phoneme.Height) ->
                 case a of wild {
                   Data.Phoneme.CLOSE
                   -> case b of wild1 {
                        Data.Phoneme.CLOSE -> GHC.Types.EQ
                        Data.Phoneme.NEARCLOSE -> GHC.Types.LT
                        Data.Phoneme.CLOSEMID -> GHC.Types.LT
                        Data.Phoneme.MID -> GHC.Types.LT
                        Data.Phoneme.OPENMID -> GHC.Types.LT
                        Data.Phoneme.NEAROPEN -> GHC.Types.LT
                        Data.Phoneme.OPEN -> GHC.Types.LT }
                   Data.Phoneme.NEARCLOSE
                   -> case b of wild1 {
                        Data.Phoneme.CLOSE -> GHC.Types.GT
                        Data.Phoneme.NEARCLOSE -> GHC.Types.EQ
                        Data.Phoneme.CLOSEMID -> GHC.Types.LT
                        Data.Phoneme.MID -> GHC.Types.LT
                        Data.Phoneme.OPENMID -> GHC.Types.LT
                        Data.Phoneme.NEAROPEN -> GHC.Types.LT
                        Data.Phoneme.OPEN -> GHC.Types.LT }
                   Data.Phoneme.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.CLOSEMID -> GHC.Types.EQ
                        Data.Phoneme.MID -> GHC.Types.LT
                        Data.Phoneme.OPENMID -> GHC.Types.LT
                        Data.Phoneme.NEAROPEN -> GHC.Types.LT
                        Data.Phoneme.OPEN -> GHC.Types.LT }
                   Data.Phoneme.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.MID -> GHC.Types.EQ
                        Data.Phoneme.OPENMID -> GHC.Types.LT
                        Data.Phoneme.NEAROPEN -> GHC.Types.LT
                        Data.Phoneme.OPEN -> GHC.Types.LT }
                   Data.Phoneme.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.OPENMID -> GHC.Types.EQ
                        Data.Phoneme.NEAROPEN -> GHC.Types.LT
                        Data.Phoneme.OPEN -> GHC.Types.LT }
                   Data.Phoneme.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.NEAROPEN -> GHC.Types.EQ
                        Data.Phoneme.OPEN -> GHC.Types.LT }
                   Data.Phoneme.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT Data.Phoneme.OPEN -> GHC.Types.EQ } }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fOrdHeight_$cmax ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> Data.Phoneme.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Height) (y :: Data.Phoneme.Height) ->
                 case Data.Phoneme.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
e52daabfd4cc5d18128954ffcda031bb
  $fOrdHeight_$cmin ::
    Data.Phoneme.Height -> Data.Phoneme.Height -> Data.Phoneme.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Height) (y :: Data.Phoneme.Height) ->
                 case Data.Phoneme.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
3bc911798122c419c4b3747def87cb7a
  $fOrdLength :: GHC.Classes.Ord Data.Phoneme.Length
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Length
                  Data.Phoneme.$fEqLength
                  Data.Phoneme.$fOrdLength_$ccompare
                  Data.Phoneme.$fOrdLength_$c<
                  Data.Phoneme.$fOrdLength_$c<=
                  Data.Phoneme.$fOrdLength_$c>
                  Data.Phoneme.$fOrdLength_$c>=
                  Data.Phoneme.$fOrdLength_$cmax
                  Data.Phoneme.$fOrdLength_$cmin -}
3bc911798122c419c4b3747def87cb7a
  $fOrdLength_$c< ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Length) (b :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT
                   -> case b of wild1 {
                        Data.Phoneme.SHORT -> GHC.Types.False
                        Data.Phoneme.NORMAL -> GHC.Types.True
                        Data.Phoneme.LONG -> GHC.Types.True }
                   Data.Phoneme.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False Data.Phoneme.LONG -> GHC.Types.True }
                   Data.Phoneme.LONG
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
3bc911798122c419c4b3747def87cb7a
  $fOrdLength_$c<= ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Length) (b :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   Data.Phoneme.NORMAL
                   -> case b of wild1 {
                        Data.Phoneme.SHORT -> GHC.Types.False
                        Data.Phoneme.NORMAL -> GHC.Types.True
                        Data.Phoneme.LONG -> GHC.Types.True }
                   Data.Phoneme.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.LONG -> GHC.Types.True } }) -}
3bc911798122c419c4b3747def87cb7a
  $fOrdLength_$c> ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Length) (b :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   Data.Phoneme.NORMAL
                   -> case b of wild1 {
                        Data.Phoneme.SHORT -> GHC.Types.True
                        Data.Phoneme.NORMAL -> GHC.Types.False
                        Data.Phoneme.LONG -> GHC.Types.False }
                   Data.Phoneme.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.LONG -> GHC.Types.False } }) -}
3bc911798122c419c4b3747def87cb7a
  $fOrdLength_$c>= ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Length) (b :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT
                   -> case b of wild1 {
                        Data.Phoneme.SHORT -> GHC.Types.True
                        Data.Phoneme.NORMAL -> GHC.Types.False
                        Data.Phoneme.LONG -> GHC.Types.False }
                   Data.Phoneme.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Data.Phoneme.LONG -> GHC.Types.False }
                   Data.Phoneme.LONG
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
3bc911798122c419c4b3747def87cb7a
  $fOrdLength_$ccompare ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Length)
                   (b :: Data.Phoneme.Length) ->
                 case a of wild {
                   Data.Phoneme.SHORT
                   -> case b of wild1 {
                        Data.Phoneme.SHORT -> GHC.Types.EQ
                        Data.Phoneme.NORMAL -> GHC.Types.LT
                        Data.Phoneme.LONG -> GHC.Types.LT }
                   Data.Phoneme.NORMAL
                   -> case b of wild1 {
                        Data.Phoneme.SHORT -> GHC.Types.GT
                        Data.Phoneme.NORMAL -> GHC.Types.EQ
                        Data.Phoneme.LONG -> GHC.Types.LT }
                   Data.Phoneme.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT Data.Phoneme.LONG -> GHC.Types.EQ } }) -}
3bc911798122c419c4b3747def87cb7a
  $fOrdLength_$cmax ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> Data.Phoneme.Length
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Length) (y :: Data.Phoneme.Length) ->
                 case x of wild {
                   Data.Phoneme.SHORT -> y
                   Data.Phoneme.NORMAL
                   -> case y of wild1 {
                        DEFAULT -> Data.Phoneme.NORMAL
                        Data.Phoneme.LONG -> Data.Phoneme.LONG }
                   Data.Phoneme.LONG
                   -> case y of wild1 { DEFAULT -> Data.Phoneme.LONG } }) -}
3bc911798122c419c4b3747def87cb7a
  $fOrdLength_$cmin ::
    Data.Phoneme.Length -> Data.Phoneme.Length -> Data.Phoneme.Length
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Length) (y :: Data.Phoneme.Length) ->
                 case x of wild {
                   Data.Phoneme.SHORT
                   -> case y of wild1 { DEFAULT -> Data.Phoneme.SHORT }
                   Data.Phoneme.NORMAL
                   -> case y of wild1 {
                        Data.Phoneme.SHORT -> Data.Phoneme.SHORT
                        Data.Phoneme.NORMAL -> Data.Phoneme.NORMAL
                        Data.Phoneme.LONG -> Data.Phoneme.NORMAL }
                   Data.Phoneme.LONG -> y }) -}
457727c142c08ed8e753e8053528da14
  $fOrdManner :: GHC.Classes.Ord Data.Phoneme.Manner
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Manner
                  Data.Phoneme.$fEqManner
                  Data.Phoneme.$fOrdManner_$ccompare
                  Data.Phoneme.$fOrdManner_$c<
                  Data.Phoneme.$fOrdManner_$c<=
                  Data.Phoneme.$fOrdManner_$c>
                  Data.Phoneme.$fOrdManner_$c>=
                  Data.Phoneme.$fOrdManner_$cmax
                  Data.Phoneme.$fOrdManner_$cmin -}
457727c142c08ed8e753e8053528da14
  $fOrdManner_$c< ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Manner) (b :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2)) } }) -}
457727c142c08ed8e753e8053528da14
  $fOrdManner_$c<= ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Manner) (b :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2)) } }) -}
457727c142c08ed8e753e8053528da14
  $fOrdManner_$c> ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Manner) (b :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2)) } }) -}
457727c142c08ed8e753e8053528da14
  $fOrdManner_$c>= ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Manner) (b :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2)) } }) -}
457727c142c08ed8e753e8053528da14
  $fOrdManner_$ccompare ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Manner) (b :: Data.Phoneme.Manner) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
457727c142c08ed8e753e8053528da14
  $fOrdManner_$cmax ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> Data.Phoneme.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Manner) (y :: Data.Phoneme.Manner) ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
457727c142c08ed8e753e8053528da14
  $fOrdManner_$cmin ::
    Data.Phoneme.Manner -> Data.Phoneme.Manner -> Data.Phoneme.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Manner) (y :: Data.Phoneme.Manner) ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Manner x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fOrdMorpheme :: GHC.Classes.Ord Data.Phoneme.Morpheme
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Morpheme
                  Data.Phoneme.$fEqMorpheme
                  Data.Phoneme.$fOrdMorpheme_$ccompare
                  Data.Phoneme.$fOrdMorpheme_$c<
                  Data.Phoneme.$fOrdMorpheme_$c<=
                  Data.Phoneme.$fOrdMorpheme_$c>
                  Data.Phoneme.$fOrdMorpheme_$c>=
                  Data.Phoneme.$fOrdMorpheme_$cmax
                  Data.Phoneme.$fOrdMorpheme_$cmin -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fOrdMorpheme_$c< ::
    Data.Phoneme.Morpheme -> Data.Phoneme.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Morpheme) (b :: Data.Phoneme.Morpheme) ->
                 case a of wild { Data.Phoneme.Morpheme a1 ->
                 case b of wild1 { Data.Phoneme.Morpheme b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Phoneme
                        Data.Phoneme.$fOrdPhoneme
                        a1
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True } } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fOrdMorpheme_$c<= ::
    Data.Phoneme.Morpheme -> Data.Phoneme.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Morpheme) (b :: Data.Phoneme.Morpheme) ->
                 case a of wild { Data.Phoneme.Morpheme a1 ->
                 case b of wild1 { Data.Phoneme.Morpheme b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Phoneme
                        Data.Phoneme.$fOrdPhoneme
                        a1
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fOrdMorpheme_$c> ::
    Data.Phoneme.Morpheme -> Data.Phoneme.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Morpheme) (b :: Data.Phoneme.Morpheme) ->
                 case a of wild { Data.Phoneme.Morpheme a1 ->
                 case b of wild1 { Data.Phoneme.Morpheme b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Phoneme
                        Data.Phoneme.$fOrdPhoneme
                        a1
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fOrdMorpheme_$c>= ::
    Data.Phoneme.Morpheme -> Data.Phoneme.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Morpheme) (b :: Data.Phoneme.Morpheme) ->
                 case a of wild { Data.Phoneme.Morpheme a1 ->
                 case b of wild1 { Data.Phoneme.Morpheme b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Phoneme
                        Data.Phoneme.$fOrdPhoneme
                        a1
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fOrdMorpheme_$ccompare ::
    Data.Phoneme.Morpheme
    -> Data.Phoneme.Morpheme -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Morpheme) (b :: Data.Phoneme.Morpheme) ->
                 case a of wild { Data.Phoneme.Morpheme a1 ->
                 case b of wild1 { Data.Phoneme.Morpheme b1 ->
                 GHC.Classes.$fOrd[]_$ccompare
                   @ Data.Phoneme.Phoneme
                   Data.Phoneme.$fOrdPhoneme
                   a1
                   b1 } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fOrdMorpheme_$cmax ::
    Data.Phoneme.Morpheme
    -> Data.Phoneme.Morpheme -> Data.Phoneme.Morpheme
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Morpheme) (y :: Data.Phoneme.Morpheme) ->
                 case x of wild { Data.Phoneme.Morpheme a1 ->
                 case y of wild1 { Data.Phoneme.Morpheme b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Phoneme
                        Data.Phoneme.$fOrdPhoneme
                        a1
                        b1 of wild2 {
                   DEFAULT -> wild1 GHC.Types.GT -> wild } } }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fOrdMorpheme_$cmin ::
    Data.Phoneme.Morpheme
    -> Data.Phoneme.Morpheme -> Data.Phoneme.Morpheme
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Morpheme) (y :: Data.Phoneme.Morpheme) ->
                 case x of wild { Data.Phoneme.Morpheme a1 ->
                 case y of wild1 { Data.Phoneme.Morpheme b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Phoneme
                        Data.Phoneme.$fOrdPhoneme
                        a1
                        b1 of wild2 {
                   DEFAULT -> wild GHC.Types.GT -> wild1 } } }) -}
ff541d1764888145304960d9b00dcecd
  $fOrdPhonation :: GHC.Classes.Ord Data.Phoneme.Phonation
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phonation
                  Data.Phoneme.$fEqPhonation
                  Data.Phoneme.$fOrdPhonation_$ccompare
                  Data.Phoneme.$fOrdPhonation_$c<
                  Data.Phoneme.$fOrdPhonation_$c<=
                  Data.Phoneme.$fOrdPhonation_$c>
                  Data.Phoneme.$fOrdPhonation_$c>=
                  Data.Phoneme.$fOrdPhonation_$cmax
                  Data.Phoneme.$fOrdPhonation_$cmin -}
ff541d1764888145304960d9b00dcecd
  $fOrdPhonation_$c< ::
    Data.Phoneme.Phonation -> Data.Phoneme.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Phonation)
                   (b :: Data.Phoneme.Phonation) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       Data.Phoneme.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0#)
                       Data.Phoneme.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1#)
                       Data.Phoneme.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2#)
                       Data.Phoneme.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3#)
                       Data.Phoneme.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4#)
                       Data.Phoneme.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5#)
                       Data.Phoneme.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6#) }
                 } in
                 case a of wild {
                   Data.Phoneme.VOICELESS -> $j 0#
                   Data.Phoneme.BREATHY -> $j 1#
                   Data.Phoneme.SLACK -> $j 2#
                   Data.Phoneme.MODAL -> $j 3#
                   Data.Phoneme.STIFF -> $j 4#
                   Data.Phoneme.CREAKY -> $j 5#
                   Data.Phoneme.ASPIRATED -> $j 6# }) -}
ff541d1764888145304960d9b00dcecd
  $fOrdPhonation_$c<= ::
    Data.Phoneme.Phonation -> Data.Phoneme.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Phonation)
                   (b :: Data.Phoneme.Phonation) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       Data.Phoneme.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0#)
                       Data.Phoneme.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1#)
                       Data.Phoneme.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2#)
                       Data.Phoneme.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3#)
                       Data.Phoneme.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4#)
                       Data.Phoneme.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5#)
                       Data.Phoneme.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6#) }
                 } in
                 case a of wild {
                   Data.Phoneme.VOICELESS -> $j 0#
                   Data.Phoneme.BREATHY -> $j 1#
                   Data.Phoneme.SLACK -> $j 2#
                   Data.Phoneme.MODAL -> $j 3#
                   Data.Phoneme.STIFF -> $j 4#
                   Data.Phoneme.CREAKY -> $j 5#
                   Data.Phoneme.ASPIRATED -> $j 6# }) -}
ff541d1764888145304960d9b00dcecd
  $fOrdPhonation_$c> ::
    Data.Phoneme.Phonation -> Data.Phoneme.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Phonation)
                   (b :: Data.Phoneme.Phonation) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       Data.Phoneme.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0#)
                       Data.Phoneme.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1#)
                       Data.Phoneme.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2#)
                       Data.Phoneme.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3#)
                       Data.Phoneme.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4#)
                       Data.Phoneme.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5#)
                       Data.Phoneme.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6#) }
                 } in
                 case a of wild {
                   Data.Phoneme.VOICELESS -> $j 0#
                   Data.Phoneme.BREATHY -> $j 1#
                   Data.Phoneme.SLACK -> $j 2#
                   Data.Phoneme.MODAL -> $j 3#
                   Data.Phoneme.STIFF -> $j 4#
                   Data.Phoneme.CREAKY -> $j 5#
                   Data.Phoneme.ASPIRATED -> $j 6# }) -}
ff541d1764888145304960d9b00dcecd
  $fOrdPhonation_$c>= ::
    Data.Phoneme.Phonation -> Data.Phoneme.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Phonation)
                   (b :: Data.Phoneme.Phonation) ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (a# :: GHC.Prim.Int#)[OneShot] ->
                     case b of wild {
                       Data.Phoneme.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0#)
                       Data.Phoneme.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1#)
                       Data.Phoneme.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2#)
                       Data.Phoneme.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3#)
                       Data.Phoneme.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4#)
                       Data.Phoneme.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5#)
                       Data.Phoneme.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6#) }
                 } in
                 case a of wild {
                   Data.Phoneme.VOICELESS -> $j 0#
                   Data.Phoneme.BREATHY -> $j 1#
                   Data.Phoneme.SLACK -> $j 2#
                   Data.Phoneme.MODAL -> $j 3#
                   Data.Phoneme.STIFF -> $j 4#
                   Data.Phoneme.CREAKY -> $j 5#
                   Data.Phoneme.ASPIRATED -> $j 6# }) -}
ff541d1764888145304960d9b00dcecd
  $fOrdPhonation_$ccompare ::
    Data.Phoneme.Phonation
    -> Data.Phoneme.Phonation -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Phonation)
                   (b :: Data.Phoneme.Phonation) ->
                 case a of wild {
                   Data.Phoneme.VOICELESS
                   -> case b of wild1 {
                        Data.Phoneme.VOICELESS -> GHC.Types.EQ
                        Data.Phoneme.BREATHY -> GHC.Types.LT
                        Data.Phoneme.SLACK -> GHC.Types.LT
                        Data.Phoneme.MODAL -> GHC.Types.LT
                        Data.Phoneme.STIFF -> GHC.Types.LT
                        Data.Phoneme.CREAKY -> GHC.Types.LT
                        Data.Phoneme.ASPIRATED -> GHC.Types.LT }
                   Data.Phoneme.BREATHY
                   -> case b of wild1 {
                        Data.Phoneme.VOICELESS -> GHC.Types.GT
                        Data.Phoneme.BREATHY -> GHC.Types.EQ
                        Data.Phoneme.SLACK -> GHC.Types.LT
                        Data.Phoneme.MODAL -> GHC.Types.LT
                        Data.Phoneme.STIFF -> GHC.Types.LT
                        Data.Phoneme.CREAKY -> GHC.Types.LT
                        Data.Phoneme.ASPIRATED -> GHC.Types.LT }
                   Data.Phoneme.SLACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.SLACK -> GHC.Types.EQ
                        Data.Phoneme.MODAL -> GHC.Types.LT
                        Data.Phoneme.STIFF -> GHC.Types.LT
                        Data.Phoneme.CREAKY -> GHC.Types.LT
                        Data.Phoneme.ASPIRATED -> GHC.Types.LT }
                   Data.Phoneme.MODAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.MODAL -> GHC.Types.EQ
                        Data.Phoneme.STIFF -> GHC.Types.LT
                        Data.Phoneme.CREAKY -> GHC.Types.LT
                        Data.Phoneme.ASPIRATED -> GHC.Types.LT }
                   Data.Phoneme.STIFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.STIFF -> GHC.Types.EQ
                        Data.Phoneme.CREAKY -> GHC.Types.LT
                        Data.Phoneme.ASPIRATED -> GHC.Types.LT }
                   Data.Phoneme.CREAKY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.CREAKY -> GHC.Types.EQ
                        Data.Phoneme.ASPIRATED -> GHC.Types.LT }
                   Data.Phoneme.ASPIRATED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.ASPIRATED -> GHC.Types.EQ } }) -}
ff541d1764888145304960d9b00dcecd
  $fOrdPhonation_$cmax ::
    Data.Phoneme.Phonation
    -> Data.Phoneme.Phonation -> Data.Phoneme.Phonation
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Phonation) (y :: Data.Phoneme.Phonation) ->
                 case Data.Phoneme.$fOrdPhonation_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
ff541d1764888145304960d9b00dcecd
  $fOrdPhonation_$cmin ::
    Data.Phoneme.Phonation
    -> Data.Phoneme.Phonation -> Data.Phoneme.Phonation
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Phonation) (y :: Data.Phoneme.Phonation) ->
                 case Data.Phoneme.$fOrdPhonation_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fOrdPhoneme :: GHC.Classes.Ord Data.Phoneme.Phoneme
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phoneme
                  Data.Phoneme.$fEqPhoneme
                  Data.Phoneme.$fOrdPhoneme_$ccompare
                  Data.Phoneme.$fOrdPhoneme_$c<
                  Data.Phoneme.$fOrdPhoneme_$c<=
                  Data.Phoneme.$fOrdPhoneme_$c>
                  Data.Phoneme.$fOrdPhoneme_$c>=
                  Data.Phoneme.$fOrdPhoneme_$cmax
                  Data.Phoneme.$fOrdPhoneme_$cmin -}
83c67fc806e8317ebba4d84ed8aa040f
  $fOrdPhoneme_$c< ::
    Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Phoneme) (y :: Data.Phoneme.Phoneme) ->
                 case Data.Phoneme.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fOrdPhoneme_$c<= ::
    Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Phoneme) (y :: Data.Phoneme.Phoneme) ->
                 case Data.Phoneme.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fOrdPhoneme_$c> ::
    Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Phoneme) (y :: Data.Phoneme.Phoneme) ->
                 case Data.Phoneme.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fOrdPhoneme_$c>= ::
    Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Phoneme) (y :: Data.Phoneme.Phoneme) ->
                 case Data.Phoneme.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fOrdPhoneme_$ccompare ::
    Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
83c67fc806e8317ebba4d84ed8aa040f
  $fOrdPhoneme_$cmax ::
    Data.Phoneme.Phoneme
    -> Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Phoneme) (y :: Data.Phoneme.Phoneme) ->
                 case Data.Phoneme.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fOrdPhoneme_$cmin ::
    Data.Phoneme.Phoneme
    -> Data.Phoneme.Phoneme -> Data.Phoneme.Phoneme
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Phoneme) (y :: Data.Phoneme.Phoneme) ->
                 case Data.Phoneme.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
1971716d79acadd98b648de5350e6f24
  $fOrdPlace :: GHC.Classes.Ord Data.Phoneme.Place
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Place
                  Data.Phoneme.$fEqPlace
                  Data.Phoneme.$fOrdPlace_$ccompare
                  Data.Phoneme.$fOrdPlace_$c<
                  Data.Phoneme.$fOrdPlace_$c<=
                  Data.Phoneme.$fOrdPlace_$c>
                  Data.Phoneme.$fOrdPlace_$c>=
                  Data.Phoneme.$fOrdPlace_$cmax
                  Data.Phoneme.$fOrdPlace_$cmin -}
1971716d79acadd98b648de5350e6f24
  $fOrdPlace_$c< ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Place) (b :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x2)) } }) -}
1971716d79acadd98b648de5350e6f24
  $fOrdPlace_$c<= ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Place) (b :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x2)) } }) -}
1971716d79acadd98b648de5350e6f24
  $fOrdPlace_$c> ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Place) (b :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x2)) } }) -}
1971716d79acadd98b648de5350e6f24
  $fOrdPlace_$c>= ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Place) (b :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Place x2)) } }) -}
1971716d79acadd98b648de5350e6f24
  $fOrdPlace_$ccompare ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Place) (b :: Data.Phoneme.Place) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
1971716d79acadd98b648de5350e6f24
  $fOrdPlace_$cmax ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> Data.Phoneme.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Place) (y :: Data.Phoneme.Place) ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Place x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
1971716d79acadd98b648de5350e6f24
  $fOrdPlace_$cmin ::
    Data.Phoneme.Place -> Data.Phoneme.Place -> Data.Phoneme.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Place) (y :: Data.Phoneme.Place) ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Place x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Place x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
974abd7cc25c83307948d0001b49f38e
  $fOrdRoundedness :: GHC.Classes.Ord Data.Phoneme.Roundedness
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Roundedness
                  Data.Phoneme.$fEqRoundedness
                  Data.Phoneme.$fOrdRoundedness_$ccompare
                  Data.Phoneme.$fOrdRoundedness_$c<
                  Data.Phoneme.$fOrdRoundedness_$c<=
                  Data.Phoneme.$fOrdRoundedness_$c>
                  Data.Phoneme.$fOrdRoundedness_$c>=
                  Data.Phoneme.$fOrdRoundedness_$cmax
                  Data.Phoneme.$fOrdRoundedness_$cmin -}
974abd7cc25c83307948d0001b49f38e
  $fOrdRoundedness_$c< ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Roundedness)
                   (b :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT
                   -> case b of wild1 {
                        Data.Phoneme.DEFAULT -> GHC.Types.False
                        Data.Phoneme.ROUNDED -> GHC.Types.True
                        Data.Phoneme.UNROUNDED -> GHC.Types.True }
                   Data.Phoneme.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.UNROUNDED -> GHC.Types.True }
                   Data.Phoneme.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
974abd7cc25c83307948d0001b49f38e
  $fOrdRoundedness_$c<= ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Roundedness)
                   (b :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT
                   -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   Data.Phoneme.ROUNDED
                   -> case b of wild1 {
                        Data.Phoneme.DEFAULT -> GHC.Types.False
                        Data.Phoneme.ROUNDED -> GHC.Types.True
                        Data.Phoneme.UNROUNDED -> GHC.Types.True }
                   Data.Phoneme.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Data.Phoneme.UNROUNDED -> GHC.Types.True } }) -}
974abd7cc25c83307948d0001b49f38e
  $fOrdRoundedness_$c> ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Roundedness)
                   (b :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   Data.Phoneme.ROUNDED
                   -> case b of wild1 {
                        Data.Phoneme.DEFAULT -> GHC.Types.True
                        Data.Phoneme.ROUNDED -> GHC.Types.False
                        Data.Phoneme.UNROUNDED -> GHC.Types.False }
                   Data.Phoneme.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.UNROUNDED -> GHC.Types.False } }) -}
974abd7cc25c83307948d0001b49f38e
  $fOrdRoundedness_$c>= ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Roundedness)
                   (b :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT
                   -> case b of wild1 {
                        Data.Phoneme.DEFAULT -> GHC.Types.True
                        Data.Phoneme.ROUNDED -> GHC.Types.False
                        Data.Phoneme.UNROUNDED -> GHC.Types.False }
                   Data.Phoneme.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Data.Phoneme.UNROUNDED -> GHC.Types.False }
                   Data.Phoneme.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
974abd7cc25c83307948d0001b49f38e
  $fOrdRoundedness_$ccompare ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Data.Phoneme.Roundedness)
                   (b :: Data.Phoneme.Roundedness) ->
                 case a of wild {
                   Data.Phoneme.DEFAULT
                   -> case b of wild1 {
                        Data.Phoneme.DEFAULT -> GHC.Types.EQ
                        Data.Phoneme.ROUNDED -> GHC.Types.LT
                        Data.Phoneme.UNROUNDED -> GHC.Types.LT }
                   Data.Phoneme.ROUNDED
                   -> case b of wild1 {
                        Data.Phoneme.DEFAULT -> GHC.Types.GT
                        Data.Phoneme.ROUNDED -> GHC.Types.EQ
                        Data.Phoneme.UNROUNDED -> GHC.Types.LT }
                   Data.Phoneme.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Data.Phoneme.UNROUNDED -> GHC.Types.EQ } }) -}
974abd7cc25c83307948d0001b49f38e
  $fOrdRoundedness_$cmax ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> Data.Phoneme.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Roundedness)
                   (y :: Data.Phoneme.Roundedness) ->
                 case x of wild {
                   Data.Phoneme.DEFAULT -> y
                   Data.Phoneme.ROUNDED
                   -> case y of wild1 {
                        DEFAULT -> Data.Phoneme.ROUNDED
                        Data.Phoneme.UNROUNDED -> Data.Phoneme.UNROUNDED }
                   Data.Phoneme.UNROUNDED
                   -> case y of wild1 { DEFAULT -> Data.Phoneme.UNROUNDED } }) -}
974abd7cc25c83307948d0001b49f38e
  $fOrdRoundedness_$cmin ::
    Data.Phoneme.Roundedness
    -> Data.Phoneme.Roundedness -> Data.Phoneme.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Roundedness)
                   (y :: Data.Phoneme.Roundedness) ->
                 case x of wild {
                   Data.Phoneme.DEFAULT
                   -> case y of wild1 { DEFAULT -> Data.Phoneme.DEFAULT }
                   Data.Phoneme.ROUNDED
                   -> case y of wild1 {
                        Data.Phoneme.DEFAULT -> Data.Phoneme.DEFAULT
                        Data.Phoneme.ROUNDED -> Data.Phoneme.ROUNDED
                        Data.Phoneme.UNROUNDED -> Data.Phoneme.ROUNDED }
                   Data.Phoneme.UNROUNDED -> y }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fOrdTone :: GHC.Classes.Ord Data.Phoneme.Tone
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Tone
                  Data.Phoneme.$fEqTone
                  Data.Phoneme.$fOrdTone_$ccompare
                  Data.Phoneme.$fOrdTone_$c<
                  Data.Phoneme.$fOrdTone_$c<=
                  Data.Phoneme.$fOrdTone_$c>
                  Data.Phoneme.$fOrdTone_$c>=
                  Data.Phoneme.$fOrdTone_$cmax
                  Data.Phoneme.$fOrdTone_$cmin -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fOrdTone_$c< ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Tone) (b :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2)) } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fOrdTone_$c<= ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Tone) (b :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2)) } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fOrdTone_$c> ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Tone) (b :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2)) } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fOrdTone_$c>= ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Tone) (b :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1)
                      (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2)) } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fOrdTone_$ccompare ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Tone) (b :: Data.Phoneme.Tone) ->
                 case a of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fOrdTone_$cmax ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> Data.Phoneme.Tone
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Tone) (y :: Data.Phoneme.Tone) ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fOrdTone_$cmin ::
    Data.Phoneme.Tone -> Data.Phoneme.Tone -> Data.Phoneme.Tone
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Tone) (y :: Data.Phoneme.Tone) ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x1)
                           (GHC.Prim.dataToTag# @ Data.Phoneme.Tone x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
7b936d811d140964313d74386435dc67
  $fOrdWord :: GHC.Classes.Ord Data.Phoneme.Word
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Word
                  Data.Phoneme.$fEqWord
                  Data.Phoneme.$fOrdWord_$ccompare
                  Data.Phoneme.$fOrdWord_$c<
                  Data.Phoneme.$fOrdWord_$c<=
                  Data.Phoneme.$fOrdWord_$c>
                  Data.Phoneme.$fOrdWord_$c>=
                  Data.Phoneme.$fOrdWord_$cmax
                  Data.Phoneme.$fOrdWord_$cmin -}
7b936d811d140964313d74386435dc67
  $fOrdWord_$c< ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Word) (b :: Data.Phoneme.Word) ->
                 case a of wild { Data.Phoneme.Word a1 ->
                 case b of wild1 { Data.Phoneme.Word b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Morpheme
                        Data.Phoneme.$fOrdMorpheme
                        a1
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True } } }) -}
7b936d811d140964313d74386435dc67
  $fOrdWord_$c<= ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Word) (b :: Data.Phoneme.Word) ->
                 case a of wild { Data.Phoneme.Word a1 ->
                 case b of wild1 { Data.Phoneme.Word b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Morpheme
                        Data.Phoneme.$fOrdMorpheme
                        a1
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } } }) -}
7b936d811d140964313d74386435dc67
  $fOrdWord_$c> ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Word) (b :: Data.Phoneme.Word) ->
                 case a of wild { Data.Phoneme.Word a1 ->
                 case b of wild1 { Data.Phoneme.Word b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Morpheme
                        Data.Phoneme.$fOrdMorpheme
                        a1
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } } }) -}
7b936d811d140964313d74386435dc67
  $fOrdWord_$c>= ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Word) (b :: Data.Phoneme.Word) ->
                 case a of wild { Data.Phoneme.Word a1 ->
                 case b of wild1 { Data.Phoneme.Word b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Morpheme
                        Data.Phoneme.$fOrdMorpheme
                        a1
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
7b936d811d140964313d74386435dc67
  $fOrdWord_$ccompare ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Data.Phoneme.Word) (b :: Data.Phoneme.Word) ->
                 case a of wild { Data.Phoneme.Word a1 ->
                 case b of wild1 { Data.Phoneme.Word b1 ->
                 GHC.Classes.$fOrd[]_$ccompare
                   @ Data.Phoneme.Morpheme
                   Data.Phoneme.$fOrdMorpheme
                   a1
                   b1 } }) -}
7b936d811d140964313d74386435dc67
  $fOrdWord_$cmax ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> Data.Phoneme.Word
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Word) (y :: Data.Phoneme.Word) ->
                 case x of wild { Data.Phoneme.Word a1 ->
                 case y of wild1 { Data.Phoneme.Word b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Morpheme
                        Data.Phoneme.$fOrdMorpheme
                        a1
                        b1 of wild2 {
                   DEFAULT -> wild1 GHC.Types.GT -> wild } } }) -}
7b936d811d140964313d74386435dc67
  $fOrdWord_$cmin ::
    Data.Phoneme.Word -> Data.Phoneme.Word -> Data.Phoneme.Word
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Data.Phoneme.Word) (y :: Data.Phoneme.Word) ->
                 case x of wild { Data.Phoneme.Word a1 ->
                 case y of wild1 { Data.Phoneme.Word b1 ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ Data.Phoneme.Morpheme
                        Data.Phoneme.$fOrdMorpheme
                        a1
                        b1 of wild2 {
                   DEFAULT -> wild GHC.Types.GT -> wild1 } } }) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness :: GHC.Read.Read Data.Phoneme.Backness
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Backness
                  Data.Phoneme.$fReadBackness_$creadsPrec
                  Data.Phoneme.$fReadBackness_$creadList
                  Data.Phoneme.$fReadBackness_$creadPrec
                  Data.Phoneme.$fReadBackness_$creadListPrec -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Backness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Backness]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Backness
                   Data.Phoneme.$fReadBackness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Backness>_R))
                   @ b
                   eta1) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Backness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.FRONT) -}
947c2610272332dab49e83e523b981ad
  $fReadBackness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRONT"#) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadBackness14,
                  Data.Phoneme.$fReadBackness13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Backness>_R))))) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Backness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.NEARFRONT) -}
9c01d213cbf96bb47537662451a938c4
  $fReadBackness14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARFRONT"#) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadBackness17,
                  Data.Phoneme.$fReadBackness16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Backness>_R))))) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Backness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.CENTRAL) -}
4f2e13e6e28a64522f133f6e7c4ce4d0
  $fReadBackness17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CENTRAL"#) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadBackness20,
                  Data.Phoneme.$fReadBackness19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Backness>_R))))) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Backness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.NEARBACK) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Backness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Backness
                   Data.Phoneme.$fReadBackness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Backness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Backness>_R)))) -}
bf5cf530a9ddb61bea8f491b30cd0623
  $fReadBackness20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARBACK"#) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadBackness23,
                  Data.Phoneme.$fReadBackness22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Backness>_R))))) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Backness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.BACK) -}
6a614b3c1cd0c3ee11d06602e1caea51
  $fReadBackness23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACK"#) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness24 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Backness]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Backness
                   Data.Phoneme.$fReadBackness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Backness>_R))
                   @ [Data.Phoneme.Backness]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Backness])) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Phoneme.Backness
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Phoneme.Backness
                   Data.Phoneme.$fReadBackness4
                   eta
                   @ b
                   eta1) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
                   Data.Phoneme.$fReadBackness21
                   Data.Phoneme.$fReadBackness5) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
                   Data.Phoneme.$fReadBackness18
                   Data.Phoneme.$fReadBackness6) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
                   Data.Phoneme.$fReadBackness15
                   Data.Phoneme.$fReadBackness7) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
                   Data.Phoneme.$fReadBackness12
                   Data.Phoneme.$fReadBackness8) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
                   Data.Phoneme.$fReadBackness9
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Phoneme.Backness))) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadBackness11,
                  Data.Phoneme.$fReadBackness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Backness>_R))))) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Backness]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Backness]
                   Data.Phoneme.$fReadBackness24) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Backness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadBackness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Backness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Backness]>_R))) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Backness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadBackness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Backness>_R)) -}
a3d34da76e787829b1272672cb3d501f
  $fReadBackness_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Backness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Backness
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Backness
                       Data.Phoneme.$fReadBackness3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Backness>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Backness>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Backness>_R)
                      @ Data.Phoneme.Backness
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Backness))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight :: GHC.Read.Read Data.Phoneme.Height
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Height
                  Data.Phoneme.$fReadHeight_$creadsPrec
                  Data.Phoneme.$fReadHeight_$creadList
                  Data.Phoneme.$fReadHeight_$creadPrec
                  Data.Phoneme.$fReadHeight_$creadListPrec -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Height] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Height]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Height
                   Data.Phoneme.$fReadHeight2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Height>_R))
                   @ b
                   eta1) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
                   Data.Phoneme.$fReadHeight11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadHeight13,
                  Data.Phoneme.$fReadHeight12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Height>_R))))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.OPEN) -}
7f2c13e9546594bd8d50a40d09ebeb6c
  $fReadHeight13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPEN"#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadHeight16,
                  Data.Phoneme.$fReadHeight15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Height>_R))))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.NEAROPEN) -}
3f2a6dd6234c917ff7443a9fe8496c9c
  $fReadHeight16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEAROPEN"#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadHeight19,
                  Data.Phoneme.$fReadHeight18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Height>_R))))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.OPENMID) -}
dd85bfb70b57b25b3bf77e2ec26c8654
  $fReadHeight19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPENMID"#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Height
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Height
                   Data.Phoneme.$fReadHeight3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Height>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Height>_R)))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadHeight22,
                  Data.Phoneme.$fReadHeight21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Height>_R))))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.MID) -}
ed285fa09381d65881c49bf4303b878b
  $fReadHeight22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MID"#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadHeight25,
                  Data.Phoneme.$fReadHeight24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Height>_R))))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.CLOSEMID) -}
70108138998f3c953b5b133e3e76454c
  $fReadHeight25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSEMID"#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadHeight28,
                  Data.Phoneme.$fReadHeight27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Height>_R))))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.NEARCLOSE) -}
efa174410c1f519d6ccd762088fe7d62
  $fReadHeight28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARCLOSE"#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadHeight31,
                  Data.Phoneme.$fReadHeight30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Height>_R))))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Phoneme.Height
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Phoneme.Height
                   Data.Phoneme.$fReadHeight4
                   eta
                   @ b
                   eta1) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Height -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.CLOSE) -}
a3e783e87a1512cf3780b8c238e64e5c
  $fReadHeight31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSE"#) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight32 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Height]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Height
                   Data.Phoneme.$fReadHeight2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Height>_R))
                   @ [Data.Phoneme.Height]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Height])) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
                   Data.Phoneme.$fReadHeight29
                   Data.Phoneme.$fReadHeight5) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
                   Data.Phoneme.$fReadHeight26
                   Data.Phoneme.$fReadHeight6) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
                   Data.Phoneme.$fReadHeight23
                   Data.Phoneme.$fReadHeight7) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
                   Data.Phoneme.$fReadHeight20
                   Data.Phoneme.$fReadHeight8) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
                   Data.Phoneme.$fReadHeight17
                   Data.Phoneme.$fReadHeight9) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height)
                   Data.Phoneme.$fReadHeight14
                   Data.Phoneme.$fReadHeight10) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Height]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Height]
                   Data.Phoneme.$fReadHeight32) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Height]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadHeight1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Height]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Height]>_R))) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Height
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadHeight2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Height>_R)) -}
e52daabfd4cc5d18128954ffcda031bb
  $fReadHeight_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Height
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Height
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Height
                       Data.Phoneme.$fReadHeight3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Height>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Height>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Height>_R)
                      @ Data.Phoneme.Height
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Height))) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength :: GHC.Read.Read Data.Phoneme.Length
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Length
                  Data.Phoneme.$fReadLength_$creadsPrec
                  Data.Phoneme.$fReadLength_$creadList
                  Data.Phoneme.$fReadLength_$creadPrec
                  Data.Phoneme.$fReadLength_$creadListPrec -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Length] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Length]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Length
                   Data.Phoneme.$fReadLength2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Length>_R))
                   @ b
                   eta1) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadLength12,
                  Data.Phoneme.$fReadLength11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Length>_R))))) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Length -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.NORMAL) -}
b549db2e3ddefd1dff13efc42c04e8d9
  $fReadLength12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NORMAL"#) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadLength15,
                  Data.Phoneme.$fReadLength14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Length>_R))))) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Length -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.SHORT) -}
15d4444a690a18a15d1b1f9612f32365
  $fReadLength15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SHORT"#) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength16 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Length]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Length
                   Data.Phoneme.$fReadLength2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Length>_R))
                   @ [Data.Phoneme.Length]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Length])) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Length
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Length
                   Data.Phoneme.$fReadLength3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Length>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Length>_R)))) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Phoneme.Length
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Phoneme.Length
                   Data.Phoneme.$fReadLength4
                   eta
                   @ b
                   eta1) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)
                   Data.Phoneme.$fReadLength13
                   Data.Phoneme.$fReadLength5) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)
                   Data.Phoneme.$fReadLength10
                   Data.Phoneme.$fReadLength6) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)
                   Data.Phoneme.$fReadLength7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length))) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadLength9,
                  Data.Phoneme.$fReadLength8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Length>_R))))) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Length -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LONG) -}
812a2164b106c8b4e5444794ebd8528a
  $fReadLength9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LONG"#) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Length]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Length]
                   Data.Phoneme.$fReadLength16) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Length]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadLength1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Length]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Length]>_R))) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Length
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadLength2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Length>_R)) -}
3bc911798122c419c4b3747def87cb7a
  $fReadLength_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Length
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Length
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Length
                       Data.Phoneme.$fReadLength3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Length>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Length>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Length>_R)
                      @ Data.Phoneme.Length
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Length))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner :: GHC.Read.Read Data.Phoneme.Manner
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Manner
                  Data.Phoneme.$fReadManner_$creadsPrec
                  Data.Phoneme.$fReadManner_$creadList
                  Data.Phoneme.$fReadManner_$creadPrec
                  Data.Phoneme.$fReadManner_$creadListPrec -}
457727c142c08ed8e753e8053528da14
  $fReadManner1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Manner] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Manner]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Manner
                   Data.Phoneme.$fReadManner2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Manner>_R))
                   @ b
                   eta1) -}
457727c142c08ed8e753e8053528da14
  $fReadManner10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner35
                   Data.Phoneme.$fReadManner11) -}
457727c142c08ed8e753e8053528da14
  $fReadManner11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner32
                   Data.Phoneme.$fReadManner12) -}
457727c142c08ed8e753e8053528da14
  $fReadManner12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner29
                   Data.Phoneme.$fReadManner13) -}
457727c142c08ed8e753e8053528da14
  $fReadManner13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner26
                   Data.Phoneme.$fReadManner14) -}
457727c142c08ed8e753e8053528da14
  $fReadManner14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner23
                   Data.Phoneme.$fReadManner15) -}
457727c142c08ed8e753e8053528da14
  $fReadManner15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner20
                   Data.Phoneme.$fReadManner16) -}
457727c142c08ed8e753e8053528da14
  $fReadManner16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner17
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner19,
                  Data.Phoneme.$fReadManner18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LFLAP) -}
cccc08757c80a35ddbf1d418e5d4adc3
  $fReadManner19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFLAP"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Manner
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Manner
                   Data.Phoneme.$fReadManner3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Manner>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Manner>_R)))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner22,
                  Data.Phoneme.$fReadManner21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LAPPROXIMANT) -}
3d05d29f6b3b1f8d1418943d3749bb66
  $fReadManner22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAPPROXIMANT"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner25,
                  Data.Phoneme.$fReadManner24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LFRICATIVE) -}
cebd6272ab77ff67583b4dafee2accda
  $fReadManner25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFRICATIVE"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner28,
                  Data.Phoneme.$fReadManner27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LAFFRICATE) -}
49fdee61b557ce9e0fbb5a67c0d1c455
  $fReadManner28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAFFRICATE"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner31,
                  Data.Phoneme.$fReadManner30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Phoneme.Manner
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Phoneme.Manner
                   Data.Phoneme.$fReadManner4
                   eta
                   @ b
                   eta1) -}
457727c142c08ed8e753e8053528da14
  $fReadManner30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.TRILL) -}
7b8f9aa4b761356629c474dce276b48d
  $fReadManner31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRILL"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner34,
                  Data.Phoneme.$fReadManner33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.FLAP) -}
58396741b9440bdc0f3fc43468395385
  $fReadManner34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FLAP"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner37,
                  Data.Phoneme.$fReadManner36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.APPROXIMANT) -}
043e010639f14a5d9883aaa0084044ea
  $fReadManner37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "APPROXIMANT"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner40,
                  Data.Phoneme.$fReadManner39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.FRICATIVE) -}
457727c142c08ed8e753e8053528da14
  $fReadManner4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner53
                   Data.Phoneme.$fReadManner5) -}
be3d5c7585e56a0c61f1d91f434446a6
  $fReadManner40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRICATIVE"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner43,
                  Data.Phoneme.$fReadManner42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.SILIBANT) -}
0e6d5dcba8ff081f4435218dacc62d5a
  $fReadManner43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SILIBANT"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner44 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner46,
                  Data.Phoneme.$fReadManner45
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.AFFRICATE) -}
201d02c38c844a2a75c6f0a9e2487b80
  $fReadManner46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFFRICATE"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner47 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner49,
                  Data.Phoneme.$fReadManner48
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner48 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.SAFFRICATE) -}
2e61d292bbcc733039106cd33bc10bee
  $fReadManner49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SAFFRICATE"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner50
                   Data.Phoneme.$fReadManner6) -}
457727c142c08ed8e753e8053528da14
  $fReadManner50 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner52,
                  Data.Phoneme.$fReadManner51
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner51 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.STOP) -}
db17eac884b99e3b8999264dba9084ea
  $fReadManner52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STOP"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadManner55,
                  Data.Phoneme.$fReadManner54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Manner>_R))))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Manner -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.NASAL) -}
bc88278510660977f05623072ff98283
  $fReadManner55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NASAL"#) -}
457727c142c08ed8e753e8053528da14
  $fReadManner56 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Manner]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Manner
                   Data.Phoneme.$fReadManner2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Manner>_R))
                   @ [Data.Phoneme.Manner]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Manner])) -}
457727c142c08ed8e753e8053528da14
  $fReadManner6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner47
                   Data.Phoneme.$fReadManner7) -}
457727c142c08ed8e753e8053528da14
  $fReadManner7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner44
                   Data.Phoneme.$fReadManner8) -}
457727c142c08ed8e753e8053528da14
  $fReadManner8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner41
                   Data.Phoneme.$fReadManner9) -}
457727c142c08ed8e753e8053528da14
  $fReadManner9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner)
                   Data.Phoneme.$fReadManner38
                   Data.Phoneme.$fReadManner10) -}
457727c142c08ed8e753e8053528da14
  $fReadManner_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Manner]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Manner]
                   Data.Phoneme.$fReadManner56) -}
457727c142c08ed8e753e8053528da14
  $fReadManner_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Manner]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadManner1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Manner]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Manner]>_R))) -}
457727c142c08ed8e753e8053528da14
  $fReadManner_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Manner
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadManner2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Manner>_R)) -}
457727c142c08ed8e753e8053528da14
  $fReadManner_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Manner
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Manner
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Manner
                       Data.Phoneme.$fReadManner3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Manner>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Manner>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Manner>_R)
                      @ Data.Phoneme.Manner
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Manner))) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme :: GHC.Read.Read Data.Phoneme.Morpheme
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Morpheme
                  Data.Phoneme.$fReadMorpheme_$creadsPrec
                  Data.Phoneme.$fReadMorpheme_$creadList
                  Data.Phoneme.$fReadMorpheme_$creadPrec
                  Data.Phoneme.$fReadMorpheme_$creadListPrec -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Morpheme] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Morpheme]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Morpheme
                   Data.Phoneme.$fReadMorpheme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Morpheme>_R))
                   @ b
                   eta1) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Morpheme
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Morpheme
                   Data.Phoneme.$fReadMorpheme3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Morpheme>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Morpheme>_R)))) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Morpheme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Data.Phoneme.Morpheme
                          -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$creadPrec ww1 @ b w1 }) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme4 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Morpheme]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Morpheme
                   Data.Phoneme.$fReadMorpheme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Morpheme>_R))
                   @ [Data.Phoneme.Morpheme]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Morpheme])) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Morpheme]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Morpheme]
                   Data.Phoneme.$fReadMorpheme4) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Morpheme]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadMorpheme1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Morpheme]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Morpheme]>_R))) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Morpheme
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadMorpheme2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Morpheme>_R)) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fReadMorpheme_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Morpheme
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Morpheme
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Morpheme
                       Data.Phoneme.$fReadMorpheme3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Morpheme>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Morpheme>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Morpheme>_R)
                      @ Data.Phoneme.Morpheme
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Morpheme))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation :: GHC.Read.Read Data.Phoneme.Phonation
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phonation
                  Data.Phoneme.$fReadPhonation_$creadsPrec
                  Data.Phoneme.$fReadPhonation_$creadList
                  Data.Phoneme.$fReadPhonation_$creadPrec
                  Data.Phoneme.$fReadPhonation_$creadListPrec -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Phonation] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Phonation]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Phonation
                   Data.Phoneme.$fReadPhonation2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Phonation>_R))
                   @ b
                   eta1) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
                   Data.Phoneme.$fReadPhonation11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Phoneme.Phonation))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPhonation13,
                  Data.Phoneme.$fReadPhonation12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Phonation>_R))))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Phonation
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.ASPIRATED) -}
8787ba853958d3a57126759dfe6f66ba
  $fReadPhonation13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ASPIRATED"#) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPhonation16,
                  Data.Phoneme.$fReadPhonation15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Phonation>_R))))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Phonation
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.CREAKY) -}
3ee2410378c9777414b2c41b6ded8794
  $fReadPhonation16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CREAKY"#) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPhonation19,
                  Data.Phoneme.$fReadPhonation18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Phonation>_R))))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Phonation
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.STIFF) -}
6adaf3c8fa418ab5013d50e3eccba9d5
  $fReadPhonation19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STIFF"#) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Phonation
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Phonation
                   Data.Phoneme.$fReadPhonation3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Phonation>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Phonation>_R)))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPhonation22,
                  Data.Phoneme.$fReadPhonation21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Phonation>_R))))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Phonation
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.MODAL) -}
59284646978a07063e1d760c4f90ceed
  $fReadPhonation22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MODAL"#) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPhonation25,
                  Data.Phoneme.$fReadPhonation24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Phonation>_R))))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Phonation
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.SLACK) -}
e5b22501d0cf3054970ac5655104a1a4
  $fReadPhonation25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SLACK"#) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPhonation28,
                  Data.Phoneme.$fReadPhonation27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Phonation>_R))))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Phonation
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.BREATHY) -}
0a01b5aaf982dbed0ef0846357f8395a
  $fReadPhonation28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BREATHY"#) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPhonation31,
                  Data.Phoneme.$fReadPhonation30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Phonation>_R))))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Phoneme.Phonation
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Phoneme.Phonation
                   Data.Phoneme.$fReadPhonation4
                   eta
                   @ b
                   eta1) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Phonation
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.VOICELESS) -}
44381f1fb6a78c6c008f79872b1c7996
  $fReadPhonation31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICELESS"#) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation32 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Phonation]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Phonation
                   Data.Phoneme.$fReadPhonation2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Phonation>_R))
                   @ [Data.Phoneme.Phonation]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Phonation])) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
                   Data.Phoneme.$fReadPhonation29
                   Data.Phoneme.$fReadPhonation5) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
                   Data.Phoneme.$fReadPhonation26
                   Data.Phoneme.$fReadPhonation6) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
                   Data.Phoneme.$fReadPhonation23
                   Data.Phoneme.$fReadPhonation7) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
                   Data.Phoneme.$fReadPhonation20
                   Data.Phoneme.$fReadPhonation8) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
                   Data.Phoneme.$fReadPhonation17
                   Data.Phoneme.$fReadPhonation9) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation)
                   Data.Phoneme.$fReadPhonation14
                   Data.Phoneme.$fReadPhonation10) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Phonation]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Phonation]
                   Data.Phoneme.$fReadPhonation32) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Phonation]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadPhonation1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Phonation]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Phonation]>_R))) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phonation
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadPhonation2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Phonation>_R)) -}
ff541d1764888145304960d9b00dcecd
  $fReadPhonation_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Phonation
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Phonation
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Phonation
                       Data.Phoneme.$fReadPhonation3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Phonation>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Phonation>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Phoneme.Phonation>_R)
                      @ Data.Phoneme.Phonation
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Phonation))) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme :: GHC.Read.Read Data.Phoneme.Phoneme
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phoneme
                  Data.Phoneme.$fReadPhoneme_$creadsPrec
                  Data.Phoneme.$fReadPhoneme_$creadList
                  Data.Phoneme.$fReadPhoneme_$creadPrec
                  Data.Phoneme.$fReadPhoneme_$creadListPrec -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Phoneme] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Phoneme]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Phoneme
                   Data.Phoneme.$fReadPhoneme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Phoneme>_R))
                   @ b
                   eta1) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Phoneme
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Phoneme
                   Data.Phoneme.$fReadPhoneme3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Phoneme>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Phoneme>_R)))) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Phoneme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)> -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme4 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Phoneme]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Phoneme
                   Data.Phoneme.$fReadPhoneme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Phoneme>_R))
                   @ [Data.Phoneme.Phoneme]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Phoneme])) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Phoneme]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Phoneme]
                   Data.Phoneme.$fReadPhoneme4) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Phoneme]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadPhoneme1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Phoneme]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Phoneme]>_R))) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Phoneme
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadPhoneme2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Phoneme>_R)) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fReadPhoneme_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Phoneme
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Phoneme
                       Data.Phoneme.$fReadPhoneme3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Phoneme>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Phoneme>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Phoneme>_R)
                      @ Data.Phoneme.Phoneme
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Phoneme))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace :: GHC.Read.Read Data.Phoneme.Place
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Place
                  Data.Phoneme.$fReadPlace_$creadsPrec
                  Data.Phoneme.$fReadPlace_$creadList
                  Data.Phoneme.$fReadPlace_$creadPrec
                  Data.Phoneme.$fReadPlace_$creadListPrec -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Place] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Place]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Place
                   Data.Phoneme.$fReadPlace2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Place>_R))
                   @ b
                   eta1) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace59
                   Data.Phoneme.$fReadPlace11) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace56
                   Data.Phoneme.$fReadPlace12) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace53
                   Data.Phoneme.$fReadPlace13) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace50
                   Data.Phoneme.$fReadPlace14) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace47
                   Data.Phoneme.$fReadPlace15) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace44
                   Data.Phoneme.$fReadPlace16) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace41
                   Data.Phoneme.$fReadPlace17) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace17 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace38
                   Data.Phoneme.$fReadPlace18) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace18 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace35
                   Data.Phoneme.$fReadPlace19) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace19 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace32
                   Data.Phoneme.$fReadPlace20) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Place
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Place
                   Data.Phoneme.$fReadPlace3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Place>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Place>_R)))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace20 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace29
                   Data.Phoneme.$fReadPlace21) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace26
                   Data.Phoneme.$fReadPlace22) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace22 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace23
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace25,
                  Data.Phoneme.$fReadPlace24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.GLOTTAL) -}
344ace4f752253c351c7dc8aead77ca3
  $fReadPlace25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace28,
                  Data.Phoneme.$fReadPlace27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.EPIGLOTTAL) -}
7fa23af61b150f134aea8cd0fb7c79c6
  $fReadPlace28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIGLOTTAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace31,
                  Data.Phoneme.$fReadPlace30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Phoneme.Place
                   Data.Phoneme.$fReadPlace4
                   eta
                   @ b
                   eta1) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.PHARYNGEAL) -}
3cde9f45b726f4fd9bd057c06819e6da
  $fReadPlace31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PHARYNGEAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace34,
                  Data.Phoneme.$fReadPlace33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.EPIPHARYNGEAL) -}
811c95e86d66eca2cb05128d55ba9197
  $fReadPlace34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIPHARYNGEAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace37,
                  Data.Phoneme.$fReadPlace36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LARYNGEAL) -}
988725a4eb4716fa54fdcac3d17d682d
  $fReadPlace37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LARYNGEAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace40,
                  Data.Phoneme.$fReadPlace39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.UVULAR) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace77
                   Data.Phoneme.$fReadPlace5) -}
8ab9891da28d4646bffc4fdcdb8cb8e2
  $fReadPlace40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVULAR"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace43,
                  Data.Phoneme.$fReadPlace42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.VELAR) -}
54dde00035cc6498d3155331cbf292cc
  $fReadPlace43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VELAR"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace44 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace46,
                  Data.Phoneme.$fReadPlace45
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.PALATAL) -}
22ba112ece90d00cf807f925e23676a7
  $fReadPlace46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PALATAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace47 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace49,
                  Data.Phoneme.$fReadPlace48
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace48 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.ALVEOLOPALATAL) -}
632041ef9de057bb911c077935870c7f
  $fReadPlace49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLOPALATAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace74
                   Data.Phoneme.$fReadPlace6) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace50 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace52,
                  Data.Phoneme.$fReadPlace51
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace51 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.DORSAL) -}
5e7794c04c020660b6361703f8b261d3
  $fReadPlace52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DORSAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace55,
                  Data.Phoneme.$fReadPlace54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.RETROFLEX) -}
9e0f74f4ca79f1be3b552ccf0e63a6a5
  $fReadPlace55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RETROFLEX"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace56 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace58,
                  Data.Phoneme.$fReadPlace57
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace57 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.POSTALVEOLAR) -}
b426f306f31705331ed48ef9b5adc370
  $fReadPlace58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POSTALVEOLAR"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace59 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace61,
                  Data.Phoneme.$fReadPlace60
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace71
                   Data.Phoneme.$fReadPlace7) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace60 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.ALVEOLAR) -}
3ce9d77d5fe53b497e688f1cc61feba6
  $fReadPlace61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLAR"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace62 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace64,
                  Data.Phoneme.$fReadPlace63
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace63 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.DENTAL) -}
3e39163fa183400ecf13b9f23b10dbf3
  $fReadPlace64 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace65 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace67,
                  Data.Phoneme.$fReadPlace66
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace66 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.DENTIALVEOLAR) -}
20f16c458d336003596e58197e3cd599
  $fReadPlace67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTIALVEOLAR"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace68 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace70,
                  Data.Phoneme.$fReadPlace69
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace69 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.CORONAL) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace68
                   Data.Phoneme.$fReadPlace8) -}
ef472acfaf526231d7c5cfbf0c176306
  $fReadPlace70 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CORONAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace71 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace73,
                  Data.Phoneme.$fReadPlace72
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace72 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LABIODENTAL) -}
3b27d397dbe20ecea83d8709297e9b5d
  $fReadPlace73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIODENTAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace74 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace76,
                  Data.Phoneme.$fReadPlace75
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace75 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.BILABIAL) -}
dfd0b528cdaeb41c3e6810e643bfc374
  $fReadPlace76 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BILABIAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace77 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadPlace79,
                  Data.Phoneme.$fReadPlace78
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Place>_R))))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace78 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Place -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LABIAL) -}
5a654218b7aa5070ba19a69a5fa17ae4
  $fReadPlace79 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIAL"#) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace65
                   Data.Phoneme.$fReadPlace9) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace80 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Place]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Place
                   Data.Phoneme.$fReadPlace2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Place>_R))
                   @ [Data.Phoneme.Place]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Place])) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place)
                   Data.Phoneme.$fReadPlace62
                   Data.Phoneme.$fReadPlace10) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Place]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Place]
                   Data.Phoneme.$fReadPlace80) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Place]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadPlace1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Place]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Place]>_R))) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Place
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadPlace2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Place>_R)) -}
1971716d79acadd98b648de5350e6f24
  $fReadPlace_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Place
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Place
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Place
                       Data.Phoneme.$fReadPlace3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Place>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Place>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Place>_R)
                      @ Data.Phoneme.Place
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Place))) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness :: GHC.Read.Read Data.Phoneme.Roundedness
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Roundedness
                  Data.Phoneme.$fReadRoundedness_$creadsPrec
                  Data.Phoneme.$fReadRoundedness_$creadList
                  Data.Phoneme.$fReadRoundedness_$creadPrec
                  Data.Phoneme.$fReadRoundedness_$creadListPrec -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Roundedness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Roundedness]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Roundedness
                   Data.Phoneme.$fReadRoundedness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Roundedness>_R))
                   @ b
                   eta1) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadRoundedness12,
                  Data.Phoneme.$fReadRoundedness11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Roundedness>_R))))) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Roundedness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.ROUNDED) -}
95acc6684eebb0a3e626919a02ec9d03
  $fReadRoundedness12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ROUNDED"#) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadRoundedness15,
                  Data.Phoneme.$fReadRoundedness14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Roundedness>_R))))) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Roundedness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.DEFAULT) -}
b9c86cf615202e3711182aed784ffcf2
  $fReadRoundedness15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DEFAULT"#) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness16 ::
    Text.ParserCombinators.ReadP.P [Data.Phoneme.Roundedness]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Roundedness
                   Data.Phoneme.$fReadRoundedness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Roundedness>_R))
                   @ [Data.Phoneme.Roundedness]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Roundedness])) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Roundedness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Roundedness
                   Data.Phoneme.$fReadRoundedness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Roundedness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Roundedness>_R)))) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Phoneme.Roundedness
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Phoneme.Roundedness
                   Data.Phoneme.$fReadRoundedness4
                   eta
                   @ b
                   eta1) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)
                   Data.Phoneme.$fReadRoundedness13
                   Data.Phoneme.$fReadRoundedness5) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)
                   Data.Phoneme.$fReadRoundedness10
                   Data.Phoneme.$fReadRoundedness6) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)
                   Data.Phoneme.$fReadRoundedness7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           Data.Phoneme.Roundedness))) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadRoundedness9,
                  Data.Phoneme.$fReadRoundedness8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Roundedness>_R))))) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Roundedness
                           -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.UNROUNDED) -}
37d3f95043bdc53266325d4840dc809a
  $fReadRoundedness9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UNROUNDED"#) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Roundedness]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Roundedness]
                   Data.Phoneme.$fReadRoundedness16) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Roundedness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadRoundedness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Roundedness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Roundedness]>_R))) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Roundedness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadRoundedness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Roundedness>_R)) -}
974abd7cc25c83307948d0001b49f38e
  $fReadRoundedness_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Roundedness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Roundedness
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Roundedness
                       Data.Phoneme.$fReadRoundedness3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Roundedness>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Roundedness>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0]
                         <Data.Phoneme.Roundedness>_R)
                      @ Data.Phoneme.Roundedness
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Roundedness))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone :: GHC.Read.Read Data.Phoneme.Tone
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Tone
                  Data.Phoneme.$fReadTone_$creadsPrec
                  Data.Phoneme.$fReadTone_$creadList
                  Data.Phoneme.$fReadTone_$creadPrec
                  Data.Phoneme.$fReadTone_$creadListPrec -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Tone] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Tone]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Tone
                   Data.Phoneme.$fReadTone2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Tone>_R))
                   @ b
                   eta1) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone39
                   Data.Phoneme.$fReadTone11) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone36
                   Data.Phoneme.$fReadTone12) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone33
                   Data.Phoneme.$fReadTone13) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone30
                   Data.Phoneme.$fReadTone14) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone27
                   Data.Phoneme.$fReadTone15) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone24
                   Data.Phoneme.$fReadTone16) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone21
                   Data.Phoneme.$fReadTone17) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone17 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone18
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone20,
                  Data.Phoneme.$fReadTone19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.PEAKT) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Tone
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Tone
                   Data.Phoneme.$fReadTone3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Tone>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Tone>_R)))) -}
563fe9c5fa7099c647dc0c365c1fe9c5
  $fReadTone20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PEAKT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone23,
                  Data.Phoneme.$fReadTone22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.DIPT) -}
c151342084d4bfb65babe26cb9f8b012
  $fReadTone23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DIPT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone24 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone26,
                  Data.Phoneme.$fReadTone25
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone25 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LRISET) -}
1a8bebc245e345182870a5e87fb5eb09
  $fReadTone26 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LRISET"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone27 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone29,
                  Data.Phoneme.$fReadTone28
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone28 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.HRISET) -}
55a83cfe422947b0e7c0969744f1dcb6
  $fReadTone29 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HRISET"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.choose2
                   @ Data.Phoneme.Tone
                   Data.Phoneme.$fReadTone4
                   eta
                   @ b
                   eta1) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone30 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone32,
                  Data.Phoneme.$fReadTone31
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone31 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.RISET) -}
671f12a61ea4293c5481ebc17c6534eb
  $fReadTone32 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RISET"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone33 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone35,
                  Data.Phoneme.$fReadTone34
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone34 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LFALLT) -}
a3dab89ddd1eac30c80bca7ee692c063
  $fReadTone35 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFALLT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone36 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone38,
                  Data.Phoneme.$fReadTone37
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone37 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.HFALLT) -}
84216e56b011d7f53ff5f15b7eae8b28
  $fReadTone38 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HFALLT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone39 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone41,
                  Data.Phoneme.$fReadTone40
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone57
                   Data.Phoneme.$fReadTone5) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone40 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.FALLT) -}
f8874657a16f8b17ba06d99d57783087
  $fReadTone41 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FALLT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone42 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone44,
                  Data.Phoneme.$fReadTone43
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone43 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.BOTTOMT) -}
203c84620f26f654bdeecd675347af2a
  $fReadTone44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BOTTOMT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone45 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone47,
                  Data.Phoneme.$fReadTone46
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone46 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.LOWT) -}
b633e3812354404250051dc6ac8ae142
  $fReadTone47 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LOWT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone48 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone50,
                  Data.Phoneme.$fReadTone49
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone49 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.MIDT) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone54
                   Data.Phoneme.$fReadTone6) -}
b4966432c5f78f98e0becee85da7146a
  $fReadTone50 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MIDT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone51 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone53,
                  Data.Phoneme.$fReadTone52
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone52 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.HIGHT) -}
a2dedbf706250c01e3b555ac2ecf337b
  $fReadTone53 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HIGHT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone54 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone56,
                  Data.Phoneme.$fReadTone55
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone55 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.TOPT) -}
f6a1378f8b1c65a641cf4ff25b061e65
  $fReadTone56 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TOPT"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone57 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
  {- Strictness: m,
     Unfolding: ((Data.Phoneme.$fReadTone59,
                  Data.Phoneme.$fReadTone58
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Data.Phoneme.Tone>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Data.Phoneme.Tone>_R))))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone58 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Data.Phoneme.Tone -> Text.ParserCombinators.ReadP.P b) ->
                 eta Data.Phoneme.NONET) -}
30a174dbe082fc14c5e941a7fd755cc9
  $fReadTone59 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NONET"#) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone51
                   Data.Phoneme.$fReadTone7) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone60 :: Text.ParserCombinators.ReadP.P [Data.Phoneme.Tone]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Tone
                   Data.Phoneme.$fReadTone2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Tone>_R))
                   @ [Data.Phoneme.Tone]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Tone])) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone48
                   Data.Phoneme.$fReadTone8) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone45
                   Data.Phoneme.$fReadTone9) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone)
                   Data.Phoneme.$fReadTone42
                   Data.Phoneme.$fReadTone10) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Tone]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Tone]
                   Data.Phoneme.$fReadTone60) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Tone]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadTone1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Tone]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Tone]>_R))) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Tone
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadTone2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Tone>_R)) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fReadTone_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Tone
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Tone
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Tone
                       Data.Phoneme.$fReadTone3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Tone>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Tone>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Tone>_R)
                      @ Data.Phoneme.Tone
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Tone))) -}
7b936d811d140964313d74386435dc67
  $fReadWord :: GHC.Read.Read Data.Phoneme.Word
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Word
                  Data.Phoneme.$fReadWord_$creadsPrec
                  Data.Phoneme.$fReadWord_$creadList
                  Data.Phoneme.$fReadWord_$creadPrec
                  Data.Phoneme.$fReadWord_$creadListPrec -}
7b936d811d140964313d74386435dc67
  $fReadWord1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Data.Phoneme.Word] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Data.Phoneme.Word]
                            -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.$wlist
                   @ Data.Phoneme.Word
                   Data.Phoneme.$fReadWord2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Word>_R))
                   @ b
                   eta1) -}
7b936d811d140964313d74386435dc67
  $fReadWord2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Data.Phoneme.Word
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ Data.Phoneme.Word
                   Data.Phoneme.$fReadWord3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <Data.Phoneme.Word>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <Data.Phoneme.Word>_R)))) -}
7b936d811d140964313d74386435dc67
  $fReadWord3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Data.Phoneme.Word -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (w1 :: Data.Phoneme.Word -> Text.ParserCombinators.ReadP.P b) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Data.Phoneme.$w$creadPrec1 ww1 @ b w1 }) -}
7b936d811d140964313d74386435dc67
  $fReadWord4 :: Text.ParserCombinators.ReadP.P [Data.Phoneme.Word]
  {- Unfolding: (GHC.Read.$wlist
                   @ Data.Phoneme.Word
                   Data.Phoneme.$fReadWord2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Data.Phoneme.Word>_R))
                   @ [Data.Phoneme.Word]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Data.Phoneme.Word])) -}
7b936d811d140964313d74386435dc67
  $fReadWord_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Data.Phoneme.Word]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Data.Phoneme.Word]
                   Data.Phoneme.$fReadWord4) -}
7b936d811d140964313d74386435dc67
  $fReadWord_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Data.Phoneme.Word]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadWord1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Data.Phoneme.Word]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Data.Phoneme.Word]>_R))) -}
7b936d811d140964313d74386435dc67
  $fReadWord_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Data.Phoneme.Word
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Data.Phoneme.$fReadWord2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Data.Phoneme.Word>_R)) -}
7b936d811d140964313d74386435dc67
  $fReadWord_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS Data.Phoneme.Word
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Data.Phoneme.Word
                   ((GHC.Read.$fReadDouble10
                       @ Data.Phoneme.Word
                       Data.Phoneme.$fReadWord3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                           <Data.Phoneme.Word>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                      <Data.Phoneme.Word>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Data.Phoneme.Word>_R)
                      @ Data.Phoneme.Word
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Data.Phoneme.Word))) -}
a3d34da76e787829b1272672cb3d501f
  $fShowBackness :: GHC.Show.Show Data.Phoneme.Backness
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Backness
                  Data.Phoneme.$fShowBackness_$cshowsPrec
                  Data.Phoneme.$fShowBackness_$cshow
                  Data.Phoneme.$fShowBackness_$cshowList -}
a3d34da76e787829b1272672cb3d501f
  $fShowBackness_$cshow :: Data.Phoneme.Backness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Backness) ->
                 Data.Phoneme.$fShowBackness_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a3d34da76e787829b1272672cb3d501f
  $fShowBackness_$cshowList ::
    [Data.Phoneme.Backness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Backness
                   Data.Phoneme.$w$cshowsPrec) -}
a3d34da76e787829b1272672cb3d501f
  $fShowBackness_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Backness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Backness)
                   (w2 :: GHC.Base.String) ->
                 Data.Phoneme.$w$cshowsPrec w1 w2) -}
e52daabfd4cc5d18128954ffcda031bb
  $fShowHeight :: GHC.Show.Show Data.Phoneme.Height
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Height
                  Data.Phoneme.$fShowHeight_$cshowsPrec
                  Data.Phoneme.$fShowHeight_$cshow
                  Data.Phoneme.$fShowHeight_$cshowList -}
e52daabfd4cc5d18128954ffcda031bb
  $fShowHeight_$cshow :: Data.Phoneme.Height -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Height) ->
                 Data.Phoneme.$fShowHeight_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e52daabfd4cc5d18128954ffcda031bb
  $fShowHeight_$cshowList :: [Data.Phoneme.Height] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Height
                   Data.Phoneme.$w$cshowsPrec1) -}
e52daabfd4cc5d18128954ffcda031bb
  $fShowHeight_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Height -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Height)
                   (w2 :: GHC.Base.String) ->
                 Data.Phoneme.$w$cshowsPrec1 w1 w2) -}
3bc911798122c419c4b3747def87cb7a
  $fShowLength :: GHC.Show.Show Data.Phoneme.Length
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Length
                  Data.Phoneme.$fShowLength_$cshowsPrec
                  Data.Phoneme.$fShowLength_$cshow
                  Data.Phoneme.$fShowLength_$cshowList -}
3bc911798122c419c4b3747def87cb7a
  $fShowLength_$cshow :: Data.Phoneme.Length -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Length) ->
                 case x of wild {
                   Data.Phoneme.SHORT -> Data.Phoneme.$fReadLength15
                   Data.Phoneme.NORMAL -> Data.Phoneme.$fReadLength12
                   Data.Phoneme.LONG -> Data.Phoneme.$fReadLength9 }) -}
3bc911798122c419c4b3747def87cb7a
  $fShowLength_$cshowList :: [Data.Phoneme.Length] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Length
                   Data.Phoneme.$w$cshowsPrec2) -}
3bc911798122c419c4b3747def87cb7a
  $fShowLength_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Length -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Length)
                   (w2 :: GHC.Base.String) ->
                 Data.Phoneme.$w$cshowsPrec2 w1 w2) -}
457727c142c08ed8e753e8053528da14
  $fShowManner :: GHC.Show.Show Data.Phoneme.Manner
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Manner
                  Data.Phoneme.$fShowManner_$cshowsPrec
                  Data.Phoneme.$fShowManner_$cshow
                  Data.Phoneme.$fShowManner_$cshowList -}
457727c142c08ed8e753e8053528da14
  $fShowManner_$cshow :: Data.Phoneme.Manner -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Manner) ->
                 Data.Phoneme.$fShowManner_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
457727c142c08ed8e753e8053528da14
  $fShowManner_$cshowList :: [Data.Phoneme.Manner] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Manner
                   Data.Phoneme.$w$cshowsPrec3) -}
457727c142c08ed8e753e8053528da14
  $fShowManner_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Manner -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Manner)
                   (w2 :: GHC.Base.String) ->
                 Data.Phoneme.$w$cshowsPrec3 w1 w2) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fShowMorpheme :: GHC.Show.Show Data.Phoneme.Morpheme
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Morpheme
                  Data.Phoneme.$fShowMorpheme_$cshowsPrec1
                  Data.Phoneme.$fShowMorpheme_$cshow
                  Data.Phoneme.$fShowMorpheme_$cshowList -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fShowMorpheme1 :: Data.Phoneme.Morpheme -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Data.Phoneme.Morpheme)
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Data.Phoneme.Morpheme ww1 ->
                 Data.Phoneme.$w$cshowsPrec4 0# ww1 w1 }) -}
ddaf639fd37e8dc517f7674468e64ebd
  $fShowMorpheme2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
89e5d0b6babf9aaa48847a7d75dd140c
  $fShowMorpheme3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
a0250463e8596b39dbecec57d5d12fc8
  $fShowMorpheme4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getPhonemes = "#) -}
21beffae1561ff316135473bbf14441d
  $fShowMorpheme5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Morpheme {"#) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fShowMorpheme_$cshow :: Data.Phoneme.Morpheme -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Morpheme) ->
                 Data.Phoneme.$fShowMorpheme_$cshowsPrec1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fShowMorpheme_$cshowList ::
    [Data.Phoneme.Morpheme] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Morpheme
                   Data.Phoneme.$fShowMorpheme1) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fShowMorpheme_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Phoneme -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $fShowMorpheme_$cshowsPrec1 ::
    GHC.Types.Int -> Data.Phoneme.Morpheme -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Morpheme)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Data.Phoneme.Morpheme ww3 ->
                 Data.Phoneme.$w$cshowsPrec4 ww1 ww3 w2 } }) -}
ff541d1764888145304960d9b00dcecd
  $fShowPhonation :: GHC.Show.Show Data.Phoneme.Phonation
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phonation
                  Data.Phoneme.$fShowPhonation_$cshowsPrec
                  Data.Phoneme.$fShowPhonation_$cshow
                  Data.Phoneme.$fShowPhonation_$cshowList -}
ff541d1764888145304960d9b00dcecd
  $fShowPhonation_$cshow :: Data.Phoneme.Phonation -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Phonation) ->
                 Data.Phoneme.$fShowPhonation_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ff541d1764888145304960d9b00dcecd
  $fShowPhonation_$cshowList ::
    [Data.Phoneme.Phonation] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Phonation
                   Data.Phoneme.$w$cshowsPrec5) -}
ff541d1764888145304960d9b00dcecd
  $fShowPhonation_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Phonation -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Phonation)
                   (w2 :: GHC.Base.String) ->
                 Data.Phoneme.$w$cshowsPrec5 w1 w2) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fShowPhoneme :: GHC.Show.Show Data.Phoneme.Phoneme
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Phoneme
                  Data.Phoneme.$fShowMorpheme_$cshowsPrec
                  Data.Phoneme.$fShowPhoneme_$cshow
                  Data.Phoneme.$fShowPhoneme_$cshowList -}
83c67fc806e8317ebba4d84ed8aa040f
  $fShowPhoneme1 :: Data.Phoneme.Phoneme -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Data.Phoneme.$fShowMorpheme_$cshowsPrec
                   Data.Phoneme.$fShowMorpheme2) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fShowPhoneme_$cshow :: Data.Phoneme.Phoneme -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Phoneme) ->
                 Data.Phoneme.$fShowMorpheme_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
83c67fc806e8317ebba4d84ed8aa040f
  $fShowPhoneme_$cshowList ::
    [Data.Phoneme.Phoneme] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Phoneme
                   Data.Phoneme.$fShowPhoneme1) -}
1971716d79acadd98b648de5350e6f24
  $fShowPlace :: GHC.Show.Show Data.Phoneme.Place
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Place
                  Data.Phoneme.$fShowPlace_$cshowsPrec
                  Data.Phoneme.$fShowPlace_$cshow
                  Data.Phoneme.$fShowPlace_$cshowList -}
1971716d79acadd98b648de5350e6f24
  $fShowPlace_$cshow :: Data.Phoneme.Place -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Place) ->
                 Data.Phoneme.$fShowPlace_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1971716d79acadd98b648de5350e6f24
  $fShowPlace_$cshowList :: [Data.Phoneme.Place] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Place
                   Data.Phoneme.$w$cshowsPrec6) -}
1971716d79acadd98b648de5350e6f24
  $fShowPlace_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Place -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Place)
                   (w2 :: GHC.Base.String) ->
                 Data.Phoneme.$w$cshowsPrec6 w1 w2) -}
974abd7cc25c83307948d0001b49f38e
  $fShowRoundedness :: GHC.Show.Show Data.Phoneme.Roundedness
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Roundedness
                  Data.Phoneme.$fShowRoundedness_$cshowsPrec
                  Data.Phoneme.$fShowRoundedness_$cshow
                  Data.Phoneme.$fShowRoundedness_$cshowList -}
974abd7cc25c83307948d0001b49f38e
  $fShowRoundedness_$cshow ::
    Data.Phoneme.Roundedness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Roundedness) ->
                 case x of wild {
                   Data.Phoneme.DEFAULT -> Data.Phoneme.$fReadRoundedness15
                   Data.Phoneme.ROUNDED -> Data.Phoneme.$fReadRoundedness12
                   Data.Phoneme.UNROUNDED -> Data.Phoneme.$fReadRoundedness9 }) -}
974abd7cc25c83307948d0001b49f38e
  $fShowRoundedness_$cshowList ::
    [Data.Phoneme.Roundedness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Roundedness
                   Data.Phoneme.$w$cshowsPrec7) -}
974abd7cc25c83307948d0001b49f38e
  $fShowRoundedness_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Roundedness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Roundedness)
                   (w2 :: GHC.Base.String) ->
                 Data.Phoneme.$w$cshowsPrec7 w1 w2) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fShowTone :: GHC.Show.Show Data.Phoneme.Tone
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Tone
                  Data.Phoneme.$fShowTone_$cshowsPrec
                  Data.Phoneme.$fShowTone_$cshow
                  Data.Phoneme.$fShowTone_$cshowList -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fShowTone_$cshow :: Data.Phoneme.Tone -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Tone) ->
                 Data.Phoneme.$fShowTone_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fShowTone_$cshowList :: [Data.Phoneme.Tone] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Tone
                   Data.Phoneme.$w$cshowsPrec8) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $fShowTone_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Tone -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Tone)
                   (w2 :: GHC.Base.String) ->
                 Data.Phoneme.$w$cshowsPrec8 w1 w2) -}
7b936d811d140964313d74386435dc67
  $fShowWord :: GHC.Show.Show Data.Phoneme.Word
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Phoneme.Word
                  Data.Phoneme.$fShowWord_$cshowsPrec
                  Data.Phoneme.$fShowWord_$cshow
                  Data.Phoneme.$fShowWord_$cshowList -}
7b936d811d140964313d74386435dc67
  $fShowWord1 :: Data.Phoneme.Word -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Data.Phoneme.Word) (w1 :: GHC.Base.String) ->
                 case w of ww { Data.Phoneme.Word ww1 ->
                 Data.Phoneme.$w$cshowsPrec9 0# ww1 w1 }) -}
b947de99203209ae87a35b808827b67e
  $fShowWord2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getMorphemes = "#) -}
17065b0edbcd519131006085829b0eec
  $fShowWord3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Word {"#) -}
7b936d811d140964313d74386435dc67
  $fShowWord_$cshow :: Data.Phoneme.Word -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Phoneme.Word) ->
                 Data.Phoneme.$fShowWord_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7b936d811d140964313d74386435dc67
  $fShowWord_$cshowList :: [Data.Phoneme.Word] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Phoneme.Word
                   Data.Phoneme.$fShowWord1) -}
7b936d811d140964313d74386435dc67
  $fShowWord_$cshowsPrec ::
    GHC.Types.Int -> Data.Phoneme.Word -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Data.Phoneme.Word)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Data.Phoneme.Word ww3 ->
                 Data.Phoneme.$w$cshowsPrec9 ww1 ww3 w2 } }) -}
5ab3889f1b0b3a464173700d6f2f793d
  $tc'AFFRICATE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4360585234528253916##
                   9119125645685101139##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'AFFRICATE1) -}
d43b45014220e5bccd12b628303f199a
  $tc'AFFRICATE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AFFRICATE"#) -}
9543285ad7117f335a2e582772e74bcd
  $tc'ALVEOLAR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4120595323266972002##
                   12205218595779865227##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'ALVEOLAR1) -}
cf0e6bb1c10ae90f72093e580b280dc0
  $tc'ALVEOLAR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ALVEOLAR"#) -}
e9a599c3e53436b5b0ad8f2363d557ce
  $tc'ALVEOLOPALATAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   226229785078117361##
                   174139404013183987##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'ALVEOLOPALATAL1) -}
9f197a7ff0592365e57e5fc0416c1364
  $tc'ALVEOLOPALATAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ALVEOLOPALATAL"#) -}
8ad547a50e640c69175e4f6b4c96e235
  $tc'APPROXIMANT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14072413640426100771##
                   7203158696289281042##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'APPROXIMANT1) -}
73acdfc9dbe21bb6bbe3a7873e9588c8
  $tc'APPROXIMANT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'APPROXIMANT"#) -}
072aa191e85bce765995d7b774bc06e6
  $tc'ASPIRATED :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9285861573733914287##
                   10230714833680052272##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'ASPIRATED1) -}
f21ec5de0ee219bb3f0d1b7639057ce3
  $tc'ASPIRATED1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ASPIRATED"#) -}
e051c1cbb311e5aa852ba8d58352605e
  $tc'BACK :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12765272409316248689##
                   3789899928382838847##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'BACK1) -}
56715c8cafcd2dc4a5a99c07767e3b56
  $tc'BACK1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BACK"#) -}
1431827f1effc9f67b405119f3e4f777
  $tc'BILABIAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3480536017005413607##
                   17992646956436979850##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'BILABIAL1) -}
6c86be09f6012a4b8c163790b94f79f5
  $tc'BILABIAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BILABIAL"#) -}
aebb652b597a749ad278a9517f1301e6
  $tc'BOTTOMT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13086849427399732072##
                   7900065640693024429##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'BOTTOMT1) -}
05e439e419517480180ff8d3a2d31796
  $tc'BOTTOMT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BOTTOMT"#) -}
282cfdfba84a2c940b4136d430c33612
  $tc'BREATHY :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5225199892946364809##
                   8908054474322770716##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'BREATHY1) -}
94b54d17a73c4a3b150c871827469df5
  $tc'BREATHY1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'BREATHY"#) -}
e5c1d54a94db5784cac1dd82db4a71b3
  $tc'Blank :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5584566888176652013##
                   2423476856859189735##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'Blank1) -}
08a6996ba6ded05d1b14c8b207504acd
  $tc'Blank1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Blank"#) -}
bd8206e7333a18afb7607321245a9300
  $tc'CENTRAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13297843810030772483##
                   9869461773202670902##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'CENTRAL1) -}
3825d9260370ee4da8ac6d21cde6210b
  $tc'CENTRAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CENTRAL"#) -}
5c3e94bbb03a2fb1d733dbb5668cd4c9
  $tc'CLOSE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9266824343132019119##
                   25330029522839952##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'CLOSE1) -}
22b58d99fd5e2c9708e0986bf7f4789f
  $tc'CLOSE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CLOSE"#) -}
1b504c0c4a224b5e243854067404cc74
  $tc'CLOSEMID :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12598844290568139816##
                   5831249077620698625##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'CLOSEMID1) -}
34564a3ee438cfdd5171a3a8c796b44d
  $tc'CLOSEMID1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CLOSEMID"#) -}
457be3d91507d78eed52725a2ad487e6
  $tc'CORONAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10546751232030788955##
                   1056708071925086024##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'CORONAL1) -}
0f52da796db21df224e6802c0dc4ba6b
  $tc'CORONAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CORONAL"#) -}
8714a4a408f15807920a726e735887ec
  $tc'CREAKY :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15521660054063540356##
                   8303221222569733560##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'CREAKY1) -}
62152a9907be66619ad5bc2a8414d5a6
  $tc'CREAKY1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'CREAKY"#) -}
fe9023506b000f104984a43f389468c6
  $tc'Consonant :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8940094066735937223##
                   15137395784956818483##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'Consonant1) -}
8014dbb98db0c69da123877942aaf135
  $tc'Consonant1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Consonant"#) -}
eab87e52a415a7457eb0624f2767cfb4
  $tc'DEFAULT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4123327569863359380##
                   6387692972015686867##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'DEFAULT1) -}
2746324e48d74c34db007ffa137b8125
  $tc'DEFAULT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DEFAULT"#) -}
9e218a4f7b19419c04ae9b08839393f8
  $tc'DENTAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17766996974520482581##
                   17018632512748593628##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'DENTAL1) -}
994904b22e07558530bc51961e41fc0d
  $tc'DENTAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DENTAL"#) -}
adadf3370dcacc6c9f4a3f717124495b
  $tc'DENTIALVEOLAR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17536095183802932553##
                   1828749584283442754##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'DENTIALVEOLAR1) -}
1aa9796529c469063de609ae1722982b
  $tc'DENTIALVEOLAR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DENTIALVEOLAR"#) -}
27f0651b94c408b8af28742b9e6578c6
  $tc'DIPT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9924233534505072672##
                   15406612570754878735##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'DIPT1) -}
66701bdd8ed68332006810005da84c60
  $tc'DIPT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DIPT"#) -}
ff1dbf968acd32c973a82ebfa5083feb
  $tc'DORSAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2577854092666508032##
                   659555467724842690##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'DORSAL1) -}
01fa763db0651871bb7ee3ef7632fc51
  $tc'DORSAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'DORSAL"#) -}
688050c8b5aed28638762f86a9b0b3a1
  $tc'Diphthong :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6499645154714227548##
                   17957656417082859463##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'Diphthong1) -}
93111c8d2759ce9b41ebe73d918bb42c
  $tc'Diphthong1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Diphthong"#) -}
2e366aaeaf9d35a8fa1d79f3567dcdc4
  $tc'EPIGLOTTAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3346148758474222591##
                   14792205659578833593##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'EPIGLOTTAL1) -}
87362240f54dc897a8158192603da0bc
  $tc'EPIGLOTTAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EPIGLOTTAL"#) -}
8cafe3f4f7869e38f06efd28e8b209bb
  $tc'EPIPHARYNGEAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3238821929999152896##
                   10779052276429648876##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'EPIPHARYNGEAL1) -}
040449c1eccf4c1e5fea4a12a1b468a7
  $tc'EPIPHARYNGEAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EPIPHARYNGEAL"#) -}
990d543367c7f20b10409cd45f333e4c
  $tc'FALLT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6611055694536834611##
                   15939124545723997960##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'FALLT1) -}
b42672c2ed90505d54bfe83e8a5f0618
  $tc'FALLT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FALLT"#) -}
4f4788e827fade6587744f1e98cadbab
  $tc'FLAP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   885378595859966756##
                   3425645884175944385##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'FLAP1) -}
4e93632fc1ffa495aed8ed559955b2ec
  $tc'FLAP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FLAP"#) -}
89791370f12a9cfc0f1ac35e1de5a53e
  $tc'FRICATIVE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2141516794675987534##
                   10785181322442599607##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'FRICATIVE1) -}
d2b8504ed50121e35b1432a7e3c179f2
  $tc'FRICATIVE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FRICATIVE"#) -}
7b39bbdf23c726898ae59ee32a295893
  $tc'FRONT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7011212075044447235##
                   11295366981150749104##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'FRONT1) -}
afaa578c482a4b399c221d0fbf240643
  $tc'FRONT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'FRONT"#) -}
1f4f785981bbfc6c5154edf47982e1c2
  $tc'GLOTTAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3971593125706904017##
                   9073928313566457283##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'GLOTTAL1) -}
435b6e6f98d38d12cd94666c13643e0c
  $tc'GLOTTAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'GLOTTAL"#) -}
efbbb6039f0004cf1d866f625f5ef722
  $tc'HFALLT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4613617116750121307##
                   14505158592287020256##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'HFALLT1) -}
e70c8f13b617940e7d1ba683a3491b43
  $tc'HFALLT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HFALLT"#) -}
4a97f969f6363714cf3f3ad1c038745d
  $tc'HIGHT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12718317535581485637##
                   17816654096964659534##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'HIGHT1) -}
f413563ea471b864899122720146d400
  $tc'HIGHT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HIGHT"#) -}
771178bc9abfeb39a4cc85609eb62feb
  $tc'HRISET :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1885988375697459722##
                   6954572188602719816##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'HRISET1) -}
a1dfaf216d4380f186b10bf9fc6f1262
  $tc'HRISET1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HRISET"#) -}
8049f540c69d09fca027d1168ff80890
  $tc'LABIAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11376943580477901500##
                   9905947731838119084##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LABIAL1) -}
8cd8b8374c1d3fe5c4bd7d8c72dfe155
  $tc'LABIAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LABIAL"#) -}
857aa9009089acbc07a58648b66fd841
  $tc'LABIODENTAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3575548021339716145##
                   15154195513282359497##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LABIODENTAL1) -}
9f0505b23d533abff1ea5901d7c5b5a5
  $tc'LABIODENTAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LABIODENTAL"#) -}
e71988d11525d91e84dca028c09a95cf
  $tc'LAFFRICATE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9446580418441749373##
                   9816449925453015973##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LAFFRICATE1) -}
bca3a5428d356c29a5698255b27d3eeb
  $tc'LAFFRICATE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LAFFRICATE"#) -}
92f9aa43e0005232a4fe304829ee3232
  $tc'LAPPROXIMANT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5590077009513436733##
                   16236689394224047992##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LAPPROXIMANT1) -}
2f9f705610b0f61fac47e0fed042b3cf
  $tc'LAPPROXIMANT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LAPPROXIMANT"#) -}
56d7295326baf16bbea3d204c47181f9
  $tc'LARYNGEAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14878981658604418598##
                   2994373886690710633##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LARYNGEAL1) -}
48e134ba3fbd91175c2ee11abf46122b
  $tc'LARYNGEAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LARYNGEAL"#) -}
f7a79b6432fbfd688a6c9aa86dd0fa81
  $tc'LFALLT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6595206217472778593##
                   15842116571200636878##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LFALLT1) -}
ad925b738ce569e1ffa95e175b28f261
  $tc'LFALLT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LFALLT"#) -}
a8d9e2e4e71c885b2211f5b034aa1887
  $tc'LFLAP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14724970518649505967##
                   14218898901614972777##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LFLAP1) -}
54d057d8c3a926f48e3785eff730af1e
  $tc'LFLAP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LFLAP"#) -}
ce334cbd2f6c2b9f04b96d5c159b0fce
  $tc'LFRICATIVE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9063852435248754875##
                   17726081043189808968##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LFRICATIVE1) -}
c32fefbb5e12b4ddd6bcae57dfa18caa
  $tc'LFRICATIVE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LFRICATIVE"#) -}
ca88f99789734ebbe5a318d5dfb15306
  $tc'LONG :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5892203029394436645##
                   352515478328500494##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LONG1) -}
cf3f6e39de054c5823e5a40bb58e207f
  $tc'LONG1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LONG"#) -}
c7245abbd70605400533efb49c565e4c
  $tc'LOWT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2536698857774269784##
                   12361176538736320726##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LOWT1) -}
d8e6f96ad0f9a807917c601ffea72558
  $tc'LOWT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LOWT"#) -}
92b8c1a6dc6911fc8bc3b2d3253c9a7a
  $tc'LRISET :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5240707804571675902##
                   13245056929366956359##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'LRISET1) -}
4b0696b215c47d72465d326e39c0d03d
  $tc'LRISET1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LRISET"#) -}
45c264b23b349902eb44e23fcac1d3e7
  $tc'MID :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1528844425714211919##
                   16302470106927089153##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'MID1) -}
16e911f31bfaf61b39ee44664d7d0422
  $tc'MID1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MID"#) -}
3f77b82e82907402a5bc36d6cc6394b7
  $tc'MIDT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10431305063943357649##
                   13679563099303255754##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'MIDT1) -}
79bb3120bf24e53985afbadc619312d3
  $tc'MIDT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MIDT"#) -}
b37d48c5a39ffca399e3bbac0fe80b2d
  $tc'MODAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7363317082474073406##
                   10587461302703809438##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'MODAL1) -}
ce41d41d4968e7e01f7ef6cfcea6aa7c
  $tc'MODAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MODAL"#) -}
e848e915995eab392b43b93da26b4b4a
  $tc'Morpheme :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14535568160007908595##
                   17514582974085356774##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'Morpheme1) -}
d0e1c4ea6006140ea4a31cd52f4cf320
  $tc'Morpheme1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Morpheme"#) -}
094df0d8cedd639e3454841e090975bc
  $tc'NASAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7263850906178206244##
                   1321269916647823333##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'NASAL1) -}
ceb9feae8cb9141ab374a38483fb4605
  $tc'NASAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NASAL"#) -}
fd6a1a6482776bc324dc2a6f220eb1d5
  $tc'NEARBACK :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14217757001877662617##
                   14566294124861166934##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'NEARBACK1) -}
3ac226859f03de46fc4f05295a44e0f4
  $tc'NEARBACK1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NEARBACK"#) -}
3c0657b041312c8a13c1cf129d2b3623
  $tc'NEARCLOSE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8842003614252009734##
                   15346102515153318449##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'NEARCLOSE1) -}
91c6fa38e2dc4798f459bf2bb87aa869
  $tc'NEARCLOSE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NEARCLOSE"#) -}
095a6a34f88fedc04c0740d242845d43
  $tc'NEARFRONT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11526220887270493357##
                   14145761561618005581##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'NEARFRONT1) -}
8e83e2223a463440dfb1c3fe16108e8b
  $tc'NEARFRONT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NEARFRONT"#) -}
c373313c8ca167e6d3485241141ebbfb
  $tc'NEAROPEN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6489636167600132679##
                   6340687684217672920##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'NEAROPEN1) -}
c8e6d65b7c3a9f75b2f1dd65f49b06f1
  $tc'NEAROPEN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NEAROPEN"#) -}
4043b779947e2d02ac265a5dca309dda
  $tc'NONET :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9052825556342921429##
                   5788520380485071179##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'NONET1) -}
905db54e9b6a319e01988ae9e74ccb3d
  $tc'NONET1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NONET"#) -}
ea07713a3c4ce4889f70bca0d9e9678f
  $tc'NORMAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5229060517060369148##
                   7300313472546147080##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'NORMAL1) -}
4b23568ba652e5210e1570197bd77616
  $tc'NORMAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NORMAL"#) -}
e2ab0ee53bf911e1461341addaaa01b4
  $tc'OPEN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7924412487627215345##
                   15077288048539560303##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'OPEN1) -}
76c27371257fc7bc168cff266e1fbe4b
  $tc'OPEN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OPEN"#) -}
f232ad8e076fd138a2e2e58efb516cc0
  $tc'OPENMID :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12667821843503536153##
                   5057903997262653413##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'OPENMID1) -}
ef77ce6db1f18f8fd24bd83e9db0252c
  $tc'OPENMID1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'OPENMID"#) -}
9dc68100c1b61b0ed05327b81cf7fc56
  $tc'PALATAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11138232056927028450##
                   6989960162375901147##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'PALATAL1) -}
1a11ab2bab7a6909f96fe3b686164e61
  $tc'PALATAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PALATAL"#) -}
4600745d1b5ac9c41f1a98ffaa5cee47
  $tc'PEAKT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12549228983940140619##
                   3737993963354717253##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'PEAKT1) -}
f8852412ef27cd81a4ba234d9f6b3305
  $tc'PEAKT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PEAKT"#) -}
499b1c3840a1f189ba90e2552444b504
  $tc'PHARYNGEAL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17484367742858196664##
                   2952078066417352758##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'PHARYNGEAL1) -}
898d5a17e397655c7d834d06f3e2efbe
  $tc'PHARYNGEAL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PHARYNGEAL"#) -}
6c739dbd7fdfb9028b26ab8c3a1b2870
  $tc'POSTALVEOLAR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13527285148059579737##
                   11965185349059459867##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'POSTALVEOLAR1) -}
d488f15649d4da1b80e7834b6364fc28
  $tc'POSTALVEOLAR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'POSTALVEOLAR"#) -}
16d416e3a84feb70f80c1f213323ef87
  $tc'RETROFLEX :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11483985847822174526##
                   16676928892670417803##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'RETROFLEX1) -}
0aebebbbad7a2028275a967fbc0f1f70
  $tc'RETROFLEX1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RETROFLEX"#) -}
582dfaa0bde5c9280f4ee48f31a51e2c
  $tc'RISET :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   78553520219531832##
                   9886987989944129284##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'RISET1) -}
df8de5a8e0def8128eef5ccacc045684
  $tc'RISET1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RISET"#) -}
d358995f1ae0d3a54453c5ef2ba634dc
  $tc'ROUNDED :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   416275528162210276##
                   17165541844168779875##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'ROUNDED1) -}
1bf5244adc529782580d73a88f343fbf
  $tc'ROUNDED1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'ROUNDED"#) -}
6a11984ae76d1ebdd73c7c3ffe0de406
  $tc'SAFFRICATE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   504234974565433579##
                   6802316744373603909##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'SAFFRICATE1) -}
f7b1e6c26d2d4fce5beced513a60e734
  $tc'SAFFRICATE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SAFFRICATE"#) -}
389f05c1a968c10f7d73b3d7abdaffab
  $tc'SHORT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14079228483468066917##
                   2189902258099432437##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'SHORT1) -}
d5f8aee27d4f2f129bbdd659703eef9e
  $tc'SHORT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SHORT"#) -}
06b47cf8325be6cc91ad3c2dbe519d59
  $tc'SILIBANT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14952001887929455016##
                   1823914944104228357##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'SILIBANT1) -}
4e1d5d0db596c96159f162dc8237917f
  $tc'SILIBANT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SILIBANT"#) -}
8702d2256ac076b675f853ec330fc2d5
  $tc'SLACK :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9130097094553576309##
                   178178190182367968##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'SLACK1) -}
0c965113726c62665aa929a32c423b19
  $tc'SLACK1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SLACK"#) -}
8230da84d139392f90083681d15d581b
  $tc'STIFF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1888622603144188041##
                   7989438629203786295##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'STIFF1) -}
8d9b8dbeb627441d893af14917795540
  $tc'STIFF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'STIFF"#) -}
009f8a2cebc0d8ae431b48112d65e61a
  $tc'STOP :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9288022390957478789##
                   6756535593748219994##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'STOP1) -}
e8a00f81d1cb3a2d3cfc9d0a90e5ae8b
  $tc'STOP1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'STOP"#) -}
4fc2e872b47b1b43f9dc5f925e0873f5
  $tc'TOPT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6263688827426526536##
                   18434662353058472418##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'TOPT1) -}
f4b7be7c5c95f8ff5e94e57296b99700
  $tc'TOPT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TOPT"#) -}
d6fa529f338badc6995a8bf5d53ed4f4
  $tc'TRILL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6530676477315754685##
                   13715462827449184461##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'TRILL1) -}
113b23dc5e1858ba8162cc804db479ab
  $tc'TRILL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TRILL"#) -}
1bd95b934849beed48b0a5642e08eeae
  $tc'UNROUNDED :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7553076839922409849##
                   2007286765694850853##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'UNROUNDED1) -}
167a4ab9d031b54225bb359c0ffffbbf
  $tc'UNROUNDED1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UNROUNDED"#) -}
865db0eb7aeb6a588e0f2586af385776
  $tc'UVULAR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18184033149481829708##
                   400250929971274705##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'UVULAR1) -}
450af19a7b96f73d2db0f5a5056b34c4
  $tc'UVULAR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'UVULAR"#) -}
9daf4e293518bfd17bb7a66549986b89
  $tc'VELAR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10590520975656195373##
                   12345212445077612040##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'VELAR1) -}
52ba075bc05955a0e2a9d1b7f1277a3f
  $tc'VELAR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'VELAR"#) -}
1504132ec67f03334ac86fc015b51927
  $tc'VOICELESS :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13277704166117437879##
                   8419119423016071779##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'VOICELESS1) -}
a830b054cdce4f10ce0a239607d9ca32
  $tc'VOICELESS1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'VOICELESS"#) -}
f214f5f0e98deec879e41f5ae9e56494
  $tc'Vowel :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12695548909570315209##
                   4590775241670126712##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'Vowel1) -}
f960f529cf9fa4505b9783c7aac70743
  $tc'Vowel1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Vowel"#) -}
17af2fda5b01f83c61de7f6debe06630
  $tc'Word :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17007446377622755369##
                   5811056800704070542##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tc'Word1) -}
7c6a3649d4948c18811d970d2b1323b9
  $tc'Word1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Word"#) -}
0624afac39bec69747ea238d3e50c998
  $tcBackness :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1559126243480199001##
                   8117623806942198986##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcBackness1) -}
bf4e44687221b201b9a50a182ecaabc2
  $tcBackness1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Backness"#) -}
4d89f68aed18164bff948686d203e08d
  $tcHeight :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7539065133158943221##
                   17770824694585889860##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcHeight1) -}
86ad14430af42ae4cf956ad83bba232f
  $tcHeight1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Height"#) -}
937a9dd4afccd728f85d54bdad48284d
  $tcLength :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10423682430088078755##
                   3639727928844064991##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcLength1) -}
8b83a1cc71f602765727188e2b282a7b
  $tcLength1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Length"#) -}
004bbb07710e77ce7f57dfcacf0d9eea
  $tcManner :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13878762449396813748##
                   5302531086491840923##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcManner1) -}
4d1b23cfc881a7385f643feb6bf76753
  $tcManner1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Manner"#) -}
26445a42da7e85e011d5450e19664b7a
  $tcMorpheme :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11855940567410884429##
                   5421869369979094521##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcMorpheme1) -}
ce3ecc108f83762162da8ba9f5a716d2
  $tcMorpheme1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Morpheme"#) -}
34b676c1a32977bf21feffe32daf951c
  $tcPhonation :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1525535112269546789##
                   14572782143998247852##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcPhonation1) -}
8fead9f21c78386420da00970af70df3
  $tcPhonation1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Phonation"#) -}
e1a38b8776352922dbf8936fde74117e
  $tcPhoneme :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4796525741664848035##
                   11046541551457632469##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcPhoneme1) -}
e4e14241d749bdd602c9c2b9358f26c2
  $tcPhoneme1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Phoneme"#) -}
2d5f760e726b471f9b3e8ad7a07b50a4
  $tcPlace :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   928137067779640736##
                   13791633646407170682##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcPlace1) -}
9c5a2ba3190afb5dc6875455ea1f4479
  $tcPlace1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Place"#) -}
e313f348490ba0e1c2b0c1438c8b2cd3
  $tcRoundedness :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   714966441238787687##
                   6482417115040692313##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcRoundedness1) -}
f4e2a00b179c55ad663c5cbab33b71b7
  $tcRoundedness1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Roundedness"#) -}
4661db03cc877153e46dc658f2dd6336
  $tcTone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5143701021332275168##
                   14739963883621612083##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcTone1) -}
97364b46085a4e2ff3f4ae60951bba52
  $tcTone1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tone"#) -}
5dc34f7a9f0e1b9779329d7a49bc0a27
  $tcWord :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7698766451454858718##
                   9109405736359282935##
                   Data.Phoneme.$trModule
                   Data.Phoneme.$tcWord1) -}
5fce9c48bc3520d6b898c25d98b8d12b
  $tcWord1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Word"#) -}
d25aa0fe781a6e7e310a51740ee880d2
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Data.Phoneme.$trModule2
                   Data.Phoneme.$trModule1) -}
96569ac578a336ff62b9c3b6688a6227
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Data.Phoneme"#) -}
390da0004d40f791ed2d75b0beee1540
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "con-lang-gen-0.0.0.1-JpecSLrjfNmG1CUMEdSr39"#) -}
b30fcf8c1909ae0b282e12f97a52fc6c
  $w$creadPrec ::
    GHC.Prim.Int#
    -> forall b.
       (Data.Phoneme.Morpheme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0] -}
7b936d811d140964313d74386435dc67
  $w$creadPrec1 ::
    GHC.Prim.Int#
    -> forall b.
       (Data.Phoneme.Word -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,U><L,C(U)>, Inline: [0] -}
a3d34da76e787829b1272672cb3d501f
  $w$cshowsPrec ::
    Data.Phoneme.Backness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Phoneme.Backness)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Phoneme.BACK
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadBackness23 w1
                   Data.Phoneme.NEARBACK
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadBackness20 w1
                   Data.Phoneme.CENTRAL
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadBackness17 w1
                   Data.Phoneme.NEARFRONT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadBackness14 w1
                   Data.Phoneme.FRONT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Phoneme.$fReadBackness11
                        w1 }) -}
e52daabfd4cc5d18128954ffcda031bb
  $w$cshowsPrec1 ::
    Data.Phoneme.Height -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Phoneme.Height) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Phoneme.CLOSE
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadHeight31 w1
                   Data.Phoneme.NEARCLOSE
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadHeight28 w1
                   Data.Phoneme.CLOSEMID
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadHeight25 w1
                   Data.Phoneme.MID
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadHeight22 w1
                   Data.Phoneme.OPENMID
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadHeight19 w1
                   Data.Phoneme.NEAROPEN
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadHeight16 w1
                   Data.Phoneme.OPEN
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Phoneme.$fReadHeight13
                        w1 }) -}
3bc911798122c419c4b3747def87cb7a
  $w$cshowsPrec2 ::
    Data.Phoneme.Length -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Phoneme.Length) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Phoneme.SHORT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadLength15 w1
                   Data.Phoneme.NORMAL
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadLength12 w1
                   Data.Phoneme.LONG
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadLength9 w1 }) -}
457727c142c08ed8e753e8053528da14
  $w$cshowsPrec3 ::
    Data.Phoneme.Manner -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Phoneme.Manner) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Phoneme.NASAL
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner55 w1
                   Data.Phoneme.STOP
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner52 w1
                   Data.Phoneme.SAFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner49 w1
                   Data.Phoneme.AFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner46 w1
                   Data.Phoneme.SILIBANT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner43 w1
                   Data.Phoneme.FRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner40 w1
                   Data.Phoneme.APPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner37 w1
                   Data.Phoneme.FLAP
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner34 w1
                   Data.Phoneme.TRILL
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner31 w1
                   Data.Phoneme.LAFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner28 w1
                   Data.Phoneme.LFRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner25 w1
                   Data.Phoneme.LAPPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadManner22 w1
                   Data.Phoneme.LFLAP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Phoneme.$fReadManner19
                        w1 }) -}
75546b279fee21518635efcfe156f8ee
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> [Data.Phoneme.Phoneme] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: [Data.Phoneme.Phoneme])
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Data.Phoneme.$fShowMorpheme5
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Data.Phoneme.$fShowMorpheme4
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fShowMorpheme3 x
                           } in
                           case ww1 of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__2
                                  (Data.Phoneme.$fShowMorpheme_$cshowsPrec
                                     Data.Phoneme.$fShowMorpheme2
                                     x1
                                     (let {
                                        lvl120 :: [GHC.Types.Char]
                                        = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__1 s
                                      } in
                                      letrec {
                                        showl :: [Data.Phoneme.Phoneme] -> GHC.Base.String
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ (ds2 :: [Data.Phoneme.Phoneme]) ->
                                          case ds2 of wild1 {
                                            [] -> lvl120
                                            : y ys
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.shows7
                                                 (Data.Phoneme.$fShowMorpheme_$cshowsPrec
                                                    Data.Phoneme.$fShowMorpheme2
                                                    y
                                                    (showl ys)) }
                                      } in
                                      showl xs)) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w)) }) -}
ff541d1764888145304960d9b00dcecd
  $w$cshowsPrec5 ::
    Data.Phoneme.Phonation -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Phoneme.Phonation)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Phoneme.VOICELESS
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadPhonation31 w1
                   Data.Phoneme.BREATHY
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadPhonation28 w1
                   Data.Phoneme.SLACK
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadPhonation25 w1
                   Data.Phoneme.MODAL
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadPhonation22 w1
                   Data.Phoneme.STIFF
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadPhonation19 w1
                   Data.Phoneme.CREAKY
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadPhonation16 w1
                   Data.Phoneme.ASPIRATED
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Phoneme.$fReadPhonation13
                        w1 }) -}
1971716d79acadd98b648de5350e6f24
  $w$cshowsPrec6 ::
    Data.Phoneme.Place -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
974abd7cc25c83307948d0001b49f38e
  $w$cshowsPrec7 ::
    Data.Phoneme.Roundedness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Phoneme.Roundedness)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Phoneme.DEFAULT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadRoundedness15 w1
                   Data.Phoneme.ROUNDED
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadRoundedness12 w1
                   Data.Phoneme.UNROUNDED
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Data.Phoneme.$fReadRoundedness9
                        w1 }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $w$cshowsPrec8 ::
    Data.Phoneme.Tone -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Data.Phoneme.Tone) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Data.Phoneme.NONET
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone59 w1
                   Data.Phoneme.TOPT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone56 w1
                   Data.Phoneme.HIGHT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone53 w1
                   Data.Phoneme.MIDT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone50 w1
                   Data.Phoneme.LOWT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone47 w1
                   Data.Phoneme.BOTTOMT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone44 w1
                   Data.Phoneme.FALLT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone41 w1
                   Data.Phoneme.HFALLT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone38 w1
                   Data.Phoneme.LFALLT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone35 w1
                   Data.Phoneme.RISET
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone32 w1
                   Data.Phoneme.HRISET
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone29 w1
                   Data.Phoneme.LRISET
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone26 w1
                   Data.Phoneme.DIPT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone23 w1
                   Data.Phoneme.PEAKT
                   -> GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fReadTone20 w1 }) -}
6f8224a5a163caeed343796612dcd625
  $w$cshowsPrec9 ::
    GHC.Prim.Int#
    -> [Data.Phoneme.Morpheme] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: [Data.Phoneme.Morpheme])
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Data.Phoneme.$fShowWord3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Data.Phoneme.$fShowWord2
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++ @ GHC.Types.Char Data.Phoneme.$fShowMorpheme3 x
                           } in
                           case ww1 of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__2
                                  (case x1 of ww2 { Data.Phoneme.Morpheme ww3 ->
                                   Data.Phoneme.$w$cshowsPrec4
                                     0#
                                     ww3
                                     (let {
                                        lvl120 :: [GHC.Types.Char]
                                        = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__1 s
                                      } in
                                      letrec {
                                        showl :: [Data.Phoneme.Morpheme] -> GHC.Base.String
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ (ds2 :: [Data.Phoneme.Morpheme]) ->
                                          case ds2 of wild1 {
                                            [] -> lvl120
                                            : y ys
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.shows7
                                                 (case y of ww4 { Data.Phoneme.Morpheme ww5 ->
                                                  Data.Phoneme.$w$cshowsPrec4 0# ww5 (showl ys) }) }
                                      } in
                                      showl xs) }) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w)) }) -}
a3d34da76e787829b1272672cb3d501f
  $w$ctoEnum :: GHC.Prim.Int# -> Data.Phoneme.Backness
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumBackness6 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 4#) of wild1 {
                        GHC.Types.False -> Data.Phoneme.$fEnumBackness6 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Phoneme.Backness ww } }) -}
e52daabfd4cc5d18128954ffcda031bb
  $w$ctoEnum1 :: GHC.Prim.Int# -> Data.Phoneme.Height
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumHeight8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6#) of wild1 {
                        GHC.Types.False -> Data.Phoneme.$fEnumHeight8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Phoneme.Height ww } }) -}
3bc911798122c419c4b3747def87cb7a
  $w$ctoEnum2 :: GHC.Prim.Int# -> Data.Phoneme.Length
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumLength1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2#) of wild1 {
                        GHC.Types.False -> Data.Phoneme.$fEnumLength1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Phoneme.Length ww } }) -}
457727c142c08ed8e753e8053528da14
  $w$ctoEnum3 :: GHC.Prim.Int# -> Data.Phoneme.Manner
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumManner1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 12#) of wild1 {
                        GHC.Types.False -> Data.Phoneme.$fEnumManner1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Phoneme.Manner ww } }) -}
ff541d1764888145304960d9b00dcecd
  $w$ctoEnum4 :: GHC.Prim.Int# -> Data.Phoneme.Phonation
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumPhonation8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6#) of wild1 {
                        GHC.Types.False -> Data.Phoneme.$fEnumPhonation8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Phoneme.Phonation ww } }) -}
1971716d79acadd98b648de5350e6f24
  $w$ctoEnum5 :: GHC.Prim.Int# -> Data.Phoneme.Place
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumPlace1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 18#) of wild1 {
                        GHC.Types.False -> Data.Phoneme.$fEnumPlace1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Phoneme.Place ww } }) -}
974abd7cc25c83307948d0001b49f38e
  $w$ctoEnum6 :: GHC.Prim.Int# -> Data.Phoneme.Roundedness
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumRoundedness1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2#) of wild1 {
                        GHC.Types.False -> Data.Phoneme.$fEnumRoundedness1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Phoneme.Roundedness ww } }) -}
8a5e65312c0d4c3c751cfe378d84cf4e
  $w$ctoEnum7 :: GHC.Prim.Int# -> Data.Phoneme.Tone
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0#) of wild {
                   GHC.Types.False -> Data.Phoneme.$fEnumTone1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 13#) of wild1 {
                        GHC.Types.False -> Data.Phoneme.$fEnumTone1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ Data.Phoneme.Tone ww } }) -}
a3d34da76e787829b1272672cb3d501f
  data Backness = BACK | NEARBACK | CENTRAL | NEARFRONT | FRONT
e52daabfd4cc5d18128954ffcda031bb
  data Height
    = CLOSE | NEARCLOSE | CLOSEMID | MID | OPENMID | NEAROPEN | OPEN
3bc911798122c419c4b3747def87cb7a
  data Length = SHORT | NORMAL | LONG
457727c142c08ed8e753e8053528da14
  data Manner
    = NASAL
    | STOP
    | SAFFRICATE
    | AFFRICATE
    | SILIBANT
    | FRICATIVE
    | APPROXIMANT
    | FLAP
    | TRILL
    | LAFFRICATE
    | LFRICATIVE
    | LAPPROXIMANT
    | LFLAP
b30fcf8c1909ae0b282e12f97a52fc6c
  data Morpheme = Morpheme {getPhonemes :: [Data.Phoneme.Phoneme]}
ff541d1764888145304960d9b00dcecd
  data Phonation
    = VOICELESS | BREATHY | SLACK | MODAL | STIFF | CREAKY | ASPIRATED
83c67fc806e8317ebba4d84ed8aa040f
  data Phoneme
    = Consonant {cplace :: Data.Phoneme.Place,
                 cmanner :: Data.Phoneme.Manner,
                 cvoice :: Data.Phoneme.Phonation,
                 csymbol :: GHC.Base.String}
    | Vowel {vheight :: Data.Phoneme.Height,
             vbackness :: Data.Phoneme.Backness,
             vroundedness :: Data.Phoneme.Roundedness,
             vlength :: Data.Phoneme.Length,
             vtone :: Data.Phoneme.Tone,
             vsymbol :: GHC.Base.String}
    | Diphthong {dheight1 :: Data.Phoneme.Height,
                 dbackness1 :: Data.Phoneme.Backness,
                 droundedness1 :: Data.Phoneme.Roundedness,
                 dheight2 :: Data.Phoneme.Height,
                 dbackness2 :: Data.Phoneme.Backness,
                 droundedness2 :: Data.Phoneme.Roundedness,
                 dlength :: Data.Phoneme.Length,
                 dtone :: Data.Phoneme.Tone,
                 dsymbol :: GHC.Base.String}
    | Blank
1971716d79acadd98b648de5350e6f24
  data Place
    = LABIAL
    | BILABIAL
    | LABIODENTAL
    | CORONAL
    | DENTIALVEOLAR
    | DENTAL
    | ALVEOLAR
    | POSTALVEOLAR
    | RETROFLEX
    | DORSAL
    | ALVEOLOPALATAL
    | PALATAL
    | VELAR
    | UVULAR
    | LARYNGEAL
    | EPIPHARYNGEAL
    | PHARYNGEAL
    | EPIGLOTTAL
    | GLOTTAL
974abd7cc25c83307948d0001b49f38e
  data Roundedness = DEFAULT | ROUNDED | UNROUNDED
8a5e65312c0d4c3c751cfe378d84cf4e
  data Tone
    = NONET
    | TOPT
    | HIGHT
    | MIDT
    | LOWT
    | BOTTOMT
    | FALLT
    | HFALLT
    | LFALLT
    | RISET
    | HRISET
    | LRISET
    | DIPT
    | PEAKT
7b936d811d140964313d74386435dc67
  data Word = Word {getMorphemes :: [Data.Phoneme.Morpheme]}
df29c44681261589a5277b466c000e75
  cmanner :: Data.Phoneme.Phoneme -> Data.Phoneme.Manner
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.cmanner1
                   Data.Phoneme.Consonant ds1 ds2 ds3 ds4 -> ds2 }) -}
5919773655686a9b27052d1cc4ca7247
  cmanner1 :: Data.Phoneme.Manner
  {- Strictness: x -}
24043e3dbeebae55ba5cec8a2f8134aa
  cplace :: Data.Phoneme.Phoneme -> Data.Phoneme.Place
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.cplace1
                   Data.Phoneme.Consonant ds1 ds2 ds3 ds4 -> ds1 }) -}
5d45792bda05be1dd34e0d952bf63b85
  cplace1 :: Data.Phoneme.Place
  {- Strictness: x -}
44e09bc93432887c79fdaf7cc2bfc5ab
  csymbol :: Data.Phoneme.Phoneme -> GHC.Base.String
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.csymbol1
                   Data.Phoneme.Consonant ds1 ds2 ds3 ds4 -> ds4 }) -}
d8212555ed776dd070bfc1e9c962748c
  csymbol1 :: GHC.Base.String
  {- Strictness: x -}
0a4b8638aa83b35ac426c39b485d065d
  cvoice :: Data.Phoneme.Phoneme -> Data.Phoneme.Phonation
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.cvoice1
                   Data.Phoneme.Consonant ds1 ds2 ds3 ds4 -> ds3 }) -}
b178b64e6a3fed73bb3f3ade7acf8d6b
  cvoice1 :: Data.Phoneme.Phonation
  {- Strictness: x -}
3eb11271e23884fc502982f93528501e
  dbackness1 :: Data.Phoneme.Phoneme -> Data.Phoneme.Backness
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.dbackness4
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds2 }) -}
a5bd6b6303c40b65caf6620846b7169e
  dbackness2 :: Data.Phoneme.Phoneme -> Data.Phoneme.Backness
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.dbackness5
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds5 }) -}
5860a35330ba2507f89a0230fce2b54d
  dbackness4 :: Data.Phoneme.Backness
  {- Strictness: x -}
00651d8f618fb81f5998773cbf2de8a3
  dbackness5 :: Data.Phoneme.Backness
  {- Strictness: x -}
4a25e8f7d4cf8050e161cd6ea79a1f2a
  dheight1 :: Data.Phoneme.Phoneme -> Data.Phoneme.Height
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.dheight4
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds1 }) -}
39581141c667941f389e5cebd695b361
  dheight2 :: Data.Phoneme.Phoneme -> Data.Phoneme.Height
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.dheight5
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds4 }) -}
39185d41db64999737c9e62a2bd4f666
  dheight4 :: Data.Phoneme.Height
  {- Strictness: x -}
f272df5334a60e664252409229aa4821
  dheight5 :: Data.Phoneme.Height
  {- Strictness: x -}
eff9d600c01008cae96808a9f7f4e69c
  dlength :: Data.Phoneme.Phoneme -> Data.Phoneme.Length
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.dlength1
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds7 }) -}
806f68a3cff13fe9bb6de966d9c6bb14
  dlength1 :: Data.Phoneme.Length
  {- Strictness: x -}
135db4accda8c414e64ed921fee50503
  droundedness1 :: Data.Phoneme.Phoneme -> Data.Phoneme.Roundedness
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.droundedness4
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds3 }) -}
a8da04c82d1ef7a548307ee971d54495
  droundedness2 :: Data.Phoneme.Phoneme -> Data.Phoneme.Roundedness
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.droundedness5
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds6 }) -}
3f1e72fb00d1a25504fb8d6bdaadcd23
  droundedness4 :: Data.Phoneme.Roundedness
  {- Strictness: x -}
3a540330fb589234f4091135ed29b312
  droundedness5 :: Data.Phoneme.Roundedness
  {- Strictness: x -}
b23771056bc25746861c31efb78848c4
  dsymbol :: Data.Phoneme.Phoneme -> GHC.Base.String
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.dsymbol1
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds9 }) -}
5b129fb4ca30445a34f5a4f770767072
  dsymbol1 :: GHC.Base.String
  {- Strictness: x -}
d907f1c9541e023a5a4b1dccefa349df
  dtone :: Data.Phoneme.Phoneme -> Data.Phoneme.Tone
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.dtone1
                   Data.Phoneme.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds8 }) -}
7c7bf78d16188f42f462e6520dc1b927
  dtone1 :: Data.Phoneme.Tone
  {- Strictness: x -}
51600f61a88293384584c88e1d26f051
  getMorphemes :: Data.Phoneme.Word -> [Data.Phoneme.Morpheme]
  RecSel Left Data.Phoneme.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Word) ->
                 case ds of wild { Data.Phoneme.Word ds1 -> ds1 }) -}
2b3a49114618fbf0b50dd81fc2203f21
  getPhonemes :: Data.Phoneme.Morpheme -> [Data.Phoneme.Phoneme]
  RecSel Left Data.Phoneme.Morpheme
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Morpheme) ->
                 case ds of wild { Data.Phoneme.Morpheme ds1 -> ds1 }) -}
278774761e419b853f511918700171be
  vbackness :: Data.Phoneme.Phoneme -> Data.Phoneme.Backness
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.vbackness1
                   Data.Phoneme.Vowel ds1 ds2 ds3 ds4 ds5 ds6 -> ds2 }) -}
d7a48d3615c46e6799bcc868adb9e319
  vbackness1 :: Data.Phoneme.Backness
  {- Strictness: x -}
7597c06b89876e69acff6f6c48c809c6
  vheight :: Data.Phoneme.Phoneme -> Data.Phoneme.Height
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.vheight1
                   Data.Phoneme.Vowel ds1 ds2 ds3 ds4 ds5 ds6 -> ds1 }) -}
3774e8505fdfcead9d694071068ee765
  vheight1 :: Data.Phoneme.Height
  {- Strictness: x -}
644bc3a961e397a54db1b036fcb49bff
  vlength :: Data.Phoneme.Phoneme -> Data.Phoneme.Length
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.vlength1
                   Data.Phoneme.Vowel ds1 ds2 ds3 ds4 ds5 ds6 -> ds4 }) -}
474a25e5cdbac9a3a0bbe764ee52a3bb
  vlength1 :: Data.Phoneme.Length
  {- Strictness: x -}
22939e32347a0b7202720bd0f7ace4c0
  vroundedness :: Data.Phoneme.Phoneme -> Data.Phoneme.Roundedness
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.vroundedness1
                   Data.Phoneme.Vowel ds1 ds2 ds3 ds4 ds5 ds6 -> ds3 }) -}
95e2af1c87722409d13e5171f674df43
  vroundedness1 :: Data.Phoneme.Roundedness
  {- Strictness: x -}
d7238a8b79e42f07f54238aaf4e0c6dd
  vsymbol :: Data.Phoneme.Phoneme -> GHC.Base.String
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.vsymbol1
                   Data.Phoneme.Vowel ds1 ds2 ds3 ds4 ds5 ds6 -> ds6 }) -}
70e442dd464691b5fa578fd06d8b63ea
  vsymbol1 :: GHC.Base.String
  {- Strictness: x -}
7489df6956c5b94339694845b89fd6e0
  vtone :: Data.Phoneme.Phoneme -> Data.Phoneme.Tone
  RecSel Left Data.Phoneme.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Phoneme.Phoneme) ->
                 case ds of wild {
                   DEFAULT -> Data.Phoneme.vtone1
                   Data.Phoneme.Vowel ds1 ds2 ds3 ds4 ds5 ds6 -> ds5 }) -}
c4f56a10881779d2c4c7a63c6c315c6f
  vtone1 :: Data.Phoneme.Tone
  {- Strictness: x -}
instance [safe] GHC.Enum.Bounded [Data.Phoneme.Backness]
  = Data.Phoneme.$fBoundedBackness
instance [safe] GHC.Enum.Bounded [Data.Phoneme.Height]
  = Data.Phoneme.$fBoundedHeight
instance [safe] GHC.Enum.Bounded [Data.Phoneme.Length]
  = Data.Phoneme.$fBoundedLength
instance [safe] GHC.Enum.Bounded [Data.Phoneme.Manner]
  = Data.Phoneme.$fBoundedManner
instance [safe] GHC.Enum.Bounded [Data.Phoneme.Phonation]
  = Data.Phoneme.$fBoundedPhonation
instance [safe] GHC.Enum.Bounded [Data.Phoneme.Place]
  = Data.Phoneme.$fBoundedPlace
instance [safe] GHC.Enum.Bounded [Data.Phoneme.Roundedness]
  = Data.Phoneme.$fBoundedRoundedness
instance [safe] GHC.Enum.Bounded [Data.Phoneme.Tone]
  = Data.Phoneme.$fBoundedTone
instance [safe] GHC.Enum.Enum [Data.Phoneme.Backness]
  = Data.Phoneme.$fEnumBackness
instance [safe] GHC.Enum.Enum [Data.Phoneme.Height]
  = Data.Phoneme.$fEnumHeight
instance [safe] GHC.Enum.Enum [Data.Phoneme.Length]
  = Data.Phoneme.$fEnumLength
instance [safe] GHC.Enum.Enum [Data.Phoneme.Manner]
  = Data.Phoneme.$fEnumManner
instance [safe] GHC.Enum.Enum [Data.Phoneme.Phonation]
  = Data.Phoneme.$fEnumPhonation
instance [safe] GHC.Enum.Enum [Data.Phoneme.Place]
  = Data.Phoneme.$fEnumPlace
instance [safe] GHC.Enum.Enum [Data.Phoneme.Roundedness]
  = Data.Phoneme.$fEnumRoundedness
instance [safe] GHC.Enum.Enum [Data.Phoneme.Tone]
  = Data.Phoneme.$fEnumTone
instance [safe] GHC.Classes.Eq [Data.Phoneme.Backness]
  = Data.Phoneme.$fEqBackness
instance [safe] GHC.Classes.Eq [Data.Phoneme.Height]
  = Data.Phoneme.$fEqHeight
instance [safe] GHC.Classes.Eq [Data.Phoneme.Length]
  = Data.Phoneme.$fEqLength
instance [safe] GHC.Classes.Eq [Data.Phoneme.Manner]
  = Data.Phoneme.$fEqManner
instance [safe] GHC.Classes.Eq [Data.Phoneme.Morpheme]
  = Data.Phoneme.$fEqMorpheme
instance [safe] GHC.Classes.Eq [Data.Phoneme.Phonation]
  = Data.Phoneme.$fEqPhonation
instance [safe] GHC.Classes.Eq [Data.Phoneme.Phoneme]
  = Data.Phoneme.$fEqPhoneme
instance [safe] GHC.Classes.Eq [Data.Phoneme.Place]
  = Data.Phoneme.$fEqPlace
instance [safe] GHC.Classes.Eq [Data.Phoneme.Roundedness]
  = Data.Phoneme.$fEqRoundedness
instance [safe] GHC.Classes.Eq [Data.Phoneme.Tone]
  = Data.Phoneme.$fEqTone
instance [safe] GHC.Classes.Eq [Data.Phoneme.Word]
  = Data.Phoneme.$fEqWord
instance [safe] GHC.Classes.Ord [Data.Phoneme.Backness]
  = Data.Phoneme.$fOrdBackness
instance [safe] GHC.Classes.Ord [Data.Phoneme.Height]
  = Data.Phoneme.$fOrdHeight
instance [safe] GHC.Classes.Ord [Data.Phoneme.Length]
  = Data.Phoneme.$fOrdLength
instance [safe] GHC.Classes.Ord [Data.Phoneme.Manner]
  = Data.Phoneme.$fOrdManner
instance [safe] GHC.Classes.Ord [Data.Phoneme.Morpheme]
  = Data.Phoneme.$fOrdMorpheme
instance [safe] GHC.Classes.Ord [Data.Phoneme.Phonation]
  = Data.Phoneme.$fOrdPhonation
instance [safe] GHC.Classes.Ord [Data.Phoneme.Phoneme]
  = Data.Phoneme.$fOrdPhoneme
instance [safe] GHC.Classes.Ord [Data.Phoneme.Place]
  = Data.Phoneme.$fOrdPlace
instance [safe] GHC.Classes.Ord [Data.Phoneme.Roundedness]
  = Data.Phoneme.$fOrdRoundedness
instance [safe] GHC.Classes.Ord [Data.Phoneme.Tone]
  = Data.Phoneme.$fOrdTone
instance [safe] GHC.Classes.Ord [Data.Phoneme.Word]
  = Data.Phoneme.$fOrdWord
instance [safe] GHC.Read.Read [Data.Phoneme.Backness]
  = Data.Phoneme.$fReadBackness
instance [safe] GHC.Read.Read [Data.Phoneme.Height]
  = Data.Phoneme.$fReadHeight
instance [safe] GHC.Read.Read [Data.Phoneme.Length]
  = Data.Phoneme.$fReadLength
instance [safe] GHC.Read.Read [Data.Phoneme.Manner]
  = Data.Phoneme.$fReadManner
instance [safe] GHC.Read.Read [Data.Phoneme.Morpheme]
  = Data.Phoneme.$fReadMorpheme
instance [safe] GHC.Read.Read [Data.Phoneme.Phonation]
  = Data.Phoneme.$fReadPhonation
instance [safe] GHC.Read.Read [Data.Phoneme.Phoneme]
  = Data.Phoneme.$fReadPhoneme
instance [safe] GHC.Read.Read [Data.Phoneme.Place]
  = Data.Phoneme.$fReadPlace
instance [safe] GHC.Read.Read [Data.Phoneme.Roundedness]
  = Data.Phoneme.$fReadRoundedness
instance [safe] GHC.Read.Read [Data.Phoneme.Tone]
  = Data.Phoneme.$fReadTone
instance [safe] GHC.Read.Read [Data.Phoneme.Word]
  = Data.Phoneme.$fReadWord
instance [safe] GHC.Show.Show [Data.Phoneme.Backness]
  = Data.Phoneme.$fShowBackness
instance [safe] GHC.Show.Show [Data.Phoneme.Height]
  = Data.Phoneme.$fShowHeight
instance [safe] GHC.Show.Show [Data.Phoneme.Length]
  = Data.Phoneme.$fShowLength
instance [safe] GHC.Show.Show [Data.Phoneme.Manner]
  = Data.Phoneme.$fShowManner
instance [safe] GHC.Show.Show [Data.Phoneme.Morpheme]
  = Data.Phoneme.$fShowMorpheme
instance [safe] GHC.Show.Show [Data.Phoneme.Phonation]
  = Data.Phoneme.$fShowPhonation
instance [safe] GHC.Show.Show [Data.Phoneme.Phoneme]
  = Data.Phoneme.$fShowPhoneme
instance [safe] GHC.Show.Show [Data.Phoneme.Place]
  = Data.Phoneme.$fShowPlace
instance [safe] GHC.Show.Show [Data.Phoneme.Roundedness]
  = Data.Phoneme.$fShowRoundedness
instance [safe] GHC.Show.Show [Data.Phoneme.Tone]
  = Data.Phoneme.$fShowTone
instance [safe] GHC.Show.Show [Data.Phoneme.Word]
  = Data.Phoneme.$fShowWord
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

