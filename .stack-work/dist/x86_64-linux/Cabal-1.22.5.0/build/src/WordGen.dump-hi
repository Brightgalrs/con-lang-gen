
==================== FINAL INTERFACE ====================
2016-11-02 18:56:34.778788 UTC

interface conla_1eA9qWUPH9nBowcXqqaV8r:WordGen 7103
  interface hash: 39202d89c0eaa399983208372d70cdee
  ABI hash: 5d4976051e9ead79ee9ab0d44eb3662e
  export-list hash: 5ee31c708723536bda1554f47c037d50
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  WordGen.loadMeaningData
  WordGen.makeDictionary
  WordGen.makeMorpheme
module dependencies: OtherData PhonemeData PhonemeGen
                     PhonotacticsGen
package dependencies: MonadPrompt-1.0.0.5@Monad_5vpMHuuRBzi4bKjpRN3A9L
                      MonadRandom-0.4.2.3@Monad_I7tEJH7vOtsKQS7CpG48fz
                      array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA base-4.8.2.0
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59
                      erf-2.0.0.0@erf_6l78BnvLL4b2mWYp3HJJxX
                      flexible-defaults-0.0.1.2@flexi_70LqvhG3vbS8bRvV8pHtMk
                      ghc-prim-0.4.0.0 integer-gmp-1.0.0.0
                      math-functions-0.1.7.0@mathf_BN6S7j0ar3LC4TsnYu0us5
                      mersenne-random-pure64-0.2.0.5@merse_42koSxEhmjwBS69WXi19xI
                      monad-loops-0.4.3@monad_LQiHRUYhFhYBU7nOOWDOrb
                      mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      mwc-random-0.13.4.0@mwcra_0lrQ1SkkNA85sa8eZ98xQk
                      old-locale-1.0.0.7@oldlo_7h2Gx6mVPJ5Gheca8j9Mpe
                      old-time-1.1.0.3@oldti_JVjJvknZJ0JKghfag2Jw2L
                      pretty-1.1.2.0@prett_JItwetRppk1H5Uq3xbjDGC
                      primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3
                      random-extras-0.19@rando_11jAc932BDRD7ydjCrRr4L
                      random-source-0.3.0.6@rando_2sxt9MoqACW6I0STyXc5JW
                      random-1.1@rando_9Kgekc9yEaLHLNUuw6paWL
                      random-shuffle-0.0.4@rando_9kOz9tEn1526ShtWz8x59X
                      random-fu-0.2.7.0@rando_HO0DW1nA2fDCxZJ62mvJHr
                      rvar-0.2.0.3@rvar_HDSuhGFxwNTDX4EfF6w8WG
                      stateref-0.3@state_KptOBHsY85L8YzpDAos2Hi
                      stm-2.4.4.1@stm_EyxFXFfnfY05IrjGaqCxeD
                      syb-0.6@syb_4kccWaTe3QZLxAMQYKgEyE template-haskell-2.10.0.0
                      th-extras-0.0.0.4@thext_LRY1RUMy7ShLl2tqhMyHdO
                      time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
                      vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln
orphans: MonadRandom-0.4.2.3@Monad_I7tEJH7vOtsKQS7CpG48fz:Control.Monad.Random
         base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         mersenne-random-pure64-0.2.0.5@merse_42koSxEhmjwBS69WXi19xI:System.Random.Mersenne.Pure64
         random-source-0.3.0.6@rando_2sxt9MoqACW6I0STyXc5JW:Data.Random.Source
         random-source-0.3.0.6@rando_2sxt9MoqACW6I0STyXc5JW:Data.Random.Source.IO
         random-source-0.3.0.6@rando_2sxt9MoqACW6I0STyXc5JW:Data.Random.Source.MWC
         random-source-0.3.0.6@rando_2sxt9MoqACW6I0STyXc5JW:Data.Random.Source.PureMT
         random-source-0.3.0.6@rando_2sxt9MoqACW6I0STyXc5JW:Data.Random.Source.StdGen
         stateref-0.3@state_KptOBHsY85L8YzpDAos2Hi:Data.StateRef.Instances
         stateref-0.3@state_KptOBHsY85L8YzpDAos2Hi:Data.StateRef.Instances.STM
         stm-2.4.4.1@stm_EyxFXFfnfY05IrjGaqCxeD:Control.Monad.STM
         syb-0.6@syb_4kccWaTe3QZLxAMQYKgEyE:Data.Generics.Instances
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.Format.Parse
         time-1.5.0.1@time_FTheb6LSxyX1UABIbBXRfn:Data.Time.LocalTime.LocalTime
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector.Fusion.Bundle
         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector.Unboxed
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         mwc-random-0.13.4.0@mwcra_0lrQ1SkkNA85sa8eZ98xQk:System.Random.MWC
                         pretty-1.1.2.0@prett_JItwetRppk1H5Uq3xbjDGC:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_EphY2c7CCxSCBKjAN0YTR3:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector
                         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector.Primitive
                         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector.Unboxed
                         vector-0.11.0.0@vecto_LmZ3LQW4ivu8MsQuVgukln:Data.Vector.Unboxed.Base
import  -/  base-4.8.2.0:Control.Monad 480c5067477275068c9b98be08410df9
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Traversable 7576318f4ef8587ad947f87012b65abf
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.IO bb5b81adcea33b14bd4abe16d7dde45f
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0248c1e850b7ea124cf7a2e1669ebf67
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  OtherData ef85631315e8bb1c90bd776e9bb7751c
  exports: f505dec72f229982fb85e59b44566731
import  -/  PhonemeData 86639d5baa3c8896a59c20b5d5d0708d
  exports: 8834c83badd5837275d7ec1bbd2f424a
  Morpheme 638ca31a2fd80dc92fadb76f1b8badfd
  Morpheme f6ac1984a4423d03613ec94d362955ea
  Phoneme 725a483aa2dd4b7c0473c29cf990b878
  Word 58728e383c3ae1ba22d7c75c2611ac1b
  Word 53dc4151a59abddfd798786b00d0a617
import  -/  PhonemeGen 44431a2b9295a7efdbb24a370fea6130
  exports: ac2fac7549593bb4b2279f37f817f5be
import  -/  PhonotacticsGen 6b0ffb15d766a08cc9d1828eaa725159
  exports: 5bbf082cfe2be7a4eaae7a2a5f6b7de8
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  random-extras-0.19@rando_11jAc932BDRD7ydjCrRr4L:Data.Random.Extras 5dc1684f88e3f2655bfb5d7aca60bf5c
import  -/  random-fu-0.2.7.0@rando_HO0DW1nA2fDCxZJ62mvJHr:Data.Random 355d6844bb1b3189cb19ec0007f6f130
import  -/  random-fu-0.2.7.0@rando_HO0DW1nA2fDCxZJ62mvJHr:Data.Random.Distribution.Uniform ce34c1edd0e59e868fcf9e0bf914c4ef
import  -/  rvar-0.2.0.3@rvar_HDSuhGFxwNTDX4EfF6w8WG:Data.RVar 9b7fbdb5f1778e76b8a65f45a17cccb1
1b2f7479f84fca9c768d6e597203211f
  $sreplicateM2 ::
    [Data.RVar.RVarT Data.Functor.Identity.Identity a3]
    -> forall b.
       ([a3] -> b)
       -> (forall a.
           Control.Monad.Prompt.Lift
             Data.Random.Source.Internal.Prim.Prim
             Data.Functor.Identity.Identity
             a
           -> (a -> b) -> b)
       -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,C(U)><L,U> -}
f551fa8ec43477300f5eca9065bcc1fe
  $wmakeDictionary ::
    [GHC.Base.String]
    -> [PhonemeData.Phoneme]
    -> [[PhonemeData.Phoneme]]
    -> ((GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int))
    -> Data.RVar.RVarT
         Data.Functor.Identity.Identity
         [(PhonemeData.Word, GHC.Base.String)]
  {- Arity: 4,
     Strictness: <L,U><L,U><L,U><L,1*U(1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)))>,
     Inline: [0],
     Unfolding: (\ ww :: [GHC.Base.String]
                   w :: [PhonemeData.Phoneme]
                   w1 :: [[PhonemeData.Phoneme]]
                   w2 :: ((GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int)) ->
                 let {
                   m1 :: Data.RVar.RVarT
                           Data.Functor.Identity.Identity PhonemeData.Word
                   = case w2 of wild { (,,,) ds ds1 ds2 ds3 ->
                     case ds of wild1 { (,) ns xs ->
                     case ds1 of wild2 { (,) ni xi ->
                     case ds2 of wild3 { (,) nt xt ->
                     case ds3 of wild4 { (,) ne xe ->
                     let {
                       m2 :: Data.RVar.RVarT
                               Data.Functor.Identity.Identity PhonemeData.Morpheme
                       = WordGen.$wmakeMorpheme w w1 ns xs ni xi nt xt ne xe
                     } in
                     (\ @ b1
                        eta :: PhonemeData.Word -> b1
                        eta1 :: forall a7.
                                Control.Monad.Prompt.Lift
                                  Data.Random.Source.Internal.Prim.Prim
                                  Data.Functor.Identity.Identity
                                  a7
                                -> (a7 -> b1) -> b1 ->
                      m2
                        `cast`
                      (Trans
                           (Trans
                                (Data.RVar.NTCo:RVarT[0] <Data.Functor.Identity.Identity>_N)
                                (Control.Monad.Prompt.NTCo:PromptT[0]
                                     <Data.Random.Source.Internal.Prim.Prim>_R
                                     <Data.Functor.Identity.Identity>_R) <PhonemeData.Morpheme>_N)
                           (Control.Monad.Prompt.NTCo:Prompt[0]
                                <Control.Monad.Prompt.Lift
                                   Data.Random.Source.Internal.Prim.Prim
                                   Data.Functor.Identity.Identity>_R
                                <PhonemeData.Morpheme>_R))
                        @ b1
                        (\ x :: PhonemeData.Morpheme ->
                         case x of x1 { PhonemeData.Morpheme ipv ->
                         eta
                           (PhonemeData.Word
                              (GHC.Types.:
                                 @ PhonemeData.Morpheme
                                 x1
                                 (GHC.Types.[] @ PhonemeData.Morpheme))) })
                        eta1)
                       `cast`
                     (Trans
                          (Sym (Control.Monad.Prompt.NTCo:Prompt[0]
                                    <Control.Monad.Prompt.Lift
                                       Data.Random.Source.Internal.Prim.Prim
                                       Data.Functor.Identity.Identity>_R
                                    <PhonemeData.Word>_R))
                          (Trans
                               (Sym (Control.Monad.Prompt.NTCo:PromptT[0]
                                         <Data.Random.Source.Internal.Prim.Prim>_R
                                         <Data.Functor.Identity.Identity>_R))
                               (Sym (Data.RVar.NTCo:RVarT[0]) <Data.Functor.Identity.Identity>_N) <PhonemeData.Word>_N)) } } } } }
                 } in
                 letrec {
                   a7 :: [GHC.Base.String]
                         -> forall b.
                            ([(PhonemeData.Word, GHC.Base.String)] -> b)
                            -> (forall a7.
                                Control.Monad.Prompt.Lift
                                  Data.Random.Source.Internal.Prim.Prim
                                  Data.Functor.Identity.Identity
                                  a7
                                -> (a7 -> b) -> b)
                            -> b
                     {- Arity: 3, Strictness: <S,1*U><L,C(U)><L,U> -}
                   = \ ds :: [GHC.Base.String]
                       @ b
                       eta :: [(PhonemeData.Word, GHC.Base.String)] -> b
                       eta1 :: forall a8.
                               Control.Monad.Prompt.Lift
                                 Data.Random.Source.Internal.Prim.Prim
                                 Data.Functor.Identity.Identity
                                 a8
                               -> (a8 -> b) -> b ->
                     case ds of wild {
                       [] -> eta (GHC.Types.[] @ (PhonemeData.Word, GHC.Base.String))
                       : y ys
                       -> m1
                            `cast`
                          (Trans
                               (Trans
                                    (Data.RVar.NTCo:RVarT[0] <Data.Functor.Identity.Identity>_N)
                                    (Control.Monad.Prompt.NTCo:PromptT[0]
                                         <Data.Random.Source.Internal.Prim.Prim>_R
                                         <Data.Functor.Identity.Identity>_R) <PhonemeData.Word>_N)
                               (Control.Monad.Prompt.NTCo:Prompt[0]
                                    <Control.Monad.Prompt.Lift
                                       Data.Random.Source.Internal.Prim.Prim
                                       Data.Functor.Identity.Identity>_R
                                    <PhonemeData.Word>_R))
                            @ b
                            (\ x :: PhonemeData.Word ->
                             case x of x1 { PhonemeData.Word ipv ->
                             case y of vx { DEFAULT ->
                             a7
                               ys
                               @ b
                               (\ x2 :: [(PhonemeData.Word, GHC.Base.String)][OneShot] ->
                                case x2 of x3 { DEFAULT ->
                                eta
                                  (GHC.Types.: @ (PhonemeData.Word, GHC.Base.String) (x1, vx) x3) })
                               eta1 } })
                            eta1 }
                 } in
                 (a7 ww)
                   `cast`
                 (Trans
                      (Sym (Control.Monad.Prompt.NTCo:Prompt[0]
                                <Control.Monad.Prompt.Lift
                                   Data.Random.Source.Internal.Prim.Prim
                                   Data.Functor.Identity.Identity>_R
                                <[(PhonemeData.Word, GHC.Base.String)]>_R))
                      (Trans
                           (Sym (Control.Monad.Prompt.NTCo:PromptT[0]
                                     <Data.Random.Source.Internal.Prim.Prim>_R
                                     <Data.Functor.Identity.Identity>_R))
                           (Sym (Data.RVar.NTCo:RVarT[0]) <Data.Functor.Identity.Identity>_N) <[(PhonemeData.Word,
                                                                                                 GHC.Base.String)]>_N))) -}
a9223fbd4bbfb5ca739ca06f93a9d6ea
  $wmakeMorpheme ::
    [PhonemeData.Phoneme]
    -> [[PhonemeData.Phoneme]]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> Data.RVar.RVar PhonemeData.Morpheme
  {- Arity: 10,
     Strictness: <L,U><L,U><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,1*U(U)><L,1*U(U)>,
     Inline: [0] -}
37230cbb867b845f5082ac5d2224ab87
  data MeaningData = MeaningData {inputGeneral :: [GHC.Base.String]}
f4705d51cb711a87e0ff984121cbe8f5
  inputGeneral :: WordGen.MeaningData -> [GHC.Base.String]
  RecSel WordGen.MeaningData
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: WordGen.MeaningData ->
                 case ds of wild { WordGen.MeaningData ds1 -> ds1 }) -}
1ebe00339a3912fd448704bb1ed38f24
  loadMeaningData :: GHC.Types.IO WordGen.MeaningData
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                WordGen.loadMeaningData1
                  `cast`
                (Sym (GHC.Types.NTCo:IO[0] <WordGen.MeaningData>_R)) -}
cb85182aef85950a9c0c9f1a1d94bb1a
  loadMeaningData1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, WordGen.MeaningData #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        WordGen.loadMeaningData5
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    WordGen.MeaningData
                      (case Text.Read.readEither6
                              @ [GHC.Base.String]
                              (Text.ParserCombinators.ReadP.run
                                 @ [GHC.Base.String]
                                 WordGen.loadMeaningData4
                                 ipv3) of wild {
                         [] -> WordGen.loadMeaningData3
                         : x ds2
                         -> case ds2 of wild1 {
                              [] -> x : ipv4 ipv5 -> WordGen.loadMeaningData2 } }) #) } }) -}
50b8516d1b82dcdd4d22aa18ef7f8ff6
  loadMeaningData2 :: [GHC.Base.String]
  {- Strictness: b -}
cd74c6bc9d3efb24b0cbd3c1c7e0c709
  loadMeaningData3 :: [GHC.Base.String]
  {- Strictness: b -}
38546eadcac7e04cd952b076d20cd841
  loadMeaningData4 ::
    Text.ParserCombinators.ReadP.P [GHC.Base.String]
  {- Unfolding: (GHC.Read.$wa
                   @ [GHC.Types.Char]
                   GHC.Read.$fReadChar1
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <[GHC.Types.Char]>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <[GHC.Types.Char]>_R)))
                   @ [GHC.Base.String]
                   (Text.Read.readEither5 @ [GHC.Base.String])) -}
0dfe337481c763ce95f7c504cf99969e
  loadMeaningData5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "raw/meanings/meanings.txt"#) -}
a15fdd886617677a6d96f4cc8ed7f706
  makeDictionary ::
    WordGen.MeaningData
    -> [PhonemeData.Phoneme]
    -> [[PhonemeData.Phoneme]]
    -> ((GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int))
    -> Data.RVar.RVar [(PhonemeData.Word, GHC.Base.String)]
  {- Arity: 4,
     Strictness: <S,1*U(U)><L,U><L,U><L,1*U(1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ w :: WordGen.MeaningData
                   w1 :: [PhonemeData.Phoneme]
                   w2 :: [[PhonemeData.Phoneme]]
                   w3 :: ((GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { WordGen.MeaningData ww1 ->
                 WordGen.$wmakeDictionary ww1 w1 w2 w3 }) -}
da75a9aaeb42e0ae5821796c1595af68
  makeMorpheme ::
    [PhonemeData.Phoneme]
    -> [[PhonemeData.Phoneme]]
    -> ((GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int),
        (GHC.Types.Int, GHC.Types.Int))
    -> Data.RVar.RVar PhonemeData.Morpheme
  {- Arity: 3,
     Strictness: <L,U><L,U><S(SSSS),1*U(1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)),1*U(1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: [PhonemeData.Phoneme]
                   w1 :: [[PhonemeData.Phoneme]]
                   w2 :: ((GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int),
                          (GHC.Types.Int, GHC.Types.Int)) ->
                 case w2 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { (,) ww6 ww7 ->
                 case ww2 of ww8 { (,) ww9 ww10 ->
                 case ww3 of ww11 { (,) ww12 ww13 ->
                 case ww4 of ww14 { (,) ww15 ww16 ->
                 WordGen.$wmakeMorpheme
                   w
                   w1
                   ww6
                   ww7
                   ww9
                   ww10
                   ww12
                   ww13
                   ww15
                   ww16 } } } } }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

