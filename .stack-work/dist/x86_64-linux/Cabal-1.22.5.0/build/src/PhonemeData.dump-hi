
==================== FINAL INTERFACE ====================
2016-11-03 21:25:36.454559 UTC

interface conla_1eA9qWUPH9nBowcXqqaV8r:PhonemeData 7103
  interface hash: 6b70e992fbfaec9d61e1e8eb76410dd8
  ABI hash: 2bc4225bb63ccf0a16ac10bab410e892
  export-list hash: 8834c83badd5837275d7ec1bbd2f424a
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  PhonemeData.Backness{PhonemeData.BACK PhonemeData.CENTRAL PhonemeData.FRONT PhonemeData.NEARBACK PhonemeData.NEARFRONT}
  PhonemeData.Height{PhonemeData.CLOSE PhonemeData.CLOSEMID PhonemeData.MID PhonemeData.NEARCLOSE PhonemeData.NEAROPEN PhonemeData.OPEN PhonemeData.OPENMID}
  PhonemeData.Length{PhonemeData.LONG PhonemeData.NORMAL PhonemeData.SHORT}
  PhonemeData.Manner{PhonemeData.AFFRICATE PhonemeData.APPROXIMANT PhonemeData.FLAP PhonemeData.FRICATIVE PhonemeData.LAFFRICATE PhonemeData.LAPPROXIMANT PhonemeData.LFLAP PhonemeData.LFRICATIVE PhonemeData.NASAL PhonemeData.SAFFRICATE PhonemeData.SILIBANT PhonemeData.STOP PhonemeData.TRILL}
  PhonemeData.Morpheme{PhonemeData.Morpheme PhonemeData.getPhonemes}
  PhonemeData.Phonation{PhonemeData.ASPIRATED PhonemeData.BREATHY PhonemeData.CREAKY PhonemeData.MODAL PhonemeData.SLACK PhonemeData.STIFF PhonemeData.VOICELESS}
  PhonemeData.Phoneme{PhonemeData.Blank PhonemeData.Consonant PhonemeData.Diphthong PhonemeData.Vowel PhonemeData.cmanner PhonemeData.cplace PhonemeData.csymbol PhonemeData.cvoice PhonemeData.dbackness1 PhonemeData.dbackness2 PhonemeData.dheight1 PhonemeData.dheight2 PhonemeData.dlength PhonemeData.droundedness1 PhonemeData.droundedness2 PhonemeData.dsymbol PhonemeData.vbackness PhonemeData.vheight PhonemeData.vlength PhonemeData.vroundedness PhonemeData.vsymbol}
  PhonemeData.Place{PhonemeData.ALVEOLAR PhonemeData.ALVEOLOPALATAL PhonemeData.BILABIAL PhonemeData.CORONAL PhonemeData.DENTAL PhonemeData.DENTIALVEOLAR PhonemeData.DORSAL PhonemeData.EPIGLOTTAL PhonemeData.EPIPHARYNGEAL PhonemeData.GLOTTAL PhonemeData.LABIAL PhonemeData.LABIODENTAL PhonemeData.LARYNGEAL PhonemeData.PALATAL PhonemeData.PHARYNGEAL PhonemeData.POSTALVEOLAR PhonemeData.RETROFLEX PhonemeData.UVULAR PhonemeData.VELAR}
  PhonemeData.Roundedness{PhonemeData.DEFAULT PhonemeData.ROUNDED PhonemeData.UNROUNDED}
  PhonemeData.Word{PhonemeData.Word PhonemeData.getMorphemes}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.ParserCombinators.ReadPrec 2590e0e0a57a86ac7c62727f4d868dd2
import  -/  base-4.8.2.0:Text.Read.Lex 724ca44ddd38ddc5f47a501d62736c26
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
9747e3c7b5ae543ddf6a14d6c68612ef
  $fBoundedBackness :: GHC.Enum.Bounded PhonemeData.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Backness PhonemeData.BACK PhonemeData.FRONT -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fBoundedHeight :: GHC.Enum.Bounded PhonemeData.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Height PhonemeData.CLOSE PhonemeData.OPEN -}
414a8b878bf71816d2002a26fce00728
  $fBoundedLength :: GHC.Enum.Bounded PhonemeData.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Length PhonemeData.SHORT PhonemeData.LONG -}
2286baa806cedbe4b7d0c4916ea37630
  $fBoundedManner :: GHC.Enum.Bounded PhonemeData.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Manner PhonemeData.NASAL PhonemeData.LFLAP -}
d728b957933ed40e5f338884385b44c8
  $fBoundedPhonation :: GHC.Enum.Bounded PhonemeData.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phonation
                  PhonemeData.VOICELESS
                  PhonemeData.ASPIRATED -}
e0644167ea1572fa835311f673311319
  $fBoundedPlace :: GHC.Enum.Bounded PhonemeData.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Place PhonemeData.LABIAL PhonemeData.GLOTTAL -}
4c51106b8aab206d34cb6b9d104e8504
  $fBoundedRoundedness :: GHC.Enum.Bounded PhonemeData.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Roundedness
                  PhonemeData.DEFAULT
                  PhonemeData.UNROUNDED -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness :: GHC.Enum.Enum PhonemeData.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Backness
                  PhonemeData.$fEnumBackness_$csucc
                  PhonemeData.$fEnumBackness_$cpred
                  PhonemeData.$fEnumBackness_$ctoEnum
                  PhonemeData.$fEnumBackness_$cfromEnum
                  PhonemeData.$fEnumBackness_$cenumFrom
                  PhonemeData.$fEnumBackness_$cenumFromThen
                  PhonemeData.$fEnumBackness_$cenumFromTo
                  PhonemeData.$fEnumBackness_$cenumFromThenTo -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness1 :: [PhonemeData.Backness]
  {- Unfolding: (PhonemeData.$fEnumBackness_go5 4) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness2 :: [PhonemeData.Backness]
  {- Unfolding: (PhonemeData.$fEnumBackness_go6 3) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness3 :: [PhonemeData.Backness]
  {- Unfolding: (PhonemeData.$fEnumBackness_go7 2) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness4 :: [PhonemeData.Backness]
  {- Unfolding: (PhonemeData.$fEnumBackness_go8 1) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness5 :: [PhonemeData.Backness]
  {- Unfolding: (PhonemeData.$fEnumBackness_go9 0) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness6 :: GHC.Prim.Int# -> PhonemeData.Backness
  {- Arity: 1, Strictness: <L,U>b -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness7 :: PhonemeData.Backness
  {- Strictness: b -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness8 :: PhonemeData.Backness
  {- Strictness: b -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_$cenumFrom ::
    PhonemeData.Backness -> [PhonemeData.Backness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK -> PhonemeData.$fEnumBackness5
                   PhonemeData.NEARBACK -> PhonemeData.$fEnumBackness4
                   PhonemeData.CENTRAL -> PhonemeData.$fEnumBackness3
                   PhonemeData.NEARFRONT -> PhonemeData.$fEnumBackness2
                   PhonemeData.FRONT -> PhonemeData.$fEnumBackness1 }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_$cenumFromThen ::
    PhonemeData.Backness
    -> PhonemeData.Backness -> [PhonemeData.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Backness
                   b :: PhonemeData.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeData.Backness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeData.Backness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeData.Backness]
                                    PhonemeData.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeData.Backness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeData.Backness]
                                    PhonemeData.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeData.Backness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 4 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeData.BACK -> $j1 0
                       PhonemeData.NEARBACK -> $j1 1
                       PhonemeData.CENTRAL -> $j1 2
                       PhonemeData.NEARFRONT -> $j1 3
                       PhonemeData.FRONT -> $j1 4 }
                 } in
                 case a8 of wild {
                   PhonemeData.BACK -> $j 0
                   PhonemeData.NEARBACK -> $j 1
                   PhonemeData.CENTRAL -> $j 2
                   PhonemeData.NEARFRONT -> $j 3
                   PhonemeData.FRONT -> $j 4 }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_$cenumFromThenTo ::
    PhonemeData.Backness
    -> PhonemeData.Backness
    -> PhonemeData.Backness
    -> [PhonemeData.Backness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_$cenumFromTo ::
    PhonemeData.Backness
    -> PhonemeData.Backness -> [PhonemeData.Backness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Backness
                   y :: PhonemeData.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeData.BACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumBackness_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Backness }
                       PhonemeData.NEARBACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumBackness_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Backness }
                       PhonemeData.CENTRAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumBackness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Backness }
                       PhonemeData.NEARFRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumBackness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Backness }
                       PhonemeData.FRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumBackness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Backness } }
                 } in
                 case x of wild {
                   PhonemeData.BACK -> $j 0
                   PhonemeData.NEARBACK -> $j 1
                   PhonemeData.CENTRAL -> $j 2
                   PhonemeData.NEARFRONT -> $j 3
                   PhonemeData.FRONT -> $j 4 }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_$cfromEnum :: PhonemeData.Backness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeData.Backness ->
                 case w of wild {
                   PhonemeData.BACK -> GHC.Types.I# 0
                   PhonemeData.NEARBACK -> GHC.Types.I# 1
                   PhonemeData.CENTRAL -> GHC.Types.I# 2
                   PhonemeData.NEARFRONT -> GHC.Types.I# 3
                   PhonemeData.FRONT -> GHC.Types.I# 4 }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_$cpred ::
    PhonemeData.Backness -> PhonemeData.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK -> PhonemeData.$fEnumBackness7
                   PhonemeData.NEARBACK -> PhonemeData.BACK
                   PhonemeData.CENTRAL -> PhonemeData.NEARBACK
                   PhonemeData.NEARFRONT -> PhonemeData.CENTRAL
                   PhonemeData.FRONT -> PhonemeData.NEARFRONT }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_$csucc ::
    PhonemeData.Backness -> PhonemeData.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK -> PhonemeData.NEARBACK
                   PhonemeData.NEARBACK -> PhonemeData.CENTRAL
                   PhonemeData.CENTRAL -> PhonemeData.NEARFRONT
                   PhonemeData.NEARFRONT -> PhonemeData.FRONT
                   PhonemeData.FRONT -> PhonemeData.$fEnumBackness8 }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_$ctoEnum :: GHC.Types.Int -> PhonemeData.Backness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 -> PhonemeData.$w$ctoEnum ww1 }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_c ::
    GHC.Types.Int -> [PhonemeData.Backness] -> [PhonemeData.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Backness] ->
                 GHC.Types.:
                   @ PhonemeData.Backness
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeData.Backness a8 })
                   ys) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go1 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go2 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go3 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go4 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go5 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go6 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go7 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go8 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEnumBackness_go9 :: GHC.Prim.Int# -> [PhonemeData.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight :: GHC.Enum.Enum PhonemeData.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Height
                  PhonemeData.$fEnumHeight_$csucc
                  PhonemeData.$fEnumHeight_$cpred
                  PhonemeData.$fEnumHeight_$ctoEnum
                  PhonemeData.$fEnumHeight_$cfromEnum
                  PhonemeData.$fEnumHeight_$cenumFrom
                  PhonemeData.$fEnumHeight_$cenumFromThen
                  PhonemeData.$fEnumHeight_$cenumFromTo
                  PhonemeData.$fEnumHeight_$cenumFromThenTo -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight1 :: [PhonemeData.Height]
  {- Unfolding: (PhonemeData.$fEnumHeight_go7 6) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight10 :: PhonemeData.Height
  {- Strictness: b -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight2 :: [PhonemeData.Height]
  {- Unfolding: (PhonemeData.$fEnumHeight_go8 5) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight3 :: [PhonemeData.Height]
  {- Unfolding: (PhonemeData.$fEnumHeight_go9 4) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight4 :: [PhonemeData.Height]
  {- Unfolding: (PhonemeData.$fEnumHeight_go10 3) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight5 :: [PhonemeData.Height]
  {- Unfolding: (PhonemeData.$fEnumHeight_go11 2) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight6 :: [PhonemeData.Height]
  {- Unfolding: (PhonemeData.$fEnumHeight_go12 1) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight7 :: [PhonemeData.Height]
  {- Unfolding: (PhonemeData.$fEnumHeight_go13 0) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight8 :: GHC.Prim.Int# -> PhonemeData.Height
  {- Arity: 1, Strictness: <L,U>b -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight9 :: PhonemeData.Height
  {- Strictness: b -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_$cenumFrom ::
    PhonemeData.Height -> [PhonemeData.Height]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Height ->
                 case a8 of wild {
                   PhonemeData.CLOSE -> PhonemeData.$fEnumHeight7
                   PhonemeData.NEARCLOSE -> PhonemeData.$fEnumHeight6
                   PhonemeData.CLOSEMID -> PhonemeData.$fEnumHeight5
                   PhonemeData.MID -> PhonemeData.$fEnumHeight4
                   PhonemeData.OPENMID -> PhonemeData.$fEnumHeight3
                   PhonemeData.NEAROPEN -> PhonemeData.$fEnumHeight2
                   PhonemeData.OPEN -> PhonemeData.$fEnumHeight1 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_$cenumFromThen ::
    PhonemeData.Height -> PhonemeData.Height -> [PhonemeData.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Height b :: PhonemeData.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeData.Height]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeData.Height]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeData.Height]
                                    PhonemeData.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeData.Height)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeData.Height]
                                    PhonemeData.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeData.Height)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeData.CLOSE -> $j1 0
                       PhonemeData.NEARCLOSE -> $j1 1
                       PhonemeData.CLOSEMID -> $j1 2
                       PhonemeData.MID -> $j1 3
                       PhonemeData.OPENMID -> $j1 4
                       PhonemeData.NEAROPEN -> $j1 5
                       PhonemeData.OPEN -> $j1 6 }
                 } in
                 case a8 of wild {
                   PhonemeData.CLOSE -> $j 0
                   PhonemeData.NEARCLOSE -> $j 1
                   PhonemeData.CLOSEMID -> $j 2
                   PhonemeData.MID -> $j 3
                   PhonemeData.OPENMID -> $j 4
                   PhonemeData.NEAROPEN -> $j 5
                   PhonemeData.OPEN -> $j 6 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_$cenumFromThenTo ::
    PhonemeData.Height
    -> PhonemeData.Height -> PhonemeData.Height -> [PhonemeData.Height]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_$cenumFromTo ::
    PhonemeData.Height -> PhonemeData.Height -> [PhonemeData.Height]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Height y :: PhonemeData.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeData.CLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumHeight_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Height }
                       PhonemeData.NEARCLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumHeight_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Height }
                       PhonemeData.CLOSEMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumHeight_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Height }
                       PhonemeData.MID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumHeight_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Height }
                       PhonemeData.OPENMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumHeight_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Height }
                       PhonemeData.NEAROPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumHeight_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Height }
                       PhonemeData.OPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumHeight_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Height } }
                 } in
                 case x of wild {
                   PhonemeData.CLOSE -> $j 0
                   PhonemeData.NEARCLOSE -> $j 1
                   PhonemeData.CLOSEMID -> $j 2
                   PhonemeData.MID -> $j 3
                   PhonemeData.OPENMID -> $j 4
                   PhonemeData.NEAROPEN -> $j 5
                   PhonemeData.OPEN -> $j 6 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_$cfromEnum :: PhonemeData.Height -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeData.Height ->
                 case w of wild {
                   PhonemeData.CLOSE -> GHC.Types.I# 0
                   PhonemeData.NEARCLOSE -> GHC.Types.I# 1
                   PhonemeData.CLOSEMID -> GHC.Types.I# 2
                   PhonemeData.MID -> GHC.Types.I# 3
                   PhonemeData.OPENMID -> GHC.Types.I# 4
                   PhonemeData.NEAROPEN -> GHC.Types.I# 5
                   PhonemeData.OPEN -> GHC.Types.I# 6 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_$cpred :: PhonemeData.Height -> PhonemeData.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Height ->
                 case a8 of wild {
                   PhonemeData.CLOSE -> PhonemeData.$fEnumHeight9
                   PhonemeData.NEARCLOSE -> PhonemeData.CLOSE
                   PhonemeData.CLOSEMID -> PhonemeData.NEARCLOSE
                   PhonemeData.MID -> PhonemeData.CLOSEMID
                   PhonemeData.OPENMID -> PhonemeData.MID
                   PhonemeData.NEAROPEN -> PhonemeData.OPENMID
                   PhonemeData.OPEN -> PhonemeData.NEAROPEN }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_$csucc :: PhonemeData.Height -> PhonemeData.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Height ->
                 case a8 of wild {
                   PhonemeData.CLOSE -> PhonemeData.NEARCLOSE
                   PhonemeData.NEARCLOSE -> PhonemeData.CLOSEMID
                   PhonemeData.CLOSEMID -> PhonemeData.MID
                   PhonemeData.MID -> PhonemeData.OPENMID
                   PhonemeData.OPENMID -> PhonemeData.NEAROPEN
                   PhonemeData.NEAROPEN -> PhonemeData.OPEN
                   PhonemeData.OPEN -> PhonemeData.$fEnumHeight10 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_$ctoEnum :: GHC.Types.Int -> PhonemeData.Height
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeData.$w$ctoEnum1 ww1 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_c ::
    GHC.Types.Int -> [PhonemeData.Height] -> [PhonemeData.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Height] ->
                 GHC.Types.:
                   @ PhonemeData.Height
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeData.Height a8 })
                   ys) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go1 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go10 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go11 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go12 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go13 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go2 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go3 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go4 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go5 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go6 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go7 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go8 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEnumHeight_go9 :: GHC.Prim.Int# -> [PhonemeData.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength :: GHC.Enum.Enum PhonemeData.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Length
                  PhonemeData.$fEnumLength_$csucc
                  PhonemeData.$fEnumLength_$cpred
                  PhonemeData.$fEnumLength_$ctoEnum
                  PhonemeData.$fEnumLength_$cfromEnum
                  PhonemeData.$fEnumLength_$cenumFrom
                  PhonemeData.$fEnumLength_$cenumFromThen
                  PhonemeData.$fEnumLength_$cenumFromTo
                  PhonemeData.$fEnumLength_$cenumFromThenTo -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength1 :: GHC.Prim.Int# -> PhonemeData.Length
  {- Arity: 1, Strictness: <L,U>b -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength2 :: [PhonemeData.Length]
  {- Unfolding: (PhonemeData.$fEnumLength_go3 2) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength3 :: [PhonemeData.Length]
  {- Unfolding: (PhonemeData.$fEnumLength_go4 1) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength4 :: [PhonemeData.Length]
  {- Unfolding: (PhonemeData.$fEnumLength_go5 0) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength5 :: PhonemeData.Length
  {- Strictness: b -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength6 :: PhonemeData.Length
  {- Strictness: b -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_$cenumFrom ::
    PhonemeData.Length -> [PhonemeData.Length]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT -> PhonemeData.$fEnumLength4
                   PhonemeData.NORMAL -> PhonemeData.$fEnumLength3
                   PhonemeData.LONG -> PhonemeData.$fEnumLength2 }) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_$cenumFromThen ::
    PhonemeData.Length -> PhonemeData.Length -> [PhonemeData.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Length b :: PhonemeData.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeData.Length]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeData.Length]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeData.Length]
                                    PhonemeData.$fEnumLength_c1
                                    (GHC.Types.[] @ PhonemeData.Length)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeData.Length]
                                    PhonemeData.$fEnumLength_c1
                                    (GHC.Types.[] @ PhonemeData.Length)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeData.SHORT -> $j1 0
                       PhonemeData.NORMAL -> $j1 1
                       PhonemeData.LONG -> $j1 2 }
                 } in
                 case a8 of wild {
                   PhonemeData.SHORT -> $j 0
                   PhonemeData.NORMAL -> $j 1
                   PhonemeData.LONG -> $j 2 }) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_$cenumFromThenTo ::
    PhonemeData.Length
    -> PhonemeData.Length -> PhonemeData.Length -> [PhonemeData.Length]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeData.Length
                   x2 :: PhonemeData.Length
                   y :: PhonemeData.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeData.Length]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeData.SHORT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeData.Length]
                                     PhonemeData.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeData.Length)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeData.Length]
                                     PhonemeData.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeData.Length)
                                     x4
                                     x5
                                     0 }
                           PhonemeData.NORMAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeData.Length]
                                     PhonemeData.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeData.Length)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeData.Length]
                                     PhonemeData.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeData.Length)
                                     x4
                                     x5
                                     1 }
                           PhonemeData.LONG
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeData.Length]
                                     PhonemeData.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeData.Length)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeData.Length]
                                     PhonemeData.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeData.Length)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeData.SHORT -> $j1 0
                       PhonemeData.NORMAL -> $j1 1
                       PhonemeData.LONG -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeData.SHORT -> $j 0
                   PhonemeData.NORMAL -> $j 1
                   PhonemeData.LONG -> $j 2 }) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_$cenumFromTo ::
    PhonemeData.Length -> PhonemeData.Length -> [PhonemeData.Length]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Length y :: PhonemeData.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeData.SHORT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumLength_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Length }
                       PhonemeData.NORMAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumLength_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Length }
                       PhonemeData.LONG
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumLength_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Length } }
                 } in
                 case x of wild {
                   PhonemeData.SHORT -> $j 0
                   PhonemeData.NORMAL -> $j 1
                   PhonemeData.LONG -> $j 2 }) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_$cfromEnum :: PhonemeData.Length -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT -> GHC.Types.I# 0
                   PhonemeData.NORMAL -> GHC.Types.I# 1
                   PhonemeData.LONG -> GHC.Types.I# 2 }) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_$cpred :: PhonemeData.Length -> PhonemeData.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT -> PhonemeData.$fEnumLength5
                   PhonemeData.NORMAL -> PhonemeData.SHORT
                   PhonemeData.LONG -> PhonemeData.NORMAL }) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_$csucc :: PhonemeData.Length -> PhonemeData.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT -> PhonemeData.NORMAL
                   PhonemeData.NORMAL -> PhonemeData.LONG
                   PhonemeData.LONG -> PhonemeData.$fEnumLength6 }) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_$ctoEnum :: GHC.Types.Int -> PhonemeData.Length
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeData.$w$ctoEnum2 ww1 }) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_c ::
    GHC.Types.Int -> [PhonemeData.Length] -> [PhonemeData.Length]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Length] ->
                 GHC.Types.:
                   @ PhonemeData.Length
                   (PhonemeData.$fEnumLength_$ctoEnum x)
                   ys) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_c1 ::
    GHC.Types.Int -> [PhonemeData.Length] -> [PhonemeData.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Length] ->
                 GHC.Types.:
                   @ PhonemeData.Length
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeData.Length a8 })
                   ys) -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_go :: GHC.Prim.Int# -> [PhonemeData.Length]
  {- Arity: 1, Strictness: <L,U> -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_go1 :: GHC.Prim.Int# -> [PhonemeData.Length]
  {- Arity: 1, Strictness: <L,U> -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_go2 :: GHC.Prim.Int# -> [PhonemeData.Length]
  {- Arity: 1, Strictness: <L,U> -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_go3 :: GHC.Prim.Int# -> [PhonemeData.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_go4 :: GHC.Prim.Int# -> [PhonemeData.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
414a8b878bf71816d2002a26fce00728
  $fEnumLength_go5 :: GHC.Prim.Int# -> [PhonemeData.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner :: GHC.Enum.Enum PhonemeData.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Manner
                  PhonemeData.$fEnumManner_$csucc
                  PhonemeData.$fEnumManner_$cpred
                  PhonemeData.$fEnumManner_$ctoEnum
                  PhonemeData.$fEnumManner_$cfromEnum
                  PhonemeData.$fEnumManner_$cenumFrom
                  PhonemeData.$fEnumManner_$cenumFromThen
                  PhonemeData.$fEnumManner_$cenumFromTo
                  PhonemeData.$fEnumManner_$cenumFromThenTo -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner1 :: GHC.Prim.Int# -> PhonemeData.Manner
  {- Arity: 1, Strictness: <L,U>b -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner2 :: PhonemeData.Manner
  {- Strictness: b -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner3 :: PhonemeData.Manner
  {- Strictness: b -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_$cenumFrom ::
    PhonemeData.Manner -> [PhonemeData.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 12) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumManner_go x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeData.Manner } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_$cenumFromThen ::
    PhonemeData.Manner -> PhonemeData.Manner -> [PhonemeData.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Manner b :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x1
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Manner]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeData.Manner]
                            PhonemeData.$fEnumManner_c1
                            (GHC.Types.[] @ PhonemeData.Manner)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeData.Manner]
                            PhonemeData.$fEnumManner_c1
                            (GHC.Types.[] @ PhonemeData.Manner)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 12 GHC.Types.True -> $j 0 } } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_$cenumFromThenTo ::
    PhonemeData.Manner
    -> PhonemeData.Manner -> PhonemeData.Manner -> [PhonemeData.Manner]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeData.Manner
                   x2 :: PhonemeData.Manner
                   y :: PhonemeData.Manner ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeData.Manner]
                        PhonemeData.$fEnumManner_c
                        (GHC.Types.[] @ PhonemeData.Manner)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeData.Manner x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeData.Manner]
                        PhonemeData.$fEnumManner_c
                        (GHC.Types.[] @ PhonemeData.Manner)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeData.Manner x6) } } } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_$cenumFromTo ::
    PhonemeData.Manner -> PhonemeData.Manner -> [PhonemeData.Manner]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Manner y :: PhonemeData.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go25 :: GHC.Prim.Int# -> [PhonemeData.Manner]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeData.Manner
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeData.$fEnumManner1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 12) of wild2 {
                                    GHC.Types.False -> PhonemeData.$fEnumManner1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeData.Manner x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go25 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeData.Manner })
                      } in
                      go25 x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeData.Manner } } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_$cfromEnum :: PhonemeData.Manner -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ PhonemeData.Manner x1) }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_$cpred :: PhonemeData.Manner -> PhonemeData.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeData.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeData.Manner (GHC.Prim.+# wild (-1))
                   0 -> PhonemeData.$fEnumManner2 } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_$csucc :: PhonemeData.Manner -> PhonemeData.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeData.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeData.Manner (GHC.Prim.+# wild 1)
                   12 -> PhonemeData.$fEnumManner3 } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_$ctoEnum :: GHC.Types.Int -> PhonemeData.Manner
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeData.$w$ctoEnum3 ww1 }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_c ::
    GHC.Types.Int -> [PhonemeData.Manner] -> [PhonemeData.Manner]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Manner] ->
                 GHC.Types.:
                   @ PhonemeData.Manner
                   (PhonemeData.$fEnumManner_$ctoEnum x)
                   ys) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_c1 ::
    GHC.Types.Int -> [PhonemeData.Manner] -> [PhonemeData.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Manner] ->
                 GHC.Types.:
                   @ PhonemeData.Manner
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeData.Manner a8 })
                   ys) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEnumManner_go :: GHC.Prim.Int# -> [PhonemeData.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation :: GHC.Enum.Enum PhonemeData.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phonation
                  PhonemeData.$fEnumPhonation_$csucc
                  PhonemeData.$fEnumPhonation_$cpred
                  PhonemeData.$fEnumPhonation_$ctoEnum
                  PhonemeData.$fEnumPhonation_$cfromEnum
                  PhonemeData.$fEnumPhonation_$cenumFrom
                  PhonemeData.$fEnumPhonation_$cenumFromThen
                  PhonemeData.$fEnumPhonation_$cenumFromTo
                  PhonemeData.$fEnumPhonation_$cenumFromThenTo -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation1 :: [PhonemeData.Phonation]
  {- Unfolding: (PhonemeData.$fEnumPhonation_go7 6) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation10 :: PhonemeData.Phonation
  {- Strictness: b -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation2 :: [PhonemeData.Phonation]
  {- Unfolding: (PhonemeData.$fEnumPhonation_go8 5) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation3 :: [PhonemeData.Phonation]
  {- Unfolding: (PhonemeData.$fEnumPhonation_go9 4) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation4 :: [PhonemeData.Phonation]
  {- Unfolding: (PhonemeData.$fEnumPhonation_go10 3) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation5 :: [PhonemeData.Phonation]
  {- Unfolding: (PhonemeData.$fEnumPhonation_go11 2) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation6 :: [PhonemeData.Phonation]
  {- Unfolding: (PhonemeData.$fEnumPhonation_go12 1) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation7 :: [PhonemeData.Phonation]
  {- Unfolding: (PhonemeData.$fEnumPhonation_go13 0) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation8 :: GHC.Prim.Int# -> PhonemeData.Phonation
  {- Arity: 1, Strictness: <L,U>b -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation9 :: PhonemeData.Phonation
  {- Strictness: b -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_$cenumFrom ::
    PhonemeData.Phonation -> [PhonemeData.Phonation]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Phonation ->
                 case a8 of wild {
                   PhonemeData.VOICELESS -> PhonemeData.$fEnumPhonation7
                   PhonemeData.BREATHY -> PhonemeData.$fEnumPhonation6
                   PhonemeData.SLACK -> PhonemeData.$fEnumPhonation5
                   PhonemeData.MODAL -> PhonemeData.$fEnumPhonation4
                   PhonemeData.STIFF -> PhonemeData.$fEnumPhonation3
                   PhonemeData.CREAKY -> PhonemeData.$fEnumPhonation2
                   PhonemeData.ASPIRATED -> PhonemeData.$fEnumPhonation1 }) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_$cenumFromThen ::
    PhonemeData.Phonation
    -> PhonemeData.Phonation -> [PhonemeData.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Phonation
                   b :: PhonemeData.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Phonation]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeData.Phonation]
                                    PhonemeData.$fEnumPhonation_c
                                    (GHC.Types.[] @ PhonemeData.Phonation)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeData.Phonation]
                                    PhonemeData.$fEnumPhonation_c
                                    (GHC.Types.[] @ PhonemeData.Phonation)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeData.VOICELESS -> $j1 0
                       PhonemeData.BREATHY -> $j1 1
                       PhonemeData.SLACK -> $j1 2
                       PhonemeData.MODAL -> $j1 3
                       PhonemeData.STIFF -> $j1 4
                       PhonemeData.CREAKY -> $j1 5
                       PhonemeData.ASPIRATED -> $j1 6 }
                 } in
                 case a8 of wild {
                   PhonemeData.VOICELESS -> $j 0
                   PhonemeData.BREATHY -> $j 1
                   PhonemeData.SLACK -> $j 2
                   PhonemeData.MODAL -> $j 3
                   PhonemeData.STIFF -> $j 4
                   PhonemeData.CREAKY -> $j 5
                   PhonemeData.ASPIRATED -> $j 6 }) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_$cenumFromThenTo ::
    PhonemeData.Phonation
    -> PhonemeData.Phonation
    -> PhonemeData.Phonation
    -> [PhonemeData.Phonation]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_$cenumFromTo ::
    PhonemeData.Phonation
    -> PhonemeData.Phonation -> [PhonemeData.Phonation]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Phonation
                   y :: PhonemeData.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Phonation]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeData.VOICELESS
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumPhonation_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Phonation }
                       PhonemeData.BREATHY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumPhonation_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Phonation }
                       PhonemeData.SLACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumPhonation_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Phonation }
                       PhonemeData.MODAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumPhonation_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Phonation }
                       PhonemeData.STIFF
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumPhonation_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Phonation }
                       PhonemeData.CREAKY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumPhonation_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Phonation }
                       PhonemeData.ASPIRATED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumPhonation_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Phonation } }
                 } in
                 case x of wild {
                   PhonemeData.VOICELESS -> $j 0
                   PhonemeData.BREATHY -> $j 1
                   PhonemeData.SLACK -> $j 2
                   PhonemeData.MODAL -> $j 3
                   PhonemeData.STIFF -> $j 4
                   PhonemeData.CREAKY -> $j 5
                   PhonemeData.ASPIRATED -> $j 6 }) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_$cfromEnum ::
    PhonemeData.Phonation -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeData.Phonation ->
                 case w of wild {
                   PhonemeData.VOICELESS -> GHC.Types.I# 0
                   PhonemeData.BREATHY -> GHC.Types.I# 1
                   PhonemeData.SLACK -> GHC.Types.I# 2
                   PhonemeData.MODAL -> GHC.Types.I# 3
                   PhonemeData.STIFF -> GHC.Types.I# 4
                   PhonemeData.CREAKY -> GHC.Types.I# 5
                   PhonemeData.ASPIRATED -> GHC.Types.I# 6 }) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_$cpred ::
    PhonemeData.Phonation -> PhonemeData.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Phonation ->
                 case a8 of wild {
                   PhonemeData.VOICELESS -> PhonemeData.$fEnumPhonation9
                   PhonemeData.BREATHY -> PhonemeData.VOICELESS
                   PhonemeData.SLACK -> PhonemeData.BREATHY
                   PhonemeData.MODAL -> PhonemeData.SLACK
                   PhonemeData.STIFF -> PhonemeData.MODAL
                   PhonemeData.CREAKY -> PhonemeData.STIFF
                   PhonemeData.ASPIRATED -> PhonemeData.CREAKY }) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_$csucc ::
    PhonemeData.Phonation -> PhonemeData.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Phonation ->
                 case a8 of wild {
                   PhonemeData.VOICELESS -> PhonemeData.BREATHY
                   PhonemeData.BREATHY -> PhonemeData.SLACK
                   PhonemeData.SLACK -> PhonemeData.MODAL
                   PhonemeData.MODAL -> PhonemeData.STIFF
                   PhonemeData.STIFF -> PhonemeData.CREAKY
                   PhonemeData.CREAKY -> PhonemeData.ASPIRATED
                   PhonemeData.ASPIRATED -> PhonemeData.$fEnumPhonation10 }) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_$ctoEnum :: GHC.Types.Int -> PhonemeData.Phonation
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeData.$w$ctoEnum4 ww1 }) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_c ::
    GHC.Types.Int -> [PhonemeData.Phonation] -> [PhonemeData.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Phonation] ->
                 GHC.Types.:
                   @ PhonemeData.Phonation
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeData.Phonation a8 })
                   ys) -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go1 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go10 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go11 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go12 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go13 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go2 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go3 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go4 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go5 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go6 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go7 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go8 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d728b957933ed40e5f338884385b44c8
  $fEnumPhonation_go9 :: GHC.Prim.Int# -> [PhonemeData.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e0644167ea1572fa835311f673311319
  $fEnumPlace :: GHC.Enum.Enum PhonemeData.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Place
                  PhonemeData.$fEnumPlace_$csucc
                  PhonemeData.$fEnumPlace_$cpred
                  PhonemeData.$fEnumPlace_$ctoEnum
                  PhonemeData.$fEnumPlace_$cfromEnum
                  PhonemeData.$fEnumPlace_$cenumFrom
                  PhonemeData.$fEnumPlace_$cenumFromThen
                  PhonemeData.$fEnumPlace_$cenumFromTo
                  PhonemeData.$fEnumPlace_$cenumFromThenTo -}
e0644167ea1572fa835311f673311319
  $fEnumPlace1 :: GHC.Prim.Int# -> PhonemeData.Place
  {- Arity: 1, Strictness: <L,U>b -}
e0644167ea1572fa835311f673311319
  $fEnumPlace2 :: PhonemeData.Place
  {- Strictness: b -}
e0644167ea1572fa835311f673311319
  $fEnumPlace3 :: PhonemeData.Place
  {- Strictness: b -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_$cenumFrom :: PhonemeData.Place -> [PhonemeData.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 18) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumPlace_go x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeData.Place } }) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_$cenumFromThen ::
    PhonemeData.Place -> PhonemeData.Place -> [PhonemeData.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Place b :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x1
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Place]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeData.Place]
                            PhonemeData.$fEnumPlace_c1
                            (GHC.Types.[] @ PhonemeData.Place)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeData.Place]
                            PhonemeData.$fEnumPlace_c1
                            (GHC.Types.[] @ PhonemeData.Place)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 18 GHC.Types.True -> $j 0 } } }) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_$cenumFromThenTo ::
    PhonemeData.Place
    -> PhonemeData.Place -> PhonemeData.Place -> [PhonemeData.Place]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeData.Place
                   x2 :: PhonemeData.Place
                   y :: PhonemeData.Place ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeData.Place]
                        PhonemeData.$fEnumPlace_c
                        (GHC.Types.[] @ PhonemeData.Place)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeData.Place x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeData.Place]
                        PhonemeData.$fEnumPlace_c
                        (GHC.Types.[] @ PhonemeData.Place)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeData.Place x6) } } } }) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_$cenumFromTo ::
    PhonemeData.Place -> PhonemeData.Place -> [PhonemeData.Place]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Place y :: PhonemeData.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go25 :: GHC.Prim.Int# -> [PhonemeData.Place]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeData.Place
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeData.$fEnumPlace1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 18) of wild2 {
                                    GHC.Types.False -> PhonemeData.$fEnumPlace1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeData.Place x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go25 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeData.Place })
                      } in
                      go25 x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeData.Place } } }) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_$cfromEnum :: PhonemeData.Place -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ PhonemeData.Place x1) }) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_$cpred :: PhonemeData.Place -> PhonemeData.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeData.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeData.Place (GHC.Prim.+# wild (-1))
                   0 -> PhonemeData.$fEnumPlace2 } }) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_$csucc :: PhonemeData.Place -> PhonemeData.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeData.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeData.Place (GHC.Prim.+# wild 1)
                   18 -> PhonemeData.$fEnumPlace3 } }) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_$ctoEnum :: GHC.Types.Int -> PhonemeData.Place
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeData.$w$ctoEnum5 ww1 }) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_c ::
    GHC.Types.Int -> [PhonemeData.Place] -> [PhonemeData.Place]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Place] ->
                 GHC.Types.:
                   @ PhonemeData.Place
                   (PhonemeData.$fEnumPlace_$ctoEnum x)
                   ys) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_c1 ::
    GHC.Types.Int -> [PhonemeData.Place] -> [PhonemeData.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Place] ->
                 GHC.Types.:
                   @ PhonemeData.Place
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeData.Place a8 })
                   ys) -}
e0644167ea1572fa835311f673311319
  $fEnumPlace_go :: GHC.Prim.Int# -> [PhonemeData.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness :: GHC.Enum.Enum PhonemeData.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Roundedness
                  PhonemeData.$fEnumRoundedness_$csucc
                  PhonemeData.$fEnumRoundedness_$cpred
                  PhonemeData.$fEnumRoundedness_$ctoEnum
                  PhonemeData.$fEnumRoundedness_$cfromEnum
                  PhonemeData.$fEnumRoundedness_$cenumFrom
                  PhonemeData.$fEnumRoundedness_$cenumFromThen
                  PhonemeData.$fEnumRoundedness_$cenumFromTo
                  PhonemeData.$fEnumRoundedness_$cenumFromThenTo -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness1 :: GHC.Prim.Int# -> PhonemeData.Roundedness
  {- Arity: 1, Strictness: <L,U>b -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness2 :: [PhonemeData.Roundedness]
  {- Unfolding: (PhonemeData.$fEnumRoundedness_go3 2) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness3 :: [PhonemeData.Roundedness]
  {- Unfolding: (PhonemeData.$fEnumRoundedness_go4 1) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness4 :: [PhonemeData.Roundedness]
  {- Unfolding: (PhonemeData.$fEnumRoundedness_go5 0) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness5 :: PhonemeData.Roundedness
  {- Strictness: b -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness6 :: PhonemeData.Roundedness
  {- Strictness: b -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_$cenumFrom ::
    PhonemeData.Roundedness -> [PhonemeData.Roundedness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT -> PhonemeData.$fEnumRoundedness4
                   PhonemeData.ROUNDED -> PhonemeData.$fEnumRoundedness3
                   PhonemeData.UNROUNDED -> PhonemeData.$fEnumRoundedness2 }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_$cenumFromThen ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> [PhonemeData.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Roundedness
                   b :: PhonemeData.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeData.Roundedness]
                                    PhonemeData.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeData.Roundedness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeData.Roundedness]
                                    PhonemeData.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeData.Roundedness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeData.DEFAULT -> $j1 0
                       PhonemeData.ROUNDED -> $j1 1
                       PhonemeData.UNROUNDED -> $j1 2 }
                 } in
                 case a8 of wild {
                   PhonemeData.DEFAULT -> $j 0
                   PhonemeData.ROUNDED -> $j 1
                   PhonemeData.UNROUNDED -> $j 2 }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_$cenumFromThenTo ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness
    -> PhonemeData.Roundedness
    -> [PhonemeData.Roundedness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeData.Roundedness
                   x2 :: PhonemeData.Roundedness
                   y :: PhonemeData.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeData.DEFAULT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeData.Roundedness]
                                     PhonemeData.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeData.Roundedness)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeData.Roundedness]
                                     PhonemeData.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeData.Roundedness)
                                     x4
                                     x5
                                     0 }
                           PhonemeData.ROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeData.Roundedness]
                                     PhonemeData.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeData.Roundedness)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeData.Roundedness]
                                     PhonemeData.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeData.Roundedness)
                                     x4
                                     x5
                                     1 }
                           PhonemeData.UNROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeData.Roundedness]
                                     PhonemeData.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeData.Roundedness)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeData.Roundedness]
                                     PhonemeData.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeData.Roundedness)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeData.DEFAULT -> $j1 0
                       PhonemeData.ROUNDED -> $j1 1
                       PhonemeData.UNROUNDED -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeData.DEFAULT -> $j 0
                   PhonemeData.ROUNDED -> $j 1
                   PhonemeData.UNROUNDED -> $j 2 }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_$cenumFromTo ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> [PhonemeData.Roundedness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Roundedness
                   y :: PhonemeData.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeData.DEFAULT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumRoundedness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Roundedness }
                       PhonemeData.ROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumRoundedness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Roundedness }
                       PhonemeData.UNROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeData.$fEnumRoundedness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeData.Roundedness } }
                 } in
                 case x of wild {
                   PhonemeData.DEFAULT -> $j 0
                   PhonemeData.ROUNDED -> $j 1
                   PhonemeData.UNROUNDED -> $j 2 }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_$cfromEnum ::
    PhonemeData.Roundedness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT -> GHC.Types.I# 0
                   PhonemeData.ROUNDED -> GHC.Types.I# 1
                   PhonemeData.UNROUNDED -> GHC.Types.I# 2 }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_$cpred ::
    PhonemeData.Roundedness -> PhonemeData.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT -> PhonemeData.$fEnumRoundedness5
                   PhonemeData.ROUNDED -> PhonemeData.DEFAULT
                   PhonemeData.UNROUNDED -> PhonemeData.ROUNDED }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_$csucc ::
    PhonemeData.Roundedness -> PhonemeData.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT -> PhonemeData.ROUNDED
                   PhonemeData.ROUNDED -> PhonemeData.UNROUNDED
                   PhonemeData.UNROUNDED -> PhonemeData.$fEnumRoundedness6 }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_$ctoEnum ::
    GHC.Types.Int -> PhonemeData.Roundedness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeData.$w$ctoEnum6 ww1 }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_c ::
    GHC.Types.Int
    -> [PhonemeData.Roundedness] -> [PhonemeData.Roundedness]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeData.Roundedness
                   (PhonemeData.$fEnumRoundedness_$ctoEnum x)
                   ys) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_c1 ::
    GHC.Types.Int
    -> [PhonemeData.Roundedness] -> [PhonemeData.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeData.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeData.Roundedness
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeData.Roundedness a8 })
                   ys) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_go :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_go1 :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_go2 :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_go3 :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_go4 :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
4c51106b8aab206d34cb6b9d104e8504
  $fEnumRoundedness_go5 :: GHC.Prim.Int# -> [PhonemeData.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEqBackness :: GHC.Classes.Eq PhonemeData.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Backness
                  PhonemeData.$fEqBackness_$c==
                  PhonemeData.$fEqBackness_$c/= -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEqBackness_$c/= ::
    PhonemeData.Backness -> PhonemeData.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Backness
                   b :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.BACK -> GHC.Types.False }
                   PhonemeData.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.NEARBACK -> GHC.Types.False }
                   PhonemeData.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.CENTRAL -> GHC.Types.False }
                   PhonemeData.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.NEARFRONT -> GHC.Types.False }
                   PhonemeData.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.FRONT -> GHC.Types.False } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fEqBackness_$c== ::
    PhonemeData.Backness -> PhonemeData.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeData.Backness
                   ds1 :: PhonemeData.Backness ->
                 case ds of wild {
                   PhonemeData.BACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.BACK -> GHC.Types.True }
                   PhonemeData.NEARBACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.NEARBACK -> GHC.Types.True }
                   PhonemeData.CENTRAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.CENTRAL -> GHC.Types.True }
                   PhonemeData.NEARFRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.NEARFRONT -> GHC.Types.True }
                   PhonemeData.FRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.FRONT -> GHC.Types.True } }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEqHeight :: GHC.Classes.Eq PhonemeData.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Height
                  PhonemeData.$fEqHeight_$c==
                  PhonemeData.$fEqHeight_$c/= -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEqHeight_$c/= ::
    PhonemeData.Height -> PhonemeData.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Height b :: PhonemeData.Height ->
                 case a8 of wild {
                   PhonemeData.CLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.CLOSE -> GHC.Types.False }
                   PhonemeData.NEARCLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.NEARCLOSE -> GHC.Types.False }
                   PhonemeData.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.CLOSEMID -> GHC.Types.False }
                   PhonemeData.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.MID -> GHC.Types.False }
                   PhonemeData.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.OPENMID -> GHC.Types.False }
                   PhonemeData.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.NEAROPEN -> GHC.Types.False }
                   PhonemeData.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.OPEN -> GHC.Types.False } }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fEqHeight_$c== ::
    PhonemeData.Height -> PhonemeData.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeData.Height ds1 :: PhonemeData.Height ->
                 case ds of wild {
                   PhonemeData.CLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.CLOSE -> GHC.Types.True }
                   PhonemeData.NEARCLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.NEARCLOSE -> GHC.Types.True }
                   PhonemeData.CLOSEMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.CLOSEMID -> GHC.Types.True }
                   PhonemeData.MID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.MID -> GHC.Types.True }
                   PhonemeData.OPENMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.OPENMID -> GHC.Types.True }
                   PhonemeData.NEAROPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.NEAROPEN -> GHC.Types.True }
                   PhonemeData.OPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.OPEN -> GHC.Types.True } }) -}
414a8b878bf71816d2002a26fce00728
  $fEqLength :: GHC.Classes.Eq PhonemeData.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Length
                  PhonemeData.$fEqLength_$c==
                  PhonemeData.$fEqLength_$c/= -}
414a8b878bf71816d2002a26fce00728
  $fEqLength_$c/= ::
    PhonemeData.Length -> PhonemeData.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Length b :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.SHORT -> GHC.Types.False }
                   PhonemeData.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.NORMAL -> GHC.Types.False }
                   PhonemeData.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.LONG -> GHC.Types.False } }) -}
414a8b878bf71816d2002a26fce00728
  $fEqLength_$c== ::
    PhonemeData.Length -> PhonemeData.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeData.Length ds1 :: PhonemeData.Length ->
                 case ds of wild {
                   PhonemeData.SHORT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.SHORT -> GHC.Types.True }
                   PhonemeData.NORMAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.NORMAL -> GHC.Types.True }
                   PhonemeData.LONG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.LONG -> GHC.Types.True } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEqManner :: GHC.Classes.Eq PhonemeData.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Manner
                  PhonemeData.$fEqManner_$c==
                  PhonemeData.$fEqManner_$c/= -}
2286baa806cedbe4b7d0c4916ea37630
  $fEqManner_$c/= ::
    PhonemeData.Manner -> PhonemeData.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Manner b :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeData.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeData.Manner x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fEqManner_$c== ::
    PhonemeData.Manner -> PhonemeData.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Manner b :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x2)) } }) -}
a75f0140e4b212df166951d7f735baaf
  $fEqMorpheme :: GHC.Classes.Eq PhonemeData.Morpheme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Morpheme
                  PhonemeData.$fEqMorpheme_$c==
                  PhonemeData.$fEqMorpheme_$c/= -}
a75f0140e4b212df166951d7f735baaf
  $fEqMorpheme_$c/= ::
    PhonemeData.Morpheme -> PhonemeData.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Morpheme b :: PhonemeData.Morpheme ->
                 case a8 of wild { PhonemeData.Morpheme a9 ->
                 case b of wild1 { PhonemeData.Morpheme b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeData.Phoneme
                        PhonemeData.$fEqPhoneme
                        a9
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
a75f0140e4b212df166951d7f735baaf
  $fEqMorpheme_$c== ::
    PhonemeData.Morpheme -> PhonemeData.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeData.Morpheme ds1 :: PhonemeData.Morpheme ->
                 case ds of wild { PhonemeData.Morpheme a8 ->
                 case ds1 of wild1 { PhonemeData.Morpheme b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ PhonemeData.Phoneme
                   PhonemeData.$fEqPhoneme
                   a8
                   b1 } }) -}
d728b957933ed40e5f338884385b44c8
  $fEqPhonation :: GHC.Classes.Eq PhonemeData.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phonation
                  PhonemeData.$fEqPhonation_$c==
                  PhonemeData.$fEqPhonation_$c/= -}
d728b957933ed40e5f338884385b44c8
  $fEqPhonation_$c/= ::
    PhonemeData.Phonation -> PhonemeData.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Phonation
                   b :: PhonemeData.Phonation ->
                 case a8 of wild {
                   PhonemeData.VOICELESS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.VOICELESS -> GHC.Types.False }
                   PhonemeData.BREATHY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.BREATHY -> GHC.Types.False }
                   PhonemeData.SLACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.SLACK -> GHC.Types.False }
                   PhonemeData.MODAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.MODAL -> GHC.Types.False }
                   PhonemeData.STIFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.STIFF -> GHC.Types.False }
                   PhonemeData.CREAKY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.CREAKY -> GHC.Types.False }
                   PhonemeData.ASPIRATED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.ASPIRATED -> GHC.Types.False } }) -}
d728b957933ed40e5f338884385b44c8
  $fEqPhonation_$c== ::
    PhonemeData.Phonation -> PhonemeData.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeData.Phonation
                   ds1 :: PhonemeData.Phonation ->
                 case ds of wild {
                   PhonemeData.VOICELESS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.VOICELESS -> GHC.Types.True }
                   PhonemeData.BREATHY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.BREATHY -> GHC.Types.True }
                   PhonemeData.SLACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.SLACK -> GHC.Types.True }
                   PhonemeData.MODAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.MODAL -> GHC.Types.True }
                   PhonemeData.STIFF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.STIFF -> GHC.Types.True }
                   PhonemeData.CREAKY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.CREAKY -> GHC.Types.True }
                   PhonemeData.ASPIRATED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.ASPIRATED -> GHC.Types.True } }) -}
725a483aa2dd4b7c0473c29cf990b878
  $fEqPhoneme :: GHC.Classes.Eq PhonemeData.Phoneme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phoneme
                  PhonemeData.$fEqPhoneme_$c==
                  PhonemeData.$fEqPhoneme_$c/= -}
725a483aa2dd4b7c0473c29cf990b878
  $fEqPhoneme_$c/= ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Phoneme b :: PhonemeData.Phoneme ->
                 case PhonemeData.$fEqPhoneme_$c== a8 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
725a483aa2dd4b7c0473c29cf990b878
  $fEqPhoneme_$c== ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
e0644167ea1572fa835311f673311319
  $fEqPlace :: GHC.Classes.Eq PhonemeData.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Place
                  PhonemeData.$fEqPlace_$c==
                  PhonemeData.$fEqPlace_$c/= -}
e0644167ea1572fa835311f673311319
  $fEqPlace_$c/= ::
    PhonemeData.Place -> PhonemeData.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Place b :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeData.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeData.Place x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
e0644167ea1572fa835311f673311319
  $fEqPlace_$c== ::
    PhonemeData.Place -> PhonemeData.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Place b :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x2)) } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEqRoundedness :: GHC.Classes.Eq PhonemeData.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Roundedness
                  PhonemeData.$fEqRoundedness_$c==
                  PhonemeData.$fEqRoundedness_$c/= -}
4c51106b8aab206d34cb6b9d104e8504
  $fEqRoundedness_$c/= ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Roundedness b :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.DEFAULT -> GHC.Types.False }
                   PhonemeData.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.ROUNDED -> GHC.Types.False }
                   PhonemeData.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.UNROUNDED -> GHC.Types.False } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fEqRoundedness_$c== ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeData.Roundedness ds1 :: PhonemeData.Roundedness ->
                 case ds of wild {
                   PhonemeData.DEFAULT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.DEFAULT -> GHC.Types.True }
                   PhonemeData.ROUNDED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.ROUNDED -> GHC.Types.True }
                   PhonemeData.UNROUNDED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.UNROUNDED -> GHC.Types.True } }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fEqWord :: GHC.Classes.Eq PhonemeData.Word
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Word
                  PhonemeData.$fEqWord_$c==
                  PhonemeData.$fEqWord_$c/= -}
55b6ea537d860cf92b62e64e19ceba7b
  $fEqWord_$c/= ::
    PhonemeData.Word -> PhonemeData.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Word b :: PhonemeData.Word ->
                 case a8 of wild { PhonemeData.Word a9 ->
                 case b of wild1 { PhonemeData.Word b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeData.Morpheme
                        PhonemeData.$fEqMorpheme
                        a9
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fEqWord_$c== ::
    PhonemeData.Word -> PhonemeData.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeData.Word ds1 :: PhonemeData.Word ->
                 case ds of wild { PhonemeData.Word a8 ->
                 case ds1 of wild1 { PhonemeData.Word b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ PhonemeData.Morpheme
                   PhonemeData.$fEqMorpheme
                   a8
                   b1 } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fOrdBackness :: GHC.Classes.Ord PhonemeData.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Backness
                  PhonemeData.$fEqBackness
                  PhonemeData.$fOrdBackness_$ccompare
                  PhonemeData.$fOrdBackness_$c<
                  PhonemeData.$fOrdBackness_$c<=
                  PhonemeData.$fOrdBackness_$c>
                  PhonemeData.$fOrdBackness_$c>=
                  PhonemeData.$fOrdBackness_$cmax
                  PhonemeData.$fOrdBackness_$cmin -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fOrdBackness_$c< ::
    PhonemeData.Backness -> PhonemeData.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Backness
                   b :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK
                   -> case b of wild1 {
                        PhonemeData.BACK -> GHC.Types.False
                        PhonemeData.NEARBACK -> GHC.Types.True
                        PhonemeData.CENTRAL -> GHC.Types.True
                        PhonemeData.NEARFRONT -> GHC.Types.True
                        PhonemeData.FRONT -> GHC.Types.True }
                   PhonemeData.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.CENTRAL -> GHC.Types.True
                        PhonemeData.NEARFRONT -> GHC.Types.True
                        PhonemeData.FRONT -> GHC.Types.True }
                   PhonemeData.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.NEARFRONT -> GHC.Types.True
                        PhonemeData.FRONT -> GHC.Types.True }
                   PhonemeData.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.FRONT -> GHC.Types.True }
                   PhonemeData.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fOrdBackness_$c<= ::
    PhonemeData.Backness -> PhonemeData.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Backness
                   b :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeData.NEARBACK
                   -> case b of wild1 {
                        PhonemeData.BACK -> GHC.Types.False
                        PhonemeData.NEARBACK -> GHC.Types.True
                        PhonemeData.CENTRAL -> GHC.Types.True
                        PhonemeData.NEARFRONT -> GHC.Types.True
                        PhonemeData.FRONT -> GHC.Types.True }
                   PhonemeData.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.CENTRAL -> GHC.Types.True
                        PhonemeData.NEARFRONT -> GHC.Types.True
                        PhonemeData.FRONT -> GHC.Types.True }
                   PhonemeData.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.NEARFRONT -> GHC.Types.True
                        PhonemeData.FRONT -> GHC.Types.True }
                   PhonemeData.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.FRONT -> GHC.Types.True } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fOrdBackness_$c> ::
    PhonemeData.Backness -> PhonemeData.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Backness
                   b :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeData.NEARBACK
                   -> case b of wild1 {
                        PhonemeData.BACK -> GHC.Types.True
                        PhonemeData.NEARBACK -> GHC.Types.False
                        PhonemeData.CENTRAL -> GHC.Types.False
                        PhonemeData.NEARFRONT -> GHC.Types.False
                        PhonemeData.FRONT -> GHC.Types.False }
                   PhonemeData.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.CENTRAL -> GHC.Types.False
                        PhonemeData.NEARFRONT -> GHC.Types.False
                        PhonemeData.FRONT -> GHC.Types.False }
                   PhonemeData.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.NEARFRONT -> GHC.Types.False
                        PhonemeData.FRONT -> GHC.Types.False }
                   PhonemeData.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.FRONT -> GHC.Types.False } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fOrdBackness_$c>= ::
    PhonemeData.Backness -> PhonemeData.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Backness
                   b :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK
                   -> case b of wild1 {
                        PhonemeData.BACK -> GHC.Types.True
                        PhonemeData.NEARBACK -> GHC.Types.False
                        PhonemeData.CENTRAL -> GHC.Types.False
                        PhonemeData.NEARFRONT -> GHC.Types.False
                        PhonemeData.FRONT -> GHC.Types.False }
                   PhonemeData.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.CENTRAL -> GHC.Types.False
                        PhonemeData.NEARFRONT -> GHC.Types.False
                        PhonemeData.FRONT -> GHC.Types.False }
                   PhonemeData.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.NEARFRONT -> GHC.Types.False
                        PhonemeData.FRONT -> GHC.Types.False }
                   PhonemeData.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.FRONT -> GHC.Types.False }
                   PhonemeData.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fOrdBackness_$ccompare ::
    PhonemeData.Backness -> PhonemeData.Backness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Backness
                   b :: PhonemeData.Backness ->
                 case a8 of wild {
                   PhonemeData.BACK
                   -> case b of wild1 {
                        PhonemeData.BACK -> GHC.Types.EQ
                        PhonemeData.NEARBACK -> GHC.Types.LT
                        PhonemeData.CENTRAL -> GHC.Types.LT
                        PhonemeData.NEARFRONT -> GHC.Types.LT
                        PhonemeData.FRONT -> GHC.Types.LT }
                   PhonemeData.NEARBACK
                   -> case b of wild1 {
                        PhonemeData.BACK -> GHC.Types.GT
                        PhonemeData.NEARBACK -> GHC.Types.EQ
                        PhonemeData.CENTRAL -> GHC.Types.LT
                        PhonemeData.NEARFRONT -> GHC.Types.LT
                        PhonemeData.FRONT -> GHC.Types.LT }
                   PhonemeData.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.CENTRAL -> GHC.Types.EQ
                        PhonemeData.NEARFRONT -> GHC.Types.LT
                        PhonemeData.FRONT -> GHC.Types.LT }
                   PhonemeData.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.NEARFRONT -> GHC.Types.EQ
                        PhonemeData.FRONT -> GHC.Types.LT }
                   PhonemeData.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeData.FRONT -> GHC.Types.EQ } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fOrdBackness_$cmax ::
    PhonemeData.Backness
    -> PhonemeData.Backness -> PhonemeData.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Backness
                   y :: PhonemeData.Backness ->
                 case x of wild {
                   PhonemeData.BACK -> y
                   PhonemeData.NEARBACK
                   -> case y of wild1 {
                        DEFAULT -> PhonemeData.NEARBACK
                        PhonemeData.CENTRAL -> PhonemeData.CENTRAL
                        PhonemeData.NEARFRONT -> PhonemeData.NEARFRONT
                        PhonemeData.FRONT -> PhonemeData.FRONT }
                   PhonemeData.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> PhonemeData.CENTRAL
                        PhonemeData.NEARFRONT -> PhonemeData.NEARFRONT
                        PhonemeData.FRONT -> PhonemeData.FRONT }
                   PhonemeData.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> PhonemeData.NEARFRONT
                        PhonemeData.FRONT -> PhonemeData.FRONT }
                   PhonemeData.FRONT
                   -> case y of wild1 { DEFAULT -> PhonemeData.FRONT } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fOrdBackness_$cmin ::
    PhonemeData.Backness
    -> PhonemeData.Backness -> PhonemeData.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeData.Backness
                   y :: PhonemeData.Backness ->
                 case x of wild {
                   PhonemeData.BACK -> case y of wild1 { DEFAULT -> PhonemeData.BACK }
                   PhonemeData.NEARBACK
                   -> case y of wild1 {
                        PhonemeData.BACK -> PhonemeData.BACK
                        PhonemeData.NEARBACK -> PhonemeData.NEARBACK
                        PhonemeData.CENTRAL -> PhonemeData.NEARBACK
                        PhonemeData.NEARFRONT -> PhonemeData.NEARBACK
                        PhonemeData.FRONT -> PhonemeData.NEARBACK }
                   PhonemeData.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        PhonemeData.CENTRAL -> PhonemeData.CENTRAL
                        PhonemeData.NEARFRONT -> PhonemeData.CENTRAL
                        PhonemeData.FRONT -> PhonemeData.CENTRAL }
                   PhonemeData.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        PhonemeData.NEARFRONT -> PhonemeData.NEARFRONT
                        PhonemeData.FRONT -> PhonemeData.NEARFRONT }
                   PhonemeData.FRONT -> y }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fOrdHeight :: GHC.Classes.Ord PhonemeData.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Height
                  PhonemeData.$fEqHeight
                  PhonemeData.$fOrdHeight_$ccompare
                  PhonemeData.$fOrdHeight_$c<
                  PhonemeData.$fOrdHeight_$c<=
                  PhonemeData.$fOrdHeight_$c>
                  PhonemeData.$fOrdHeight_$c>=
                  PhonemeData.$fOrdHeight_$cmax
                  PhonemeData.$fOrdHeight_$cmin -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fOrdHeight_$c< ::
    PhonemeData.Height -> PhonemeData.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Height b :: PhonemeData.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeData.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0)
                       PhonemeData.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1)
                       PhonemeData.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2)
                       PhonemeData.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3)
                       PhonemeData.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4)
                       PhonemeData.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5)
                       PhonemeData.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeData.CLOSE -> $j 0
                   PhonemeData.NEARCLOSE -> $j 1
                   PhonemeData.CLOSEMID -> $j 2
                   PhonemeData.MID -> $j 3
                   PhonemeData.OPENMID -> $j 4
                   PhonemeData.NEAROPEN -> $j 5
                   PhonemeData.OPEN -> $j 6 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fOrdHeight_$c<= ::
    PhonemeData.Height -> PhonemeData.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Height b :: PhonemeData.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeData.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0)
                       PhonemeData.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1)
                       PhonemeData.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2)
                       PhonemeData.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3)
                       PhonemeData.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4)
                       PhonemeData.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5)
                       PhonemeData.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeData.CLOSE -> $j 0
                   PhonemeData.NEARCLOSE -> $j 1
                   PhonemeData.CLOSEMID -> $j 2
                   PhonemeData.MID -> $j 3
                   PhonemeData.OPENMID -> $j 4
                   PhonemeData.NEAROPEN -> $j 5
                   PhonemeData.OPEN -> $j 6 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fOrdHeight_$c> ::
    PhonemeData.Height -> PhonemeData.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Height b :: PhonemeData.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeData.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0)
                       PhonemeData.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1)
                       PhonemeData.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2)
                       PhonemeData.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3)
                       PhonemeData.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4)
                       PhonemeData.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5)
                       PhonemeData.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeData.CLOSE -> $j 0
                   PhonemeData.NEARCLOSE -> $j 1
                   PhonemeData.CLOSEMID -> $j 2
                   PhonemeData.MID -> $j 3
                   PhonemeData.OPENMID -> $j 4
                   PhonemeData.NEAROPEN -> $j 5
                   PhonemeData.OPEN -> $j 6 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fOrdHeight_$c>= ::
    PhonemeData.Height -> PhonemeData.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Height b :: PhonemeData.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeData.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0)
                       PhonemeData.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1)
                       PhonemeData.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2)
                       PhonemeData.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3)
                       PhonemeData.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4)
                       PhonemeData.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5)
                       PhonemeData.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeData.CLOSE -> $j 0
                   PhonemeData.NEARCLOSE -> $j 1
                   PhonemeData.CLOSEMID -> $j 2
                   PhonemeData.MID -> $j 3
                   PhonemeData.OPENMID -> $j 4
                   PhonemeData.NEAROPEN -> $j 5
                   PhonemeData.OPEN -> $j 6 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fOrdHeight_$ccompare ::
    PhonemeData.Height -> PhonemeData.Height -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Height b :: PhonemeData.Height ->
                 case a8 of wild {
                   PhonemeData.CLOSE
                   -> case b of wild1 {
                        PhonemeData.CLOSE -> GHC.Types.EQ
                        PhonemeData.NEARCLOSE -> GHC.Types.LT
                        PhonemeData.CLOSEMID -> GHC.Types.LT
                        PhonemeData.MID -> GHC.Types.LT
                        PhonemeData.OPENMID -> GHC.Types.LT
                        PhonemeData.NEAROPEN -> GHC.Types.LT
                        PhonemeData.OPEN -> GHC.Types.LT }
                   PhonemeData.NEARCLOSE
                   -> case b of wild1 {
                        PhonemeData.CLOSE -> GHC.Types.GT
                        PhonemeData.NEARCLOSE -> GHC.Types.EQ
                        PhonemeData.CLOSEMID -> GHC.Types.LT
                        PhonemeData.MID -> GHC.Types.LT
                        PhonemeData.OPENMID -> GHC.Types.LT
                        PhonemeData.NEAROPEN -> GHC.Types.LT
                        PhonemeData.OPEN -> GHC.Types.LT }
                   PhonemeData.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.CLOSEMID -> GHC.Types.EQ
                        PhonemeData.MID -> GHC.Types.LT
                        PhonemeData.OPENMID -> GHC.Types.LT
                        PhonemeData.NEAROPEN -> GHC.Types.LT
                        PhonemeData.OPEN -> GHC.Types.LT }
                   PhonemeData.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.MID -> GHC.Types.EQ
                        PhonemeData.OPENMID -> GHC.Types.LT
                        PhonemeData.NEAROPEN -> GHC.Types.LT
                        PhonemeData.OPEN -> GHC.Types.LT }
                   PhonemeData.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.OPENMID -> GHC.Types.EQ
                        PhonemeData.NEAROPEN -> GHC.Types.LT
                        PhonemeData.OPEN -> GHC.Types.LT }
                   PhonemeData.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.NEAROPEN -> GHC.Types.EQ
                        PhonemeData.OPEN -> GHC.Types.LT }
                   PhonemeData.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeData.OPEN -> GHC.Types.EQ } }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fOrdHeight_$cmax ::
    PhonemeData.Height -> PhonemeData.Height -> PhonemeData.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Height y :: PhonemeData.Height ->
                 case PhonemeData.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fOrdHeight_$cmin ::
    PhonemeData.Height -> PhonemeData.Height -> PhonemeData.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Height y :: PhonemeData.Height ->
                 case PhonemeData.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
414a8b878bf71816d2002a26fce00728
  $fOrdLength :: GHC.Classes.Ord PhonemeData.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Length
                  PhonemeData.$fEqLength
                  PhonemeData.$fOrdLength_$ccompare
                  PhonemeData.$fOrdLength_$c<
                  PhonemeData.$fOrdLength_$c<=
                  PhonemeData.$fOrdLength_$c>
                  PhonemeData.$fOrdLength_$c>=
                  PhonemeData.$fOrdLength_$cmax
                  PhonemeData.$fOrdLength_$cmin -}
414a8b878bf71816d2002a26fce00728
  $fOrdLength_$c< ::
    PhonemeData.Length -> PhonemeData.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Length b :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT
                   -> case b of wild1 {
                        PhonemeData.SHORT -> GHC.Types.False
                        PhonemeData.NORMAL -> GHC.Types.True
                        PhonemeData.LONG -> GHC.Types.True }
                   PhonemeData.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeData.LONG -> GHC.Types.True }
                   PhonemeData.LONG
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
414a8b878bf71816d2002a26fce00728
  $fOrdLength_$c<= ::
    PhonemeData.Length -> PhonemeData.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Length b :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeData.NORMAL
                   -> case b of wild1 {
                        PhonemeData.SHORT -> GHC.Types.False
                        PhonemeData.NORMAL -> GHC.Types.True
                        PhonemeData.LONG -> GHC.Types.True }
                   PhonemeData.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.LONG -> GHC.Types.True } }) -}
414a8b878bf71816d2002a26fce00728
  $fOrdLength_$c> ::
    PhonemeData.Length -> PhonemeData.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Length b :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeData.NORMAL
                   -> case b of wild1 {
                        PhonemeData.SHORT -> GHC.Types.True
                        PhonemeData.NORMAL -> GHC.Types.False
                        PhonemeData.LONG -> GHC.Types.False }
                   PhonemeData.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.LONG -> GHC.Types.False } }) -}
414a8b878bf71816d2002a26fce00728
  $fOrdLength_$c>= ::
    PhonemeData.Length -> PhonemeData.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Length b :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT
                   -> case b of wild1 {
                        PhonemeData.SHORT -> GHC.Types.True
                        PhonemeData.NORMAL -> GHC.Types.False
                        PhonemeData.LONG -> GHC.Types.False }
                   PhonemeData.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeData.LONG -> GHC.Types.False }
                   PhonemeData.LONG
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
414a8b878bf71816d2002a26fce00728
  $fOrdLength_$ccompare ::
    PhonemeData.Length -> PhonemeData.Length -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Length b :: PhonemeData.Length ->
                 case a8 of wild {
                   PhonemeData.SHORT
                   -> case b of wild1 {
                        PhonemeData.SHORT -> GHC.Types.EQ
                        PhonemeData.NORMAL -> GHC.Types.LT
                        PhonemeData.LONG -> GHC.Types.LT }
                   PhonemeData.NORMAL
                   -> case b of wild1 {
                        PhonemeData.SHORT -> GHC.Types.GT
                        PhonemeData.NORMAL -> GHC.Types.EQ
                        PhonemeData.LONG -> GHC.Types.LT }
                   PhonemeData.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeData.LONG -> GHC.Types.EQ } }) -}
414a8b878bf71816d2002a26fce00728
  $fOrdLength_$cmax ::
    PhonemeData.Length -> PhonemeData.Length -> PhonemeData.Length
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Length y :: PhonemeData.Length ->
                 case x of wild {
                   PhonemeData.SHORT -> y
                   PhonemeData.NORMAL
                   -> case y of wild1 {
                        DEFAULT -> PhonemeData.NORMAL
                        PhonemeData.LONG -> PhonemeData.LONG }
                   PhonemeData.LONG
                   -> case y of wild1 { DEFAULT -> PhonemeData.LONG } }) -}
414a8b878bf71816d2002a26fce00728
  $fOrdLength_$cmin ::
    PhonemeData.Length -> PhonemeData.Length -> PhonemeData.Length
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Length y :: PhonemeData.Length ->
                 case x of wild {
                   PhonemeData.SHORT
                   -> case y of wild1 { DEFAULT -> PhonemeData.SHORT }
                   PhonemeData.NORMAL
                   -> case y of wild1 {
                        PhonemeData.SHORT -> PhonemeData.SHORT
                        PhonemeData.NORMAL -> PhonemeData.NORMAL
                        PhonemeData.LONG -> PhonemeData.NORMAL }
                   PhonemeData.LONG -> y }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fOrdManner :: GHC.Classes.Ord PhonemeData.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Manner
                  PhonemeData.$fEqManner
                  PhonemeData.$fOrdManner_$ccompare
                  PhonemeData.$fOrdManner_$c<
                  PhonemeData.$fOrdManner_$c<=
                  PhonemeData.$fOrdManner_$c>
                  PhonemeData.$fOrdManner_$c>=
                  PhonemeData.$fOrdManner_$cmax
                  PhonemeData.$fOrdManner_$cmin -}
2286baa806cedbe4b7d0c4916ea37630
  $fOrdManner_$c< ::
    PhonemeData.Manner -> PhonemeData.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Manner b :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x2)) } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fOrdManner_$c<= ::
    PhonemeData.Manner -> PhonemeData.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Manner b :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x2)) } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fOrdManner_$c> ::
    PhonemeData.Manner -> PhonemeData.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Manner b :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x2)) } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fOrdManner_$c>= ::
    PhonemeData.Manner -> PhonemeData.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Manner b :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Manner x2)) } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fOrdManner_$ccompare ::
    PhonemeData.Manner -> PhonemeData.Manner -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Manner b :: PhonemeData.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fOrdManner_$cmax ::
    PhonemeData.Manner -> PhonemeData.Manner -> PhonemeData.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Manner y :: PhonemeData.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeData.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeData.Manner x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $fOrdManner_$cmin ::
    PhonemeData.Manner -> PhonemeData.Manner -> PhonemeData.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Manner y :: PhonemeData.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeData.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeData.Manner x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
a75f0140e4b212df166951d7f735baaf
  $fOrdMorpheme :: GHC.Classes.Ord PhonemeData.Morpheme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Morpheme
                  PhonemeData.$fEqMorpheme
                  PhonemeData.$fOrdMorpheme_$ccompare
                  PhonemeData.$fOrdMorpheme_$c<
                  PhonemeData.$fOrdMorpheme_$c<=
                  PhonemeData.$fOrdMorpheme_$c>
                  PhonemeData.$fOrdMorpheme_$c>=
                  PhonemeData.$fOrdMorpheme_$cmax
                  PhonemeData.$fOrdMorpheme_$cmin -}
a75f0140e4b212df166951d7f735baaf
  $fOrdMorpheme_$c< ::
    PhonemeData.Morpheme -> PhonemeData.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Morpheme b :: PhonemeData.Morpheme ->
                 case a8 of wild { PhonemeData.Morpheme a9 ->
                 case b of wild1 { PhonemeData.Morpheme b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Phoneme
                        PhonemeData.$fOrdPhoneme
                        a9
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True } } }) -}
a75f0140e4b212df166951d7f735baaf
  $fOrdMorpheme_$c<= ::
    PhonemeData.Morpheme -> PhonemeData.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Morpheme b :: PhonemeData.Morpheme ->
                 case a8 of wild { PhonemeData.Morpheme a9 ->
                 case b of wild1 { PhonemeData.Morpheme b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Phoneme
                        PhonemeData.$fOrdPhoneme
                        a9
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } } }) -}
a75f0140e4b212df166951d7f735baaf
  $fOrdMorpheme_$c> ::
    PhonemeData.Morpheme -> PhonemeData.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Morpheme b :: PhonemeData.Morpheme ->
                 case a8 of wild { PhonemeData.Morpheme a9 ->
                 case b of wild1 { PhonemeData.Morpheme b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Phoneme
                        PhonemeData.$fOrdPhoneme
                        a9
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } } }) -}
a75f0140e4b212df166951d7f735baaf
  $fOrdMorpheme_$c>= ::
    PhonemeData.Morpheme -> PhonemeData.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Morpheme b :: PhonemeData.Morpheme ->
                 case a8 of wild { PhonemeData.Morpheme a9 ->
                 case b of wild1 { PhonemeData.Morpheme b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Phoneme
                        PhonemeData.$fOrdPhoneme
                        a9
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
a75f0140e4b212df166951d7f735baaf
  $fOrdMorpheme_$ccompare ::
    PhonemeData.Morpheme -> PhonemeData.Morpheme -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Morpheme b :: PhonemeData.Morpheme ->
                 case a8 of wild { PhonemeData.Morpheme a9 ->
                 case b of wild1 { PhonemeData.Morpheme b1 ->
                 GHC.Classes.$w$ccompare14
                   @ PhonemeData.Phoneme
                   PhonemeData.$fOrdPhoneme
                   a9
                   b1 } }) -}
a75f0140e4b212df166951d7f735baaf
  $fOrdMorpheme_$cmax ::
    PhonemeData.Morpheme
    -> PhonemeData.Morpheme -> PhonemeData.Morpheme
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Morpheme y :: PhonemeData.Morpheme ->
                 case x of wild { PhonemeData.Morpheme a8 ->
                 case y of wild1 { PhonemeData.Morpheme b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Phoneme
                        PhonemeData.$fOrdPhoneme
                        a8
                        b1 of wild2 {
                   DEFAULT -> wild1 GHC.Types.GT -> wild } } }) -}
a75f0140e4b212df166951d7f735baaf
  $fOrdMorpheme_$cmin ::
    PhonemeData.Morpheme
    -> PhonemeData.Morpheme -> PhonemeData.Morpheme
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Morpheme y :: PhonemeData.Morpheme ->
                 case x of wild { PhonemeData.Morpheme a8 ->
                 case y of wild1 { PhonemeData.Morpheme b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Phoneme
                        PhonemeData.$fOrdPhoneme
                        a8
                        b1 of wild2 {
                   DEFAULT -> wild GHC.Types.GT -> wild1 } } }) -}
d728b957933ed40e5f338884385b44c8
  $fOrdPhonation :: GHC.Classes.Ord PhonemeData.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phonation
                  PhonemeData.$fEqPhonation
                  PhonemeData.$fOrdPhonation_$ccompare
                  PhonemeData.$fOrdPhonation_$c<
                  PhonemeData.$fOrdPhonation_$c<=
                  PhonemeData.$fOrdPhonation_$c>
                  PhonemeData.$fOrdPhonation_$c>=
                  PhonemeData.$fOrdPhonation_$cmax
                  PhonemeData.$fOrdPhonation_$cmin -}
d728b957933ed40e5f338884385b44c8
  $fOrdPhonation_$c< ::
    PhonemeData.Phonation -> PhonemeData.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Phonation
                   b :: PhonemeData.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeData.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0)
                       PhonemeData.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1)
                       PhonemeData.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2)
                       PhonemeData.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3)
                       PhonemeData.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4)
                       PhonemeData.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5)
                       PhonemeData.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeData.VOICELESS -> $j 0
                   PhonemeData.BREATHY -> $j 1
                   PhonemeData.SLACK -> $j 2
                   PhonemeData.MODAL -> $j 3
                   PhonemeData.STIFF -> $j 4
                   PhonemeData.CREAKY -> $j 5
                   PhonemeData.ASPIRATED -> $j 6 }) -}
d728b957933ed40e5f338884385b44c8
  $fOrdPhonation_$c<= ::
    PhonemeData.Phonation -> PhonemeData.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Phonation
                   b :: PhonemeData.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeData.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0)
                       PhonemeData.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1)
                       PhonemeData.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2)
                       PhonemeData.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3)
                       PhonemeData.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4)
                       PhonemeData.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5)
                       PhonemeData.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeData.VOICELESS -> $j 0
                   PhonemeData.BREATHY -> $j 1
                   PhonemeData.SLACK -> $j 2
                   PhonemeData.MODAL -> $j 3
                   PhonemeData.STIFF -> $j 4
                   PhonemeData.CREAKY -> $j 5
                   PhonemeData.ASPIRATED -> $j 6 }) -}
d728b957933ed40e5f338884385b44c8
  $fOrdPhonation_$c> ::
    PhonemeData.Phonation -> PhonemeData.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Phonation
                   b :: PhonemeData.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeData.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0)
                       PhonemeData.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1)
                       PhonemeData.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2)
                       PhonemeData.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3)
                       PhonemeData.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4)
                       PhonemeData.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5)
                       PhonemeData.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeData.VOICELESS -> $j 0
                   PhonemeData.BREATHY -> $j 1
                   PhonemeData.SLACK -> $j 2
                   PhonemeData.MODAL -> $j 3
                   PhonemeData.STIFF -> $j 4
                   PhonemeData.CREAKY -> $j 5
                   PhonemeData.ASPIRATED -> $j 6 }) -}
d728b957933ed40e5f338884385b44c8
  $fOrdPhonation_$c>= ::
    PhonemeData.Phonation -> PhonemeData.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Phonation
                   b :: PhonemeData.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeData.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0)
                       PhonemeData.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1)
                       PhonemeData.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2)
                       PhonemeData.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3)
                       PhonemeData.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4)
                       PhonemeData.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5)
                       PhonemeData.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeData.VOICELESS -> $j 0
                   PhonemeData.BREATHY -> $j 1
                   PhonemeData.SLACK -> $j 2
                   PhonemeData.MODAL -> $j 3
                   PhonemeData.STIFF -> $j 4
                   PhonemeData.CREAKY -> $j 5
                   PhonemeData.ASPIRATED -> $j 6 }) -}
d728b957933ed40e5f338884385b44c8
  $fOrdPhonation_$ccompare ::
    PhonemeData.Phonation
    -> PhonemeData.Phonation -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Phonation
                   b :: PhonemeData.Phonation ->
                 case a8 of wild {
                   PhonemeData.VOICELESS
                   -> case b of wild1 {
                        PhonemeData.VOICELESS -> GHC.Types.EQ
                        PhonemeData.BREATHY -> GHC.Types.LT
                        PhonemeData.SLACK -> GHC.Types.LT
                        PhonemeData.MODAL -> GHC.Types.LT
                        PhonemeData.STIFF -> GHC.Types.LT
                        PhonemeData.CREAKY -> GHC.Types.LT
                        PhonemeData.ASPIRATED -> GHC.Types.LT }
                   PhonemeData.BREATHY
                   -> case b of wild1 {
                        PhonemeData.VOICELESS -> GHC.Types.GT
                        PhonemeData.BREATHY -> GHC.Types.EQ
                        PhonemeData.SLACK -> GHC.Types.LT
                        PhonemeData.MODAL -> GHC.Types.LT
                        PhonemeData.STIFF -> GHC.Types.LT
                        PhonemeData.CREAKY -> GHC.Types.LT
                        PhonemeData.ASPIRATED -> GHC.Types.LT }
                   PhonemeData.SLACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.SLACK -> GHC.Types.EQ
                        PhonemeData.MODAL -> GHC.Types.LT
                        PhonemeData.STIFF -> GHC.Types.LT
                        PhonemeData.CREAKY -> GHC.Types.LT
                        PhonemeData.ASPIRATED -> GHC.Types.LT }
                   PhonemeData.MODAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.MODAL -> GHC.Types.EQ
                        PhonemeData.STIFF -> GHC.Types.LT
                        PhonemeData.CREAKY -> GHC.Types.LT
                        PhonemeData.ASPIRATED -> GHC.Types.LT }
                   PhonemeData.STIFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.STIFF -> GHC.Types.EQ
                        PhonemeData.CREAKY -> GHC.Types.LT
                        PhonemeData.ASPIRATED -> GHC.Types.LT }
                   PhonemeData.CREAKY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.CREAKY -> GHC.Types.EQ
                        PhonemeData.ASPIRATED -> GHC.Types.LT }
                   PhonemeData.ASPIRATED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.ASPIRATED -> GHC.Types.EQ } }) -}
d728b957933ed40e5f338884385b44c8
  $fOrdPhonation_$cmax ::
    PhonemeData.Phonation
    -> PhonemeData.Phonation -> PhonemeData.Phonation
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Phonation y :: PhonemeData.Phonation ->
                 case PhonemeData.$fOrdPhonation_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
d728b957933ed40e5f338884385b44c8
  $fOrdPhonation_$cmin ::
    PhonemeData.Phonation
    -> PhonemeData.Phonation -> PhonemeData.Phonation
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Phonation y :: PhonemeData.Phonation ->
                 case PhonemeData.$fOrdPhonation_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
725a483aa2dd4b7c0473c29cf990b878
  $fOrdPhoneme :: GHC.Classes.Ord PhonemeData.Phoneme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phoneme
                  PhonemeData.$fEqPhoneme
                  PhonemeData.$fOrdPhoneme_$ccompare
                  PhonemeData.$fOrdPhoneme_$c<
                  PhonemeData.$fOrdPhoneme_$c<=
                  PhonemeData.$fOrdPhoneme_$c>
                  PhonemeData.$fOrdPhoneme_$c>=
                  PhonemeData.$fOrdPhoneme_$cmax
                  PhonemeData.$fOrdPhoneme_$cmin -}
725a483aa2dd4b7c0473c29cf990b878
  $fOrdPhoneme_$c< ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Phoneme y :: PhonemeData.Phoneme ->
                 case PhonemeData.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
725a483aa2dd4b7c0473c29cf990b878
  $fOrdPhoneme_$c<= ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Phoneme y :: PhonemeData.Phoneme ->
                 case PhonemeData.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
725a483aa2dd4b7c0473c29cf990b878
  $fOrdPhoneme_$c> ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Phoneme y :: PhonemeData.Phoneme ->
                 case PhonemeData.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
725a483aa2dd4b7c0473c29cf990b878
  $fOrdPhoneme_$c>= ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Phoneme y :: PhonemeData.Phoneme ->
                 case PhonemeData.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
725a483aa2dd4b7c0473c29cf990b878
  $fOrdPhoneme_$ccompare ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
725a483aa2dd4b7c0473c29cf990b878
  $fOrdPhoneme_$cmax ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> PhonemeData.Phoneme
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Phoneme y :: PhonemeData.Phoneme ->
                 case PhonemeData.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
725a483aa2dd4b7c0473c29cf990b878
  $fOrdPhoneme_$cmin ::
    PhonemeData.Phoneme -> PhonemeData.Phoneme -> PhonemeData.Phoneme
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Phoneme y :: PhonemeData.Phoneme ->
                 case PhonemeData.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
e0644167ea1572fa835311f673311319
  $fOrdPlace :: GHC.Classes.Ord PhonemeData.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Place
                  PhonemeData.$fEqPlace
                  PhonemeData.$fOrdPlace_$ccompare
                  PhonemeData.$fOrdPlace_$c<
                  PhonemeData.$fOrdPlace_$c<=
                  PhonemeData.$fOrdPlace_$c>
                  PhonemeData.$fOrdPlace_$c>=
                  PhonemeData.$fOrdPlace_$cmax
                  PhonemeData.$fOrdPlace_$cmin -}
e0644167ea1572fa835311f673311319
  $fOrdPlace_$c< ::
    PhonemeData.Place -> PhonemeData.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Place b :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x2)) } }) -}
e0644167ea1572fa835311f673311319
  $fOrdPlace_$c<= ::
    PhonemeData.Place -> PhonemeData.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Place b :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x2)) } }) -}
e0644167ea1572fa835311f673311319
  $fOrdPlace_$c> ::
    PhonemeData.Place -> PhonemeData.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Place b :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x2)) } }) -}
e0644167ea1572fa835311f673311319
  $fOrdPlace_$c>= ::
    PhonemeData.Place -> PhonemeData.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Place b :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeData.Place x2)) } }) -}
e0644167ea1572fa835311f673311319
  $fOrdPlace_$ccompare ::
    PhonemeData.Place -> PhonemeData.Place -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Place b :: PhonemeData.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeData.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
e0644167ea1572fa835311f673311319
  $fOrdPlace_$cmax ::
    PhonemeData.Place -> PhonemeData.Place -> PhonemeData.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Place y :: PhonemeData.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeData.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeData.Place x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
e0644167ea1572fa835311f673311319
  $fOrdPlace_$cmin ::
    PhonemeData.Place -> PhonemeData.Place -> PhonemeData.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Place y :: PhonemeData.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeData.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeData.Place x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fOrdRoundedness :: GHC.Classes.Ord PhonemeData.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Roundedness
                  PhonemeData.$fEqRoundedness
                  PhonemeData.$fOrdRoundedness_$ccompare
                  PhonemeData.$fOrdRoundedness_$c<
                  PhonemeData.$fOrdRoundedness_$c<=
                  PhonemeData.$fOrdRoundedness_$c>
                  PhonemeData.$fOrdRoundedness_$c>=
                  PhonemeData.$fOrdRoundedness_$cmax
                  PhonemeData.$fOrdRoundedness_$cmin -}
4c51106b8aab206d34cb6b9d104e8504
  $fOrdRoundedness_$c< ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Roundedness b :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT
                   -> case b of wild1 {
                        PhonemeData.DEFAULT -> GHC.Types.False
                        PhonemeData.ROUNDED -> GHC.Types.True
                        PhonemeData.UNROUNDED -> GHC.Types.True }
                   PhonemeData.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.UNROUNDED -> GHC.Types.True }
                   PhonemeData.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fOrdRoundedness_$c<= ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Roundedness b :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT
                   -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeData.ROUNDED
                   -> case b of wild1 {
                        PhonemeData.DEFAULT -> GHC.Types.False
                        PhonemeData.ROUNDED -> GHC.Types.True
                        PhonemeData.UNROUNDED -> GHC.Types.True }
                   PhonemeData.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeData.UNROUNDED -> GHC.Types.True } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fOrdRoundedness_$c> ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Roundedness b :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeData.ROUNDED
                   -> case b of wild1 {
                        PhonemeData.DEFAULT -> GHC.Types.True
                        PhonemeData.ROUNDED -> GHC.Types.False
                        PhonemeData.UNROUNDED -> GHC.Types.False }
                   PhonemeData.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.UNROUNDED -> GHC.Types.False } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fOrdRoundedness_$c>= ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Roundedness b :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT
                   -> case b of wild1 {
                        PhonemeData.DEFAULT -> GHC.Types.True
                        PhonemeData.ROUNDED -> GHC.Types.False
                        PhonemeData.UNROUNDED -> GHC.Types.False }
                   PhonemeData.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeData.UNROUNDED -> GHC.Types.False }
                   PhonemeData.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fOrdRoundedness_$ccompare ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeData.Roundedness
                   b :: PhonemeData.Roundedness ->
                 case a8 of wild {
                   PhonemeData.DEFAULT
                   -> case b of wild1 {
                        PhonemeData.DEFAULT -> GHC.Types.EQ
                        PhonemeData.ROUNDED -> GHC.Types.LT
                        PhonemeData.UNROUNDED -> GHC.Types.LT }
                   PhonemeData.ROUNDED
                   -> case b of wild1 {
                        PhonemeData.DEFAULT -> GHC.Types.GT
                        PhonemeData.ROUNDED -> GHC.Types.EQ
                        PhonemeData.UNROUNDED -> GHC.Types.LT }
                   PhonemeData.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeData.UNROUNDED -> GHC.Types.EQ } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fOrdRoundedness_$cmax ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> PhonemeData.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Roundedness y :: PhonemeData.Roundedness ->
                 case x of wild {
                   PhonemeData.DEFAULT -> y
                   PhonemeData.ROUNDED
                   -> case y of wild1 {
                        DEFAULT -> PhonemeData.ROUNDED
                        PhonemeData.UNROUNDED -> PhonemeData.UNROUNDED }
                   PhonemeData.UNROUNDED
                   -> case y of wild1 { DEFAULT -> PhonemeData.UNROUNDED } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fOrdRoundedness_$cmin ::
    PhonemeData.Roundedness
    -> PhonemeData.Roundedness -> PhonemeData.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Roundedness y :: PhonemeData.Roundedness ->
                 case x of wild {
                   PhonemeData.DEFAULT
                   -> case y of wild1 { DEFAULT -> PhonemeData.DEFAULT }
                   PhonemeData.ROUNDED
                   -> case y of wild1 {
                        PhonemeData.DEFAULT -> PhonemeData.DEFAULT
                        PhonemeData.ROUNDED -> PhonemeData.ROUNDED
                        PhonemeData.UNROUNDED -> PhonemeData.ROUNDED }
                   PhonemeData.UNROUNDED -> y }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fOrdWord :: GHC.Classes.Ord PhonemeData.Word
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Word
                  PhonemeData.$fEqWord
                  PhonemeData.$fOrdWord_$ccompare
                  PhonemeData.$fOrdWord_$c<
                  PhonemeData.$fOrdWord_$c<=
                  PhonemeData.$fOrdWord_$c>
                  PhonemeData.$fOrdWord_$c>=
                  PhonemeData.$fOrdWord_$cmax
                  PhonemeData.$fOrdWord_$cmin -}
55b6ea537d860cf92b62e64e19ceba7b
  $fOrdWord_$c< ::
    PhonemeData.Word -> PhonemeData.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Word b :: PhonemeData.Word ->
                 case a8 of wild { PhonemeData.Word a9 ->
                 case b of wild1 { PhonemeData.Word b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Morpheme
                        PhonemeData.$fOrdMorpheme
                        a9
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True } } }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fOrdWord_$c<= ::
    PhonemeData.Word -> PhonemeData.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Word b :: PhonemeData.Word ->
                 case a8 of wild { PhonemeData.Word a9 ->
                 case b of wild1 { PhonemeData.Word b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Morpheme
                        PhonemeData.$fOrdMorpheme
                        a9
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } } }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fOrdWord_$c> ::
    PhonemeData.Word -> PhonemeData.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Word b :: PhonemeData.Word ->
                 case a8 of wild { PhonemeData.Word a9 ->
                 case b of wild1 { PhonemeData.Word b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Morpheme
                        PhonemeData.$fOrdMorpheme
                        a9
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } } }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fOrdWord_$c>= ::
    PhonemeData.Word -> PhonemeData.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Word b :: PhonemeData.Word ->
                 case a8 of wild { PhonemeData.Word a9 ->
                 case b of wild1 { PhonemeData.Word b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Morpheme
                        PhonemeData.$fOrdMorpheme
                        a9
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fOrdWord_$ccompare ::
    PhonemeData.Word -> PhonemeData.Word -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeData.Word b :: PhonemeData.Word ->
                 case a8 of wild { PhonemeData.Word a9 ->
                 case b of wild1 { PhonemeData.Word b1 ->
                 GHC.Classes.$w$ccompare14
                   @ PhonemeData.Morpheme
                   PhonemeData.$fOrdMorpheme
                   a9
                   b1 } }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fOrdWord_$cmax ::
    PhonemeData.Word -> PhonemeData.Word -> PhonemeData.Word
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Word y :: PhonemeData.Word ->
                 case x of wild { PhonemeData.Word a8 ->
                 case y of wild1 { PhonemeData.Word b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Morpheme
                        PhonemeData.$fOrdMorpheme
                        a8
                        b1 of wild2 {
                   DEFAULT -> wild1 GHC.Types.GT -> wild } } }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fOrdWord_$cmin ::
    PhonemeData.Word -> PhonemeData.Word -> PhonemeData.Word
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeData.Word y :: PhonemeData.Word ->
                 case x of wild { PhonemeData.Word a8 ->
                 case y of wild1 { PhonemeData.Word b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeData.Morpheme
                        PhonemeData.$fOrdMorpheme
                        a8
                        b1 of wild2 {
                   DEFAULT -> wild GHC.Types.GT -> wild1 } } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness :: GHC.Read.Read PhonemeData.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Backness
                  PhonemeData.$fReadBackness_$s$dmreadsPrec
                  PhonemeData.$fReadBackness_$sreadListDefault
                  PhonemeData.$fReadBackness_$creadPrec
                  PhonemeData.$fReadBackness_$creadListPrec -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Backness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Backness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Backness
                   PhonemeData.$fReadBackness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Backness>_R))
                   @ b
                   eta1) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.FRONT) -}
25e7572548896dd3771216010bf582ee
  $fReadBackness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRONT"#) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadBackness14,
                  PhonemeData.$fReadBackness13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Backness>_R))))) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.NEARFRONT) -}
c05e8335ad7467d011b233f43bab052e
  $fReadBackness14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARFRONT"#) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadBackness17,
                  PhonemeData.$fReadBackness16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Backness>_R))))) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.CENTRAL) -}
cc98323a8090bfaedb123b90721cd8c4
  $fReadBackness17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CENTRAL"#) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadBackness20,
                  PhonemeData.$fReadBackness19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Backness>_R))))) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.NEARBACK) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Backness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Backness
                   PhonemeData.$fReadBackness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Backness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Backness>_R)))) -}
cd49b259243fc70fc9b87276c51b1a75
  $fReadBackness20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARBACK"#) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadBackness23,
                  PhonemeData.$fReadBackness22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Backness>_R))))) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.BACK) -}
7915a7e59abe586369a8c86af0afb06a
  $fReadBackness23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACK"#) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeData.Backness -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeData.Backness
                   PhonemeData.$fReadBackness4
                   eta
                   @ b
                   eta1) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
                   PhonemeData.$fReadBackness21
                   PhonemeData.$fReadBackness5) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
                   PhonemeData.$fReadBackness18
                   PhonemeData.$fReadBackness6) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
                   PhonemeData.$fReadBackness15
                   PhonemeData.$fReadBackness7) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
                   PhonemeData.$fReadBackness12
                   PhonemeData.$fReadBackness8) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
                   PhonemeData.$fReadBackness9
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness))) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadBackness11,
                  PhonemeData.$fReadBackness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Backness>_R))))) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Backness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadBackness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Backness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Backness]>_R))) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Backness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadBackness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Backness>_R)) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Backness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeData.Backness
                   PhonemeData.$fReadBackness_$creadPrec
                   eta) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fReadBackness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Backness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Backness]
                   ((PhonemeData.$fReadBackness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Backness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Backness]>_R)
                      @ [PhonemeData.Backness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Backness]))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight :: GHC.Read.Read PhonemeData.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Height
                  PhonemeData.$fReadHeight_$s$dmreadsPrec
                  PhonemeData.$fReadHeight_$sreadListDefault
                  PhonemeData.$fReadHeight_$creadPrec
                  PhonemeData.$fReadHeight_$creadListPrec -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Height] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Height] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Height
                   PhonemeData.$fReadHeight2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Height>_R))
                   @ b
                   eta1) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
                   PhonemeData.$fReadHeight11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadHeight13,
                  PhonemeData.$fReadHeight12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Height>_R))))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.OPEN) -}
71623d67ee0038a3465b657dc679e5db
  $fReadHeight13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPEN"#) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadHeight16,
                  PhonemeData.$fReadHeight15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Height>_R))))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.NEAROPEN) -}
90e6b50803836edb1109804272cd6a94
  $fReadHeight16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEAROPEN"#) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadHeight19,
                  PhonemeData.$fReadHeight18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Height>_R))))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.OPENMID) -}
3792e0e0981c2607ab66ac690232ee32
  $fReadHeight19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPENMID"#) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Height
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Height
                   PhonemeData.$fReadHeight3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Height>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Height>_R)))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadHeight22,
                  PhonemeData.$fReadHeight21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Height>_R))))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.MID) -}
fd2e33c78474eea8dff4fa71b4fc57a7
  $fReadHeight22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MID"#) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadHeight25,
                  PhonemeData.$fReadHeight24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Height>_R))))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.CLOSEMID) -}
b9bb03afaf4d0a953f2058c57f358ff3
  $fReadHeight25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSEMID"#) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadHeight28,
                  PhonemeData.$fReadHeight27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Height>_R))))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.NEARCLOSE) -}
b830bcb4cf5a27b63a7116bc152fac42
  $fReadHeight28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARCLOSE"#) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadHeight31,
                  PhonemeData.$fReadHeight30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Height>_R))))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeData.Height -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeData.Height
                   PhonemeData.$fReadHeight4
                   eta
                   @ b
                   eta1) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.CLOSE) -}
848052172fd03719328db7a8f17c5883
  $fReadHeight31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSE"#) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
                   PhonemeData.$fReadHeight29
                   PhonemeData.$fReadHeight5) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
                   PhonemeData.$fReadHeight26
                   PhonemeData.$fReadHeight6) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
                   PhonemeData.$fReadHeight23
                   PhonemeData.$fReadHeight7) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
                   PhonemeData.$fReadHeight20
                   PhonemeData.$fReadHeight8) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
                   PhonemeData.$fReadHeight17
                   PhonemeData.$fReadHeight9) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height)
                   PhonemeData.$fReadHeight14
                   PhonemeData.$fReadHeight10) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Height]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadHeight1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Height]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Height]>_R))) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Height
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadHeight2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Height>_R)) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Height
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeData.Height
                   PhonemeData.$fReadHeight_$creadPrec
                   eta) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fReadHeight_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Height]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Height]
                   ((PhonemeData.$fReadHeight_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Height]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Height]>_R)
                      @ [PhonemeData.Height]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Height]))) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength :: GHC.Read.Read PhonemeData.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Length
                  PhonemeData.$fReadLength_$s$dmreadsPrec
                  PhonemeData.$fReadLength_$sreadListDefault
                  PhonemeData.$fReadLength_$creadPrec
                  PhonemeData.$fReadLength_$creadListPrec -}
414a8b878bf71816d2002a26fce00728
  $fReadLength1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Length] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Length] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Length
                   PhonemeData.$fReadLength2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Length>_R))
                   @ b
                   eta1) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadLength12,
                  PhonemeData.$fReadLength11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Length>_R))))) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.NORMAL) -}
98c055e3b510f0d830e3655737780851
  $fReadLength12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NORMAL"#) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadLength15,
                  PhonemeData.$fReadLength14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Length>_R))))) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.SHORT) -}
ce190a3ac1680e6815394f07790b4559
  $fReadLength15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SHORT"#) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Length
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Length
                   PhonemeData.$fReadLength3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Length>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Length>_R)))) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeData.Length -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeData.Length
                   PhonemeData.$fReadLength4
                   eta
                   @ b
                   eta1) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)
                   PhonemeData.$fReadLength13
                   PhonemeData.$fReadLength5) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)
                   PhonemeData.$fReadLength10
                   PhonemeData.$fReadLength6) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)
                   PhonemeData.$fReadLength7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length))) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadLength9,
                  PhonemeData.$fReadLength8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Length>_R))))) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.LONG) -}
dbdd27eb7541cf8988a9328aa90945b6
  $fReadLength9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LONG"#) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Length]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadLength1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Length]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Length]>_R))) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Length
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadLength2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Length>_R)) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Length
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeData.Length
                   PhonemeData.$fReadLength_$creadPrec
                   eta) -}
414a8b878bf71816d2002a26fce00728
  $fReadLength_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Length]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Length]
                   ((PhonemeData.$fReadLength_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Length]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Length]>_R)
                      @ [PhonemeData.Length]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Length]))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner :: GHC.Read.Read PhonemeData.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Manner
                  PhonemeData.$fReadManner_$s$dmreadsPrec
                  PhonemeData.$fReadManner_$sreadListDefault
                  PhonemeData.$fReadManner_$creadPrec
                  PhonemeData.$fReadManner_$creadListPrec -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Manner] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Manner] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Manner
                   PhonemeData.$fReadManner2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Manner>_R))
                   @ b
                   eta1) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner35
                   PhonemeData.$fReadManner11) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner32
                   PhonemeData.$fReadManner12) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner29
                   PhonemeData.$fReadManner13) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner26
                   PhonemeData.$fReadManner14) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner23
                   PhonemeData.$fReadManner15) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner20
                   PhonemeData.$fReadManner16) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner17
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner19,
                  PhonemeData.$fReadManner18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.LFLAP) -}
c027c7a59f528a6e564c9312c123092c
  $fReadManner19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFLAP"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Manner
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Manner
                   PhonemeData.$fReadManner3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Manner>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Manner>_R)))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner22,
                  PhonemeData.$fReadManner21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.LAPPROXIMANT) -}
c9ced0d6e25fb176bc7d480fd630c2d9
  $fReadManner22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAPPROXIMANT"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner25,
                  PhonemeData.$fReadManner24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.LFRICATIVE) -}
b14df3e63c47d186775d617f47056f81
  $fReadManner25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFRICATIVE"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner28,
                  PhonemeData.$fReadManner27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.LAFFRICATE) -}
42f887ce7059e83e66497027b16dd221
  $fReadManner28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAFFRICATE"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner31,
                  PhonemeData.$fReadManner30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeData.Manner
                   PhonemeData.$fReadManner4
                   eta
                   @ b
                   eta1) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.TRILL) -}
bee029d4b9495f930a68977245f60935
  $fReadManner31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRILL"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner34,
                  PhonemeData.$fReadManner33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.FLAP) -}
c425c6f8c560fb42a88caeb07e054976
  $fReadManner34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FLAP"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner37,
                  PhonemeData.$fReadManner36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.APPROXIMANT) -}
c86e09ef2ba19c3868ec64d7d8c22dd5
  $fReadManner37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "APPROXIMANT"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner40,
                  PhonemeData.$fReadManner39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.FRICATIVE) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner53
                   PhonemeData.$fReadManner5) -}
15e58000530e80a0b080e5e8070c942e
  $fReadManner40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRICATIVE"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner43,
                  PhonemeData.$fReadManner42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.SILIBANT) -}
94e719bd71fc1e4e3f4a987c6dc6f9c8
  $fReadManner43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SILIBANT"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner44 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner46,
                  PhonemeData.$fReadManner45
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.AFFRICATE) -}
ad91f0990b969b55074871aa311b4da8
  $fReadManner46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFFRICATE"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner47 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner49,
                  PhonemeData.$fReadManner48
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner48 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.SAFFRICATE) -}
5a925044b548e919290c642705f0a2cd
  $fReadManner49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SAFFRICATE"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner50
                   PhonemeData.$fReadManner6) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner50 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner52,
                  PhonemeData.$fReadManner51
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner51 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.STOP) -}
b8e9e1a5fa0f8649e0cc5b1ada80e699
  $fReadManner52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STOP"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadManner55,
                  PhonemeData.$fReadManner54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Manner>_R))))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.NASAL) -}
3cb424df51ee4b068e623820b2c076b8
  $fReadManner55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NASAL"#) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner47
                   PhonemeData.$fReadManner7) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner44
                   PhonemeData.$fReadManner8) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner41
                   PhonemeData.$fReadManner9) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner)
                   PhonemeData.$fReadManner38
                   PhonemeData.$fReadManner10) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Manner]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadManner1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Manner]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Manner]>_R))) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Manner
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadManner2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Manner>_R)) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Manner
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeData.Manner
                   PhonemeData.$fReadManner_$creadPrec
                   eta) -}
2286baa806cedbe4b7d0c4916ea37630
  $fReadManner_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Manner]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Manner]
                   ((PhonemeData.$fReadManner_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Manner]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Manner]>_R)
                      @ [PhonemeData.Manner]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Manner]))) -}
a75f0140e4b212df166951d7f735baaf
  $fReadMorpheme :: GHC.Read.Read PhonemeData.Morpheme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Morpheme
                  PhonemeData.$fReadMorpheme_$creadsPrec
                  PhonemeData.$fReadMorpheme_$sreadListDefault
                  PhonemeData.$fReadMorpheme_$creadPrec
                  PhonemeData.$fReadMorpheme_$creadListPrec -}
a75f0140e4b212df166951d7f735baaf
  $fReadMorpheme1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Morpheme] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Morpheme]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Morpheme
                   PhonemeData.$fReadMorpheme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Morpheme>_R))
                   @ b
                   eta1) -}
a75f0140e4b212df166951d7f735baaf
  $fReadMorpheme2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Morpheme
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Morpheme
                   PhonemeData.$fReadMorpheme3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Morpheme>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Morpheme>_R)))) -}
a75f0140e4b212df166951d7f735baaf
  $fReadMorpheme3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Morpheme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeData.Morpheme -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 -> PhonemeData.$wa ww1 @ b w1 }) -}
a75f0140e4b212df166951d7f735baaf
  $fReadMorpheme_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Morpheme]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadMorpheme1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Morpheme]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Morpheme]>_R))) -}
a75f0140e4b212df166951d7f735baaf
  $fReadMorpheme_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Morpheme
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadMorpheme2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Morpheme>_R)) -}
a75f0140e4b212df166951d7f735baaf
  $fReadMorpheme_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Morpheme
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeData.Morpheme
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeData.Morpheme
                       PhonemeData.$fReadMorpheme3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeData.Morpheme>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeData.Morpheme>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeData.Morpheme>_R)
                      @ PhonemeData.Morpheme
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeData.Morpheme))) -}
a75f0140e4b212df166951d7f735baaf
  $fReadMorpheme_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Morpheme]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Morpheme]
                   ((PhonemeData.$fReadMorpheme_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Morpheme]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Morpheme]>_R)
                      @ [PhonemeData.Morpheme]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Morpheme]))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation :: GHC.Read.Read PhonemeData.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phonation
                  PhonemeData.$fReadPhonation_$s$dmreadsPrec
                  PhonemeData.$fReadPhonation_$sreadListDefault
                  PhonemeData.$fReadPhonation_$creadPrec
                  PhonemeData.$fReadPhonation_$creadListPrec -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Phonation] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Phonation]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Phonation
                   PhonemeData.$fReadPhonation2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Phonation>_R))
                   @ b
                   eta1) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
                   PhonemeData.$fReadPhonation11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeData.Phonation))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPhonation13,
                  PhonemeData.$fReadPhonation12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Phonation>_R))))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.ASPIRATED) -}
3f5b1bf6b3292177046f864c9318bad2
  $fReadPhonation13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ASPIRATED"#) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPhonation16,
                  PhonemeData.$fReadPhonation15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Phonation>_R))))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.CREAKY) -}
c9ae2b6f7c3eb3cca69a8642100acdc2
  $fReadPhonation16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CREAKY"#) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPhonation19,
                  PhonemeData.$fReadPhonation18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Phonation>_R))))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.STIFF) -}
111a91caf31a439a755ecccba3c14249
  $fReadPhonation19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STIFF"#) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Phonation
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Phonation
                   PhonemeData.$fReadPhonation3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Phonation>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Phonation>_R)))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPhonation22,
                  PhonemeData.$fReadPhonation21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Phonation>_R))))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.MODAL) -}
7881fe22da0a7022597bcd3b3ce7ca85
  $fReadPhonation22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MODAL"#) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPhonation25,
                  PhonemeData.$fReadPhonation24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Phonation>_R))))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.SLACK) -}
95a179223edf731404c0ba26d7f86d80
  $fReadPhonation25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SLACK"#) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPhonation28,
                  PhonemeData.$fReadPhonation27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Phonation>_R))))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.BREATHY) -}
811b62d3b5f2a341d46ec5d26f368bf3
  $fReadPhonation28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BREATHY"#) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPhonation31,
                  PhonemeData.$fReadPhonation30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Phonation>_R))))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeData.Phonation
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeData.Phonation
                   PhonemeData.$fReadPhonation4
                   eta
                   @ b
                   eta1) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.VOICELESS) -}
480d9357084516b98625dad90ddd3aef
  $fReadPhonation31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICELESS"#) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
                   PhonemeData.$fReadPhonation29
                   PhonemeData.$fReadPhonation5) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
                   PhonemeData.$fReadPhonation26
                   PhonemeData.$fReadPhonation6) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
                   PhonemeData.$fReadPhonation23
                   PhonemeData.$fReadPhonation7) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
                   PhonemeData.$fReadPhonation20
                   PhonemeData.$fReadPhonation8) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
                   PhonemeData.$fReadPhonation17
                   PhonemeData.$fReadPhonation9) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation)
                   PhonemeData.$fReadPhonation14
                   PhonemeData.$fReadPhonation10) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Phonation]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadPhonation1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Phonation]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Phonation]>_R))) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phonation
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadPhonation2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Phonation>_R)) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Phonation
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeData.Phonation
                   PhonemeData.$fReadPhonation_$creadPrec
                   eta) -}
d728b957933ed40e5f338884385b44c8
  $fReadPhonation_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Phonation]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Phonation]
                   ((PhonemeData.$fReadPhonation_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Phonation]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Phonation]>_R)
                      @ [PhonemeData.Phonation]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Phonation]))) -}
725a483aa2dd4b7c0473c29cf990b878
  $fReadPhoneme :: GHC.Read.Read PhonemeData.Phoneme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phoneme
                  PhonemeData.$fReadPhoneme_$s$dmreadsPrec
                  PhonemeData.$fReadPhoneme_$sreadListDefault
                  PhonemeData.$fReadPhoneme_$creadPrec
                  PhonemeData.$fReadPhoneme_$creadListPrec -}
725a483aa2dd4b7c0473c29cf990b878
  $fReadPhoneme1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Phoneme] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Phoneme]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Phoneme
                   PhonemeData.$fReadPhoneme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Phoneme>_R))
                   @ b
                   eta1) -}
725a483aa2dd4b7c0473c29cf990b878
  $fReadPhoneme2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Phoneme
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Phoneme
                   PhonemeData.$fReadPhoneme3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Phoneme>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Phoneme>_R)))) -}
725a483aa2dd4b7c0473c29cf990b878
  $fReadPhoneme3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Phoneme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)> -}
725a483aa2dd4b7c0473c29cf990b878
  $fReadPhoneme_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Phoneme]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadPhoneme1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Phoneme]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Phoneme]>_R))) -}
725a483aa2dd4b7c0473c29cf990b878
  $fReadPhoneme_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Phoneme
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadPhoneme2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Phoneme>_R)) -}
725a483aa2dd4b7c0473c29cf990b878
  $fReadPhoneme_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Phoneme
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeData.Phoneme
                   PhonemeData.$fReadPhoneme_$creadPrec
                   eta) -}
725a483aa2dd4b7c0473c29cf990b878
  $fReadPhoneme_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Phoneme]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Phoneme]
                   ((PhonemeData.$fReadPhoneme_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Phoneme]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Phoneme]>_R)
                      @ [PhonemeData.Phoneme]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Phoneme]))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace :: GHC.Read.Read PhonemeData.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Place
                  PhonemeData.$fReadPlace_$s$dmreadsPrec
                  PhonemeData.$fReadPlace_$sreadListDefault
                  PhonemeData.$fReadPlace_$creadPrec
                  PhonemeData.$fReadPlace_$creadListPrec -}
e0644167ea1572fa835311f673311319
  $fReadPlace1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Place] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Place] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Place
                   PhonemeData.$fReadPlace2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Place>_R))
                   @ b
                   eta1) -}
e0644167ea1572fa835311f673311319
  $fReadPlace10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace59
                   PhonemeData.$fReadPlace11) -}
e0644167ea1572fa835311f673311319
  $fReadPlace11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace56
                   PhonemeData.$fReadPlace12) -}
e0644167ea1572fa835311f673311319
  $fReadPlace12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace53
                   PhonemeData.$fReadPlace13) -}
e0644167ea1572fa835311f673311319
  $fReadPlace13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace50
                   PhonemeData.$fReadPlace14) -}
e0644167ea1572fa835311f673311319
  $fReadPlace14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace47
                   PhonemeData.$fReadPlace15) -}
e0644167ea1572fa835311f673311319
  $fReadPlace15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace44
                   PhonemeData.$fReadPlace16) -}
e0644167ea1572fa835311f673311319
  $fReadPlace16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace41
                   PhonemeData.$fReadPlace17) -}
e0644167ea1572fa835311f673311319
  $fReadPlace17 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace38
                   PhonemeData.$fReadPlace18) -}
e0644167ea1572fa835311f673311319
  $fReadPlace18 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace35
                   PhonemeData.$fReadPlace19) -}
e0644167ea1572fa835311f673311319
  $fReadPlace19 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace32
                   PhonemeData.$fReadPlace20) -}
e0644167ea1572fa835311f673311319
  $fReadPlace2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Place
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Place
                   PhonemeData.$fReadPlace3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Place>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Place>_R)))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace20 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace29
                   PhonemeData.$fReadPlace21) -}
e0644167ea1572fa835311f673311319
  $fReadPlace21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace26
                   PhonemeData.$fReadPlace22) -}
e0644167ea1572fa835311f673311319
  $fReadPlace22 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace23
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace25,
                  PhonemeData.$fReadPlace24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.GLOTTAL) -}
08b8aaaffa49fc82360b7b4aae47bac6
  $fReadPlace25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace28,
                  PhonemeData.$fReadPlace27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.EPIGLOTTAL) -}
99b50c44ecba61869a18daac5eb642f6
  $fReadPlace28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIGLOTTAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace31,
                  PhonemeData.$fReadPlace30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeData.Place
                   PhonemeData.$fReadPlace4
                   eta
                   @ b
                   eta1) -}
e0644167ea1572fa835311f673311319
  $fReadPlace30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.PHARYNGEAL) -}
dcfb5b4346c62fdca48762bb4e94e102
  $fReadPlace31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PHARYNGEAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace34,
                  PhonemeData.$fReadPlace33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.EPIPHARYNGEAL) -}
280103608bebb215a553cb565b0b77bc
  $fReadPlace34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIPHARYNGEAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace37,
                  PhonemeData.$fReadPlace36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.LARYNGEAL) -}
6e955c8a5fb2b9cea45593de0cb6babe
  $fReadPlace37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LARYNGEAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace40,
                  PhonemeData.$fReadPlace39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.UVULAR) -}
e0644167ea1572fa835311f673311319
  $fReadPlace4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace77
                   PhonemeData.$fReadPlace5) -}
325c4b2fa346bc14fdf217ee518d27e2
  $fReadPlace40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVULAR"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace43,
                  PhonemeData.$fReadPlace42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.VELAR) -}
e7e51e8e225810a150fd3ababebda426
  $fReadPlace43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VELAR"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace44 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace46,
                  PhonemeData.$fReadPlace45
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.PALATAL) -}
164e868e0bd8898af95fb87cf96dd048
  $fReadPlace46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PALATAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace47 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace49,
                  PhonemeData.$fReadPlace48
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace48 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.ALVEOLOPALATAL) -}
f4fa766aef8b274f7a21890160e3e329
  $fReadPlace49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLOPALATAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace74
                   PhonemeData.$fReadPlace6) -}
e0644167ea1572fa835311f673311319
  $fReadPlace50 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace52,
                  PhonemeData.$fReadPlace51
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace51 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.DORSAL) -}
75c3f7a2bb79a7f0f8d0adfe2978e513
  $fReadPlace52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DORSAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace55,
                  PhonemeData.$fReadPlace54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.RETROFLEX) -}
90abb07241d4f615a1254fd23eefda81
  $fReadPlace55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RETROFLEX"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace56 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace58,
                  PhonemeData.$fReadPlace57
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace57 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.POSTALVEOLAR) -}
00dc550bf25f096cb0b0d346b1e241d8
  $fReadPlace58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POSTALVEOLAR"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace59 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace61,
                  PhonemeData.$fReadPlace60
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace71
                   PhonemeData.$fReadPlace7) -}
e0644167ea1572fa835311f673311319
  $fReadPlace60 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.ALVEOLAR) -}
f2242c1f9c69e50f65027dda9c27c358
  $fReadPlace61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLAR"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace62 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace64,
                  PhonemeData.$fReadPlace63
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace63 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.DENTAL) -}
f3417e6941b06494c32aee334d0118f6
  $fReadPlace64 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace65 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace67,
                  PhonemeData.$fReadPlace66
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace66 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.DENTIALVEOLAR) -}
99f00b9c7808bcb055cfefbd78c234df
  $fReadPlace67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTIALVEOLAR"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace68 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace70,
                  PhonemeData.$fReadPlace69
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace69 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.CORONAL) -}
e0644167ea1572fa835311f673311319
  $fReadPlace7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace68
                   PhonemeData.$fReadPlace8) -}
1452adaf94d75b594a5d44ff0c5f9ece
  $fReadPlace70 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CORONAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace71 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace73,
                  PhonemeData.$fReadPlace72
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace72 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.LABIODENTAL) -}
ff63a113f1f5bce72671392c3a674558
  $fReadPlace73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIODENTAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace74 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace76,
                  PhonemeData.$fReadPlace75
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace75 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.BILABIAL) -}
f38d29e283db57c336a48b44f1a8f283
  $fReadPlace76 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BILABIAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace77 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadPlace79,
                  PhonemeData.$fReadPlace78
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Place>_R))))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace78 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.LABIAL) -}
b343a251b2a3b0fb1efe03cac80187d3
  $fReadPlace79 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIAL"#) -}
e0644167ea1572fa835311f673311319
  $fReadPlace8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace65
                   PhonemeData.$fReadPlace9) -}
e0644167ea1572fa835311f673311319
  $fReadPlace9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place)
                   PhonemeData.$fReadPlace62
                   PhonemeData.$fReadPlace10) -}
e0644167ea1572fa835311f673311319
  $fReadPlace_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Place]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadPlace1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Place]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Place]>_R))) -}
e0644167ea1572fa835311f673311319
  $fReadPlace_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Place
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadPlace2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Place>_R)) -}
e0644167ea1572fa835311f673311319
  $fReadPlace_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Place
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeData.Place
                   PhonemeData.$fReadPlace_$creadPrec
                   eta) -}
e0644167ea1572fa835311f673311319
  $fReadPlace_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Place]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Place]
                   ((PhonemeData.$fReadPlace_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Place]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Place]>_R)
                      @ [PhonemeData.Place]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Place]))) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness :: GHC.Read.Read PhonemeData.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Roundedness
                  PhonemeData.$fReadRoundedness_$s$dmreadsPrec
                  PhonemeData.$fReadRoundedness_$sreadListDefault
                  PhonemeData.$fReadRoundedness_$creadPrec
                  PhonemeData.$fReadRoundedness_$creadListPrec -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Roundedness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Roundedness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Roundedness
                   PhonemeData.$fReadRoundedness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Roundedness>_R))
                   @ b
                   eta1) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadRoundedness12,
                  PhonemeData.$fReadRoundedness11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Roundedness>_R))))) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.ROUNDED) -}
d32be58e0d159f69c1f6b48452f67715
  $fReadRoundedness12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ROUNDED"#) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadRoundedness15,
                  PhonemeData.$fReadRoundedness14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Roundedness>_R))))) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.DEFAULT) -}
0c4234d6dbc962fda56b6d4a85f92a6a
  $fReadRoundedness15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DEFAULT"#) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Roundedness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Roundedness
                   PhonemeData.$fReadRoundedness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Roundedness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Roundedness>_R)))) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeData.Roundedness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeData.Roundedness
                   PhonemeData.$fReadRoundedness4
                   eta
                   @ b
                   eta1) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)
                   PhonemeData.$fReadRoundedness13
                   PhonemeData.$fReadRoundedness5) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)
                   PhonemeData.$fReadRoundedness10
                   PhonemeData.$fReadRoundedness6) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)
                   PhonemeData.$fReadRoundedness7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeData.Roundedness))) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeData.$fReadRoundedness9,
                  PhonemeData.$fReadRoundedness8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeData.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeData.Roundedness>_R))))) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeData.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeData.UNROUNDED) -}
0e4eed7873ad92721c346c04316e09fb
  $fReadRoundedness9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UNROUNDED"#) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Roundedness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadRoundedness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Roundedness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Roundedness]>_R))) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Roundedness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadRoundedness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Roundedness>_R)) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Roundedness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeData.Roundedness
                   PhonemeData.$fReadRoundedness_$creadPrec
                   eta) -}
4c51106b8aab206d34cb6b9d104e8504
  $fReadRoundedness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Roundedness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Roundedness]
                   ((PhonemeData.$fReadRoundedness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Roundedness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeData.Roundedness]>_R)
                      @ [PhonemeData.Roundedness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Roundedness]))) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fReadWord :: GHC.Read.Read PhonemeData.Word
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Word
                  PhonemeData.$fReadWord_$creadsPrec
                  PhonemeData.$fReadWord_$sreadListDefault
                  PhonemeData.$fReadWord_$creadPrec
                  PhonemeData.$fReadWord_$creadListPrec -}
55b6ea537d860cf92b62e64e19ceba7b
  $fReadWord1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeData.Word] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeData.Word] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeData.Word
                   PhonemeData.$fReadWord2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeData.Word>_R))
                   @ b
                   eta1) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fReadWord2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeData.Word
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeData.Word
                   PhonemeData.$fReadWord3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeData.Word>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeData.Word>_R)))) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fReadWord3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeData.Word -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeData.Word -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeData.$wa1 ww1 @ b w1 }) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fReadWord_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeData.Word]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadWord1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeData.Word]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeData.Word]>_R))) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fReadWord_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeData.Word
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeData.$fReadWord2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeData.Word>_R)) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fReadWord_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeData.Word
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeData.Word
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeData.Word
                       PhonemeData.$fReadWord3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeData.Word>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeData.Word>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <PhonemeData.Word>_R)
                      @ PhonemeData.Word
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeData.Word))) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fReadWord_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeData.Word]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeData.Word]
                   ((PhonemeData.$fReadWord_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeData.Word]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <[PhonemeData.Word]>_R)
                      @ [PhonemeData.Word]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeData.Word]))) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fShowBackness :: GHC.Show.Show PhonemeData.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Backness
                  PhonemeData.$fShowBackness_$cshowsPrec
                  PhonemeData.$fShowBackness_$cshow
                  PhonemeData.$fShowBackness_$cshowList -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fShowBackness_$cshow :: PhonemeData.Backness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Backness ->
                 PhonemeData.$fShowBackness_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fShowBackness_$cshowList ::
    [PhonemeData.Backness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Backness
                   PhonemeData.$w$cshowsPrec) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $fShowBackness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Backness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Backness
                   w2 :: GHC.Base.String ->
                 PhonemeData.$w$cshowsPrec w1 w2) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fShowHeight :: GHC.Show.Show PhonemeData.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Height
                  PhonemeData.$fShowHeight_$cshowsPrec
                  PhonemeData.$fShowHeight_$cshow
                  PhonemeData.$fShowHeight_$cshowList -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fShowHeight_$cshow :: PhonemeData.Height -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Height ->
                 PhonemeData.$fShowHeight_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fShowHeight_$cshowList :: [PhonemeData.Height] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Height
                   PhonemeData.$w$cshowsPrec1) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $fShowHeight_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Height -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Height
                   w2 :: GHC.Base.String ->
                 PhonemeData.$w$cshowsPrec1 w1 w2) -}
414a8b878bf71816d2002a26fce00728
  $fShowLength :: GHC.Show.Show PhonemeData.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Length
                  PhonemeData.$fShowLength_$cshowsPrec
                  PhonemeData.$fShowLength_$cshow
                  PhonemeData.$fShowLength_$cshowList -}
414a8b878bf71816d2002a26fce00728
  $fShowLength_$cshow :: PhonemeData.Length -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Length ->
                 case x of wild {
                   PhonemeData.SHORT -> PhonemeData.$fReadLength15
                   PhonemeData.NORMAL -> PhonemeData.$fReadLength12
                   PhonemeData.LONG -> PhonemeData.$fReadLength9 }) -}
414a8b878bf71816d2002a26fce00728
  $fShowLength_$cshowList :: [PhonemeData.Length] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Length
                   PhonemeData.$w$cshowsPrec2) -}
414a8b878bf71816d2002a26fce00728
  $fShowLength_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Length -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Length
                   w2 :: GHC.Base.String ->
                 PhonemeData.$w$cshowsPrec2 w1 w2) -}
2286baa806cedbe4b7d0c4916ea37630
  $fShowManner :: GHC.Show.Show PhonemeData.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Manner
                  PhonemeData.$fShowManner_$cshowsPrec
                  PhonemeData.$fShowManner_$cshow
                  PhonemeData.$fShowManner_$cshowList -}
2286baa806cedbe4b7d0c4916ea37630
  $fShowManner_$cshow :: PhonemeData.Manner -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Manner ->
                 PhonemeData.$fShowManner_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2286baa806cedbe4b7d0c4916ea37630
  $fShowManner_$cshowList :: [PhonemeData.Manner] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Manner
                   PhonemeData.$w$cshowsPrec3) -}
2286baa806cedbe4b7d0c4916ea37630
  $fShowManner_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Manner -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Manner
                   w2 :: GHC.Base.String ->
                 PhonemeData.$w$cshowsPrec3 w1 w2) -}
a75f0140e4b212df166951d7f735baaf
  $fShowMorpheme :: GHC.Show.Show PhonemeData.Morpheme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Morpheme
                  PhonemeData.$fShowMorpheme_$cshowsPrec1
                  PhonemeData.$fShowMorpheme_$cshow
                  PhonemeData.$fShowMorpheme_$cshowList -}
a75f0140e4b212df166951d7f735baaf
  $fShowMorpheme1 :: PhonemeData.Morpheme -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeData.Morpheme w1 :: GHC.Base.String ->
                 case w of ww { PhonemeData.Morpheme ww1 ->
                 PhonemeData.$w$cshowsPrec4 0 ww1 w1 }) -}
798d9f59b4a5f8cde02886831a03af52
  $fShowMorpheme2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
18ba1c6086eb55993be35d3f40de6dfa
  $fShowMorpheme3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
447c152dba2c8a4a274b3bd4cbcdc1d0
  $fShowMorpheme4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getPhonemes = "#) -}
e329d71a4e3390b24a04ea990c2e5be5
  $fShowMorpheme5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Morpheme {"#) -}
a75f0140e4b212df166951d7f735baaf
  $fShowMorpheme_$cshow :: PhonemeData.Morpheme -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Morpheme ->
                 PhonemeData.$fShowMorpheme_$cshowsPrec1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a75f0140e4b212df166951d7f735baaf
  $fShowMorpheme_$cshowList ::
    [PhonemeData.Morpheme] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Morpheme
                   PhonemeData.$fShowMorpheme1) -}
725a483aa2dd4b7c0473c29cf990b878
  $fShowMorpheme_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Phoneme -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
a75f0140e4b212df166951d7f735baaf
  $fShowMorpheme_$cshowsPrec1 ::
    GHC.Types.Int -> PhonemeData.Morpheme -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Morpheme
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeData.Morpheme ww3 ->
                 PhonemeData.$w$cshowsPrec4 ww1 ww3 w2 } }) -}
d728b957933ed40e5f338884385b44c8
  $fShowPhonation :: GHC.Show.Show PhonemeData.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phonation
                  PhonemeData.$fShowPhonation_$cshowsPrec
                  PhonemeData.$fShowPhonation_$cshow
                  PhonemeData.$fShowPhonation_$cshowList -}
d728b957933ed40e5f338884385b44c8
  $fShowPhonation_$cshow :: PhonemeData.Phonation -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Phonation ->
                 PhonemeData.$fShowPhonation_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d728b957933ed40e5f338884385b44c8
  $fShowPhonation_$cshowList ::
    [PhonemeData.Phonation] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Phonation
                   PhonemeData.$w$cshowsPrec5) -}
d728b957933ed40e5f338884385b44c8
  $fShowPhonation_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Phonation -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Phonation
                   w2 :: GHC.Base.String ->
                 PhonemeData.$w$cshowsPrec5 w1 w2) -}
725a483aa2dd4b7c0473c29cf990b878
  $fShowPhoneme :: GHC.Show.Show PhonemeData.Phoneme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Phoneme
                  PhonemeData.$fShowMorpheme_$cshowsPrec
                  PhonemeData.$fShowPhoneme_$cshow
                  PhonemeData.$fShowPhoneme_$cshowList -}
725a483aa2dd4b7c0473c29cf990b878
  $fShowPhoneme1 :: PhonemeData.Phoneme -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (PhonemeData.$fShowMorpheme_$cshowsPrec
                   PhonemeData.$fShowMorpheme2) -}
725a483aa2dd4b7c0473c29cf990b878
  $fShowPhoneme_$cshow :: PhonemeData.Phoneme -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Phoneme ->
                 PhonemeData.$fShowMorpheme_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
725a483aa2dd4b7c0473c29cf990b878
  $fShowPhoneme_$cshowList :: [PhonemeData.Phoneme] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Phoneme
                   PhonemeData.$fShowPhoneme1) -}
e0644167ea1572fa835311f673311319
  $fShowPlace :: GHC.Show.Show PhonemeData.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Place
                  PhonemeData.$fShowPlace_$cshowsPrec
                  PhonemeData.$fShowPlace_$cshow
                  PhonemeData.$fShowPlace_$cshowList -}
e0644167ea1572fa835311f673311319
  $fShowPlace_$cshow :: PhonemeData.Place -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Place ->
                 PhonemeData.$fShowPlace_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e0644167ea1572fa835311f673311319
  $fShowPlace_$cshowList :: [PhonemeData.Place] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Place
                   PhonemeData.$w$cshowsPrec6) -}
e0644167ea1572fa835311f673311319
  $fShowPlace_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Place -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Place
                   w2 :: GHC.Base.String ->
                 PhonemeData.$w$cshowsPrec6 w1 w2) -}
4c51106b8aab206d34cb6b9d104e8504
  $fShowRoundedness :: GHC.Show.Show PhonemeData.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Roundedness
                  PhonemeData.$fShowRoundedness_$cshowsPrec
                  PhonemeData.$fShowRoundedness_$cshow
                  PhonemeData.$fShowRoundedness_$cshowList -}
4c51106b8aab206d34cb6b9d104e8504
  $fShowRoundedness_$cshow ::
    PhonemeData.Roundedness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Roundedness ->
                 case x of wild {
                   PhonemeData.DEFAULT -> PhonemeData.$fReadRoundedness15
                   PhonemeData.ROUNDED -> PhonemeData.$fReadRoundedness12
                   PhonemeData.UNROUNDED -> PhonemeData.$fReadRoundedness9 }) -}
4c51106b8aab206d34cb6b9d104e8504
  $fShowRoundedness_$cshowList ::
    [PhonemeData.Roundedness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Roundedness
                   PhonemeData.$w$cshowsPrec7) -}
4c51106b8aab206d34cb6b9d104e8504
  $fShowRoundedness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Roundedness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Roundedness
                   w2 :: GHC.Base.String ->
                 PhonemeData.$w$cshowsPrec7 w1 w2) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fShowWord :: GHC.Show.Show PhonemeData.Word
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeData.Word
                  PhonemeData.$fShowWord_$cshowsPrec
                  PhonemeData.$fShowWord_$cshow
                  PhonemeData.$fShowWord_$cshowList -}
55b6ea537d860cf92b62e64e19ceba7b
  $fShowWord1 :: PhonemeData.Word -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeData.Word w1 :: GHC.Base.String ->
                 case w of ww { PhonemeData.Word ww1 ->
                 PhonemeData.$w$cshowsPrec8 0 ww1 w1 }) -}
61b0bbf670a69c7ec714ad206ce8a004
  $fShowWord2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getMorphemes = "#) -}
0772ec9b70d5a2e3abdb6a16d8f99c42
  $fShowWord3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Word {"#) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fShowWord_$cshow :: PhonemeData.Word -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeData.Word ->
                 PhonemeData.$fShowWord_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fShowWord_$cshowList :: [PhonemeData.Word] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeData.Word
                   PhonemeData.$fShowWord1) -}
55b6ea537d860cf92b62e64e19ceba7b
  $fShowWord_$cshowsPrec ::
    GHC.Types.Int -> PhonemeData.Word -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeData.Word
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeData.Word ww3 ->
                 PhonemeData.$w$cshowsPrec8 ww1 ww3 w2 } }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $w$cshowsPrec ::
    PhonemeData.Backness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeData.Backness w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeData.BACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadBackness23 w1
                   PhonemeData.NEARBACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadBackness20 w1
                   PhonemeData.CENTRAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadBackness17 w1
                   PhonemeData.NEARFRONT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadBackness14 w1
                   PhonemeData.FRONT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeData.$fReadBackness11
                        w1 }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $w$cshowsPrec1 ::
    PhonemeData.Height -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeData.Height w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeData.CLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadHeight31 w1
                   PhonemeData.NEARCLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadHeight28 w1
                   PhonemeData.CLOSEMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadHeight25 w1
                   PhonemeData.MID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadHeight22 w1
                   PhonemeData.OPENMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadHeight19 w1
                   PhonemeData.NEAROPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadHeight16 w1
                   PhonemeData.OPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadHeight13 w1 }) -}
414a8b878bf71816d2002a26fce00728
  $w$cshowsPrec2 ::
    PhonemeData.Length -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeData.Length w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeData.SHORT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadLength15 w1
                   PhonemeData.NORMAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadLength12 w1
                   PhonemeData.LONG
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadLength9 w1 }) -}
2286baa806cedbe4b7d0c4916ea37630
  $w$cshowsPrec3 ::
    PhonemeData.Manner -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeData.Manner w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeData.NASAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner55 w1
                   PhonemeData.STOP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner52 w1
                   PhonemeData.SAFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner49 w1
                   PhonemeData.AFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner46 w1
                   PhonemeData.SILIBANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner43 w1
                   PhonemeData.FRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner40 w1
                   PhonemeData.APPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner37 w1
                   PhonemeData.FLAP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner34 w1
                   PhonemeData.TRILL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner31 w1
                   PhonemeData.LAFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner28 w1
                   PhonemeData.LFRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner25 w1
                   PhonemeData.LAPPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner22 w1
                   PhonemeData.LFLAP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadManner19 w1 }) -}
1bd2b305715e1321a43119509d60718f
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> [PhonemeData.Phoneme] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeData.Phoneme]
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeData.$fShowMorpheme5
                       (GHC.Base.++
                          @ GHC.Types.Char
                          PhonemeData.$fShowMorpheme4
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++ @ GHC.Types.Char PhonemeData.$fShowMorpheme3 x
                           } in
                           case ww1 of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (PhonemeData.$fShowMorpheme_$cshowsPrec
                                     PhonemeData.$fShowMorpheme2
                                     x1
                                     (let {
                                        lvl92 :: [GHC.Types.Char]
                                        = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s
                                      } in
                                      letrec {
                                        showl :: [PhonemeData.Phoneme] -> [GHC.Types.Char]
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ ds2 :: [PhonemeData.Phoneme] ->
                                          case ds2 of wild1 {
                                            [] -> lvl92
                                            : y ys
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.showList__1
                                                 (PhonemeData.$fShowMorpheme_$cshowsPrec
                                                    PhonemeData.$fShowMorpheme2
                                                    y
                                                    (showl ys)) }
                                      } in
                                      showl xs)) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
d728b957933ed40e5f338884385b44c8
  $w$cshowsPrec5 ::
    PhonemeData.Phonation -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeData.Phonation w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeData.VOICELESS
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadPhonation31 w1
                   PhonemeData.BREATHY
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadPhonation28 w1
                   PhonemeData.SLACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadPhonation25 w1
                   PhonemeData.MODAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadPhonation22 w1
                   PhonemeData.STIFF
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadPhonation19 w1
                   PhonemeData.CREAKY
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadPhonation16 w1
                   PhonemeData.ASPIRATED
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeData.$fReadPhonation13
                        w1 }) -}
e0644167ea1572fa835311f673311319
  $w$cshowsPrec6 ::
    PhonemeData.Place -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
4c51106b8aab206d34cb6b9d104e8504
  $w$cshowsPrec7 ::
    PhonemeData.Roundedness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeData.Roundedness w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeData.DEFAULT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadRoundedness15 w1
                   PhonemeData.ROUNDED
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeData.$fReadRoundedness12 w1
                   PhonemeData.UNROUNDED
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeData.$fReadRoundedness9
                        w1 }) -}
f763807058f37536ebda6c8bc0ad4dfb
  $w$cshowsPrec8 ::
    GHC.Prim.Int#
    -> [PhonemeData.Morpheme] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeData.Morpheme]
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeData.$fShowWord3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          PhonemeData.$fShowWord2
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++ @ GHC.Types.Char PhonemeData.$fShowMorpheme3 x
                           } in
                           case ww1 of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (case x1 of ww2 { PhonemeData.Morpheme ww3 ->
                                   PhonemeData.$w$cshowsPrec4
                                     0
                                     ww3
                                     (let {
                                        lvl92 :: [GHC.Types.Char]
                                        = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s
                                      } in
                                      letrec {
                                        showl :: [PhonemeData.Morpheme] -> [GHC.Types.Char]
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ ds2 :: [PhonemeData.Morpheme] ->
                                          case ds2 of wild1 {
                                            [] -> lvl92
                                            : y ys
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.showList__1
                                                 (case y of ww4 { PhonemeData.Morpheme ww5 ->
                                                  PhonemeData.$w$cshowsPrec4 0 ww5 (showl ys) }) }
                                      } in
                                      showl xs) }) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
9747e3c7b5ae543ddf6a14d6c68612ef
  $w$ctoEnum :: GHC.Prim.Int# -> PhonemeData.Backness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumBackness6 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 4) of wild1 {
                        GHC.Types.False -> PhonemeData.$fEnumBackness6 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeData.Backness ww } }) -}
56a4ebd86a55476fcceec0b5b5ad52dd
  $w$ctoEnum1 :: GHC.Prim.Int# -> PhonemeData.Height
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumHeight8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeData.$fEnumHeight8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeData.Height ww } }) -}
414a8b878bf71816d2002a26fce00728
  $w$ctoEnum2 :: GHC.Prim.Int# -> PhonemeData.Length
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumLength1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeData.$fEnumLength1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeData.Length ww } }) -}
2286baa806cedbe4b7d0c4916ea37630
  $w$ctoEnum3 :: GHC.Prim.Int# -> PhonemeData.Manner
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumManner1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 12) of wild1 {
                        GHC.Types.False -> PhonemeData.$fEnumManner1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeData.Manner ww } }) -}
d728b957933ed40e5f338884385b44c8
  $w$ctoEnum4 :: GHC.Prim.Int# -> PhonemeData.Phonation
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumPhonation8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeData.$fEnumPhonation8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeData.Phonation ww } }) -}
e0644167ea1572fa835311f673311319
  $w$ctoEnum5 :: GHC.Prim.Int# -> PhonemeData.Place
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumPlace1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 18) of wild1 {
                        GHC.Types.False -> PhonemeData.$fEnumPlace1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeData.Place ww } }) -}
4c51106b8aab206d34cb6b9d104e8504
  $w$ctoEnum6 :: GHC.Prim.Int# -> PhonemeData.Roundedness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeData.$fEnumRoundedness1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeData.$fEnumRoundedness1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeData.Roundedness ww } }) -}
a75f0140e4b212df166951d7f735baaf
  $wa ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeData.Morpheme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
55b6ea537d860cf92b62e64e19ceba7b
  $wa1 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeData.Word -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
9747e3c7b5ae543ddf6a14d6c68612ef
  data Backness = BACK | NEARBACK | CENTRAL | NEARFRONT | FRONT
    Promotable
56a4ebd86a55476fcceec0b5b5ad52dd
  data Height
    = CLOSE | NEARCLOSE | CLOSEMID | MID | OPENMID | NEAROPEN | OPEN
    Promotable
414a8b878bf71816d2002a26fce00728
  data Length = SHORT | NORMAL | LONG
    Promotable
2286baa806cedbe4b7d0c4916ea37630
  data Manner
    = NASAL
    | STOP
    | SAFFRICATE
    | AFFRICATE
    | SILIBANT
    | FRICATIVE
    | APPROXIMANT
    | FLAP
    | TRILL
    | LAFFRICATE
    | LFRICATIVE
    | LAPPROXIMANT
    | LFLAP
    Promotable
a75f0140e4b212df166951d7f735baaf
  data Morpheme = Morpheme {getPhonemes :: [PhonemeData.Phoneme]}
d728b957933ed40e5f338884385b44c8
  data Phonation
    = VOICELESS | BREATHY | SLACK | MODAL | STIFF | CREAKY | ASPIRATED
    Promotable
725a483aa2dd4b7c0473c29cf990b878
  data Phoneme
    = Consonant {cplace :: PhonemeData.Place,
                 cmanner :: PhonemeData.Manner,
                 cvoice :: PhonemeData.Phonation,
                 csymbol :: GHC.Base.String}
    | Vowel {vheight :: PhonemeData.Height,
             vbackness :: PhonemeData.Backness,
             vroundedness :: PhonemeData.Roundedness,
             vlength :: PhonemeData.Length,
             vsymbol :: GHC.Base.String}
    | Diphthong {dheight1 :: PhonemeData.Height,
                 dbackness1 :: PhonemeData.Backness,
                 droundedness1 :: PhonemeData.Roundedness,
                 dheight2 :: PhonemeData.Height,
                 dbackness2 :: PhonemeData.Backness,
                 droundedness2 :: PhonemeData.Roundedness,
                 dlength :: PhonemeData.Length,
                 dsymbol :: GHC.Base.String}
    | Blank
e0644167ea1572fa835311f673311319
  data Place
    = LABIAL
    | BILABIAL
    | LABIODENTAL
    | CORONAL
    | DENTIALVEOLAR
    | DENTAL
    | ALVEOLAR
    | POSTALVEOLAR
    | RETROFLEX
    | DORSAL
    | ALVEOLOPALATAL
    | PALATAL
    | VELAR
    | UVULAR
    | LARYNGEAL
    | EPIPHARYNGEAL
    | PHARYNGEAL
    | EPIGLOTTAL
    | GLOTTAL
    Promotable
4c51106b8aab206d34cb6b9d104e8504
  data Roundedness = DEFAULT | ROUNDED | UNROUNDED
    Promotable
55b6ea537d860cf92b62e64e19ceba7b
  data Word = Word {getMorphemes :: [PhonemeData.Morpheme]}
a9429695b211c23c7924d39159db5ba5
  cmanner :: PhonemeData.Phoneme -> PhonemeData.Manner
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.cmanner1
                   PhonemeData.Consonant ds1 ds2 ds3 ds4 -> ds2 }) -}
bdab60069268458b72cedffbf607340f
  cmanner1 :: PhonemeData.Manner
  {- Strictness: b -}
fca7d253ab64bc724a01d2e6925663e3
  cplace :: PhonemeData.Phoneme -> PhonemeData.Place
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.cplace1
                   PhonemeData.Consonant ds1 ds2 ds3 ds4 -> ds1 }) -}
45c4d39093d8e31e48eeb3aa6be105f5
  cplace1 :: PhonemeData.Place
  {- Strictness: b -}
adede1920d7863e2930e586cb77c5227
  csymbol :: PhonemeData.Phoneme -> GHC.Base.String
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.csymbol1
                   PhonemeData.Consonant ds1 ds2 ds3 ds4 -> ds4 }) -}
bd515fc741b83bb5caed7715dcc9382b
  csymbol1 :: GHC.Base.String
  {- Strictness: b -}
5b16e74a055f469d2f2e1c9a9bbdec50
  cvoice :: PhonemeData.Phoneme -> PhonemeData.Phonation
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.cvoice1
                   PhonemeData.Consonant ds1 ds2 ds3 ds4 -> ds3 }) -}
3361e164e559ac235e2730f0612d82a8
  cvoice1 :: PhonemeData.Phonation
  {- Strictness: b -}
e69056079e0bf45a107e4f56416cbfea
  dbackness1 :: PhonemeData.Phoneme -> PhonemeData.Backness
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.dbackness4
                   PhonemeData.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds2 }) -}
75e9bffbc1f0bc6be8be51c2c3084845
  dbackness2 :: PhonemeData.Phoneme -> PhonemeData.Backness
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.dbackness5
                   PhonemeData.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds5 }) -}
95ca1f220f40b7b4836cc927fec2c27a
  dbackness4 :: PhonemeData.Backness
  {- Strictness: b -}
d7f354e54dcab6cc2b1f67412f61518e
  dbackness5 :: PhonemeData.Backness
  {- Strictness: b -}
d533b56bb045d48d677e0b754b35f76d
  dheight1 :: PhonemeData.Phoneme -> PhonemeData.Height
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.dheight4
                   PhonemeData.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds1 }) -}
ccf5662908cbc3698fecdc8b0e5e9188
  dheight2 :: PhonemeData.Phoneme -> PhonemeData.Height
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.dheight5
                   PhonemeData.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds4 }) -}
260513ae8d7024138f897ccb60060330
  dheight4 :: PhonemeData.Height
  {- Strictness: b -}
c7eb8528f865ec62beab2dc1f6819923
  dheight5 :: PhonemeData.Height
  {- Strictness: b -}
6044fd4362bd1438bf80ed6224e16b09
  dlength :: PhonemeData.Phoneme -> PhonemeData.Length
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.dlength1
                   PhonemeData.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds7 }) -}
30c09bc33aad304488843585de28b186
  dlength1 :: PhonemeData.Length
  {- Strictness: b -}
31fefc477ad1283a17611750d3d29953
  droundedness1 :: PhonemeData.Phoneme -> PhonemeData.Roundedness
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.droundedness4
                   PhonemeData.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds3 }) -}
281d224a6d082bad6cdabfd2157a9eb6
  droundedness2 :: PhonemeData.Phoneme -> PhonemeData.Roundedness
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.droundedness5
                   PhonemeData.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds6 }) -}
00e79cfd490b488918c2a3b0364c4868
  droundedness4 :: PhonemeData.Roundedness
  {- Strictness: b -}
83bfe9f4882fd8587aac0d7a8aa5c2f0
  droundedness5 :: PhonemeData.Roundedness
  {- Strictness: b -}
bec541e0cb1a1452a6c2e406ed05a5a0
  dsymbol :: PhonemeData.Phoneme -> GHC.Base.String
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.dsymbol1
                   PhonemeData.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds8 }) -}
0be3116cc6f7622eb9af782601085f77
  dsymbol1 :: GHC.Base.String
  {- Strictness: b -}
7e4952227a029392fc878e694c115fd8
  getMorphemes :: PhonemeData.Word -> [PhonemeData.Morpheme]
  RecSel PhonemeData.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Word ->
                 case ds of wild { PhonemeData.Word ds1 -> ds1 }) -}
cf67a99225ac5cd3326bdeda7d07491d
  getPhonemes :: PhonemeData.Morpheme -> [PhonemeData.Phoneme]
  RecSel PhonemeData.Morpheme
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Morpheme ->
                 case ds of wild { PhonemeData.Morpheme ds1 -> ds1 }) -}
6f1fb383b2a73d447d9d5f1dd473e5c0
  vbackness :: PhonemeData.Phoneme -> PhonemeData.Backness
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.vbackness1
                   PhonemeData.Vowel ds1 ds2 ds3 ds4 ds5 -> ds2 }) -}
8f94bfe3152f59a9c4da2a9e68e1bb8a
  vbackness1 :: PhonemeData.Backness
  {- Strictness: b -}
0f7d942c2614df514c517f8648778873
  vheight :: PhonemeData.Phoneme -> PhonemeData.Height
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.vheight1
                   PhonemeData.Vowel ds1 ds2 ds3 ds4 ds5 -> ds1 }) -}
7fcc315de1cd8a1119efb5377816c280
  vheight1 :: PhonemeData.Height
  {- Strictness: b -}
05c5ab0dac630f6caaad7463a7e39b70
  vlength :: PhonemeData.Phoneme -> PhonemeData.Length
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.vlength1
                   PhonemeData.Vowel ds1 ds2 ds3 ds4 ds5 -> ds4 }) -}
cb617eebd12fa4980740aeb25b0cd39a
  vlength1 :: PhonemeData.Length
  {- Strictness: b -}
a782703079e3810ad39fced02b947a40
  vroundedness :: PhonemeData.Phoneme -> PhonemeData.Roundedness
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.vroundedness1
                   PhonemeData.Vowel ds1 ds2 ds3 ds4 ds5 -> ds3 }) -}
604ccf45217c37df35a3645fa70dbcb9
  vroundedness1 :: PhonemeData.Roundedness
  {- Strictness: b -}
d4a50191fa439edee5dacea3c2489af1
  vsymbol :: PhonemeData.Phoneme -> GHC.Base.String
  RecSel PhonemeData.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeData.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeData.vsymbol1
                   PhonemeData.Vowel ds1 ds2 ds3 ds4 ds5 -> ds5 }) -}
8328c48486ded9b12a0d5f5f39ba447a
  vsymbol1 :: GHC.Base.String
  {- Strictness: b -}
instance GHC.Enum.Bounded [PhonemeData.Backness]
  = PhonemeData.$fBoundedBackness
instance GHC.Enum.Bounded [PhonemeData.Height]
  = PhonemeData.$fBoundedHeight
instance GHC.Enum.Bounded [PhonemeData.Length]
  = PhonemeData.$fBoundedLength
instance GHC.Enum.Bounded [PhonemeData.Manner]
  = PhonemeData.$fBoundedManner
instance GHC.Enum.Bounded [PhonemeData.Phonation]
  = PhonemeData.$fBoundedPhonation
instance GHC.Enum.Bounded [PhonemeData.Place]
  = PhonemeData.$fBoundedPlace
instance GHC.Enum.Bounded [PhonemeData.Roundedness]
  = PhonemeData.$fBoundedRoundedness
instance GHC.Enum.Enum [PhonemeData.Backness]
  = PhonemeData.$fEnumBackness
instance GHC.Enum.Enum [PhonemeData.Height]
  = PhonemeData.$fEnumHeight
instance GHC.Enum.Enum [PhonemeData.Length]
  = PhonemeData.$fEnumLength
instance GHC.Enum.Enum [PhonemeData.Manner]
  = PhonemeData.$fEnumManner
instance GHC.Enum.Enum [PhonemeData.Phonation]
  = PhonemeData.$fEnumPhonation
instance GHC.Enum.Enum [PhonemeData.Place]
  = PhonemeData.$fEnumPlace
instance GHC.Enum.Enum [PhonemeData.Roundedness]
  = PhonemeData.$fEnumRoundedness
instance GHC.Classes.Eq [PhonemeData.Backness]
  = PhonemeData.$fEqBackness
instance GHC.Classes.Eq [PhonemeData.Height]
  = PhonemeData.$fEqHeight
instance GHC.Classes.Eq [PhonemeData.Length]
  = PhonemeData.$fEqLength
instance GHC.Classes.Eq [PhonemeData.Manner]
  = PhonemeData.$fEqManner
instance GHC.Classes.Eq [PhonemeData.Morpheme]
  = PhonemeData.$fEqMorpheme
instance GHC.Classes.Eq [PhonemeData.Phonation]
  = PhonemeData.$fEqPhonation
instance GHC.Classes.Eq [PhonemeData.Phoneme]
  = PhonemeData.$fEqPhoneme
instance GHC.Classes.Eq [PhonemeData.Place] = PhonemeData.$fEqPlace
instance GHC.Classes.Eq [PhonemeData.Roundedness]
  = PhonemeData.$fEqRoundedness
instance GHC.Classes.Eq [PhonemeData.Word] = PhonemeData.$fEqWord
instance GHC.Classes.Ord [PhonemeData.Backness]
  = PhonemeData.$fOrdBackness
instance GHC.Classes.Ord [PhonemeData.Height]
  = PhonemeData.$fOrdHeight
instance GHC.Classes.Ord [PhonemeData.Length]
  = PhonemeData.$fOrdLength
instance GHC.Classes.Ord [PhonemeData.Manner]
  = PhonemeData.$fOrdManner
instance GHC.Classes.Ord [PhonemeData.Morpheme]
  = PhonemeData.$fOrdMorpheme
instance GHC.Classes.Ord [PhonemeData.Phonation]
  = PhonemeData.$fOrdPhonation
instance GHC.Classes.Ord [PhonemeData.Phoneme]
  = PhonemeData.$fOrdPhoneme
instance GHC.Classes.Ord [PhonemeData.Place]
  = PhonemeData.$fOrdPlace
instance GHC.Classes.Ord [PhonemeData.Roundedness]
  = PhonemeData.$fOrdRoundedness
instance GHC.Classes.Ord [PhonemeData.Word] = PhonemeData.$fOrdWord
instance GHC.Read.Read [PhonemeData.Backness]
  = PhonemeData.$fReadBackness
instance GHC.Read.Read [PhonemeData.Height]
  = PhonemeData.$fReadHeight
instance GHC.Read.Read [PhonemeData.Length]
  = PhonemeData.$fReadLength
instance GHC.Read.Read [PhonemeData.Manner]
  = PhonemeData.$fReadManner
instance GHC.Read.Read [PhonemeData.Morpheme]
  = PhonemeData.$fReadMorpheme
instance GHC.Read.Read [PhonemeData.Phonation]
  = PhonemeData.$fReadPhonation
instance GHC.Read.Read [PhonemeData.Phoneme]
  = PhonemeData.$fReadPhoneme
instance GHC.Read.Read [PhonemeData.Place]
  = PhonemeData.$fReadPlace
instance GHC.Read.Read [PhonemeData.Roundedness]
  = PhonemeData.$fReadRoundedness
instance GHC.Read.Read [PhonemeData.Word] = PhonemeData.$fReadWord
instance GHC.Show.Show [PhonemeData.Backness]
  = PhonemeData.$fShowBackness
instance GHC.Show.Show [PhonemeData.Height]
  = PhonemeData.$fShowHeight
instance GHC.Show.Show [PhonemeData.Length]
  = PhonemeData.$fShowLength
instance GHC.Show.Show [PhonemeData.Manner]
  = PhonemeData.$fShowManner
instance GHC.Show.Show [PhonemeData.Morpheme]
  = PhonemeData.$fShowMorpheme
instance GHC.Show.Show [PhonemeData.Phonation]
  = PhonemeData.$fShowPhonation
instance GHC.Show.Show [PhonemeData.Phoneme]
  = PhonemeData.$fShowPhoneme
instance GHC.Show.Show [PhonemeData.Place]
  = PhonemeData.$fShowPlace
instance GHC.Show.Show [PhonemeData.Roundedness]
  = PhonemeData.$fShowRoundedness
instance GHC.Show.Show [PhonemeData.Word] = PhonemeData.$fShowWord
"SPEC/PhonemeData $dmreadsPrec @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeData.Backness
  GHC.Read.$dmreadsPrec @ PhonemeData.Backness $dRead
  = PhonemeData.$fReadBackness_$s$dmreadsPrec
"SPEC/PhonemeData $dmreadsPrec @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeData.Height
  GHC.Read.$dmreadsPrec @ PhonemeData.Height $dRead
  = PhonemeData.$fReadHeight_$s$dmreadsPrec
"SPEC/PhonemeData $dmreadsPrec @ Length" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeData.Length
  GHC.Read.$dmreadsPrec @ PhonemeData.Length $dRead
  = PhonemeData.$fReadLength_$s$dmreadsPrec
"SPEC/PhonemeData $dmreadsPrec @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeData.Manner
  GHC.Read.$dmreadsPrec @ PhonemeData.Manner $dRead
  = PhonemeData.$fReadManner_$s$dmreadsPrec
"SPEC/PhonemeData $dmreadsPrec @ Phonation" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeData.Phonation
  GHC.Read.$dmreadsPrec @ PhonemeData.Phonation $dRead
  = PhonemeData.$fReadPhonation_$s$dmreadsPrec
"SPEC/PhonemeData $dmreadsPrec @ Phoneme" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeData.Phoneme
  GHC.Read.$dmreadsPrec @ PhonemeData.Phoneme $dRead
  = PhonemeData.$fReadPhoneme_$s$dmreadsPrec
"SPEC/PhonemeData $dmreadsPrec @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                    PhonemeData.Place
  GHC.Read.$dmreadsPrec @ PhonemeData.Place $dRead
  = PhonemeData.$fReadPlace_$s$dmreadsPrec
"SPEC/PhonemeData $dmreadsPrec @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          PhonemeData.Roundedness
  GHC.Read.$dmreadsPrec @ PhonemeData.Roundedness $dRead
  = PhonemeData.$fReadRoundedness_$s$dmreadsPrec
"SPEC/PhonemeData readListDefault @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          PhonemeData.Backness
  GHC.Read.readListDefault @ PhonemeData.Backness $dRead
  = PhonemeData.$fReadBackness_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeData.Height
  GHC.Read.readListDefault @ PhonemeData.Height $dRead
  = PhonemeData.$fReadHeight_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Length" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeData.Length
  GHC.Read.readListDefault @ PhonemeData.Length $dRead
  = PhonemeData.$fReadLength_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeData.Manner
  GHC.Read.readListDefault @ PhonemeData.Manner $dRead
  = PhonemeData.$fReadManner_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Morpheme" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          PhonemeData.Morpheme
  GHC.Read.readListDefault @ PhonemeData.Morpheme $dRead
  = PhonemeData.$fReadMorpheme_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Phonation" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                           PhonemeData.Phonation
  GHC.Read.readListDefault @ PhonemeData.Phonation $dRead
  = PhonemeData.$fReadPhonation_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Phoneme" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeData.Phoneme
  GHC.Read.readListDefault @ PhonemeData.Phoneme $dRead
  = PhonemeData.$fReadPhoneme_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeData.Place
  GHC.Read.readListDefault @ PhonemeData.Place $dRead
  = PhonemeData.$fReadPlace_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                             PhonemeData.Roundedness
  GHC.Read.readListDefault @ PhonemeData.Roundedness $dRead
  = PhonemeData.$fReadRoundedness_$sreadListDefault
"SPEC/PhonemeData readListDefault @ Word" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeData.Word
  GHC.Read.readListDefault @ PhonemeData.Word $dRead
  = PhonemeData.$fReadWord_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

