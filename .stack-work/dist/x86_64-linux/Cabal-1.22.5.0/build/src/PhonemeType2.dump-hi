
==================== FINAL INTERFACE ====================
2016-09-05 02:25:23.65022 UTC

interface conla_4HxSYcynNloL3TkunNPLrN:PhonemeType2 7103
  interface hash: f0324882b7f3019659052beca1f36fa6
  ABI hash: c07b384cc0a784e3fee4dcb9db67075c
  export-list hash: 88062b193b82d38245a3a936792746cd
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  PhonemeType2.ActiveArticulator{PhonemeType2.LARYNX PhonemeType2.LOWERLIP PhonemeType2.TONGUEBLADE PhonemeType2.TONGUEBODY PhonemeType2.TONGUEROOT PhonemeType2.TONGUETIP PhonemeType2.TONGUEUNDER}
  PhonemeType2.AirEscape{PhonemeType2.NASALIZED PhonemeType2.ORAL}
  PhonemeType2.Airstream{PhonemeType2.Airstream PhonemeType2.direction PhonemeType2.initiator}
  PhonemeType2.Backness{PhonemeType2.BACK PhonemeType2.CENTRAL PhonemeType2.FRONT PhonemeType2.NEARBACK PhonemeType2.NEARFRONT}
  PhonemeType2.Consonant{PhonemeType2.Consonant PhonemeType2.airstream PhonemeType2.manner PhonemeType2.phonation PhonemeType2.place}
  PhonemeType2.ConsonantPhonemeInventory{PhonemeType2.ConsonantPhonemeInventory}
  PhonemeType2.Direction{PhonemeType2.EGRESSIVE PhonemeType2.INGRESSIVE}
  PhonemeType2.Height{PhonemeType2.CLOSE PhonemeType2.CLOSEMID PhonemeType2.MID PhonemeType2.NEARCLOSE PhonemeType2.NEAROPEN PhonemeType2.OPEN PhonemeType2.OPENMID}
  PhonemeType2.Initiator{PhonemeType2.GLOTTIC PhonemeType2.LINGUAL PhonemeType2.PULMONIC}
  PhonemeType2.Laterality{PhonemeType2.LATERAL PhonemeType2.NONLATERAL}
  PhonemeType2.Length{PhonemeType2.LONG PhonemeType2.NORMAL PhonemeType2.SHORT}
  PhonemeType2.Manner{PhonemeType2.Manner PhonemeType2.airescape PhonemeType2.laterality PhonemeType2.mannerLength PhonemeType2.silibance PhonemeType2.stricture PhonemeType2.trill PhonemeType2.vot}
  PhonemeType2.MaybeContour{PhonemeType2.Contour PhonemeType2.NoContour}
  PhonemeType2.MaybeImpossible{PhonemeType2.Impossible PhonemeType2.Possible}
  PhonemeType2.PassiveArticulator{PhonemeType2.BACKRIDGE PhonemeType2.EPIGLOTTIS PhonemeType2.GLOTTIS PhonemeType2.HARDPALATE PhonemeType2.PHARYNX PhonemeType2.RIDGE PhonemeType2.SOFTPALATE PhonemeType2.TEETHRIDGE PhonemeType2.UPPERLIP PhonemeType2.UPPERTEETH PhonemeType2.UVULA}
  PhonemeType2.Phonation{PhonemeType2.BREATHY PhonemeType2.CLOSURE PhonemeType2.CREAKY PhonemeType2.MODAL PhonemeType2.SLACK PhonemeType2.STIFF PhonemeType2.VOICELESS}
  PhonemeType2.Place{PhonemeType2.Place PhonemeType2.active PhonemeType2.passive}
  PhonemeType2.Roundedness{PhonemeType2.ROUNDED PhonemeType2.UNROUNDED}
  PhonemeType2.Silibance{PhonemeType2.NONSILIBANT PhonemeType2.SILIBANT}
  PhonemeType2.Stricture{PhonemeType2.OCCLUSION PhonemeType2.SLIGHTTURBULENT PhonemeType2.TURBULENT}
  PhonemeType2.Trill{PhonemeType2.NOTTRILLED PhonemeType2.TRILLED}
  PhonemeType2.VOT{PhonemeType2.NEGATIVE PhonemeType2.POSITIVE PhonemeType2.ZERO}
  PhonemeType2.Vowel{PhonemeType2.VowelFeaturesContour PhonemeType2.airescape2 PhonemeType2.airstream2 PhonemeType2.backness PhonemeType2.height PhonemeType2.phonation2 PhonemeType2.roundedness PhonemeType2.vowelLength}
  PhonemeType2.VowelPhonemeInventory{PhonemeType2.VowelPhonemeInventory}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.ParserCombinators.ReadPrec 2590e0e0a57a86ac7c62727f4d868dd2
import  -/  base-4.8.2.0:Text.Read.Lex 724ca44ddd38ddc5f47a501d62736c26
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
d12400f0f662bae3ab829b7afc21c4a1
  $fBoundedActiveArticulator ::
    GHC.Enum.Bounded PhonemeType2.ActiveArticulator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.ActiveArticulator
                  PhonemeType2.LOWERLIP
                  PhonemeType2.LARYNX -}
e607fa7baa5310b2ce6a27a01c437a40
  $fBoundedAirEscape :: GHC.Enum.Bounded PhonemeType2.AirEscape
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.AirEscape
                  PhonemeType2.NASALIZED
                  PhonemeType2.ORAL -}
9918c87837d4f215d9649b53c1c134de
  $fBoundedBackness :: GHC.Enum.Bounded PhonemeType2.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness PhonemeType2.BACK PhonemeType2.FRONT -}
3de6396777539178df86bdf5ea849b5e
  $fBoundedDirection :: GHC.Enum.Bounded PhonemeType2.Direction
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Direction
                  PhonemeType2.INGRESSIVE
                  PhonemeType2.EGRESSIVE -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fBoundedHeight :: GHC.Enum.Bounded PhonemeType2.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height PhonemeType2.CLOSE PhonemeType2.OPEN -}
cf0efd186b87d1976dba6b7feef6e065
  $fBoundedInitiator :: GHC.Enum.Bounded PhonemeType2.Initiator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Initiator
                  PhonemeType2.LINGUAL
                  PhonemeType2.PULMONIC -}
f28c4174999e39eea0edf7a94bde9432
  $fBoundedLaterality :: GHC.Enum.Bounded PhonemeType2.Laterality
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Laterality
                  PhonemeType2.LATERAL
                  PhonemeType2.NONLATERAL -}
195969ff33df4040ea1319692f018c08
  $fBoundedLength :: GHC.Enum.Bounded PhonemeType2.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length PhonemeType2.SHORT PhonemeType2.LONG -}
b99e0542eafd4baafc4b7c93a8988262
  $fBoundedPassiveArticulator ::
    GHC.Enum.Bounded PhonemeType2.PassiveArticulator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PassiveArticulator
                  PhonemeType2.UPPERLIP
                  PhonemeType2.GLOTTIS -}
a4e0caad2d1174c9226145cc0019ed73
  $fBoundedPhonation :: GHC.Enum.Bounded PhonemeType2.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.VOICELESS
                  PhonemeType2.CLOSURE -}
e8a534a069fcf11d22fabc02549d84ae
  $fBoundedRoundedness :: GHC.Enum.Bounded PhonemeType2.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.UNROUNDED
                  PhonemeType2.ROUNDED -}
6f56b9eb1985eff94cee6d9814538c86
  $fBoundedSilibance :: GHC.Enum.Bounded PhonemeType2.Silibance
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Silibance
                  PhonemeType2.SILIBANT
                  PhonemeType2.NONSILIBANT -}
57e37fc45e7527176af3ce2952794c24
  $fBoundedStricture :: GHC.Enum.Bounded PhonemeType2.Stricture
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Stricture
                  PhonemeType2.OCCLUSION
                  PhonemeType2.SLIGHTTURBULENT -}
8650e80162817fe79be4acc77e003de6
  $fBoundedTrill :: GHC.Enum.Bounded PhonemeType2.Trill
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Trill
                  PhonemeType2.TRILLED
                  PhonemeType2.NOTTRILLED -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fBoundedVOT :: GHC.Enum.Bounded PhonemeType2.VOT
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.VOT PhonemeType2.POSITIVE PhonemeType2.NEGATIVE -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator ::
    GHC.Enum.Enum PhonemeType2.ActiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.ActiveArticulator
                  PhonemeType2.$fEnumActiveArticulator_$csucc
                  PhonemeType2.$fEnumActiveArticulator_$cpred
                  PhonemeType2.$fEnumActiveArticulator_$ctoEnum
                  PhonemeType2.$fEnumActiveArticulator_$cfromEnum
                  PhonemeType2.$fEnumActiveArticulator_$cenumFrom
                  PhonemeType2.$fEnumActiveArticulator_$cenumFromThen
                  PhonemeType2.$fEnumActiveArticulator_$cenumFromTo
                  PhonemeType2.$fEnumActiveArticulator_$cenumFromThenTo -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator1 :: [PhonemeType2.ActiveArticulator]
  {- Unfolding: (PhonemeType2.$fEnumActiveArticulator_go7 6) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator10 :: PhonemeType2.ActiveArticulator
  {- Strictness: b -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator2 :: [PhonemeType2.ActiveArticulator]
  {- Unfolding: (PhonemeType2.$fEnumActiveArticulator_go8 5) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator3 :: [PhonemeType2.ActiveArticulator]
  {- Unfolding: (PhonemeType2.$fEnumActiveArticulator_go9 4) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator4 :: [PhonemeType2.ActiveArticulator]
  {- Unfolding: (PhonemeType2.$fEnumActiveArticulator_go10 3) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator5 :: [PhonemeType2.ActiveArticulator]
  {- Unfolding: (PhonemeType2.$fEnumActiveArticulator_go11 2) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator6 :: [PhonemeType2.ActiveArticulator]
  {- Unfolding: (PhonemeType2.$fEnumActiveArticulator_go12 1) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator7 :: [PhonemeType2.ActiveArticulator]
  {- Unfolding: (PhonemeType2.$fEnumActiveArticulator_go13 0) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator8 ::
    GHC.Prim.Int# -> PhonemeType2.ActiveArticulator
  {- Arity: 1, Strictness: <L,U>b -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator9 :: PhonemeType2.ActiveArticulator
  {- Strictness: b -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_$cenumFrom ::
    PhonemeType2.ActiveArticulator -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.ActiveArticulator ->
                 case a18 of wild {
                   PhonemeType2.LOWERLIP -> PhonemeType2.$fEnumActiveArticulator7
                   PhonemeType2.TONGUEBLADE -> PhonemeType2.$fEnumActiveArticulator6
                   PhonemeType2.TONGUETIP -> PhonemeType2.$fEnumActiveArticulator5
                   PhonemeType2.TONGUEUNDER -> PhonemeType2.$fEnumActiveArticulator4
                   PhonemeType2.TONGUEBODY -> PhonemeType2.$fEnumActiveArticulator3
                   PhonemeType2.TONGUEROOT -> PhonemeType2.$fEnumActiveArticulator2
                   PhonemeType2.LARYNX -> PhonemeType2.$fEnumActiveArticulator1 }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_$cenumFromThen ::
    PhonemeType2.ActiveArticulator
    -> PhonemeType2.ActiveArticulator
    -> [PhonemeType2.ActiveArticulator]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.ActiveArticulator
                   b :: PhonemeType2.ActiveArticulator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.ActiveArticulator]
                                    PhonemeType2.$fEnumActiveArticulator_c
                                    (GHC.Types.[] @ PhonemeType2.ActiveArticulator)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.ActiveArticulator]
                                    PhonemeType2.$fEnumActiveArticulator_c
                                    (GHC.Types.[] @ PhonemeType2.ActiveArticulator)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.LOWERLIP -> $j1 0
                       PhonemeType2.TONGUEBLADE -> $j1 1
                       PhonemeType2.TONGUETIP -> $j1 2
                       PhonemeType2.TONGUEUNDER -> $j1 3
                       PhonemeType2.TONGUEBODY -> $j1 4
                       PhonemeType2.TONGUEROOT -> $j1 5
                       PhonemeType2.LARYNX -> $j1 6 }
                 } in
                 case a18 of wild {
                   PhonemeType2.LOWERLIP -> $j 0
                   PhonemeType2.TONGUEBLADE -> $j 1
                   PhonemeType2.TONGUETIP -> $j 2
                   PhonemeType2.TONGUEUNDER -> $j 3
                   PhonemeType2.TONGUEBODY -> $j 4
                   PhonemeType2.TONGUEROOT -> $j 5
                   PhonemeType2.LARYNX -> $j 6 }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_$cenumFromThenTo ::
    PhonemeType2.ActiveArticulator
    -> PhonemeType2.ActiveArticulator
    -> PhonemeType2.ActiveArticulator
    -> [PhonemeType2.ActiveArticulator]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_$cenumFromTo ::
    PhonemeType2.ActiveArticulator
    -> PhonemeType2.ActiveArticulator
    -> [PhonemeType2.ActiveArticulator]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.ActiveArticulator
                   y :: PhonemeType2.ActiveArticulator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.LOWERLIP
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.ActiveArticulator }
                       PhonemeType2.TONGUEBLADE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.ActiveArticulator }
                       PhonemeType2.TONGUETIP
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.ActiveArticulator }
                       PhonemeType2.TONGUEUNDER
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.ActiveArticulator }
                       PhonemeType2.TONGUEBODY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.ActiveArticulator }
                       PhonemeType2.TONGUEROOT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.ActiveArticulator }
                       PhonemeType2.LARYNX
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.ActiveArticulator } }
                 } in
                 case x of wild {
                   PhonemeType2.LOWERLIP -> $j 0
                   PhonemeType2.TONGUEBLADE -> $j 1
                   PhonemeType2.TONGUETIP -> $j 2
                   PhonemeType2.TONGUEUNDER -> $j 3
                   PhonemeType2.TONGUEBODY -> $j 4
                   PhonemeType2.TONGUEROOT -> $j 5
                   PhonemeType2.LARYNX -> $j 6 }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_$cfromEnum ::
    PhonemeType2.ActiveArticulator -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.ActiveArticulator ->
                 case w of wild {
                   PhonemeType2.LOWERLIP -> GHC.Types.I# 0
                   PhonemeType2.TONGUEBLADE -> GHC.Types.I# 1
                   PhonemeType2.TONGUETIP -> GHC.Types.I# 2
                   PhonemeType2.TONGUEUNDER -> GHC.Types.I# 3
                   PhonemeType2.TONGUEBODY -> GHC.Types.I# 4
                   PhonemeType2.TONGUEROOT -> GHC.Types.I# 5
                   PhonemeType2.LARYNX -> GHC.Types.I# 6 }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_$cpred ::
    PhonemeType2.ActiveArticulator -> PhonemeType2.ActiveArticulator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.ActiveArticulator ->
                 case a18 of wild {
                   PhonemeType2.LOWERLIP -> PhonemeType2.$fEnumActiveArticulator9
                   PhonemeType2.TONGUEBLADE -> PhonemeType2.LOWERLIP
                   PhonemeType2.TONGUETIP -> PhonemeType2.TONGUEBLADE
                   PhonemeType2.TONGUEUNDER -> PhonemeType2.TONGUETIP
                   PhonemeType2.TONGUEBODY -> PhonemeType2.TONGUEUNDER
                   PhonemeType2.TONGUEROOT -> PhonemeType2.TONGUEBODY
                   PhonemeType2.LARYNX -> PhonemeType2.TONGUEROOT }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_$csucc ::
    PhonemeType2.ActiveArticulator -> PhonemeType2.ActiveArticulator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.ActiveArticulator ->
                 case a18 of wild {
                   PhonemeType2.LOWERLIP -> PhonemeType2.TONGUEBLADE
                   PhonemeType2.TONGUEBLADE -> PhonemeType2.TONGUETIP
                   PhonemeType2.TONGUETIP -> PhonemeType2.TONGUEUNDER
                   PhonemeType2.TONGUEUNDER -> PhonemeType2.TONGUEBODY
                   PhonemeType2.TONGUEBODY -> PhonemeType2.TONGUEROOT
                   PhonemeType2.TONGUEROOT -> PhonemeType2.LARYNX
                   PhonemeType2.LARYNX -> PhonemeType2.$fEnumActiveArticulator10 }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_$ctoEnum ::
    GHC.Types.Int -> PhonemeType2.ActiveArticulator
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum ww1 }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_c ::
    GHC.Types.Int
    -> [PhonemeType2.ActiveArticulator]
    -> [PhonemeType2.ActiveArticulator]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.ActiveArticulator] ->
                 GHC.Types.:
                   @ PhonemeType2.ActiveArticulator
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.ActiveArticulator a18 })
                   ys) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go1 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go10 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go11 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go12 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go13 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go2 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go3 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go4 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go5 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go6 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go7 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go8 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEnumActiveArticulator_go9 ::
    GHC.Prim.Int# -> [PhonemeType2.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape :: GHC.Enum.Enum PhonemeType2.AirEscape
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.AirEscape
                  PhonemeType2.$fEnumAirEscape_$csucc
                  PhonemeType2.$fEnumAirEscape_$cpred
                  PhonemeType2.$fEnumAirEscape_$ctoEnum
                  PhonemeType2.$fEnumAirEscape_$cfromEnum
                  PhonemeType2.$fEnumAirEscape_$cenumFrom
                  PhonemeType2.$fEnumAirEscape_$cenumFromThen
                  PhonemeType2.$fEnumAirEscape_$cenumFromTo
                  PhonemeType2.$fEnumAirEscape_$cenumFromThenTo -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape1 :: GHC.Prim.Int# -> PhonemeType2.AirEscape
  {- Arity: 1, Strictness: <L,U>b -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape2 :: [PhonemeType2.AirEscape]
  {- Unfolding: (PhonemeType2.$fEnumAirEscape_go2 1) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape3 :: [PhonemeType2.AirEscape]
  {- Unfolding: (PhonemeType2.$fEnumAirEscape_go3 0) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape4 :: PhonemeType2.AirEscape
  {- Strictness: b -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape5 :: PhonemeType2.AirEscape
  {- Strictness: b -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_$cenumFrom ::
    PhonemeType2.AirEscape -> [PhonemeType2.AirEscape]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.AirEscape ->
                 case a18 of wild {
                   PhonemeType2.NASALIZED -> PhonemeType2.$fEnumAirEscape3
                   PhonemeType2.ORAL -> PhonemeType2.$fEnumAirEscape2 }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_$cenumFromThen ::
    PhonemeType2.AirEscape
    -> PhonemeType2.AirEscape -> [PhonemeType2.AirEscape]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.AirEscape
                   b :: PhonemeType2.AirEscape ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.AirEscape]
                                    PhonemeType2.$fEnumAirEscape_c1
                                    (GHC.Types.[] @ PhonemeType2.AirEscape)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.AirEscape]
                                    PhonemeType2.$fEnumAirEscape_c1
                                    (GHC.Types.[] @ PhonemeType2.AirEscape)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.NASALIZED -> $j1 0 PhonemeType2.ORAL -> $j1 1 }
                 } in
                 case a18 of wild {
                   PhonemeType2.NASALIZED -> $j 0 PhonemeType2.ORAL -> $j 1 }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_$cenumFromThenTo ::
    PhonemeType2.AirEscape
    -> PhonemeType2.AirEscape
    -> PhonemeType2.AirEscape
    -> [PhonemeType2.AirEscape]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.AirEscape
                   x2 :: PhonemeType2.AirEscape
                   y :: PhonemeType2.AirEscape ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.NASALIZED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.AirEscape]
                                     PhonemeType2.$fEnumAirEscape_c
                                     (GHC.Types.[] @ PhonemeType2.AirEscape)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.AirEscape]
                                     PhonemeType2.$fEnumAirEscape_c
                                     (GHC.Types.[] @ PhonemeType2.AirEscape)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.ORAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.AirEscape]
                                     PhonemeType2.$fEnumAirEscape_c
                                     (GHC.Types.[] @ PhonemeType2.AirEscape)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.AirEscape]
                                     PhonemeType2.$fEnumAirEscape_c
                                     (GHC.Types.[] @ PhonemeType2.AirEscape)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.NASALIZED -> $j1 0 PhonemeType2.ORAL -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType2.NASALIZED -> $j 0 PhonemeType2.ORAL -> $j 1 }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_$cenumFromTo ::
    PhonemeType2.AirEscape
    -> PhonemeType2.AirEscape -> [PhonemeType2.AirEscape]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.AirEscape
                   y :: PhonemeType2.AirEscape ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.NASALIZED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumAirEscape_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.AirEscape }
                       PhonemeType2.ORAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumAirEscape_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.AirEscape } }
                 } in
                 case x of wild {
                   PhonemeType2.NASALIZED -> $j 0 PhonemeType2.ORAL -> $j 1 }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_$cfromEnum ::
    PhonemeType2.AirEscape -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.AirEscape ->
                 case a18 of wild {
                   PhonemeType2.NASALIZED -> GHC.Types.I# 0
                   PhonemeType2.ORAL -> GHC.Types.I# 1 }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_$cpred ::
    PhonemeType2.AirEscape -> PhonemeType2.AirEscape
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.AirEscape ->
                 case a18 of wild {
                   PhonemeType2.NASALIZED -> PhonemeType2.$fEnumAirEscape4
                   PhonemeType2.ORAL -> PhonemeType2.NASALIZED }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_$csucc ::
    PhonemeType2.AirEscape -> PhonemeType2.AirEscape
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.AirEscape ->
                 case a18 of wild {
                   PhonemeType2.NASALIZED -> PhonemeType2.ORAL
                   PhonemeType2.ORAL -> PhonemeType2.$fEnumAirEscape5 }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_$ctoEnum :: GHC.Types.Int -> PhonemeType2.AirEscape
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum1 ww1 }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_c ::
    GHC.Types.Int
    -> [PhonemeType2.AirEscape] -> [PhonemeType2.AirEscape]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.AirEscape] ->
                 GHC.Types.:
                   @ PhonemeType2.AirEscape
                   (PhonemeType2.$fEnumAirEscape_$ctoEnum x)
                   ys) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.AirEscape] -> [PhonemeType2.AirEscape]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.AirEscape] ->
                 GHC.Types.:
                   @ PhonemeType2.AirEscape
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.AirEscape a18 })
                   ys) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_go :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
  {- Arity: 1, Strictness: <L,U> -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_go1 :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
  {- Arity: 1, Strictness: <L,U> -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_go2 :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEnumAirEscape_go3 :: GHC.Prim.Int# -> [PhonemeType2.AirEscape]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness :: GHC.Enum.Enum PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fEnumBackness_$csucc
                  PhonemeType2.$fEnumBackness_$cpred
                  PhonemeType2.$fEnumBackness_$ctoEnum
                  PhonemeType2.$fEnumBackness_$cfromEnum
                  PhonemeType2.$fEnumBackness_$cenumFrom
                  PhonemeType2.$fEnumBackness_$cenumFromThen
                  PhonemeType2.$fEnumBackness_$cenumFromTo
                  PhonemeType2.$fEnumBackness_$cenumFromThenTo -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness1 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go5 4) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness2 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go6 3) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness3 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go7 2) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness4 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go8 1) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness5 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go9 0) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness6 :: GHC.Prim.Int# -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>b -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness7 :: PhonemeType2.Backness
  {- Strictness: b -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness8 :: PhonemeType2.Backness
  {- Strictness: b -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_$cenumFrom ::
    PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Backness ->
                 case a18 of wild {
                   PhonemeType2.BACK -> PhonemeType2.$fEnumBackness5
                   PhonemeType2.NEARBACK -> PhonemeType2.$fEnumBackness4
                   PhonemeType2.CENTRAL -> PhonemeType2.$fEnumBackness3
                   PhonemeType2.NEARFRONT -> PhonemeType2.$fEnumBackness2
                   PhonemeType2.FRONT -> PhonemeType2.$fEnumBackness1 }) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_$cenumFromThen ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Backness]
                                    PhonemeType2.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType2.Backness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Backness]
                                    PhonemeType2.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType2.Backness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 4 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.BACK -> $j1 0
                       PhonemeType2.NEARBACK -> $j1 1
                       PhonemeType2.CENTRAL -> $j1 2
                       PhonemeType2.NEARFRONT -> $j1 3
                       PhonemeType2.FRONT -> $j1 4 }
                 } in
                 case a18 of wild {
                   PhonemeType2.BACK -> $j 0
                   PhonemeType2.NEARBACK -> $j 1
                   PhonemeType2.CENTRAL -> $j 2
                   PhonemeType2.NEARFRONT -> $j 3
                   PhonemeType2.FRONT -> $j 4 }) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_$cenumFromThenTo ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness
    -> PhonemeType2.Backness
    -> [PhonemeType2.Backness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_$cenumFromTo ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Backness
                   y :: PhonemeType2.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.BACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.NEARBACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.CENTRAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.NEARFRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.FRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness } }
                 } in
                 case x of wild {
                   PhonemeType2.BACK -> $j 0
                   PhonemeType2.NEARBACK -> $j 1
                   PhonemeType2.CENTRAL -> $j 2
                   PhonemeType2.NEARFRONT -> $j 3
                   PhonemeType2.FRONT -> $j 4 }) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_$cfromEnum :: PhonemeType2.Backness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.Backness ->
                 case w of wild {
                   PhonemeType2.BACK -> GHC.Types.I# 0
                   PhonemeType2.NEARBACK -> GHC.Types.I# 1
                   PhonemeType2.CENTRAL -> GHC.Types.I# 2
                   PhonemeType2.NEARFRONT -> GHC.Types.I# 3
                   PhonemeType2.FRONT -> GHC.Types.I# 4 }) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_$cpred ::
    PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Backness ->
                 case a18 of wild {
                   PhonemeType2.BACK -> PhonemeType2.$fEnumBackness7
                   PhonemeType2.NEARBACK -> PhonemeType2.BACK
                   PhonemeType2.CENTRAL -> PhonemeType2.NEARBACK
                   PhonemeType2.NEARFRONT -> PhonemeType2.CENTRAL
                   PhonemeType2.FRONT -> PhonemeType2.NEARFRONT }) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_$csucc ::
    PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Backness ->
                 case a18 of wild {
                   PhonemeType2.BACK -> PhonemeType2.NEARBACK
                   PhonemeType2.NEARBACK -> PhonemeType2.CENTRAL
                   PhonemeType2.CENTRAL -> PhonemeType2.NEARFRONT
                   PhonemeType2.NEARFRONT -> PhonemeType2.FRONT
                   PhonemeType2.FRONT -> PhonemeType2.$fEnumBackness8 }) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum2 ww1 }) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_c ::
    GHC.Types.Int -> [PhonemeType2.Backness] -> [PhonemeType2.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Backness] ->
                 GHC.Types.:
                   @ PhonemeType2.Backness
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Backness a18 })
                   ys) -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go1 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go2 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go3 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go4 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go5 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go6 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go7 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go8 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9918c87837d4f215d9649b53c1c134de
  $fEnumBackness_go9 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection :: GHC.Enum.Enum PhonemeType2.Direction
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Direction
                  PhonemeType2.$fEnumDirection_$csucc
                  PhonemeType2.$fEnumDirection_$cpred
                  PhonemeType2.$fEnumDirection_$ctoEnum
                  PhonemeType2.$fEnumDirection_$cfromEnum
                  PhonemeType2.$fEnumDirection_$cenumFrom
                  PhonemeType2.$fEnumDirection_$cenumFromThen
                  PhonemeType2.$fEnumDirection_$cenumFromTo
                  PhonemeType2.$fEnumDirection_$cenumFromThenTo -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection1 :: GHC.Prim.Int# -> PhonemeType2.Direction
  {- Arity: 1, Strictness: <L,U>b -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection2 :: [PhonemeType2.Direction]
  {- Unfolding: (PhonemeType2.$fEnumDirection_go2 1) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection3 :: [PhonemeType2.Direction]
  {- Unfolding: (PhonemeType2.$fEnumDirection_go3 0) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection4 :: PhonemeType2.Direction
  {- Strictness: b -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection5 :: PhonemeType2.Direction
  {- Strictness: b -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_$cenumFrom ::
    PhonemeType2.Direction -> [PhonemeType2.Direction]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Direction ->
                 case a18 of wild {
                   PhonemeType2.INGRESSIVE -> PhonemeType2.$fEnumDirection3
                   PhonemeType2.EGRESSIVE -> PhonemeType2.$fEnumDirection2 }) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_$cenumFromThen ::
    PhonemeType2.Direction
    -> PhonemeType2.Direction -> [PhonemeType2.Direction]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Direction
                   b :: PhonemeType2.Direction ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Direction]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Direction]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Direction]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Direction]
                                    PhonemeType2.$fEnumDirection_c1
                                    (GHC.Types.[] @ PhonemeType2.Direction)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Direction]
                                    PhonemeType2.$fEnumDirection_c1
                                    (GHC.Types.[] @ PhonemeType2.Direction)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.INGRESSIVE -> $j1 0 PhonemeType2.EGRESSIVE -> $j1 1 }
                 } in
                 case a18 of wild {
                   PhonemeType2.INGRESSIVE -> $j 0
                   PhonemeType2.EGRESSIVE -> $j 1 }) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_$cenumFromThenTo ::
    PhonemeType2.Direction
    -> PhonemeType2.Direction
    -> PhonemeType2.Direction
    -> [PhonemeType2.Direction]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Direction
                   x2 :: PhonemeType2.Direction
                   y :: PhonemeType2.Direction ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Direction]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Direction]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.INGRESSIVE
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Direction]
                                     PhonemeType2.$fEnumDirection_c
                                     (GHC.Types.[] @ PhonemeType2.Direction)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Direction]
                                     PhonemeType2.$fEnumDirection_c
                                     (GHC.Types.[] @ PhonemeType2.Direction)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.EGRESSIVE
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Direction]
                                     PhonemeType2.$fEnumDirection_c
                                     (GHC.Types.[] @ PhonemeType2.Direction)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Direction]
                                     PhonemeType2.$fEnumDirection_c
                                     (GHC.Types.[] @ PhonemeType2.Direction)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.INGRESSIVE -> $j1 0 PhonemeType2.EGRESSIVE -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType2.INGRESSIVE -> $j 0
                   PhonemeType2.EGRESSIVE -> $j 1 }) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_$cenumFromTo ::
    PhonemeType2.Direction
    -> PhonemeType2.Direction -> [PhonemeType2.Direction]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Direction
                   y :: PhonemeType2.Direction ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Direction]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.INGRESSIVE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumDirection_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Direction }
                       PhonemeType2.EGRESSIVE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumDirection_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Direction } }
                 } in
                 case x of wild {
                   PhonemeType2.INGRESSIVE -> $j 0
                   PhonemeType2.EGRESSIVE -> $j 1 }) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_$cfromEnum ::
    PhonemeType2.Direction -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Direction ->
                 case a18 of wild {
                   PhonemeType2.INGRESSIVE -> GHC.Types.I# 0
                   PhonemeType2.EGRESSIVE -> GHC.Types.I# 1 }) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_$cpred ::
    PhonemeType2.Direction -> PhonemeType2.Direction
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Direction ->
                 case a18 of wild {
                   PhonemeType2.INGRESSIVE -> PhonemeType2.$fEnumDirection4
                   PhonemeType2.EGRESSIVE -> PhonemeType2.INGRESSIVE }) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_$csucc ::
    PhonemeType2.Direction -> PhonemeType2.Direction
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Direction ->
                 case a18 of wild {
                   PhonemeType2.INGRESSIVE -> PhonemeType2.EGRESSIVE
                   PhonemeType2.EGRESSIVE -> PhonemeType2.$fEnumDirection5 }) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Direction
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum3 ww1 }) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_c ::
    GHC.Types.Int
    -> [PhonemeType2.Direction] -> [PhonemeType2.Direction]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Direction] ->
                 GHC.Types.:
                   @ PhonemeType2.Direction
                   (PhonemeType2.$fEnumDirection_$ctoEnum x)
                   ys) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.Direction] -> [PhonemeType2.Direction]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Direction] ->
                 GHC.Types.:
                   @ PhonemeType2.Direction
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Direction a18 })
                   ys) -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_go :: GHC.Prim.Int# -> [PhonemeType2.Direction]
  {- Arity: 1, Strictness: <L,U> -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_go1 :: GHC.Prim.Int# -> [PhonemeType2.Direction]
  {- Arity: 1, Strictness: <L,U> -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_go2 :: GHC.Prim.Int# -> [PhonemeType2.Direction]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
3de6396777539178df86bdf5ea849b5e
  $fEnumDirection_go3 :: GHC.Prim.Int# -> [PhonemeType2.Direction]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight :: GHC.Enum.Enum PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fEnumHeight_$csucc
                  PhonemeType2.$fEnumHeight_$cpred
                  PhonemeType2.$fEnumHeight_$ctoEnum
                  PhonemeType2.$fEnumHeight_$cfromEnum
                  PhonemeType2.$fEnumHeight_$cenumFrom
                  PhonemeType2.$fEnumHeight_$cenumFromThen
                  PhonemeType2.$fEnumHeight_$cenumFromTo
                  PhonemeType2.$fEnumHeight_$cenumFromThenTo -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight1 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go7 6) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight10 :: PhonemeType2.Height
  {- Strictness: b -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight2 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go8 5) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight3 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go9 4) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight4 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go10 3) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight5 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go11 2) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight6 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go12 1) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight7 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go13 0) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight8 :: GHC.Prim.Int# -> PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>b -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight9 :: PhonemeType2.Height
  {- Strictness: b -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_$cenumFrom ::
    PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Height ->
                 case a18 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.$fEnumHeight7
                   PhonemeType2.NEARCLOSE -> PhonemeType2.$fEnumHeight6
                   PhonemeType2.CLOSEMID -> PhonemeType2.$fEnumHeight5
                   PhonemeType2.MID -> PhonemeType2.$fEnumHeight4
                   PhonemeType2.OPENMID -> PhonemeType2.$fEnumHeight3
                   PhonemeType2.NEAROPEN -> PhonemeType2.$fEnumHeight2
                   PhonemeType2.OPEN -> PhonemeType2.$fEnumHeight1 }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_$cenumFromThen ::
    PhonemeType2.Height -> PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Height
                   b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Height]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Height]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Height]
                                    PhonemeType2.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType2.Height)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Height]
                                    PhonemeType2.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType2.Height)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.CLOSE -> $j1 0
                       PhonemeType2.NEARCLOSE -> $j1 1
                       PhonemeType2.CLOSEMID -> $j1 2
                       PhonemeType2.MID -> $j1 3
                       PhonemeType2.OPENMID -> $j1 4
                       PhonemeType2.NEAROPEN -> $j1 5
                       PhonemeType2.OPEN -> $j1 6 }
                 } in
                 case a18 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_$cenumFromThenTo ::
    PhonemeType2.Height
    -> PhonemeType2.Height
    -> PhonemeType2.Height
    -> [PhonemeType2.Height]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_$cenumFromTo ::
    PhonemeType2.Height -> PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Height y :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.CLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.NEARCLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.CLOSEMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.MID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.OPENMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.NEAROPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.OPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height } }
                 } in
                 case x of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_$cfromEnum :: PhonemeType2.Height -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.Height ->
                 case w of wild {
                   PhonemeType2.CLOSE -> GHC.Types.I# 0
                   PhonemeType2.NEARCLOSE -> GHC.Types.I# 1
                   PhonemeType2.CLOSEMID -> GHC.Types.I# 2
                   PhonemeType2.MID -> GHC.Types.I# 3
                   PhonemeType2.OPENMID -> GHC.Types.I# 4
                   PhonemeType2.NEAROPEN -> GHC.Types.I# 5
                   PhonemeType2.OPEN -> GHC.Types.I# 6 }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_$cpred :: PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Height ->
                 case a18 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.$fEnumHeight9
                   PhonemeType2.NEARCLOSE -> PhonemeType2.CLOSE
                   PhonemeType2.CLOSEMID -> PhonemeType2.NEARCLOSE
                   PhonemeType2.MID -> PhonemeType2.CLOSEMID
                   PhonemeType2.OPENMID -> PhonemeType2.MID
                   PhonemeType2.NEAROPEN -> PhonemeType2.OPENMID
                   PhonemeType2.OPEN -> PhonemeType2.NEAROPEN }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_$csucc :: PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Height ->
                 case a18 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.NEARCLOSE
                   PhonemeType2.NEARCLOSE -> PhonemeType2.CLOSEMID
                   PhonemeType2.CLOSEMID -> PhonemeType2.MID
                   PhonemeType2.MID -> PhonemeType2.OPENMID
                   PhonemeType2.OPENMID -> PhonemeType2.NEAROPEN
                   PhonemeType2.NEAROPEN -> PhonemeType2.OPEN
                   PhonemeType2.OPEN -> PhonemeType2.$fEnumHeight10 }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum4 ww1 }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_c ::
    GHC.Types.Int -> [PhonemeType2.Height] -> [PhonemeType2.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Height] ->
                 GHC.Types.:
                   @ PhonemeType2.Height
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Height a18 })
                   ys) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go1 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go10 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go11 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go12 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go13 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go2 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go3 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go4 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go5 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go6 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go7 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go8 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEnumHeight_go9 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator :: GHC.Enum.Enum PhonemeType2.Initiator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Initiator
                  PhonemeType2.$fEnumInitiator_$csucc
                  PhonemeType2.$fEnumInitiator_$cpred
                  PhonemeType2.$fEnumInitiator_$ctoEnum
                  PhonemeType2.$fEnumInitiator_$cfromEnum
                  PhonemeType2.$fEnumInitiator_$cenumFrom
                  PhonemeType2.$fEnumInitiator_$cenumFromThen
                  PhonemeType2.$fEnumInitiator_$cenumFromTo
                  PhonemeType2.$fEnumInitiator_$cenumFromThenTo -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator1 :: GHC.Prim.Int# -> PhonemeType2.Initiator
  {- Arity: 1, Strictness: <L,U>b -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator2 :: [PhonemeType2.Initiator]
  {- Unfolding: (PhonemeType2.$fEnumInitiator_go3 2) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator3 :: [PhonemeType2.Initiator]
  {- Unfolding: (PhonemeType2.$fEnumInitiator_go4 1) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator4 :: [PhonemeType2.Initiator]
  {- Unfolding: (PhonemeType2.$fEnumInitiator_go5 0) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator5 :: PhonemeType2.Initiator
  {- Strictness: b -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator6 :: PhonemeType2.Initiator
  {- Strictness: b -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_$cenumFrom ::
    PhonemeType2.Initiator -> [PhonemeType2.Initiator]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Initiator ->
                 case a18 of wild {
                   PhonemeType2.LINGUAL -> PhonemeType2.$fEnumInitiator4
                   PhonemeType2.GLOTTIC -> PhonemeType2.$fEnumInitiator3
                   PhonemeType2.PULMONIC -> PhonemeType2.$fEnumInitiator2 }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_$cenumFromThen ::
    PhonemeType2.Initiator
    -> PhonemeType2.Initiator -> [PhonemeType2.Initiator]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Initiator
                   b :: PhonemeType2.Initiator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Initiator]
                                    PhonemeType2.$fEnumInitiator_c1
                                    (GHC.Types.[] @ PhonemeType2.Initiator)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Initiator]
                                    PhonemeType2.$fEnumInitiator_c1
                                    (GHC.Types.[] @ PhonemeType2.Initiator)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.LINGUAL -> $j1 0
                       PhonemeType2.GLOTTIC -> $j1 1
                       PhonemeType2.PULMONIC -> $j1 2 }
                 } in
                 case a18 of wild {
                   PhonemeType2.LINGUAL -> $j 0
                   PhonemeType2.GLOTTIC -> $j 1
                   PhonemeType2.PULMONIC -> $j 2 }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_$cenumFromThenTo ::
    PhonemeType2.Initiator
    -> PhonemeType2.Initiator
    -> PhonemeType2.Initiator
    -> [PhonemeType2.Initiator]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Initiator
                   x2 :: PhonemeType2.Initiator
                   y :: PhonemeType2.Initiator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.LINGUAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Initiator]
                                     PhonemeType2.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType2.Initiator)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Initiator]
                                     PhonemeType2.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType2.Initiator)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.GLOTTIC
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Initiator]
                                     PhonemeType2.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType2.Initiator)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Initiator]
                                     PhonemeType2.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType2.Initiator)
                                     x4
                                     x5
                                     1 }
                           PhonemeType2.PULMONIC
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Initiator]
                                     PhonemeType2.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType2.Initiator)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Initiator]
                                     PhonemeType2.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType2.Initiator)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.LINGUAL -> $j1 0
                       PhonemeType2.GLOTTIC -> $j1 1
                       PhonemeType2.PULMONIC -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType2.LINGUAL -> $j 0
                   PhonemeType2.GLOTTIC -> $j 1
                   PhonemeType2.PULMONIC -> $j 2 }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_$cenumFromTo ::
    PhonemeType2.Initiator
    -> PhonemeType2.Initiator -> [PhonemeType2.Initiator]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Initiator
                   y :: PhonemeType2.Initiator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.LINGUAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumInitiator_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Initiator }
                       PhonemeType2.GLOTTIC
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumInitiator_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Initiator }
                       PhonemeType2.PULMONIC
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumInitiator_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Initiator } }
                 } in
                 case x of wild {
                   PhonemeType2.LINGUAL -> $j 0
                   PhonemeType2.GLOTTIC -> $j 1
                   PhonemeType2.PULMONIC -> $j 2 }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_$cfromEnum ::
    PhonemeType2.Initiator -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Initiator ->
                 case a18 of wild {
                   PhonemeType2.LINGUAL -> GHC.Types.I# 0
                   PhonemeType2.GLOTTIC -> GHC.Types.I# 1
                   PhonemeType2.PULMONIC -> GHC.Types.I# 2 }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_$cpred ::
    PhonemeType2.Initiator -> PhonemeType2.Initiator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Initiator ->
                 case a18 of wild {
                   PhonemeType2.LINGUAL -> PhonemeType2.$fEnumInitiator5
                   PhonemeType2.GLOTTIC -> PhonemeType2.LINGUAL
                   PhonemeType2.PULMONIC -> PhonemeType2.GLOTTIC }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_$csucc ::
    PhonemeType2.Initiator -> PhonemeType2.Initiator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Initiator ->
                 case a18 of wild {
                   PhonemeType2.LINGUAL -> PhonemeType2.GLOTTIC
                   PhonemeType2.GLOTTIC -> PhonemeType2.PULMONIC
                   PhonemeType2.PULMONIC -> PhonemeType2.$fEnumInitiator6 }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Initiator
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum5 ww1 }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_c ::
    GHC.Types.Int
    -> [PhonemeType2.Initiator] -> [PhonemeType2.Initiator]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Initiator] ->
                 GHC.Types.:
                   @ PhonemeType2.Initiator
                   (PhonemeType2.$fEnumInitiator_$ctoEnum x)
                   ys) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.Initiator] -> [PhonemeType2.Initiator]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Initiator] ->
                 GHC.Types.:
                   @ PhonemeType2.Initiator
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Initiator a18 })
                   ys) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_go :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
  {- Arity: 1, Strictness: <L,U> -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_go1 :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
  {- Arity: 1, Strictness: <L,U> -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_go2 :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
  {- Arity: 1, Strictness: <L,U> -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_go3 :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_go4 :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
cf0efd186b87d1976dba6b7feef6e065
  $fEnumInitiator_go5 :: GHC.Prim.Int# -> [PhonemeType2.Initiator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality :: GHC.Enum.Enum PhonemeType2.Laterality
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Laterality
                  PhonemeType2.$fEnumLaterality_$csucc
                  PhonemeType2.$fEnumLaterality_$cpred
                  PhonemeType2.$fEnumLaterality_$ctoEnum
                  PhonemeType2.$fEnumLaterality_$cfromEnum
                  PhonemeType2.$fEnumLaterality_$cenumFrom
                  PhonemeType2.$fEnumLaterality_$cenumFromThen
                  PhonemeType2.$fEnumLaterality_$cenumFromTo
                  PhonemeType2.$fEnumLaterality_$cenumFromThenTo -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality1 :: GHC.Prim.Int# -> PhonemeType2.Laterality
  {- Arity: 1, Strictness: <L,U>b -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality2 :: [PhonemeType2.Laterality]
  {- Unfolding: (PhonemeType2.$fEnumLaterality_go2 1) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality3 :: [PhonemeType2.Laterality]
  {- Unfolding: (PhonemeType2.$fEnumLaterality_go3 0) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality4 :: PhonemeType2.Laterality
  {- Strictness: b -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality5 :: PhonemeType2.Laterality
  {- Strictness: b -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_$cenumFrom ::
    PhonemeType2.Laterality -> [PhonemeType2.Laterality]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Laterality ->
                 case a18 of wild {
                   PhonemeType2.LATERAL -> PhonemeType2.$fEnumLaterality3
                   PhonemeType2.NONLATERAL -> PhonemeType2.$fEnumLaterality2 }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_$cenumFromThen ::
    PhonemeType2.Laterality
    -> PhonemeType2.Laterality -> [PhonemeType2.Laterality]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Laterality
                   b :: PhonemeType2.Laterality ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Laterality]
                                    PhonemeType2.$fEnumLaterality_c1
                                    (GHC.Types.[] @ PhonemeType2.Laterality)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Laterality]
                                    PhonemeType2.$fEnumLaterality_c1
                                    (GHC.Types.[] @ PhonemeType2.Laterality)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.LATERAL -> $j1 0 PhonemeType2.NONLATERAL -> $j1 1 }
                 } in
                 case a18 of wild {
                   PhonemeType2.LATERAL -> $j 0 PhonemeType2.NONLATERAL -> $j 1 }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_$cenumFromThenTo ::
    PhonemeType2.Laterality
    -> PhonemeType2.Laterality
    -> PhonemeType2.Laterality
    -> [PhonemeType2.Laterality]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Laterality
                   x2 :: PhonemeType2.Laterality
                   y :: PhonemeType2.Laterality ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.LATERAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Laterality]
                                     PhonemeType2.$fEnumLaterality_c
                                     (GHC.Types.[] @ PhonemeType2.Laterality)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Laterality]
                                     PhonemeType2.$fEnumLaterality_c
                                     (GHC.Types.[] @ PhonemeType2.Laterality)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.NONLATERAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Laterality]
                                     PhonemeType2.$fEnumLaterality_c
                                     (GHC.Types.[] @ PhonemeType2.Laterality)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Laterality]
                                     PhonemeType2.$fEnumLaterality_c
                                     (GHC.Types.[] @ PhonemeType2.Laterality)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.LATERAL -> $j1 0 PhonemeType2.NONLATERAL -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType2.LATERAL -> $j 0 PhonemeType2.NONLATERAL -> $j 1 }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_$cenumFromTo ::
    PhonemeType2.Laterality
    -> PhonemeType2.Laterality -> [PhonemeType2.Laterality]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Laterality
                   y :: PhonemeType2.Laterality ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.LATERAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumLaterality_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Laterality }
                       PhonemeType2.NONLATERAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumLaterality_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Laterality } }
                 } in
                 case x of wild {
                   PhonemeType2.LATERAL -> $j 0 PhonemeType2.NONLATERAL -> $j 1 }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_$cfromEnum ::
    PhonemeType2.Laterality -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Laterality ->
                 case a18 of wild {
                   PhonemeType2.LATERAL -> GHC.Types.I# 0
                   PhonemeType2.NONLATERAL -> GHC.Types.I# 1 }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_$cpred ::
    PhonemeType2.Laterality -> PhonemeType2.Laterality
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Laterality ->
                 case a18 of wild {
                   PhonemeType2.LATERAL -> PhonemeType2.$fEnumLaterality4
                   PhonemeType2.NONLATERAL -> PhonemeType2.LATERAL }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_$csucc ::
    PhonemeType2.Laterality -> PhonemeType2.Laterality
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Laterality ->
                 case a18 of wild {
                   PhonemeType2.LATERAL -> PhonemeType2.NONLATERAL
                   PhonemeType2.NONLATERAL -> PhonemeType2.$fEnumLaterality5 }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_$ctoEnum ::
    GHC.Types.Int -> PhonemeType2.Laterality
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum6 ww1 }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_c ::
    GHC.Types.Int
    -> [PhonemeType2.Laterality] -> [PhonemeType2.Laterality]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Laterality] ->
                 GHC.Types.:
                   @ PhonemeType2.Laterality
                   (PhonemeType2.$fEnumLaterality_$ctoEnum x)
                   ys) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.Laterality] -> [PhonemeType2.Laterality]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Laterality] ->
                 GHC.Types.:
                   @ PhonemeType2.Laterality
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Laterality a18 })
                   ys) -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_go :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
  {- Arity: 1, Strictness: <L,U> -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_go1 :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
  {- Arity: 1, Strictness: <L,U> -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_go2 :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f28c4174999e39eea0edf7a94bde9432
  $fEnumLaterality_go3 :: GHC.Prim.Int# -> [PhonemeType2.Laterality]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
195969ff33df4040ea1319692f018c08
  $fEnumLength :: GHC.Enum.Enum PhonemeType2.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fEnumLength_$csucc
                  PhonemeType2.$fEnumLength_$cpred
                  PhonemeType2.$fEnumLength_$ctoEnum
                  PhonemeType2.$fEnumLength_$cfromEnum
                  PhonemeType2.$fEnumLength_$cenumFrom
                  PhonemeType2.$fEnumLength_$cenumFromThen
                  PhonemeType2.$fEnumLength_$cenumFromTo
                  PhonemeType2.$fEnumLength_$cenumFromThenTo -}
195969ff33df4040ea1319692f018c08
  $fEnumLength1 :: GHC.Prim.Int# -> PhonemeType2.Length
  {- Arity: 1, Strictness: <L,U>b -}
195969ff33df4040ea1319692f018c08
  $fEnumLength2 :: [PhonemeType2.Length]
  {- Unfolding: (PhonemeType2.$fEnumLength_go3 2) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength3 :: [PhonemeType2.Length]
  {- Unfolding: (PhonemeType2.$fEnumLength_go4 1) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength4 :: [PhonemeType2.Length]
  {- Unfolding: (PhonemeType2.$fEnumLength_go5 0) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength5 :: PhonemeType2.Length
  {- Strictness: b -}
195969ff33df4040ea1319692f018c08
  $fEnumLength6 :: PhonemeType2.Length
  {- Strictness: b -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_$cenumFrom ::
    PhonemeType2.Length -> [PhonemeType2.Length]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Length ->
                 case a18 of wild {
                   PhonemeType2.SHORT -> PhonemeType2.$fEnumLength4
                   PhonemeType2.NORMAL -> PhonemeType2.$fEnumLength3
                   PhonemeType2.LONG -> PhonemeType2.$fEnumLength2 }) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_$cenumFromThen ::
    PhonemeType2.Length -> PhonemeType2.Length -> [PhonemeType2.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Length
                   b :: PhonemeType2.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Length]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Length]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Length]
                                    PhonemeType2.$fEnumLength_c1
                                    (GHC.Types.[] @ PhonemeType2.Length)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Length]
                                    PhonemeType2.$fEnumLength_c1
                                    (GHC.Types.[] @ PhonemeType2.Length)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.SHORT -> $j1 0
                       PhonemeType2.NORMAL -> $j1 1
                       PhonemeType2.LONG -> $j1 2 }
                 } in
                 case a18 of wild {
                   PhonemeType2.SHORT -> $j 0
                   PhonemeType2.NORMAL -> $j 1
                   PhonemeType2.LONG -> $j 2 }) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_$cenumFromThenTo ::
    PhonemeType2.Length
    -> PhonemeType2.Length
    -> PhonemeType2.Length
    -> [PhonemeType2.Length]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Length
                   x2 :: PhonemeType2.Length
                   y :: PhonemeType2.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Length]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.SHORT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.NORMAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     1 }
                           PhonemeType2.LONG
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.SHORT -> $j1 0
                       PhonemeType2.NORMAL -> $j1 1
                       PhonemeType2.LONG -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType2.SHORT -> $j 0
                   PhonemeType2.NORMAL -> $j 1
                   PhonemeType2.LONG -> $j 2 }) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_$cenumFromTo ::
    PhonemeType2.Length -> PhonemeType2.Length -> [PhonemeType2.Length]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Length y :: PhonemeType2.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.SHORT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumLength_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Length }
                       PhonemeType2.NORMAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumLength_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Length }
                       PhonemeType2.LONG
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumLength_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Length } }
                 } in
                 case x of wild {
                   PhonemeType2.SHORT -> $j 0
                   PhonemeType2.NORMAL -> $j 1
                   PhonemeType2.LONG -> $j 2 }) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_$cfromEnum :: PhonemeType2.Length -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Length ->
                 case a18 of wild {
                   PhonemeType2.SHORT -> GHC.Types.I# 0
                   PhonemeType2.NORMAL -> GHC.Types.I# 1
                   PhonemeType2.LONG -> GHC.Types.I# 2 }) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_$cpred :: PhonemeType2.Length -> PhonemeType2.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Length ->
                 case a18 of wild {
                   PhonemeType2.SHORT -> PhonemeType2.$fEnumLength5
                   PhonemeType2.NORMAL -> PhonemeType2.SHORT
                   PhonemeType2.LONG -> PhonemeType2.NORMAL }) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_$csucc :: PhonemeType2.Length -> PhonemeType2.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Length ->
                 case a18 of wild {
                   PhonemeType2.SHORT -> PhonemeType2.NORMAL
                   PhonemeType2.NORMAL -> PhonemeType2.LONG
                   PhonemeType2.LONG -> PhonemeType2.$fEnumLength6 }) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Length
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum7 ww1 }) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_c ::
    GHC.Types.Int -> [PhonemeType2.Length] -> [PhonemeType2.Length]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Length] ->
                 GHC.Types.:
                   @ PhonemeType2.Length
                   (PhonemeType2.$fEnumLength_$ctoEnum x)
                   ys) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_c1 ::
    GHC.Types.Int -> [PhonemeType2.Length] -> [PhonemeType2.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Length] ->
                 GHC.Types.:
                   @ PhonemeType2.Length
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Length a18 })
                   ys) -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_go :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, Strictness: <L,U> -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_go1 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, Strictness: <L,U> -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_go2 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, Strictness: <L,U> -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_go3 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_go4 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
195969ff33df4040ea1319692f018c08
  $fEnumLength_go5 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator ::
    GHC.Enum.Enum PhonemeType2.PassiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PassiveArticulator
                  PhonemeType2.$fEnumPassiveArticulator_$csucc
                  PhonemeType2.$fEnumPassiveArticulator_$cpred
                  PhonemeType2.$fEnumPassiveArticulator_$ctoEnum
                  PhonemeType2.$fEnumPassiveArticulator_$cfromEnum
                  PhonemeType2.$fEnumPassiveArticulator_$cenumFrom
                  PhonemeType2.$fEnumPassiveArticulator_$cenumFromThen
                  PhonemeType2.$fEnumPassiveArticulator_$cenumFromTo
                  PhonemeType2.$fEnumPassiveArticulator_$cenumFromThenTo -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator1 ::
    GHC.Prim.Int# -> PhonemeType2.PassiveArticulator
  {- Arity: 1, Strictness: <L,U>b -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator2 :: PhonemeType2.PassiveArticulator
  {- Strictness: b -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator3 :: PhonemeType2.PassiveArticulator
  {- Strictness: b -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_$cenumFrom ::
    PhonemeType2.PassiveArticulator
    -> [PhonemeType2.PassiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.PassiveArticulator ->
                 case a18 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 10) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumPassiveArticulator_go x0
                   GHC.Types.True
                   -> GHC.Types.[] @ PhonemeType2.PassiveArticulator } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_$cenumFromThen ::
    PhonemeType2.PassiveArticulator
    -> PhonemeType2.PassiveArticulator
    -> [PhonemeType2.PassiveArticulator]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.PassiveArticulator
                   b :: PhonemeType2.PassiveArticulator ->
                 case a18 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1
                 } in
                 let {
                   b# :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.PassiveArticulator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeType2.PassiveArticulator]
                            PhonemeType2.$fEnumPassiveArticulator_c1
                            (GHC.Types.[] @ PhonemeType2.PassiveArticulator)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeType2.PassiveArticulator]
                            PhonemeType2.$fEnumPassiveArticulator_c1
                            (GHC.Types.[] @ PhonemeType2.PassiveArticulator)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 10 GHC.Types.True -> $j 0 } } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_$cenumFromThenTo ::
    PhonemeType2.PassiveArticulator
    -> PhonemeType2.PassiveArticulator
    -> PhonemeType2.PassiveArticulator
    -> [PhonemeType2.PassiveArticulator]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.PassiveArticulator
                   x2 :: PhonemeType2.PassiveArticulator
                   y :: PhonemeType2.PassiveArticulator ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeType2.PassiveArticulator]
                        PhonemeType2.$fEnumPassiveArticulator_c
                        (GHC.Types.[] @ PhonemeType2.PassiveArticulator)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeType2.PassiveArticulator]
                        PhonemeType2.$fEnumPassiveArticulator_c
                        (GHC.Types.[] @ PhonemeType2.PassiveArticulator)
                        x7
                        x8
                        (GHC.Prim.dataToTag#
                           @ PhonemeType2.PassiveArticulator
                           x6) } } } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_$cenumFromTo ::
    PhonemeType2.PassiveArticulator
    -> PhonemeType2.PassiveArticulator
    -> [PhonemeType2.PassiveArticulator]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.PassiveArticulator
                   y :: PhonemeType2.PassiveArticulator ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go50 :: GHC.Prim.Int# -> [PhonemeType2.PassiveArticulator]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeType2.PassiveArticulator
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeType2.$fEnumPassiveArticulator1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 10) of wild2 {
                                    GHC.Types.False -> PhonemeType2.$fEnumPassiveArticulator1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeType2.PassiveArticulator x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go50 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeType2.PassiveArticulator })
                      } in
                      go50 x0
                   GHC.Types.True
                   -> GHC.Types.[] @ PhonemeType2.PassiveArticulator } } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_$cfromEnum ::
    PhonemeType2.PassiveArticulator -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.PassiveArticulator ->
                 case a18 of x1 { DEFAULT ->
                 GHC.Types.I#
                   (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1) }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_$cpred ::
    PhonemeType2.PassiveArticulator -> PhonemeType2.PassiveArticulator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.PassiveArticulator ->
                 case a18 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag#
                        @ PhonemeType2.PassiveArticulator
                        x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum#
                        @ PhonemeType2.PassiveArticulator
                        (GHC.Prim.+# wild (-1))
                   0 -> PhonemeType2.$fEnumPassiveArticulator2 } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_$csucc ::
    PhonemeType2.PassiveArticulator -> PhonemeType2.PassiveArticulator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.PassiveArticulator ->
                 case a18 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag#
                        @ PhonemeType2.PassiveArticulator
                        x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum#
                        @ PhonemeType2.PassiveArticulator
                        (GHC.Prim.+# wild 1)
                   10 -> PhonemeType2.$fEnumPassiveArticulator3 } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_$ctoEnum ::
    GHC.Types.Int -> PhonemeType2.PassiveArticulator
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum8 ww1 }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_c ::
    GHC.Types.Int
    -> [PhonemeType2.PassiveArticulator]
    -> [PhonemeType2.PassiveArticulator]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.PassiveArticulator] ->
                 GHC.Types.:
                   @ PhonemeType2.PassiveArticulator
                   (PhonemeType2.$fEnumPassiveArticulator_$ctoEnum x)
                   ys) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.PassiveArticulator]
    -> [PhonemeType2.PassiveArticulator]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.PassiveArticulator] ->
                 GHC.Types.:
                   @ PhonemeType2.PassiveArticulator
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.PassiveArticulator a18 })
                   ys) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEnumPassiveArticulator_go ::
    GHC.Prim.Int# -> [PhonemeType2.PassiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation :: GHC.Enum.Enum PhonemeType2.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fEnumPhonation_$csucc
                  PhonemeType2.$fEnumPhonation_$cpred
                  PhonemeType2.$fEnumPhonation_$ctoEnum
                  PhonemeType2.$fEnumPhonation_$cfromEnum
                  PhonemeType2.$fEnumPhonation_$cenumFrom
                  PhonemeType2.$fEnumPhonation_$cenumFromThen
                  PhonemeType2.$fEnumPhonation_$cenumFromTo
                  PhonemeType2.$fEnumPhonation_$cenumFromThenTo -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation1 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go7 6) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation10 :: PhonemeType2.Phonation
  {- Strictness: b -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation2 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go8 5) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation3 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go9 4) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation4 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go10 3) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation5 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go11 2) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation6 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go12 1) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation7 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go13 0) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation8 :: GHC.Prim.Int# -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <L,U>b -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation9 :: PhonemeType2.Phonation
  {- Strictness: b -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_$cenumFrom ::
    PhonemeType2.Phonation -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Phonation ->
                 case a18 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.$fEnumPhonation7
                   PhonemeType2.BREATHY -> PhonemeType2.$fEnumPhonation6
                   PhonemeType2.SLACK -> PhonemeType2.$fEnumPhonation5
                   PhonemeType2.MODAL -> PhonemeType2.$fEnumPhonation4
                   PhonemeType2.STIFF -> PhonemeType2.$fEnumPhonation3
                   PhonemeType2.CREAKY -> PhonemeType2.$fEnumPhonation2
                   PhonemeType2.CLOSURE -> PhonemeType2.$fEnumPhonation1 }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_$cenumFromThen ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation -> [PhonemeType2.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Phonation]
                                    PhonemeType2.$fEnumPhonation_c
                                    (GHC.Types.[] @ PhonemeType2.Phonation)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Phonation]
                                    PhonemeType2.$fEnumPhonation_c
                                    (GHC.Types.[] @ PhonemeType2.Phonation)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.VOICELESS -> $j1 0
                       PhonemeType2.BREATHY -> $j1 1
                       PhonemeType2.SLACK -> $j1 2
                       PhonemeType2.MODAL -> $j1 3
                       PhonemeType2.STIFF -> $j1 4
                       PhonemeType2.CREAKY -> $j1 5
                       PhonemeType2.CLOSURE -> $j1 6 }
                 } in
                 case a18 of wild {
                   PhonemeType2.VOICELESS -> $j 0
                   PhonemeType2.BREATHY -> $j 1
                   PhonemeType2.SLACK -> $j 2
                   PhonemeType2.MODAL -> $j 3
                   PhonemeType2.STIFF -> $j 4
                   PhonemeType2.CREAKY -> $j 5
                   PhonemeType2.CLOSURE -> $j 6 }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_$cenumFromThenTo ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation
    -> PhonemeType2.Phonation
    -> [PhonemeType2.Phonation]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_$cenumFromTo ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation -> [PhonemeType2.Phonation]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Phonation
                   y :: PhonemeType2.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.VOICELESS
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.BREATHY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.SLACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.MODAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.STIFF
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.CREAKY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.CLOSURE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation } }
                 } in
                 case x of wild {
                   PhonemeType2.VOICELESS -> $j 0
                   PhonemeType2.BREATHY -> $j 1
                   PhonemeType2.SLACK -> $j 2
                   PhonemeType2.MODAL -> $j 3
                   PhonemeType2.STIFF -> $j 4
                   PhonemeType2.CREAKY -> $j 5
                   PhonemeType2.CLOSURE -> $j 6 }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_$cfromEnum ::
    PhonemeType2.Phonation -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.Phonation ->
                 case w of wild {
                   PhonemeType2.VOICELESS -> GHC.Types.I# 0
                   PhonemeType2.BREATHY -> GHC.Types.I# 1
                   PhonemeType2.SLACK -> GHC.Types.I# 2
                   PhonemeType2.MODAL -> GHC.Types.I# 3
                   PhonemeType2.STIFF -> GHC.Types.I# 4
                   PhonemeType2.CREAKY -> GHC.Types.I# 5
                   PhonemeType2.CLOSURE -> GHC.Types.I# 6 }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_$cpred ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Phonation ->
                 case a18 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.$fEnumPhonation9
                   PhonemeType2.BREATHY -> PhonemeType2.VOICELESS
                   PhonemeType2.SLACK -> PhonemeType2.BREATHY
                   PhonemeType2.MODAL -> PhonemeType2.SLACK
                   PhonemeType2.STIFF -> PhonemeType2.MODAL
                   PhonemeType2.CREAKY -> PhonemeType2.STIFF
                   PhonemeType2.CLOSURE -> PhonemeType2.CREAKY }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_$csucc ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Phonation ->
                 case a18 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.BREATHY
                   PhonemeType2.BREATHY -> PhonemeType2.SLACK
                   PhonemeType2.SLACK -> PhonemeType2.MODAL
                   PhonemeType2.MODAL -> PhonemeType2.STIFF
                   PhonemeType2.STIFF -> PhonemeType2.CREAKY
                   PhonemeType2.CREAKY -> PhonemeType2.CLOSURE
                   PhonemeType2.CLOSURE -> PhonemeType2.$fEnumPhonation10 }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum9 ww1 }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_c ::
    GHC.Types.Int
    -> [PhonemeType2.Phonation] -> [PhonemeType2.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Phonation] ->
                 GHC.Types.:
                   @ PhonemeType2.Phonation
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Phonation a18 })
                   ys) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go1 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go10 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go11 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go12 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go13 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go2 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go3 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go4 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go5 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go6 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go7 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go8 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
a4e0caad2d1174c9226145cc0019ed73
  $fEnumPhonation_go9 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness :: GHC.Enum.Enum PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fEnumRoundedness_$csucc
                  PhonemeType2.$fEnumRoundedness_$cpred
                  PhonemeType2.$fEnumRoundedness_$ctoEnum
                  PhonemeType2.$fEnumRoundedness_$cfromEnum
                  PhonemeType2.$fEnumRoundedness_$cenumFrom
                  PhonemeType2.$fEnumRoundedness_$cenumFromThen
                  PhonemeType2.$fEnumRoundedness_$cenumFromTo
                  PhonemeType2.$fEnumRoundedness_$cenumFromThenTo -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness1 :: GHC.Prim.Int# -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>b -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness2 :: [PhonemeType2.Roundedness]
  {- Unfolding: (PhonemeType2.$fEnumRoundedness_go2 1) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness3 :: [PhonemeType2.Roundedness]
  {- Unfolding: (PhonemeType2.$fEnumRoundedness_go3 0) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness4 :: PhonemeType2.Roundedness
  {- Strictness: b -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness5 :: PhonemeType2.Roundedness
  {- Strictness: b -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_$cenumFrom ::
    PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Roundedness ->
                 case a18 of wild {
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fEnumRoundedness3
                   PhonemeType2.ROUNDED -> PhonemeType2.$fEnumRoundedness2 }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_$cenumFromThen ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Roundedness
                   b :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Roundedness]
                                    PhonemeType2.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType2.Roundedness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Roundedness]
                                    PhonemeType2.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType2.Roundedness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.UNROUNDED -> $j1 0 PhonemeType2.ROUNDED -> $j1 1 }
                 } in
                 case a18 of wild {
                   PhonemeType2.UNROUNDED -> $j 0 PhonemeType2.ROUNDED -> $j 1 }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_$cenumFromThenTo ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness
    -> [PhonemeType2.Roundedness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Roundedness
                   x2 :: PhonemeType2.Roundedness
                   y :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.UNROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.ROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.UNROUNDED -> $j1 0 PhonemeType2.ROUNDED -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType2.UNROUNDED -> $j 0 PhonemeType2.ROUNDED -> $j 1 }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_$cenumFromTo ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Roundedness
                   y :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.UNROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumRoundedness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Roundedness }
                       PhonemeType2.ROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumRoundedness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Roundedness } }
                 } in
                 case x of wild {
                   PhonemeType2.UNROUNDED -> $j 0 PhonemeType2.ROUNDED -> $j 1 }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_$cfromEnum ::
    PhonemeType2.Roundedness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Roundedness ->
                 case a18 of wild {
                   PhonemeType2.UNROUNDED -> GHC.Types.I# 0
                   PhonemeType2.ROUNDED -> GHC.Types.I# 1 }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_$cpred ::
    PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Roundedness ->
                 case a18 of wild {
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fEnumRoundedness4
                   PhonemeType2.ROUNDED -> PhonemeType2.UNROUNDED }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_$csucc ::
    PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Roundedness ->
                 case a18 of wild {
                   PhonemeType2.UNROUNDED -> PhonemeType2.ROUNDED
                   PhonemeType2.ROUNDED -> PhonemeType2.$fEnumRoundedness5 }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_$ctoEnum ::
    GHC.Types.Int -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum10 ww1 }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_c ::
    GHC.Types.Int
    -> [PhonemeType2.Roundedness] -> [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType2.Roundedness
                   (PhonemeType2.$fEnumRoundedness_$ctoEnum x)
                   ys) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.Roundedness] -> [PhonemeType2.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType2.Roundedness
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Roundedness a18 })
                   ys) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_go :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_go1 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_go2 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e8a534a069fcf11d22fabc02549d84ae
  $fEnumRoundedness_go3 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance :: GHC.Enum.Enum PhonemeType2.Silibance
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Silibance
                  PhonemeType2.$fEnumSilibance_$csucc
                  PhonemeType2.$fEnumSilibance_$cpred
                  PhonemeType2.$fEnumSilibance_$ctoEnum
                  PhonemeType2.$fEnumSilibance_$cfromEnum
                  PhonemeType2.$fEnumSilibance_$cenumFrom
                  PhonemeType2.$fEnumSilibance_$cenumFromThen
                  PhonemeType2.$fEnumSilibance_$cenumFromTo
                  PhonemeType2.$fEnumSilibance_$cenumFromThenTo -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance1 :: GHC.Prim.Int# -> PhonemeType2.Silibance
  {- Arity: 1, Strictness: <L,U>b -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance2 :: [PhonemeType2.Silibance]
  {- Unfolding: (PhonemeType2.$fEnumSilibance_go2 1) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance3 :: [PhonemeType2.Silibance]
  {- Unfolding: (PhonemeType2.$fEnumSilibance_go3 0) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance4 :: PhonemeType2.Silibance
  {- Strictness: b -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance5 :: PhonemeType2.Silibance
  {- Strictness: b -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_$cenumFrom ::
    PhonemeType2.Silibance -> [PhonemeType2.Silibance]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Silibance ->
                 case a18 of wild {
                   PhonemeType2.SILIBANT -> PhonemeType2.$fEnumSilibance3
                   PhonemeType2.NONSILIBANT -> PhonemeType2.$fEnumSilibance2 }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_$cenumFromThen ::
    PhonemeType2.Silibance
    -> PhonemeType2.Silibance -> [PhonemeType2.Silibance]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Silibance
                   b :: PhonemeType2.Silibance ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Silibance]
                                    PhonemeType2.$fEnumSilibance_c1
                                    (GHC.Types.[] @ PhonemeType2.Silibance)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Silibance]
                                    PhonemeType2.$fEnumSilibance_c1
                                    (GHC.Types.[] @ PhonemeType2.Silibance)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.SILIBANT -> $j1 0 PhonemeType2.NONSILIBANT -> $j1 1 }
                 } in
                 case a18 of wild {
                   PhonemeType2.SILIBANT -> $j 0
                   PhonemeType2.NONSILIBANT -> $j 1 }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_$cenumFromThenTo ::
    PhonemeType2.Silibance
    -> PhonemeType2.Silibance
    -> PhonemeType2.Silibance
    -> [PhonemeType2.Silibance]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Silibance
                   x2 :: PhonemeType2.Silibance
                   y :: PhonemeType2.Silibance ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.SILIBANT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Silibance]
                                     PhonemeType2.$fEnumSilibance_c
                                     (GHC.Types.[] @ PhonemeType2.Silibance)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Silibance]
                                     PhonemeType2.$fEnumSilibance_c
                                     (GHC.Types.[] @ PhonemeType2.Silibance)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.NONSILIBANT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Silibance]
                                     PhonemeType2.$fEnumSilibance_c
                                     (GHC.Types.[] @ PhonemeType2.Silibance)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Silibance]
                                     PhonemeType2.$fEnumSilibance_c
                                     (GHC.Types.[] @ PhonemeType2.Silibance)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.SILIBANT -> $j1 0 PhonemeType2.NONSILIBANT -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType2.SILIBANT -> $j 0
                   PhonemeType2.NONSILIBANT -> $j 1 }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_$cenumFromTo ::
    PhonemeType2.Silibance
    -> PhonemeType2.Silibance -> [PhonemeType2.Silibance]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Silibance
                   y :: PhonemeType2.Silibance ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.SILIBANT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumSilibance_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Silibance }
                       PhonemeType2.NONSILIBANT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumSilibance_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Silibance } }
                 } in
                 case x of wild {
                   PhonemeType2.SILIBANT -> $j 0
                   PhonemeType2.NONSILIBANT -> $j 1 }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_$cfromEnum ::
    PhonemeType2.Silibance -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Silibance ->
                 case a18 of wild {
                   PhonemeType2.SILIBANT -> GHC.Types.I# 0
                   PhonemeType2.NONSILIBANT -> GHC.Types.I# 1 }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_$cpred ::
    PhonemeType2.Silibance -> PhonemeType2.Silibance
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Silibance ->
                 case a18 of wild {
                   PhonemeType2.SILIBANT -> PhonemeType2.$fEnumSilibance4
                   PhonemeType2.NONSILIBANT -> PhonemeType2.SILIBANT }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_$csucc ::
    PhonemeType2.Silibance -> PhonemeType2.Silibance
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Silibance ->
                 case a18 of wild {
                   PhonemeType2.SILIBANT -> PhonemeType2.NONSILIBANT
                   PhonemeType2.NONSILIBANT -> PhonemeType2.$fEnumSilibance5 }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Silibance
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum11 ww1 }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_c ::
    GHC.Types.Int
    -> [PhonemeType2.Silibance] -> [PhonemeType2.Silibance]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Silibance] ->
                 GHC.Types.:
                   @ PhonemeType2.Silibance
                   (PhonemeType2.$fEnumSilibance_$ctoEnum x)
                   ys) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.Silibance] -> [PhonemeType2.Silibance]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Silibance] ->
                 GHC.Types.:
                   @ PhonemeType2.Silibance
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Silibance a18 })
                   ys) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_go :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
  {- Arity: 1, Strictness: <L,U> -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_go1 :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
  {- Arity: 1, Strictness: <L,U> -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_go2 :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f56b9eb1985eff94cee6d9814538c86
  $fEnumSilibance_go3 :: GHC.Prim.Int# -> [PhonemeType2.Silibance]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture :: GHC.Enum.Enum PhonemeType2.Stricture
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Stricture
                  PhonemeType2.$fEnumStricture_$csucc
                  PhonemeType2.$fEnumStricture_$cpred
                  PhonemeType2.$fEnumStricture_$ctoEnum
                  PhonemeType2.$fEnumStricture_$cfromEnum
                  PhonemeType2.$fEnumStricture_$cenumFrom
                  PhonemeType2.$fEnumStricture_$cenumFromThen
                  PhonemeType2.$fEnumStricture_$cenumFromTo
                  PhonemeType2.$fEnumStricture_$cenumFromThenTo -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture1 :: GHC.Prim.Int# -> PhonemeType2.Stricture
  {- Arity: 1, Strictness: <L,U>b -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture2 :: [PhonemeType2.Stricture]
  {- Unfolding: (PhonemeType2.$fEnumStricture_go3 2) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture3 :: [PhonemeType2.Stricture]
  {- Unfolding: (PhonemeType2.$fEnumStricture_go4 1) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture4 :: [PhonemeType2.Stricture]
  {- Unfolding: (PhonemeType2.$fEnumStricture_go5 0) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture5 :: PhonemeType2.Stricture
  {- Strictness: b -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture6 :: PhonemeType2.Stricture
  {- Strictness: b -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_$cenumFrom ::
    PhonemeType2.Stricture -> [PhonemeType2.Stricture]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Stricture ->
                 case a18 of wild {
                   PhonemeType2.OCCLUSION -> PhonemeType2.$fEnumStricture4
                   PhonemeType2.TURBULENT -> PhonemeType2.$fEnumStricture3
                   PhonemeType2.SLIGHTTURBULENT -> PhonemeType2.$fEnumStricture2 }) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_$cenumFromThen ::
    PhonemeType2.Stricture
    -> PhonemeType2.Stricture -> [PhonemeType2.Stricture]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Stricture
                   b :: PhonemeType2.Stricture ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Stricture]
                                    PhonemeType2.$fEnumStricture_c1
                                    (GHC.Types.[] @ PhonemeType2.Stricture)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Stricture]
                                    PhonemeType2.$fEnumStricture_c1
                                    (GHC.Types.[] @ PhonemeType2.Stricture)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.OCCLUSION -> $j1 0
                       PhonemeType2.TURBULENT -> $j1 1
                       PhonemeType2.SLIGHTTURBULENT -> $j1 2 }
                 } in
                 case a18 of wild {
                   PhonemeType2.OCCLUSION -> $j 0
                   PhonemeType2.TURBULENT -> $j 1
                   PhonemeType2.SLIGHTTURBULENT -> $j 2 }) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_$cenumFromThenTo ::
    PhonemeType2.Stricture
    -> PhonemeType2.Stricture
    -> PhonemeType2.Stricture
    -> [PhonemeType2.Stricture]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Stricture
                   x2 :: PhonemeType2.Stricture
                   y :: PhonemeType2.Stricture ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.OCCLUSION
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Stricture]
                                     PhonemeType2.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType2.Stricture)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Stricture]
                                     PhonemeType2.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType2.Stricture)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.TURBULENT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Stricture]
                                     PhonemeType2.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType2.Stricture)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Stricture]
                                     PhonemeType2.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType2.Stricture)
                                     x4
                                     x5
                                     1 }
                           PhonemeType2.SLIGHTTURBULENT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Stricture]
                                     PhonemeType2.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType2.Stricture)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Stricture]
                                     PhonemeType2.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType2.Stricture)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.OCCLUSION -> $j1 0
                       PhonemeType2.TURBULENT -> $j1 1
                       PhonemeType2.SLIGHTTURBULENT -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType2.OCCLUSION -> $j 0
                   PhonemeType2.TURBULENT -> $j 1
                   PhonemeType2.SLIGHTTURBULENT -> $j 2 }) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_$cenumFromTo ::
    PhonemeType2.Stricture
    -> PhonemeType2.Stricture -> [PhonemeType2.Stricture]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Stricture
                   y :: PhonemeType2.Stricture ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.OCCLUSION
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumStricture_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Stricture }
                       PhonemeType2.TURBULENT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumStricture_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Stricture }
                       PhonemeType2.SLIGHTTURBULENT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumStricture_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Stricture } }
                 } in
                 case x of wild {
                   PhonemeType2.OCCLUSION -> $j 0
                   PhonemeType2.TURBULENT -> $j 1
                   PhonemeType2.SLIGHTTURBULENT -> $j 2 }) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_$cfromEnum ::
    PhonemeType2.Stricture -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Stricture ->
                 case a18 of wild {
                   PhonemeType2.OCCLUSION -> GHC.Types.I# 0
                   PhonemeType2.TURBULENT -> GHC.Types.I# 1
                   PhonemeType2.SLIGHTTURBULENT -> GHC.Types.I# 2 }) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_$cpred ::
    PhonemeType2.Stricture -> PhonemeType2.Stricture
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Stricture ->
                 case a18 of wild {
                   PhonemeType2.OCCLUSION -> PhonemeType2.$fEnumStricture5
                   PhonemeType2.TURBULENT -> PhonemeType2.OCCLUSION
                   PhonemeType2.SLIGHTTURBULENT -> PhonemeType2.TURBULENT }) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_$csucc ::
    PhonemeType2.Stricture -> PhonemeType2.Stricture
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Stricture ->
                 case a18 of wild {
                   PhonemeType2.OCCLUSION -> PhonemeType2.TURBULENT
                   PhonemeType2.TURBULENT -> PhonemeType2.SLIGHTTURBULENT
                   PhonemeType2.SLIGHTTURBULENT -> PhonemeType2.$fEnumStricture6 }) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Stricture
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum12 ww1 }) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_c ::
    GHC.Types.Int
    -> [PhonemeType2.Stricture] -> [PhonemeType2.Stricture]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Stricture] ->
                 GHC.Types.:
                   @ PhonemeType2.Stricture
                   (PhonemeType2.$fEnumStricture_$ctoEnum x)
                   ys) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.Stricture] -> [PhonemeType2.Stricture]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Stricture] ->
                 GHC.Types.:
                   @ PhonemeType2.Stricture
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Stricture a18 })
                   ys) -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_go :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
  {- Arity: 1, Strictness: <L,U> -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_go1 :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
  {- Arity: 1, Strictness: <L,U> -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_go2 :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
  {- Arity: 1, Strictness: <L,U> -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_go3 :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_go4 :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
57e37fc45e7527176af3ce2952794c24
  $fEnumStricture_go5 :: GHC.Prim.Int# -> [PhonemeType2.Stricture]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill :: GHC.Enum.Enum PhonemeType2.Trill
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Trill
                  PhonemeType2.$fEnumTrill_$csucc
                  PhonemeType2.$fEnumTrill_$cpred
                  PhonemeType2.$fEnumTrill_$ctoEnum
                  PhonemeType2.$fEnumTrill_$cfromEnum
                  PhonemeType2.$fEnumTrill_$cenumFrom
                  PhonemeType2.$fEnumTrill_$cenumFromThen
                  PhonemeType2.$fEnumTrill_$cenumFromTo
                  PhonemeType2.$fEnumTrill_$cenumFromThenTo -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill1 :: GHC.Prim.Int# -> PhonemeType2.Trill
  {- Arity: 1, Strictness: <L,U>b -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill2 :: [PhonemeType2.Trill]
  {- Unfolding: (PhonemeType2.$fEnumTrill_go2 1) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill3 :: [PhonemeType2.Trill]
  {- Unfolding: (PhonemeType2.$fEnumTrill_go3 0) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill4 :: PhonemeType2.Trill
  {- Strictness: b -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill5 :: PhonemeType2.Trill
  {- Strictness: b -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_$cenumFrom ::
    PhonemeType2.Trill -> [PhonemeType2.Trill]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Trill ->
                 case a18 of wild {
                   PhonemeType2.TRILLED -> PhonemeType2.$fEnumTrill3
                   PhonemeType2.NOTTRILLED -> PhonemeType2.$fEnumTrill2 }) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_$cenumFromThen ::
    PhonemeType2.Trill -> PhonemeType2.Trill -> [PhonemeType2.Trill]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Trill b :: PhonemeType2.Trill ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Trill]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Trill]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Trill]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Trill]
                                    PhonemeType2.$fEnumTrill_c1
                                    (GHC.Types.[] @ PhonemeType2.Trill)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Trill]
                                    PhonemeType2.$fEnumTrill_c1
                                    (GHC.Types.[] @ PhonemeType2.Trill)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.TRILLED -> $j1 0 PhonemeType2.NOTTRILLED -> $j1 1 }
                 } in
                 case a18 of wild {
                   PhonemeType2.TRILLED -> $j 0 PhonemeType2.NOTTRILLED -> $j 1 }) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_$cenumFromThenTo ::
    PhonemeType2.Trill
    -> PhonemeType2.Trill -> PhonemeType2.Trill -> [PhonemeType2.Trill]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Trill
                   x2 :: PhonemeType2.Trill
                   y :: PhonemeType2.Trill ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Trill]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Trill]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.TRILLED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Trill]
                                     PhonemeType2.$fEnumTrill_c
                                     (GHC.Types.[] @ PhonemeType2.Trill)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Trill]
                                     PhonemeType2.$fEnumTrill_c
                                     (GHC.Types.[] @ PhonemeType2.Trill)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.NOTTRILLED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Trill]
                                     PhonemeType2.$fEnumTrill_c
                                     (GHC.Types.[] @ PhonemeType2.Trill)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Trill]
                                     PhonemeType2.$fEnumTrill_c
                                     (GHC.Types.[] @ PhonemeType2.Trill)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.TRILLED -> $j1 0 PhonemeType2.NOTTRILLED -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType2.TRILLED -> $j 0 PhonemeType2.NOTTRILLED -> $j 1 }) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_$cenumFromTo ::
    PhonemeType2.Trill -> PhonemeType2.Trill -> [PhonemeType2.Trill]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Trill y :: PhonemeType2.Trill ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Trill]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.TRILLED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumTrill_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Trill }
                       PhonemeType2.NOTTRILLED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumTrill_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Trill } }
                 } in
                 case x of wild {
                   PhonemeType2.TRILLED -> $j 0 PhonemeType2.NOTTRILLED -> $j 1 }) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_$cfromEnum :: PhonemeType2.Trill -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Trill ->
                 case a18 of wild {
                   PhonemeType2.TRILLED -> GHC.Types.I# 0
                   PhonemeType2.NOTTRILLED -> GHC.Types.I# 1 }) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_$cpred :: PhonemeType2.Trill -> PhonemeType2.Trill
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Trill ->
                 case a18 of wild {
                   PhonemeType2.TRILLED -> PhonemeType2.$fEnumTrill4
                   PhonemeType2.NOTTRILLED -> PhonemeType2.TRILLED }) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_$csucc :: PhonemeType2.Trill -> PhonemeType2.Trill
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.Trill ->
                 case a18 of wild {
                   PhonemeType2.TRILLED -> PhonemeType2.NOTTRILLED
                   PhonemeType2.NOTTRILLED -> PhonemeType2.$fEnumTrill5 }) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Trill
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum13 ww1 }) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_c ::
    GHC.Types.Int -> [PhonemeType2.Trill] -> [PhonemeType2.Trill]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Trill] ->
                 GHC.Types.:
                   @ PhonemeType2.Trill
                   (PhonemeType2.$fEnumTrill_$ctoEnum x)
                   ys) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_c1 ::
    GHC.Types.Int -> [PhonemeType2.Trill] -> [PhonemeType2.Trill]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Trill] ->
                 GHC.Types.:
                   @ PhonemeType2.Trill
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Trill a18 })
                   ys) -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_go :: GHC.Prim.Int# -> [PhonemeType2.Trill]
  {- Arity: 1, Strictness: <L,U> -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_go1 :: GHC.Prim.Int# -> [PhonemeType2.Trill]
  {- Arity: 1, Strictness: <L,U> -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_go2 :: GHC.Prim.Int# -> [PhonemeType2.Trill]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
8650e80162817fe79be4acc77e003de6
  $fEnumTrill_go3 :: GHC.Prim.Int# -> [PhonemeType2.Trill]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT :: GHC.Enum.Enum PhonemeType2.VOT
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.VOT
                  PhonemeType2.$fEnumVOT_$csucc
                  PhonemeType2.$fEnumVOT_$cpred
                  PhonemeType2.$fEnumVOT_$ctoEnum
                  PhonemeType2.$fEnumVOT_$cfromEnum
                  PhonemeType2.$fEnumVOT_$cenumFrom
                  PhonemeType2.$fEnumVOT_$cenumFromThen
                  PhonemeType2.$fEnumVOT_$cenumFromTo
                  PhonemeType2.$fEnumVOT_$cenumFromThenTo -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT1 :: GHC.Prim.Int# -> PhonemeType2.VOT
  {- Arity: 1, Strictness: <L,U>b -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT2 :: [PhonemeType2.VOT]
  {- Unfolding: (PhonemeType2.$fEnumVOT_go3 2) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT3 :: [PhonemeType2.VOT]
  {- Unfolding: (PhonemeType2.$fEnumVOT_go4 1) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT4 :: [PhonemeType2.VOT]
  {- Unfolding: (PhonemeType2.$fEnumVOT_go5 0) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT5 :: PhonemeType2.VOT
  {- Strictness: b -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT6 :: PhonemeType2.VOT
  {- Strictness: b -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_$cenumFrom :: PhonemeType2.VOT -> [PhonemeType2.VOT]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.VOT ->
                 case a18 of wild {
                   PhonemeType2.POSITIVE -> PhonemeType2.$fEnumVOT4
                   PhonemeType2.ZERO -> PhonemeType2.$fEnumVOT3
                   PhonemeType2.NEGATIVE -> PhonemeType2.$fEnumVOT2 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_$cenumFromThen ::
    PhonemeType2.VOT -> PhonemeType2.VOT -> [PhonemeType2.VOT]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.VOT b :: PhonemeType2.VOT ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.VOT]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.VOT]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.VOT]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.VOT]
                                    PhonemeType2.$fEnumVOT_c1
                                    (GHC.Types.[] @ PhonemeType2.VOT)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.VOT]
                                    PhonemeType2.$fEnumVOT_c1
                                    (GHC.Types.[] @ PhonemeType2.VOT)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.POSITIVE -> $j1 0
                       PhonemeType2.ZERO -> $j1 1
                       PhonemeType2.NEGATIVE -> $j1 2 }
                 } in
                 case a18 of wild {
                   PhonemeType2.POSITIVE -> $j 0
                   PhonemeType2.ZERO -> $j 1
                   PhonemeType2.NEGATIVE -> $j 2 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_$cenumFromThenTo ::
    PhonemeType2.VOT
    -> PhonemeType2.VOT -> PhonemeType2.VOT -> [PhonemeType2.VOT]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.VOT
                   x2 :: PhonemeType2.VOT
                   y :: PhonemeType2.VOT ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.VOT]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.VOT]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.POSITIVE
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.VOT]
                                     PhonemeType2.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType2.VOT)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.VOT]
                                     PhonemeType2.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType2.VOT)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.ZERO
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.VOT]
                                     PhonemeType2.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType2.VOT)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.VOT]
                                     PhonemeType2.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType2.VOT)
                                     x4
                                     x5
                                     1 }
                           PhonemeType2.NEGATIVE
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.VOT]
                                     PhonemeType2.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType2.VOT)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.VOT]
                                     PhonemeType2.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType2.VOT)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.POSITIVE -> $j1 0
                       PhonemeType2.ZERO -> $j1 1
                       PhonemeType2.NEGATIVE -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType2.POSITIVE -> $j 0
                   PhonemeType2.ZERO -> $j 1
                   PhonemeType2.NEGATIVE -> $j 2 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_$cenumFromTo ::
    PhonemeType2.VOT -> PhonemeType2.VOT -> [PhonemeType2.VOT]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.VOT y :: PhonemeType2.VOT ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.VOT]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.POSITIVE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumVOT_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.VOT }
                       PhonemeType2.ZERO
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumVOT_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.VOT }
                       PhonemeType2.NEGATIVE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumVOT_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.VOT } }
                 } in
                 case x of wild {
                   PhonemeType2.POSITIVE -> $j 0
                   PhonemeType2.ZERO -> $j 1
                   PhonemeType2.NEGATIVE -> $j 2 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_$cfromEnum :: PhonemeType2.VOT -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.VOT ->
                 case a18 of wild {
                   PhonemeType2.POSITIVE -> GHC.Types.I# 0
                   PhonemeType2.ZERO -> GHC.Types.I# 1
                   PhonemeType2.NEGATIVE -> GHC.Types.I# 2 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_$cpred :: PhonemeType2.VOT -> PhonemeType2.VOT
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.VOT ->
                 case a18 of wild {
                   PhonemeType2.POSITIVE -> PhonemeType2.$fEnumVOT5
                   PhonemeType2.ZERO -> PhonemeType2.POSITIVE
                   PhonemeType2.NEGATIVE -> PhonemeType2.ZERO }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_$csucc :: PhonemeType2.VOT -> PhonemeType2.VOT
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a18 :: PhonemeType2.VOT ->
                 case a18 of wild {
                   PhonemeType2.POSITIVE -> PhonemeType2.ZERO
                   PhonemeType2.ZERO -> PhonemeType2.NEGATIVE
                   PhonemeType2.NEGATIVE -> PhonemeType2.$fEnumVOT6 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_$ctoEnum :: GHC.Types.Int -> PhonemeType2.VOT
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum14 ww1 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_c ::
    GHC.Types.Int -> [PhonemeType2.VOT] -> [PhonemeType2.VOT]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.VOT] ->
                 GHC.Types.:
                   @ PhonemeType2.VOT
                   (PhonemeType2.$fEnumVOT_$ctoEnum x)
                   ys) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_c1 ::
    GHC.Types.Int -> [PhonemeType2.VOT] -> [PhonemeType2.VOT]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.VOT] ->
                 GHC.Types.:
                   @ PhonemeType2.VOT
                   (case x of wild { GHC.Types.I# a18 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.VOT a18 })
                   ys) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_go :: GHC.Prim.Int# -> [PhonemeType2.VOT]
  {- Arity: 1, Strictness: <L,U> -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_go1 :: GHC.Prim.Int# -> [PhonemeType2.VOT]
  {- Arity: 1, Strictness: <L,U> -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_go2 :: GHC.Prim.Int# -> [PhonemeType2.VOT]
  {- Arity: 1, Strictness: <L,U> -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_go3 :: GHC.Prim.Int# -> [PhonemeType2.VOT]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_go4 :: GHC.Prim.Int# -> [PhonemeType2.VOT]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEnumVOT_go5 :: GHC.Prim.Int# -> [PhonemeType2.VOT]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEqActiveArticulator ::
    GHC.Classes.Eq PhonemeType2.ActiveArticulator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.ActiveArticulator
                  PhonemeType2.$fEqActiveArticulator_$c==
                  PhonemeType2.$fEqActiveArticulator_$c/= -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEqActiveArticulator_$c/= ::
    PhonemeType2.ActiveArticulator
    -> PhonemeType2.ActiveArticulator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.ActiveArticulator
                   b :: PhonemeType2.ActiveArticulator ->
                 case a18 of wild {
                   PhonemeType2.LOWERLIP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.LOWERLIP -> GHC.Types.False }
                   PhonemeType2.TONGUEBLADE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.TONGUEBLADE -> GHC.Types.False }
                   PhonemeType2.TONGUETIP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.TONGUETIP -> GHC.Types.False }
                   PhonemeType2.TONGUEUNDER
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.TONGUEUNDER -> GHC.Types.False }
                   PhonemeType2.TONGUEBODY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.TONGUEBODY -> GHC.Types.False }
                   PhonemeType2.TONGUEROOT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.TONGUEROOT -> GHC.Types.False }
                   PhonemeType2.LARYNX
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.LARYNX -> GHC.Types.False } }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fEqActiveArticulator_$c== ::
    PhonemeType2.ActiveArticulator
    -> PhonemeType2.ActiveArticulator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.ActiveArticulator
                   ds1 :: PhonemeType2.ActiveArticulator ->
                 case ds of wild {
                   PhonemeType2.LOWERLIP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.LOWERLIP -> GHC.Types.True }
                   PhonemeType2.TONGUEBLADE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUEBLADE -> GHC.Types.True }
                   PhonemeType2.TONGUETIP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUETIP -> GHC.Types.True }
                   PhonemeType2.TONGUEUNDER
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUEUNDER -> GHC.Types.True }
                   PhonemeType2.TONGUEBODY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUEBODY -> GHC.Types.True }
                   PhonemeType2.TONGUEROOT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUEROOT -> GHC.Types.True }
                   PhonemeType2.LARYNX
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.LARYNX -> GHC.Types.True } }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEqAirEscape :: GHC.Classes.Eq PhonemeType2.AirEscape
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.AirEscape
                  PhonemeType2.$fEqAirEscape_$c==
                  PhonemeType2.$fEqAirEscape_$c/= -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEqAirEscape_$c/= ::
    PhonemeType2.AirEscape -> PhonemeType2.AirEscape -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.AirEscape b :: PhonemeType2.AirEscape ->
                 case a18 of wild {
                   PhonemeType2.NASALIZED
                   -> case b of wild1 {
                        PhonemeType2.NASALIZED -> GHC.Types.False
                        PhonemeType2.ORAL -> GHC.Types.True }
                   PhonemeType2.ORAL
                   -> case b of wild1 {
                        PhonemeType2.NASALIZED -> GHC.Types.True
                        PhonemeType2.ORAL -> GHC.Types.False } }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fEqAirEscape_$c== ::
    PhonemeType2.AirEscape -> PhonemeType2.AirEscape -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.AirEscape ds1 :: PhonemeType2.AirEscape ->
                 case ds of wild {
                   PhonemeType2.NASALIZED
                   -> case ds1 of wild1 {
                        PhonemeType2.NASALIZED -> GHC.Types.True
                        PhonemeType2.ORAL -> GHC.Types.False }
                   PhonemeType2.ORAL
                   -> case ds1 of wild1 {
                        PhonemeType2.NASALIZED -> GHC.Types.False
                        PhonemeType2.ORAL -> GHC.Types.True } }) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fEqAirstream :: GHC.Classes.Eq PhonemeType2.Airstream
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Airstream
                  PhonemeType2.$fEqAirstream_$c==
                  PhonemeType2.$fEqAirstream_$c/= -}
5c7b14d72f8f222b5cc058df80cd64de
  $fEqAirstream_$c/= ::
    PhonemeType2.Airstream -> PhonemeType2.Airstream -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Airstream b :: PhonemeType2.Airstream ->
                 case PhonemeType2.$fEqAirstream_$c== a18 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fEqAirstream_$c== ::
    PhonemeType2.Airstream -> PhonemeType2.Airstream -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType2.Airstream w1 :: PhonemeType2.Airstream ->
                 case w of ww { PhonemeType2.Airstream ww1 ww2 ->
                 case w1 of ww3 { PhonemeType2.Airstream ww4 ww5 ->
                 PhonemeType2.$w$c== ww1 ww2 ww4 ww5 } }) -}
3de6396777539178df86bdf5ea849b5e
  $fEqAirstream_$c==1 ::
    PhonemeType2.Direction -> PhonemeType2.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Direction ds1 :: PhonemeType2.Direction ->
                 case ds of wild {
                   PhonemeType2.INGRESSIVE
                   -> case ds1 of wild1 {
                        PhonemeType2.INGRESSIVE -> GHC.Types.True
                        PhonemeType2.EGRESSIVE -> GHC.Types.False }
                   PhonemeType2.EGRESSIVE
                   -> case ds1 of wild1 {
                        PhonemeType2.INGRESSIVE -> GHC.Types.False
                        PhonemeType2.EGRESSIVE -> GHC.Types.True } }) -}
9918c87837d4f215d9649b53c1c134de
  $fEqBackness :: GHC.Classes.Eq PhonemeType2.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fEqBackness_$c==
                  PhonemeType2.$fEqBackness_$c/= -}
9918c87837d4f215d9649b53c1c134de
  $fEqBackness_$c/= ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a18 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.BACK -> GHC.Types.False }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARBACK -> GHC.Types.False }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.CENTRAL -> GHC.Types.False }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.False }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.False } }) -}
9918c87837d4f215d9649b53c1c134de
  $fEqBackness_$c== ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.Backness
                   ds1 :: PhonemeType2.Backness ->
                 case ds of wild {
                   PhonemeType2.BACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.BACK -> GHC.Types.True }
                   PhonemeType2.NEARBACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARBACK -> GHC.Types.True }
                   PhonemeType2.CENTRAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.CENTRAL -> GHC.Types.True }
                   PhonemeType2.NEARFRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.True }
                   PhonemeType2.FRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.True } }) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fEqConsonant :: GHC.Classes.Eq PhonemeType2.Consonant
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Consonant
                  PhonemeType2.$fEqConsonant_$c==
                  PhonemeType2.$fEqConsonant_$c/= -}
498abb2d3230baf9073ff621a6aaa0e0
  $fEqConsonantPhonemeInventory ::
    GHC.Classes.Eq PhonemeType2.ConsonantPhonemeInventory
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.ConsonantPhonemeInventory
                  PhonemeType2.$fEqConsonantPhonemeInventory_$c==
                  PhonemeType2.$fEqConsonantPhonemeInventory_$c/= -}
498abb2d3230baf9073ff621a6aaa0e0
  $fEqConsonantPhonemeInventory_$c/= ::
    PhonemeType2.ConsonantPhonemeInventory
    -> PhonemeType2.ConsonantPhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.ConsonantPhonemeInventory
                   b :: PhonemeType2.ConsonantPhonemeInventory ->
                 case a18 of wild { PhonemeType2.ConsonantPhonemeInventory a19 ->
                 case b of wild1 { PhonemeType2.ConsonantPhonemeInventory b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeType2.Consonant
                        PhonemeType2.$fEqConsonant
                        a19
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fEqConsonantPhonemeInventory_$c== ::
    PhonemeType2.ConsonantPhonemeInventory
    -> PhonemeType2.ConsonantPhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.ConsonantPhonemeInventory
                   ds1 :: PhonemeType2.ConsonantPhonemeInventory ->
                 case ds of wild { PhonemeType2.ConsonantPhonemeInventory a18 ->
                 case ds1 of wild1 { PhonemeType2.ConsonantPhonemeInventory b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ PhonemeType2.Consonant
                   PhonemeType2.$fEqConsonant
                   a18
                   b1 } }) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fEqConsonant_$c/= ::
    PhonemeType2.Consonant -> PhonemeType2.Consonant -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Consonant b :: PhonemeType2.Consonant ->
                 case PhonemeType2.$fEqConsonant_$c== a18 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fEqConsonant_$c== ::
    PhonemeType2.Consonant -> PhonemeType2.Consonant -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType2.Consonant w1 :: PhonemeType2.Consonant ->
                 case w of ww { PhonemeType2.Consonant ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { PhonemeType2.Consonant ww6 ww7 ww8 ww9 ->
                 PhonemeType2.$w$c==1 ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
3de6396777539178df86bdf5ea849b5e
  $fEqDirection :: GHC.Classes.Eq PhonemeType2.Direction
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Direction
                  PhonemeType2.$fEqAirstream_$c==1
                  PhonemeType2.$fEqDirection_$c/= -}
3de6396777539178df86bdf5ea849b5e
  $fEqDirection_$c/= ::
    PhonemeType2.Direction -> PhonemeType2.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Direction b :: PhonemeType2.Direction ->
                 case a18 of wild {
                   PhonemeType2.INGRESSIVE
                   -> case b of wild1 {
                        PhonemeType2.INGRESSIVE -> GHC.Types.False
                        PhonemeType2.EGRESSIVE -> GHC.Types.True }
                   PhonemeType2.EGRESSIVE
                   -> case b of wild1 {
                        PhonemeType2.INGRESSIVE -> GHC.Types.True
                        PhonemeType2.EGRESSIVE -> GHC.Types.False } }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEqHeight :: GHC.Classes.Eq PhonemeType2.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fEqHeight_$c==
                  PhonemeType2.$fEqHeight_$c/= -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEqHeight_$c/= ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Height
                   b :: PhonemeType2.Height ->
                 case a18 of wild {
                   PhonemeType2.CLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.CLOSE -> GHC.Types.False }
                   PhonemeType2.NEARCLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARCLOSE -> GHC.Types.False }
                   PhonemeType2.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.CLOSEMID -> GHC.Types.False }
                   PhonemeType2.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.MID -> GHC.Types.False }
                   PhonemeType2.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.OPENMID -> GHC.Types.False }
                   PhonemeType2.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEAROPEN -> GHC.Types.False }
                   PhonemeType2.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.OPEN -> GHC.Types.False } }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fEqHeight_$c== ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.Height
                   ds1 :: PhonemeType2.Height ->
                 case ds of wild {
                   PhonemeType2.CLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.CLOSE -> GHC.Types.True }
                   PhonemeType2.NEARCLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARCLOSE -> GHC.Types.True }
                   PhonemeType2.CLOSEMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.CLOSEMID -> GHC.Types.True }
                   PhonemeType2.MID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.MID -> GHC.Types.True }
                   PhonemeType2.OPENMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.OPENMID -> GHC.Types.True }
                   PhonemeType2.NEAROPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEAROPEN -> GHC.Types.True }
                   PhonemeType2.OPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.OPEN -> GHC.Types.True } }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEqInitiator :: GHC.Classes.Eq PhonemeType2.Initiator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Initiator
                  PhonemeType2.$fEqInitiator_$c==
                  PhonemeType2.$fEqInitiator_$c/= -}
cf0efd186b87d1976dba6b7feef6e065
  $fEqInitiator_$c/= ::
    PhonemeType2.Initiator -> PhonemeType2.Initiator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Initiator b :: PhonemeType2.Initiator ->
                 case a18 of wild {
                   PhonemeType2.LINGUAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.LINGUAL -> GHC.Types.False }
                   PhonemeType2.GLOTTIC
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.GLOTTIC -> GHC.Types.False }
                   PhonemeType2.PULMONIC
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.PULMONIC -> GHC.Types.False } }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fEqInitiator_$c== ::
    PhonemeType2.Initiator -> PhonemeType2.Initiator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Initiator ds1 :: PhonemeType2.Initiator ->
                 case ds of wild {
                   PhonemeType2.LINGUAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.LINGUAL -> GHC.Types.True }
                   PhonemeType2.GLOTTIC
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.GLOTTIC -> GHC.Types.True }
                   PhonemeType2.PULMONIC
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.PULMONIC -> GHC.Types.True } }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEqLaterality :: GHC.Classes.Eq PhonemeType2.Laterality
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Laterality
                  PhonemeType2.$fEqLaterality_$c==
                  PhonemeType2.$fEqLaterality_$c/= -}
f28c4174999e39eea0edf7a94bde9432
  $fEqLaterality_$c/= ::
    PhonemeType2.Laterality
    -> PhonemeType2.Laterality -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Laterality b :: PhonemeType2.Laterality ->
                 case a18 of wild {
                   PhonemeType2.LATERAL
                   -> case b of wild1 {
                        PhonemeType2.LATERAL -> GHC.Types.False
                        PhonemeType2.NONLATERAL -> GHC.Types.True }
                   PhonemeType2.NONLATERAL
                   -> case b of wild1 {
                        PhonemeType2.LATERAL -> GHC.Types.True
                        PhonemeType2.NONLATERAL -> GHC.Types.False } }) -}
f28c4174999e39eea0edf7a94bde9432
  $fEqLaterality_$c== ::
    PhonemeType2.Laterality
    -> PhonemeType2.Laterality -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Laterality ds1 :: PhonemeType2.Laterality ->
                 case ds of wild {
                   PhonemeType2.LATERAL
                   -> case ds1 of wild1 {
                        PhonemeType2.LATERAL -> GHC.Types.True
                        PhonemeType2.NONLATERAL -> GHC.Types.False }
                   PhonemeType2.NONLATERAL
                   -> case ds1 of wild1 {
                        PhonemeType2.LATERAL -> GHC.Types.False
                        PhonemeType2.NONLATERAL -> GHC.Types.True } }) -}
195969ff33df4040ea1319692f018c08
  $fEqLength :: GHC.Classes.Eq PhonemeType2.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fEqLength_$c==
                  PhonemeType2.$fEqLength_$c/= -}
195969ff33df4040ea1319692f018c08
  $fEqLength_$c/= ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Length b :: PhonemeType2.Length ->
                 case a18 of wild {
                   PhonemeType2.SHORT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.SHORT -> GHC.Types.False }
                   PhonemeType2.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.NORMAL -> GHC.Types.False }
                   PhonemeType2.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.LONG -> GHC.Types.False } }) -}
195969ff33df4040ea1319692f018c08
  $fEqLength_$c== ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Length ds1 :: PhonemeType2.Length ->
                 case ds of wild {
                   PhonemeType2.SHORT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.SHORT -> GHC.Types.True }
                   PhonemeType2.NORMAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.NORMAL -> GHC.Types.True }
                   PhonemeType2.LONG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.LONG -> GHC.Types.True } }) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fEqManner :: GHC.Classes.Eq PhonemeType2.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fEqManner_$c==
                  PhonemeType2.$fEqManner_$c/= -}
ab5350f5942d71b67ea9edf6454c29d6
  $fEqManner_$c/= ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case PhonemeType2.$fEqManner_$c== a18 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fEqManner_$c== ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType2.Manner w1 :: PhonemeType2.Manner ->
                 case w of ww { PhonemeType2.Manner ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w1 of ww8 { PhonemeType2.Manner ww9 ww10 ww11 ww12 ww13 ww14 ww15 ->
                 PhonemeType2.$w$c==2
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15 } }) -}
8143cb44533c9c903aac37b4f4a4473c
  $fEqMaybeContour ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    GHC.Classes.Eq (PhonemeType2.MaybeContour a b)
  DFunId[0]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a18
                      @ b
                      $dEq :: GHC.Classes.Eq a18
                      $dEq1 :: GHC.Classes.Eq b.
                  @ (PhonemeType2.MaybeContour a18 b)
                  (PhonemeType2.$fEqMaybeContour_$c== @ a18 @ b $dEq $dEq1)
                  (PhonemeType2.$fEqMaybeContour_$c/= @ a18 @ b $dEq $dEq1) -}
8143cb44533c9c903aac37b4f4a4473c
  $fEqMaybeContour_$c/= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    PhonemeType2.MaybeContour a b
    -> PhonemeType2.MaybeContour a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a18
                   @ b
                   $dEq :: GHC.Classes.Eq a18
                   $dEq1 :: GHC.Classes.Eq b
                   a19 :: PhonemeType2.MaybeContour a18 b
                   b1 :: PhonemeType2.MaybeContour a18 b ->
                 case PhonemeType2.$fEqMaybeContour_$c==
                        @ a18
                        @ b
                        $dEq
                        $dEq1
                        a19
                        b1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8143cb44533c9c903aac37b4f4a4473c
  $fEqMaybeContour_$c== ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    PhonemeType2.MaybeContour a b
    -> PhonemeType2.MaybeContour a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a18
                   @ b
                   $dEq :: GHC.Classes.Eq a18
                   $dEq1 :: GHC.Classes.Eq b
                   ds :: PhonemeType2.MaybeContour a18 b
                   ds1 :: PhonemeType2.MaybeContour a18 b ->
                 case ds of wild {
                   PhonemeType2.NoContour a19
                   -> case ds1 of wild1 {
                        PhonemeType2.NoContour b1 -> GHC.Classes.== @ b $dEq1 a19 b1
                        PhonemeType2.Contour ipv ipv1 -> GHC.Types.False }
                   PhonemeType2.Contour a19 a20
                   -> case ds1 of wild1 {
                        PhonemeType2.NoContour ipv -> GHC.Types.False
                        PhonemeType2.Contour b1 b2
                        -> case GHC.Classes.== @ a18 $dEq a19 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ b $dEq1 a20 b2 } } }) -}
ce06e3a360ef67b905c70e56b1480a17
  $fEqMaybeContour_$c==1 ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType2.Place w1 :: PhonemeType2.Place ->
                 case w of ww { PhonemeType2.Place ww1 ww2 ->
                 case w1 of ww3 { PhonemeType2.Place ww4 ww5 ->
                 PhonemeType2.$w$c==3 ww1 ww2 ww4 ww5 } }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEqMaybeContour_$c==2 ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.Phonation
                   ds1 :: PhonemeType2.Phonation ->
                 case ds of wild {
                   PhonemeType2.VOICELESS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.VOICELESS -> GHC.Types.True }
                   PhonemeType2.BREATHY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.BREATHY -> GHC.Types.True }
                   PhonemeType2.SLACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.SLACK -> GHC.Types.True }
                   PhonemeType2.MODAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.MODAL -> GHC.Types.True }
                   PhonemeType2.STIFF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.STIFF -> GHC.Types.True }
                   PhonemeType2.CREAKY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.CREAKY -> GHC.Types.True }
                   PhonemeType2.CLOSURE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.CLOSURE -> GHC.Types.True } }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEqMaybeContour_$c==3 ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Roundedness
                   ds1 :: PhonemeType2.Roundedness ->
                 case ds of wild {
                   PhonemeType2.UNROUNDED
                   -> case ds1 of wild1 {
                        PhonemeType2.UNROUNDED -> GHC.Types.True
                        PhonemeType2.ROUNDED -> GHC.Types.False }
                   PhonemeType2.ROUNDED
                   -> case ds1 of wild1 {
                        PhonemeType2.UNROUNDED -> GHC.Types.False
                        PhonemeType2.ROUNDED -> GHC.Types.True } }) -}
b13bbde41449c45003ef1026fa30364d
  $fEqMaybeImpossible ::
    GHC.Classes.Eq a => GHC.Classes.Eq (PhonemeType2.MaybeImpossible a)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a18 $dEq :: GHC.Classes.Eq a18.
                  @ (PhonemeType2.MaybeImpossible a18)
                  (PhonemeType2.$fEqMaybeImpossible_$c== @ a18 $dEq)
                  (PhonemeType2.$fEqMaybeImpossible_$c/= @ a18 $dEq) -}
b13bbde41449c45003ef1026fa30364d
  $fEqMaybeImpossible_$c/= ::
    GHC.Classes.Eq a =>
    PhonemeType2.MaybeImpossible a
    -> PhonemeType2.MaybeImpossible a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a18
                   $dEq :: GHC.Classes.Eq a18
                   a19 :: PhonemeType2.MaybeImpossible a18
                   b :: PhonemeType2.MaybeImpossible a18 ->
                 case a19 of wild {
                   PhonemeType2.Possible a20
                   -> case b of wild1 {
                        PhonemeType2.Possible b1
                        -> case GHC.Classes.== @ a18 $dEq a20 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        PhonemeType2.Impossible -> GHC.Types.True }
                   PhonemeType2.Impossible
                   -> case b of wild1 {
                        PhonemeType2.Possible ipv -> GHC.Types.True
                        PhonemeType2.Impossible -> GHC.Types.False } }) -}
b13bbde41449c45003ef1026fa30364d
  $fEqMaybeImpossible_$c== ::
    GHC.Classes.Eq a =>
    PhonemeType2.MaybeImpossible a
    -> PhonemeType2.MaybeImpossible a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a18
                   $dEq :: GHC.Classes.Eq a18
                   ds :: PhonemeType2.MaybeImpossible a18
                   ds1 :: PhonemeType2.MaybeImpossible a18 ->
                 case ds of wild {
                   PhonemeType2.Possible a19
                   -> case ds1 of wild1 {
                        PhonemeType2.Possible b1 -> GHC.Classes.== @ a18 $dEq a19 b1
                        PhonemeType2.Impossible -> GHC.Types.False }
                   PhonemeType2.Impossible
                   -> case ds1 of wild1 {
                        PhonemeType2.Possible ipv -> GHC.Types.False
                        PhonemeType2.Impossible -> GHC.Types.True } }) -}
8650e80162817fe79be4acc77e003de6
  $fEqMaybeImpossible_$c==1 ::
    PhonemeType2.Trill -> PhonemeType2.Trill -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Trill ds1 :: PhonemeType2.Trill ->
                 case ds of wild {
                   PhonemeType2.TRILLED
                   -> case ds1 of wild1 {
                        PhonemeType2.TRILLED -> GHC.Types.True
                        PhonemeType2.NOTTRILLED -> GHC.Types.False }
                   PhonemeType2.NOTTRILLED
                   -> case ds1 of wild1 {
                        PhonemeType2.TRILLED -> GHC.Types.False
                        PhonemeType2.NOTTRILLED -> GHC.Types.True } }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEqMaybeImpossible_$c==2 ::
    PhonemeType2.Silibance -> PhonemeType2.Silibance -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Silibance ds1 :: PhonemeType2.Silibance ->
                 case ds of wild {
                   PhonemeType2.SILIBANT
                   -> case ds1 of wild1 {
                        PhonemeType2.SILIBANT -> GHC.Types.True
                        PhonemeType2.NONSILIBANT -> GHC.Types.False }
                   PhonemeType2.NONSILIBANT
                   -> case ds1 of wild1 {
                        PhonemeType2.SILIBANT -> GHC.Types.False
                        PhonemeType2.NONSILIBANT -> GHC.Types.True } }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEqMaybeImpossible_$c==3 ::
    PhonemeType2.VOT -> PhonemeType2.VOT -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.VOT ds1 :: PhonemeType2.VOT ->
                 case ds of wild {
                   PhonemeType2.POSITIVE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.POSITIVE -> GHC.Types.True }
                   PhonemeType2.ZERO
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.ZERO -> GHC.Types.True }
                   PhonemeType2.NEGATIVE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEGATIVE -> GHC.Types.True } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEqPassiveArticulator ::
    GHC.Classes.Eq PhonemeType2.PassiveArticulator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PassiveArticulator
                  PhonemeType2.$fEqPassiveArticulator_$c==
                  PhonemeType2.$fEqPassiveArticulator_$c/= -}
b99e0542eafd4baafc4b7c93a8988262
  $fEqPassiveArticulator_$c/= ::
    PhonemeType2.PassiveArticulator
    -> PhonemeType2.PassiveArticulator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.PassiveArticulator
                   b :: PhonemeType2.PassiveArticulator ->
                 case a18 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                           (GHC.Prim.dataToTag#
                              @ PhonemeType2.PassiveArticulator
                              x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fEqPassiveArticulator_$c== ::
    PhonemeType2.PassiveArticulator
    -> PhonemeType2.PassiveArticulator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.PassiveArticulator
                   b :: PhonemeType2.PassiveArticulator ->
                 case a18 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2)) } }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fEqPhonation :: GHC.Classes.Eq PhonemeType2.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fEqMaybeContour_$c==2
                  PhonemeType2.$fEqPhonation_$c/= -}
a4e0caad2d1174c9226145cc0019ed73
  $fEqPhonation_$c/= ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a18 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 case a18 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.VOICELESS -> GHC.Types.False }
                   PhonemeType2.BREATHY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.BREATHY -> GHC.Types.False }
                   PhonemeType2.SLACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.SLACK -> GHC.Types.False }
                   PhonemeType2.MODAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.MODAL -> GHC.Types.False }
                   PhonemeType2.STIFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.STIFF -> GHC.Types.False }
                   PhonemeType2.CREAKY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.CREAKY -> GHC.Types.False }
                   PhonemeType2.CLOSURE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.CLOSURE -> GHC.Types.False } }) -}
ce06e3a360ef67b905c70e56b1480a17
  $fEqPlace :: GHC.Classes.Eq PhonemeType2.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fEqMaybeContour_$c==1
                  PhonemeType2.$fEqPlace_$c/= -}
ce06e3a360ef67b905c70e56b1480a17
  $fEqPlace_$c/= ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case PhonemeType2.$fEqMaybeContour_$c==1 a18 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fEqRoundedness :: GHC.Classes.Eq PhonemeType2.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fEqMaybeContour_$c==3
                  PhonemeType2.$fEqRoundedness_$c/= -}
e8a534a069fcf11d22fabc02549d84ae
  $fEqRoundedness_$c/= ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a18 of wild {
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType2.UNROUNDED -> GHC.Types.False
                        PhonemeType2.ROUNDED -> GHC.Types.True }
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        PhonemeType2.UNROUNDED -> GHC.Types.True
                        PhonemeType2.ROUNDED -> GHC.Types.False } }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fEqSilibance :: GHC.Classes.Eq PhonemeType2.Silibance
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Silibance
                  PhonemeType2.$fEqMaybeImpossible_$c==2
                  PhonemeType2.$fEqSilibance_$c/= -}
6f56b9eb1985eff94cee6d9814538c86
  $fEqSilibance_$c/= ::
    PhonemeType2.Silibance -> PhonemeType2.Silibance -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Silibance b :: PhonemeType2.Silibance ->
                 case a18 of wild {
                   PhonemeType2.SILIBANT
                   -> case b of wild1 {
                        PhonemeType2.SILIBANT -> GHC.Types.False
                        PhonemeType2.NONSILIBANT -> GHC.Types.True }
                   PhonemeType2.NONSILIBANT
                   -> case b of wild1 {
                        PhonemeType2.SILIBANT -> GHC.Types.True
                        PhonemeType2.NONSILIBANT -> GHC.Types.False } }) -}
57e37fc45e7527176af3ce2952794c24
  $fEqStricture :: GHC.Classes.Eq PhonemeType2.Stricture
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Stricture
                  PhonemeType2.$fEqStricture_$c==
                  PhonemeType2.$fEqStricture_$c/= -}
57e37fc45e7527176af3ce2952794c24
  $fEqStricture_$c/= ::
    PhonemeType2.Stricture -> PhonemeType2.Stricture -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Stricture b :: PhonemeType2.Stricture ->
                 case a18 of wild {
                   PhonemeType2.OCCLUSION
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.OCCLUSION -> GHC.Types.False }
                   PhonemeType2.TURBULENT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.TURBULENT -> GHC.Types.False }
                   PhonemeType2.SLIGHTTURBULENT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.SLIGHTTURBULENT -> GHC.Types.False } }) -}
57e37fc45e7527176af3ce2952794c24
  $fEqStricture_$c== ::
    PhonemeType2.Stricture -> PhonemeType2.Stricture -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Stricture ds1 :: PhonemeType2.Stricture ->
                 case ds of wild {
                   PhonemeType2.OCCLUSION
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.OCCLUSION -> GHC.Types.True }
                   PhonemeType2.TURBULENT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TURBULENT -> GHC.Types.True }
                   PhonemeType2.SLIGHTTURBULENT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.SLIGHTTURBULENT -> GHC.Types.True } }) -}
8650e80162817fe79be4acc77e003de6
  $fEqTrill :: GHC.Classes.Eq PhonemeType2.Trill
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Trill
                  PhonemeType2.$fEqMaybeImpossible_$c==1
                  PhonemeType2.$fEqTrill_$c/= -}
8650e80162817fe79be4acc77e003de6
  $fEqTrill_$c/= ::
    PhonemeType2.Trill -> PhonemeType2.Trill -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Trill b :: PhonemeType2.Trill ->
                 case a18 of wild {
                   PhonemeType2.TRILLED
                   -> case b of wild1 {
                        PhonemeType2.TRILLED -> GHC.Types.False
                        PhonemeType2.NOTTRILLED -> GHC.Types.True }
                   PhonemeType2.NOTTRILLED
                   -> case b of wild1 {
                        PhonemeType2.TRILLED -> GHC.Types.True
                        PhonemeType2.NOTTRILLED -> GHC.Types.False } }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEqVOT :: GHC.Classes.Eq PhonemeType2.VOT
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.VOT
                  PhonemeType2.$fEqMaybeImpossible_$c==3
                  PhonemeType2.$fEqVOT_$c/= -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fEqVOT_$c/= ::
    PhonemeType2.VOT -> PhonemeType2.VOT -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.VOT b :: PhonemeType2.VOT ->
                 case a18 of wild {
                   PhonemeType2.POSITIVE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.POSITIVE -> GHC.Types.False }
                   PhonemeType2.ZERO
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.ZERO -> GHC.Types.False }
                   PhonemeType2.NEGATIVE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEGATIVE -> GHC.Types.False } }) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fEqVowel :: GHC.Classes.Eq PhonemeType2.Vowel
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Vowel
                  PhonemeType2.$fEqVowel_$c==
                  PhonemeType2.$fEqVowel_$c/= -}
836bde73953accb1955bda1c7bb62770
  $fEqVowelPhonemeInventory ::
    GHC.Classes.Eq PhonemeType2.VowelPhonemeInventory
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.VowelPhonemeInventory
                  PhonemeType2.$fEqVowelPhonemeInventory_$c==
                  PhonemeType2.$fEqVowelPhonemeInventory_$c/= -}
836bde73953accb1955bda1c7bb62770
  $fEqVowelPhonemeInventory_$c/= ::
    PhonemeType2.VowelPhonemeInventory
    -> PhonemeType2.VowelPhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.VowelPhonemeInventory
                   b :: PhonemeType2.VowelPhonemeInventory ->
                 case a18 of wild { PhonemeType2.VowelPhonemeInventory a19 ->
                 case b of wild1 { PhonemeType2.VowelPhonemeInventory b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeType2.Vowel
                        PhonemeType2.$fEqVowel
                        a19
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
836bde73953accb1955bda1c7bb62770
  $fEqVowelPhonemeInventory_$c== ::
    PhonemeType2.VowelPhonemeInventory
    -> PhonemeType2.VowelPhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.VowelPhonemeInventory
                   ds1 :: PhonemeType2.VowelPhonemeInventory ->
                 case ds of wild { PhonemeType2.VowelPhonemeInventory a18 ->
                 case ds1 of wild1 { PhonemeType2.VowelPhonemeInventory b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ PhonemeType2.Vowel
                   PhonemeType2.$fEqVowel
                   a18
                   b1 } }) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fEqVowel_$c/= ::
    PhonemeType2.Vowel -> PhonemeType2.Vowel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U(1*U,1*U),1*U)><S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U(1*U,1*U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a18 :: PhonemeType2.Vowel b :: PhonemeType2.Vowel ->
                 case PhonemeType2.$fEqVowel_$c== a18 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fEqVowel_$c== ::
    PhonemeType2.Vowel -> PhonemeType2.Vowel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U(1*U,1*U),1*U)><S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U(1*U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType2.Vowel w1 :: PhonemeType2.Vowel ->
                 case w of ww { PhonemeType2.VowelFeaturesContour ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w1 of ww8 { PhonemeType2.VowelFeaturesContour ww9 ww10 ww11 ww12 ww13 ww14 ww15 ->
                 PhonemeType2.$w$c==4
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15 } }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator ::
    GHC.Read.Read PhonemeType2.ActiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.ActiveArticulator
                  PhonemeType2.$fReadActiveArticulator_$s$dmreadsPrec
                  PhonemeType2.$fReadActiveArticulator_$sreadListDefault
                  PhonemeType2.$fReadActiveArticulator_$creadPrec
                  PhonemeType2.$fReadActiveArticulator_$creadListPrec -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.ActiveArticulator]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.ActiveArticulator]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.ActiveArticulator
                   PhonemeType2.$fReadActiveArticulator2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.ActiveArticulator>_R))
                   @ b
                   eta1) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.ActiveArticulator)
                   PhonemeType2.$fReadActiveArticulator11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.ActiveArticulator))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadActiveArticulator13,
                  PhonemeType2.$fReadActiveArticulator12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.ActiveArticulator>_R))))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ActiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LARYNX) -}
4242f19dfb1f37ba493fbfeef67c5868
  $fReadActiveArticulator13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LARYNX"#) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadActiveArticulator16,
                  PhonemeType2.$fReadActiveArticulator15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.ActiveArticulator>_R))))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ActiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TONGUEROOT) -}
198f4b3bf9f0519ef724aa9898451830
  $fReadActiveArticulator16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUEROOT"#) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadActiveArticulator19,
                  PhonemeType2.$fReadActiveArticulator18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.ActiveArticulator>_R))))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ActiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TONGUEBODY) -}
cc096d8cea3a9c9a83d61525a06ef663
  $fReadActiveArticulator19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUEBODY"#) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         PhonemeType2.ActiveArticulator
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.ActiveArticulator
                   PhonemeType2.$fReadActiveArticulator3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.ActiveArticulator>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.ActiveArticulator>_R)))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadActiveArticulator22,
                  PhonemeType2.$fReadActiveArticulator21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.ActiveArticulator>_R))))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ActiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TONGUEUNDER) -}
f1f08e2f56f8ce4cbe9ddb4163a3410a
  $fReadActiveArticulator22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUEUNDER"#) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadActiveArticulator25,
                  PhonemeType2.$fReadActiveArticulator24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.ActiveArticulator>_R))))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ActiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TONGUETIP) -}
04a226faf6d069f20707fad25d9d59f9
  $fReadActiveArticulator25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUETIP"#) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadActiveArticulator28,
                  PhonemeType2.$fReadActiveArticulator27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.ActiveArticulator>_R))))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ActiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TONGUEBLADE) -}
213a8b3e82b20a911a70726dd6acba4e
  $fReadActiveArticulator28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUEBLADE"#) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadActiveArticulator31,
                  PhonemeType2.$fReadActiveArticulator30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.ActiveArticulator>_R))))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ActiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.ActiveArticulator
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.ActiveArticulator
                   PhonemeType2.$fReadActiveArticulator4
                   eta
                   @ b
                   eta1) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ActiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LOWERLIP) -}
59b6b959379a488b756afcdf541ed0ee
  $fReadActiveArticulator31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LOWERLIP"#) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.ActiveArticulator)
                   PhonemeType2.$fReadActiveArticulator29
                   PhonemeType2.$fReadActiveArticulator5) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.ActiveArticulator)
                   PhonemeType2.$fReadActiveArticulator26
                   PhonemeType2.$fReadActiveArticulator6) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.ActiveArticulator)
                   PhonemeType2.$fReadActiveArticulator23
                   PhonemeType2.$fReadActiveArticulator7) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.ActiveArticulator)
                   PhonemeType2.$fReadActiveArticulator20
                   PhonemeType2.$fReadActiveArticulator8) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.ActiveArticulator)
                   PhonemeType2.$fReadActiveArticulator17
                   PhonemeType2.$fReadActiveArticulator9) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.ActiveArticulator)
                   PhonemeType2.$fReadActiveArticulator14
                   PhonemeType2.$fReadActiveArticulator10) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType2.ActiveArticulator]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadActiveArticulator1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.ActiveArticulator]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.ActiveArticulator]>_R))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType2.ActiveArticulator
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadActiveArticulator2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.ActiveArticulator>_R)) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         PhonemeType2.ActiveArticulator
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.ActiveArticulator
                   PhonemeType2.$fReadActiveArticulator_$creadPrec
                   eta) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fReadActiveArticulator_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.ActiveArticulator]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.ActiveArticulator]
                   ((PhonemeType2.$fReadActiveArticulator_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.ActiveArticulator]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.ActiveArticulator]>_R)
                      @ [PhonemeType2.ActiveArticulator]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.ActiveArticulator]))) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape :: GHC.Read.Read PhonemeType2.AirEscape
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.AirEscape
                  PhonemeType2.$fReadAirEscape_$s$dmreadsPrec
                  PhonemeType2.$fReadAirEscape_$sreadListDefault
                  PhonemeType2.$fReadAirEscape_$creadPrec
                  PhonemeType2.$fReadAirEscape_$creadListPrec -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.AirEscape] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.AirEscape]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.AirEscape
                   PhonemeType2.$fReadAirEscape2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.AirEscape>_R))
                   @ b
                   eta1) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.AirEscape -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.AirEscape
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NASALIZED) -}
2d877ff9605e3e2fb35d14ae6f49a777
  $fReadAirEscape11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NASALIZED"#) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.AirEscape
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.AirEscape
                   PhonemeType2.$fReadAirEscape3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.AirEscape>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.AirEscape>_R)))) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.AirEscape -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.AirEscape
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.AirEscape
                   PhonemeType2.$fReadAirEscape4
                   eta
                   @ b
                   eta1) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.AirEscape)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.AirEscape)
                   PhonemeType2.$fReadAirEscape9
                   PhonemeType2.$fReadAirEscape5) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.AirEscape)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.AirEscape)
                   PhonemeType2.$fReadAirEscape6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.AirEscape))) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.AirEscape)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadAirEscape8,
                  PhonemeType2.$fReadAirEscape7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.AirEscape>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.AirEscape>_R))))) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.AirEscape -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.AirEscape
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ORAL) -}
05a31fd477ab62b5f924b24896f4d0f6
  $fReadAirEscape8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ORAL"#) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.AirEscape)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadAirEscape11,
                  PhonemeType2.$fReadAirEscape10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.AirEscape>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.AirEscape>_R))))) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.AirEscape]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadAirEscape1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.AirEscape]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.AirEscape]>_R))) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.AirEscape
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadAirEscape2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.AirEscape>_R)) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.AirEscape
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.AirEscape
                   PhonemeType2.$fReadAirEscape_$creadPrec
                   eta) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fReadAirEscape_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.AirEscape]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.AirEscape]
                   ((PhonemeType2.$fReadAirEscape_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.AirEscape]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.AirEscape]>_R)
                      @ [PhonemeType2.AirEscape]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.AirEscape]))) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fReadAirstream :: GHC.Read.Read PhonemeType2.Airstream
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Airstream
                  PhonemeType2.$fReadAirstream_$s$dmreadsPrec
                  PhonemeType2.$fReadAirstream_$sreadListDefault
                  PhonemeType2.$fReadAirstream_$creadPrec
                  PhonemeType2.$fReadAirstream_$creadListPrec -}
5c7b14d72f8f222b5cc058df80cd64de
  $fReadAirstream1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Airstream] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Airstream]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Airstream
                   PhonemeType2.$fReadAirstream2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Airstream>_R))
                   @ b
                   eta1) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fReadAirstream2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Airstream
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Airstream
                   PhonemeType2.$fReadAirstream3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Airstream>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Airstream>_R)))) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fReadAirstream3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Airstream -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.Airstream -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa ww1 @ b w1 }) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fReadAirstream_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Airstream]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadAirstream1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Airstream]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Airstream]>_R))) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fReadAirstream_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Airstream
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadAirstream2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Airstream>_R)) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fReadAirstream_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Airstream
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Airstream
                   PhonemeType2.$fReadAirstream_$creadPrec
                   eta) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fReadAirstream_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Airstream]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Airstream]
                   ((PhonemeType2.$fReadAirstream_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Airstream]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Airstream]>_R)
                      @ [PhonemeType2.Airstream]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Airstream]))) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness :: GHC.Read.Read PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fReadBackness_$s$dmreadsPrec
                  PhonemeType2.$fReadBackness_$sreadListDefault
                  PhonemeType2.$fReadBackness_$creadPrec
                  PhonemeType2.$fReadBackness_$creadListPrec -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Backness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Backness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Backness>_R))
                   @ b
                   eta1) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.FRONT) -}
996a784b7476138638cbfec67373e117
  $fReadBackness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRONT"#) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness14,
                  PhonemeType2.$fReadBackness13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARFRONT) -}
a3de651522da98526c152de8affd7f13
  $fReadBackness14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARFRONT"#) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness17,
                  PhonemeType2.$fReadBackness16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CENTRAL) -}
5253bb4d4c012eb52f9372ecb1390df7
  $fReadBackness17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CENTRAL"#) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness20,
                  PhonemeType2.$fReadBackness19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARBACK) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Backness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Backness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Backness>_R)))) -}
cd9cf5753ad9b61f91896a629e5f8ddf
  $fReadBackness20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARBACK"#) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness23,
                  PhonemeType2.$fReadBackness22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.BACK) -}
c34a359bb782b8ab2872730ea235f532
  $fReadBackness23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACK"#) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Backness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness4
                   eta
                   @ b
                   eta1) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness21
                   PhonemeType2.$fReadBackness5) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness18
                   PhonemeType2.$fReadBackness6) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness15
                   PhonemeType2.$fReadBackness7) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness12
                   PhonemeType2.$fReadBackness8) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness9
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Backness))) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness11,
                  PhonemeType2.$fReadBackness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Backness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadBackness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Backness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Backness]>_R))) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadBackness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Backness>_R)) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness_$creadPrec
                   eta) -}
9918c87837d4f215d9649b53c1c134de
  $fReadBackness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Backness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Backness]
                   ((PhonemeType2.$fReadBackness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Backness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Backness]>_R)
                      @ [PhonemeType2.Backness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Backness]))) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fReadConsonant :: GHC.Read.Read PhonemeType2.Consonant
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Consonant
                  PhonemeType2.$fReadConsonant_$creadsPrec
                  PhonemeType2.$fReadConsonant_$sreadListDefault
                  PhonemeType2.$fReadConsonant_$creadPrec
                  PhonemeType2.$fReadConsonant_$creadListPrec -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fReadConsonant1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Consonant] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Consonant]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Consonant
                   PhonemeType2.$fReadConsonant2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Consonant>_R))
                   @ b
                   eta1) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fReadConsonant2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Consonant
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Consonant
                   PhonemeType2.$fReadConsonant3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Consonant>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Consonant>_R)))) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fReadConsonant3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Consonant -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.Consonant -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa1 ww1 @ b w1 }) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fReadConsonantPhonemeInventory ::
    GHC.Read.Read PhonemeType2.ConsonantPhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.ConsonantPhonemeInventory
                  PhonemeType2.$fReadConsonantPhonemeInventory_$creadsPrec
                  PhonemeType2.$fReadConsonantPhonemeInventory_$sreadListDefault
                  PhonemeType2.$fReadConsonantPhonemeInventory_$creadPrec
                  PhonemeType2.$fReadConsonantPhonemeInventory_$creadListPrec -}
498abb2d3230baf9073ff621a6aaa0e0
  $fReadConsonantPhonemeInventory1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.ConsonantPhonemeInventory]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.ConsonantPhonemeInventory]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.ConsonantPhonemeInventory
                   PhonemeType2.$fReadConsonantPhonemeInventory2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.ConsonantPhonemeInventory>_R))
                   @ b
                   eta1) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fReadConsonantPhonemeInventory2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         PhonemeType2.ConsonantPhonemeInventory
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.ConsonantPhonemeInventory
                   PhonemeType2.$fReadConsonantPhonemeInventory3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.ConsonantPhonemeInventory>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.ConsonantPhonemeInventory>_R)))) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fReadConsonantPhonemeInventory3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.ConsonantPhonemeInventory
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.ConsonantPhonemeInventory
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa2 ww1 @ b w1 }) -}
a57503d20540bea0d656ef14238e57ef
  $fReadConsonantPhonemeInventory4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "ConsonantPhonemeInventory"#) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fReadConsonantPhonemeInventory_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType2.ConsonantPhonemeInventory]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadConsonantPhonemeInventory1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.ConsonantPhonemeInventory]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.ConsonantPhonemeInventory]>_R))) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fReadConsonantPhonemeInventory_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType2.ConsonantPhonemeInventory
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadConsonantPhonemeInventory2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.ConsonantPhonemeInventory>_R)) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fReadConsonantPhonemeInventory_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         PhonemeType2.ConsonantPhonemeInventory
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType2.ConsonantPhonemeInventory
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType2.ConsonantPhonemeInventory
                       PhonemeType2.$fReadConsonantPhonemeInventory3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType2.ConsonantPhonemeInventory>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType2.ConsonantPhonemeInventory>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType2.ConsonantPhonemeInventory>_R)
                      @ PhonemeType2.ConsonantPhonemeInventory
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType2.ConsonantPhonemeInventory))) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fReadConsonantPhonemeInventory_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType2.ConsonantPhonemeInventory]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.ConsonantPhonemeInventory]
                   ((PhonemeType2.$fReadConsonantPhonemeInventory_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.ConsonantPhonemeInventory]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.ConsonantPhonemeInventory]>_R)
                      @ [PhonemeType2.ConsonantPhonemeInventory]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.ConsonantPhonemeInventory]))) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fReadConsonant_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Consonant]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadConsonant1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Consonant]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Consonant]>_R))) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fReadConsonant_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Consonant
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadConsonant2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Consonant>_R)) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fReadConsonant_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Consonant
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType2.Consonant
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType2.Consonant
                       PhonemeType2.$fReadConsonant3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType2.Consonant>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType2.Consonant>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType2.Consonant>_R)
                      @ PhonemeType2.Consonant
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType2.Consonant))) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fReadConsonant_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Consonant]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Consonant]
                   ((PhonemeType2.$fReadConsonant_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Consonant]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Consonant]>_R)
                      @ [PhonemeType2.Consonant]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Consonant]))) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection :: GHC.Read.Read PhonemeType2.Direction
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Direction
                  PhonemeType2.$fReadDirection_$s$dmreadsPrec
                  PhonemeType2.$fReadDirection_$sreadListDefault
                  PhonemeType2.$fReadDirection_$creadPrec
                  PhonemeType2.$fReadDirection_$creadListPrec -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Direction] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Direction]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Direction
                   PhonemeType2.$fReadDirection2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Direction>_R))
                   @ b
                   eta1) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Direction -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Direction
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.INGRESSIVE) -}
d4fb91e2bbac67e0274212a07a42c96c
  $fReadDirection11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INGRESSIVE"#) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Direction
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Direction
                   PhonemeType2.$fReadDirection3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Direction>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Direction>_R)))) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Direction -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Direction
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Direction
                   PhonemeType2.$fReadDirection4
                   eta
                   @ b
                   eta1) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Direction)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Direction)
                   PhonemeType2.$fReadDirection9
                   PhonemeType2.$fReadDirection5) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Direction)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Direction)
                   PhonemeType2.$fReadDirection6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Direction))) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Direction)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadDirection8,
                  PhonemeType2.$fReadDirection7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Direction>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Direction>_R))))) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Direction -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Direction
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.EGRESSIVE) -}
63460af595781f7911620b9bbcc14bfc
  $fReadDirection8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EGRESSIVE"#) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Direction)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadDirection11,
                  PhonemeType2.$fReadDirection10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Direction>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Direction>_R))))) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Direction]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadDirection1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Direction]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Direction]>_R))) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Direction
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadDirection2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Direction>_R)) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Direction
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Direction
                   PhonemeType2.$fReadDirection_$creadPrec
                   eta) -}
3de6396777539178df86bdf5ea849b5e
  $fReadDirection_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Direction]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Direction]
                   ((PhonemeType2.$fReadDirection_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Direction]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Direction]>_R)
                      @ [PhonemeType2.Direction]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Direction]))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight :: GHC.Read.Read PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fReadHeight_$s$dmreadsPrec
                  PhonemeType2.$fReadHeight_$sreadListDefault
                  PhonemeType2.$fReadHeight_$creadPrec
                  PhonemeType2.$fReadHeight_$creadListPrec -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Height] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Height]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Height>_R))
                   @ b
                   eta1) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight13,
                  PhonemeType2.$fReadHeight12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.OPEN) -}
5d434c916faf6b3ec719a16357c0be9f
  $fReadHeight13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPEN"#) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight16,
                  PhonemeType2.$fReadHeight15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEAROPEN) -}
b94bdd637cafa6dbc6fcc4b6db927359
  $fReadHeight16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEAROPEN"#) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight19,
                  PhonemeType2.$fReadHeight18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.OPENMID) -}
48024a8451f79712278a1666c540c14e
  $fReadHeight19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPENMID"#) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Height
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Height>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Height>_R)))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight22,
                  PhonemeType2.$fReadHeight21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.MID) -}
92371a4acc0fa5221a7f1f12fff78051
  $fReadHeight22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MID"#) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight25,
                  PhonemeType2.$fReadHeight24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CLOSEMID) -}
395533a690153f1412cae1b189becd2d
  $fReadHeight25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSEMID"#) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight28,
                  PhonemeType2.$fReadHeight27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARCLOSE) -}
823dd13c598094030103c7adfcb0c464
  $fReadHeight28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARCLOSE"#) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight31,
                  PhonemeType2.$fReadHeight30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight4
                   eta
                   @ b
                   eta1) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CLOSE) -}
9b2b4269f967b789b207c17fd857e9fc
  $fReadHeight31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSE"#) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight29
                   PhonemeType2.$fReadHeight5) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight26
                   PhonemeType2.$fReadHeight6) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight23
                   PhonemeType2.$fReadHeight7) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight20
                   PhonemeType2.$fReadHeight8) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight17
                   PhonemeType2.$fReadHeight9) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight14
                   PhonemeType2.$fReadHeight10) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Height]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadHeight1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Height]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Height]>_R))) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadHeight2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Height>_R)) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight_$creadPrec
                   eta) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fReadHeight_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Height]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Height]
                   ((PhonemeType2.$fReadHeight_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Height]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Height]>_R)
                      @ [PhonemeType2.Height]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Height]))) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator :: GHC.Read.Read PhonemeType2.Initiator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Initiator
                  PhonemeType2.$fReadInitiator_$s$dmreadsPrec
                  PhonemeType2.$fReadInitiator_$sreadListDefault
                  PhonemeType2.$fReadInitiator_$creadPrec
                  PhonemeType2.$fReadInitiator_$creadListPrec -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Initiator] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Initiator]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Initiator
                   PhonemeType2.$fReadInitiator2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Initiator>_R))
                   @ b
                   eta1) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadInitiator12,
                  PhonemeType2.$fReadInitiator11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Initiator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Initiator>_R))))) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Initiator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Initiator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.GLOTTIC) -}
8e9415b9ec22f4f30c26441d5aa7fd22
  $fReadInitiator12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTIC"#) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadInitiator15,
                  PhonemeType2.$fReadInitiator14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Initiator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Initiator>_R))))) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Initiator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Initiator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LINGUAL) -}
0158b965721c0137ae075b793ecd4ff6
  $fReadInitiator15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LINGUAL"#) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Initiator
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Initiator
                   PhonemeType2.$fReadInitiator3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Initiator>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Initiator>_R)))) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Initiator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Initiator
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Initiator
                   PhonemeType2.$fReadInitiator4
                   eta
                   @ b
                   eta1) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)
                   PhonemeType2.$fReadInitiator13
                   PhonemeType2.$fReadInitiator5) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)
                   PhonemeType2.$fReadInitiator10
                   PhonemeType2.$fReadInitiator6) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)
                   PhonemeType2.$fReadInitiator7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Initiator))) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadInitiator9,
                  PhonemeType2.$fReadInitiator8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Initiator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Initiator>_R))))) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Initiator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Initiator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.PULMONIC) -}
c5905d6150d5df615cbbeb4edfe1e6b9
  $fReadInitiator9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PULMONIC"#) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Initiator]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadInitiator1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Initiator]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Initiator]>_R))) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Initiator
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadInitiator2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Initiator>_R)) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Initiator
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Initiator
                   PhonemeType2.$fReadInitiator_$creadPrec
                   eta) -}
cf0efd186b87d1976dba6b7feef6e065
  $fReadInitiator_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Initiator]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Initiator]
                   ((PhonemeType2.$fReadInitiator_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Initiator]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Initiator]>_R)
                      @ [PhonemeType2.Initiator]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Initiator]))) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality :: GHC.Read.Read PhonemeType2.Laterality
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Laterality
                  PhonemeType2.$fReadLaterality_$s$dmreadsPrec
                  PhonemeType2.$fReadLaterality_$sreadListDefault
                  PhonemeType2.$fReadLaterality_$creadPrec
                  PhonemeType2.$fReadLaterality_$creadListPrec -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Laterality] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Laterality]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Laterality
                   PhonemeType2.$fReadLaterality2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Laterality>_R))
                   @ b
                   eta1) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Laterality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Laterality
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LATERAL) -}
1ef58cffffaa3c64b2757876e30424a4
  $fReadLaterality11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LATERAL"#) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Laterality
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Laterality
                   PhonemeType2.$fReadLaterality3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Laterality>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Laterality>_R)))) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Laterality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Laterality
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Laterality
                   PhonemeType2.$fReadLaterality4
                   eta
                   @ b
                   eta1) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Laterality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Laterality)
                   PhonemeType2.$fReadLaterality9
                   PhonemeType2.$fReadLaterality5) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Laterality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Laterality)
                   PhonemeType2.$fReadLaterality6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Laterality))) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Laterality)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadLaterality8,
                  PhonemeType2.$fReadLaterality7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Laterality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Laterality>_R))))) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Laterality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Laterality
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NONLATERAL) -}
4bfc02c168cd46a31a823037967087d3
  $fReadLaterality8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NONLATERAL"#) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Laterality)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadLaterality11,
                  PhonemeType2.$fReadLaterality10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Laterality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Laterality>_R))))) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Laterality]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadLaterality1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Laterality]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Laterality]>_R))) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Laterality
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadLaterality2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Laterality>_R)) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Laterality
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Laterality
                   PhonemeType2.$fReadLaterality_$creadPrec
                   eta) -}
f28c4174999e39eea0edf7a94bde9432
  $fReadLaterality_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Laterality]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Laterality]
                   ((PhonemeType2.$fReadLaterality_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Laterality]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Laterality]>_R)
                      @ [PhonemeType2.Laterality]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Laterality]))) -}
195969ff33df4040ea1319692f018c08
  $fReadLength :: GHC.Read.Read PhonemeType2.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fReadLength_$s$dmreadsPrec
                  PhonemeType2.$fReadLength_$sreadListDefault
                  PhonemeType2.$fReadLength_$creadPrec
                  PhonemeType2.$fReadLength_$creadListPrec -}
195969ff33df4040ea1319692f018c08
  $fReadLength1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Length] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Length]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Length
                   PhonemeType2.$fReadLength2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Length>_R))
                   @ b
                   eta1) -}
195969ff33df4040ea1319692f018c08
  $fReadLength10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadLength12,
                  PhonemeType2.$fReadLength11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Length>_R))))) -}
195969ff33df4040ea1319692f018c08
  $fReadLength11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NORMAL) -}
36653c4fd7097df7ab4ec418e6cc4652
  $fReadLength12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NORMAL"#) -}
195969ff33df4040ea1319692f018c08
  $fReadLength13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadLength15,
                  PhonemeType2.$fReadLength14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Length>_R))))) -}
195969ff33df4040ea1319692f018c08
  $fReadLength14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SHORT) -}
3026e78b942be325fdb46ab180406f96
  $fReadLength15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SHORT"#) -}
195969ff33df4040ea1319692f018c08
  $fReadLength2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Length
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Length
                   PhonemeType2.$fReadLength3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Length>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Length>_R)))) -}
195969ff33df4040ea1319692f018c08
  $fReadLength3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Length
                   PhonemeType2.$fReadLength4
                   eta
                   @ b
                   eta1) -}
195969ff33df4040ea1319692f018c08
  $fReadLength4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
                   PhonemeType2.$fReadLength13
                   PhonemeType2.$fReadLength5) -}
195969ff33df4040ea1319692f018c08
  $fReadLength5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
                   PhonemeType2.$fReadLength10
                   PhonemeType2.$fReadLength6) -}
195969ff33df4040ea1319692f018c08
  $fReadLength6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
                   PhonemeType2.$fReadLength7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length))) -}
195969ff33df4040ea1319692f018c08
  $fReadLength7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadLength9,
                  PhonemeType2.$fReadLength8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Length>_R))))) -}
195969ff33df4040ea1319692f018c08
  $fReadLength8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LONG) -}
0ddf6cd6f4823b35c4a5410b3906020e
  $fReadLength9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LONG"#) -}
195969ff33df4040ea1319692f018c08
  $fReadLength_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Length]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadLength1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Length]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Length]>_R))) -}
195969ff33df4040ea1319692f018c08
  $fReadLength_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadLength2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Length>_R)) -}
195969ff33df4040ea1319692f018c08
  $fReadLength_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Length
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Length
                   PhonemeType2.$fReadLength_$creadPrec
                   eta) -}
195969ff33df4040ea1319692f018c08
  $fReadLength_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Length]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Length]
                   ((PhonemeType2.$fReadLength_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Length]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Length]>_R)
                      @ [PhonemeType2.Length]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Length]))) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fReadManner :: GHC.Read.Read PhonemeType2.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fReadManner_$creadsPrec
                  PhonemeType2.$fReadManner_$sreadListDefault
                  PhonemeType2.$fReadManner_$creadPrec
                  PhonemeType2.$fReadManner_$creadListPrec -}
ab5350f5942d71b67ea9edf6454c29d6
  $fReadManner1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Manner] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Manner]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Manner>_R))
                   @ b
                   eta1) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fReadManner2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Manner
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Manner>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Manner>_R)))) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fReadManner3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa3 ww1 @ b w1 }) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fReadManner_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Manner]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadManner1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Manner]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Manner]>_R))) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fReadManner_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadManner2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Manner>_R)) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fReadManner_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Manner
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType2.Manner
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType2.Manner
                       PhonemeType2.$fReadManner3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType2.Manner>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType2.Manner>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType2.Manner>_R)
                      @ PhonemeType2.Manner
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType2.Manner))) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fReadManner_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Manner]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Manner]
                   ((PhonemeType2.$fReadManner_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Manner]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Manner]>_R)
                      @ [PhonemeType2.Manner]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Manner]))) -}
8143cb44533c9c903aac37b4f4a4473c
  $fReadMaybeContour ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    GHC.Read.Read (PhonemeType2.MaybeContour a b)
  DFunId[0]
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a18
                      @ b
                      $dRead :: GHC.Read.Read a18
                      $dRead1 :: GHC.Read.Read b.
                  @ (PhonemeType2.MaybeContour a18 b)
                  (PhonemeType2.$fReadMaybeContour_$creadsPrec
                     @ a18
                     @ b
                     $dRead
                     $dRead1)
                  (PhonemeType2.$fReadMaybeContour_$creadList
                     @ a18
                     @ b
                     $dRead
                     $dRead1)
                  (PhonemeType2.$fReadMaybeContour_$creadPrec
                     @ a18
                     @ b
                     $dRead
                     $dRead1)
                  (PhonemeType2.$fReadMaybeContour_$creadListPrec
                     @ a18
                     @ b
                     $dRead
                     $dRead1) -}
8143cb44533c9c903aac37b4f4a4473c
  $fReadMaybeContour1 ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b1.
       ([PhonemeType2.MaybeContour a b]
        -> Text.ParserCombinators.ReadP.P b1)
       -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 4, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a18
                   @ b
                   $dRead :: GHC.Read.Read a18
                   $dRead1 :: GHC.Read.Read b
                   eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b1
                   eta1 :: [PhonemeType2.MaybeContour a18 b]
                           -> Text.ParserCombinators.ReadP.P b1 ->
                 GHC.Read.$wa
                   @ (PhonemeType2.MaybeContour a18 b)
                   (PhonemeType2.$fReadMaybeContour2 @ a18 @ b $dRead $dRead1)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.MaybeContour a18 b>_R))
                   @ b1
                   eta1) -}
969001b0788955f5c5d2a88a852f3536
  $fReadMaybeContour10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.MaybeContour PhonemeType2.Manner PhonemeType2.Manner
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.MaybeContour
                           PhonemeType2.Manner PhonemeType2.Manner
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa6 ww1 @ b w1 }) -}
1557369991507643a5f1ea6214556c16
  $fReadMaybeContour12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.MaybeContour
          PhonemeType2.Airstream PhonemeType2.Airstream
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.MaybeContour
                           PhonemeType2.Airstream PhonemeType2.Airstream
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa7 ww1 @ b w1 }) -}
84bf296065a4acd17dfe948753593259
  $fReadMaybeContour14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.MaybeContour
          PhonemeType2.Phonation PhonemeType2.Phonation
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.MaybeContour
                           PhonemeType2.Phonation PhonemeType2.Phonation
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa8 ww1 @ b w1 }) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Phonation
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Phonation
                   PhonemeType2.$fReadMaybeContour16
                   eta
                   @ b
                   eta1) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadMaybeContour41
                   PhonemeType2.$fReadMaybeContour17) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour17 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadMaybeContour38
                   PhonemeType2.$fReadMaybeContour18) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour18 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadMaybeContour35
                   PhonemeType2.$fReadMaybeContour19) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour19 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadMaybeContour32
                   PhonemeType2.$fReadMaybeContour20) -}
8143cb44533c9c903aac37b4f4a4473c
  $fReadMaybeContour2 ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (PhonemeType2.MaybeContour a b)
  {- Arity: 3, Strictness: <L,1*U(A,A,1*U,A)><L,U(A,A,U,A)><L,U>,
     Unfolding: (\ @ a18
                   @ b
                   $dRead :: GHC.Read.Read a18
                   $dRead1 :: GHC.Read.Read b
                   eta :: Text.ParserCombinators.ReadPrec.Prec ->
                 let {
                   ds :: Text.ParserCombinators.ReadPrec.ReadPrec b
                   = GHC.Read.readPrec @ b $dRead1
                 } in
                 GHC.Read.$fReadDouble10
                   @ (PhonemeType2.MaybeContour a18 b)
                   (let {
                      ds1 :: Text.ParserCombinators.ReadPrec.ReadPrec a18
                      = GHC.Read.readPrec @ a18 $dRead
                    } in
                    (\ n :: Text.ParserCombinators.ReadPrec.Prec
                       @ b1
                       eta1 :: PhonemeType2.MaybeContour a18 b
                               -> Text.ParserCombinators.ReadP.P b1 ->
                     case n of wild { GHC.Types.I# x ->
                     let {
                       a19 :: Text.ParserCombinators.ReadP.P b1
                       = case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=# x 10) of wild2 {
                           GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                           GHC.Types.True
                           -> let {
                                lvl115 :: Text.ParserCombinators.ReadP.P b1
                                = let {
                                    lvl116 :: Text.ParserCombinators.ReadP.P b1
                                    = (ds1
                                         `cast`
                                       (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0] <a18>_R)
                                         PhonemeType2.$fReadMaybeContour5)
                                        `cast`
                                      (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <a18>_R)
                                        @ b1
                                        (\ a20 :: a18 ->
                                         (ds
                                            `cast`
                                          (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0] <b>_R)
                                            PhonemeType2.$fReadMaybeContour5)
                                           `cast`
                                         (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <b>_R)
                                           @ b1
                                           (\ a21 :: b ->
                                            eta1 (PhonemeType2.Contour @ a18 @ b a20 a21)))
                                  } in
                                  Text.Read.Lex.expect2
                                    @ b1
                                    (\ a98 :: Text.Read.Lex.Lexeme ->
                                     case a98 of wild1 {
                                       DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                                       Text.Read.Lex.Ident a20
                                       -> case GHC.Base.eqString
                                                 a20
                                                 PhonemeType2.$fReadMaybeContour4 of wild3 {
                                            GHC.Types.False
                                            -> Text.ParserCombinators.ReadP.Fail @ b1
                                            GHC.Types.True -> lvl116 } })
                              } in
                              let {
                                k :: () -> Text.ParserCombinators.ReadP.P b1
                                  {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                     Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                                = \ w2 :: () -> lvl115
                              } in
                              Text.ParserCombinators.ReadP.Look
                                @ b1
                                (\ a98 :: GHC.Base.String ->
                                 (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                                   `cast`
                                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                                   @ b1
                                   k) }
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 10) of wild2 {
                       GHC.Types.False
                       -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                            @ b1
                            (Text.ParserCombinators.ReadP.Fail @ b1)
                            a19
                       GHC.Types.True
                       -> let {
                            lvl115 :: Text.ParserCombinators.ReadP.P b1
                            = let {
                                lvl116 :: Text.ParserCombinators.ReadP.P b1
                                = (ds
                                     `cast`
                                   (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0] <b>_R)
                                     PhonemeType2.$fReadMaybeContour5)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <b>_R)
                                    @ b1
                                    (\ a20 :: b -> eta1 (PhonemeType2.NoContour @ a18 @ b a20))
                              } in
                              Text.Read.Lex.expect2
                                @ b1
                                (\ a98 :: Text.Read.Lex.Lexeme ->
                                 case a98 of wild1 {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                                   Text.Read.Lex.Ident a20
                                   -> case GHC.Base.eqString
                                             a20
                                             PhonemeType2.$fReadMaybeContour3 of wild3 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                                        GHC.Types.True -> lvl116 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b1
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                            = \ w2 :: () -> lvl115
                          } in
                          Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                            @ b1
                            (Text.ParserCombinators.ReadP.Look
                               @ b1
                               (\ a98 :: GHC.Base.String ->
                                (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                                  `cast`
                                (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                                  @ b1
                                  k))
                            a19 } })
                      `cast`
                    (Trans
                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                        <PhonemeType2.MaybeContour a18 b>_R))
                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                   <PhonemeType2.MaybeContour a18 b>_R))))
                   eta) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour20 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadMaybeContour29
                   PhonemeType2.$fReadMaybeContour21) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadMaybeContour26
                   PhonemeType2.$fReadMaybeContour22) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour22 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadMaybeContour23
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Phonation))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour25,
                  PhonemeType2.$fReadMaybeContour24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CLOSURE) -}
73993a6b76b860e4e2d318017beff854
  $fReadMaybeContour25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSURE"#) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour28,
                  PhonemeType2.$fReadMaybeContour27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CREAKY) -}
6810106ca9d0a41e7f96ef53970378ae
  $fReadMaybeContour28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CREAKY"#) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour31,
                  PhonemeType2.$fReadMaybeContour30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
cdb0c6dfc1bc77cb0a2af94038da856f
  $fReadMaybeContour3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoContour"#) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.STIFF) -}
3cc4e38f42b24f9371e65793f4f3b744
  $fReadMaybeContour31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STIFF"#) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour34,
                  PhonemeType2.$fReadMaybeContour33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.MODAL) -}
77bdb8afd42f358d1e4fb0cf62af5706
  $fReadMaybeContour34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MODAL"#) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour37,
                  PhonemeType2.$fReadMaybeContour36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SLACK) -}
8673de43a303bcf549d6e54439cf358c
  $fReadMaybeContour37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SLACK"#) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour40,
                  PhonemeType2.$fReadMaybeContour39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.BREATHY) -}
e7f0f9c33e75621bb9ad409c646a0033
  $fReadMaybeContour4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Contour"#) -}
4e806fb0af8c04f3a1b3f1b5b21aa6b7
  $fReadMaybeContour40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BREATHY"#) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour43,
                  PhonemeType2.$fReadMaybeContour42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadMaybeContour42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.VOICELESS) -}
bb44a07b718363f3f025cc7c12c8ca8b
  $fReadMaybeContour43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICELESS"#) -}
10d1f62e8f77ad0287336c3304fb2506
  $fReadMaybeContour45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.MaybeContour PhonemeType2.Height PhonemeType2.Height
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.MaybeContour
                           PhonemeType2.Height PhonemeType2.Height
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa9 ww1 @ b w1 }) -}
197dc3244c41c383e41adc303488f08e
  $fReadMaybeContour47 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.MaybeContour
          PhonemeType2.Backness PhonemeType2.Backness
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.MaybeContour
                           PhonemeType2.Backness PhonemeType2.Backness
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa10 ww1 @ b w1 }) -}
7a7c49f168c111dc202f7b3a6a6cbffe
  $fReadMaybeContour49 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.MaybeContour
          PhonemeType2.Roundedness PhonemeType2.Roundedness
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.MaybeContour
                           PhonemeType2.Roundedness PhonemeType2.Roundedness
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa11 ww1 @ b w1 }) -}
5bd2d92a99c2e5dc06ad08cbef57ddaf
  $fReadMaybeContour5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadMaybeContour50 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Roundedness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadMaybeContour51
                   eta
                   @ b
                   eta1) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadMaybeContour51 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
                   PhonemeType2.$fReadMaybeContour56
                   PhonemeType2.$fReadMaybeContour52) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadMaybeContour52 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
                   PhonemeType2.$fReadMaybeContour53
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Roundedness))) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadMaybeContour53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour55,
                  PhonemeType2.$fReadMaybeContour54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Roundedness>_R))))) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadMaybeContour54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ROUNDED) -}
e815cea9aa2849891c27098ea85c98d6
  $fReadMaybeContour55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ROUNDED"#) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadMaybeContour56 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeContour58,
                  PhonemeType2.$fReadMaybeContour57
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Roundedness>_R))))) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadMaybeContour57 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.UNROUNDED) -}
3eba81b41f49cfb373d33bec8a72785f
  $fReadMaybeContour58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UNROUNDED"#) -}
abc8ebc8dacd6236b9f1bf4830082ce8
  $fReadMaybeContour7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.MaybeContour PhonemeType2.Place PhonemeType2.Place
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.MaybeContour
                           PhonemeType2.Place PhonemeType2.Place
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa4 ww1 @ b w1 }) -}
ce06e3a360ef67b905c70e56b1480a17
  $fReadMaybeContour8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa5 ww1 @ b w1 }) -}
8143cb44533c9c903aac37b4f4a4473c
  $fReadMaybeContour_$creadList ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.MaybeContour a b]
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a18
                   @ b
                   $dRead :: GHC.Read.Read a18
                   $dRead1 :: GHC.Read.Read b ->
                 Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.MaybeContour a18 b]
                   (GHC.Read.$wa
                      @ (PhonemeType2.MaybeContour a18 b)
                      (PhonemeType2.$fReadMaybeContour2 @ a18 @ b $dRead $dRead1)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                <PhonemeType2.MaybeContour a18 b>_R))
                      @ [PhonemeType2.MaybeContour a18 b]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.MaybeContour a18 b]))) -}
8143cb44533c9c903aac37b4f4a4473c
  $fReadMaybeContour_$creadListPrec ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType2.MaybeContour a b]
  {- Arity: 4, Strictness: <L,U(A,A,U,A)><L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadMaybeContour1
                  `cast`
                (forall a18 b.
                 <GHC.Read.Read a18>_R
                 ->_R <GHC.Read.Read b>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                         <[PhonemeType2.MaybeContour a18 b]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                    <[PhonemeType2.MaybeContour a18 b]>_R))) -}
8143cb44533c9c903aac37b4f4a4473c
  $fReadMaybeContour_$creadPrec ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      (PhonemeType2.MaybeContour a b)
  {- Arity: 3, Strictness: <L,1*U(A,A,1*U,A)><L,U(A,A,U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadMaybeContour2
                  `cast`
                (forall a18 b.
                 <GHC.Read.Read a18>_R
                 ->_R <GHC.Read.Read b>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <PhonemeType2.MaybeContour a18 b>_R)) -}
8143cb44533c9c903aac37b4f4a4473c
  $fReadMaybeContour_$creadsPrec ::
    (GHC.Read.Read a, GHC.Read.Read b) =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (PhonemeType2.MaybeContour a b)
  {- Arity: 3, Strictness: <L,1*U(A,A,1*U,A)><L,U(A,A,U,A)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a18
                   @ b
                   $dRead :: GHC.Read.Read a18
                   $dRead1 :: GHC.Read.Read b
                   eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType2.MaybeContour a18 b)
                   ((PhonemeType2.$fReadMaybeContour2 @ a18 @ b $dRead $dRead1 eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType2.MaybeContour a18 b>_R)
                      @ (PhonemeType2.MaybeContour a18 b)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType2.MaybeContour a18 b)))) -}
b13bbde41449c45003ef1026fa30364d
  $fReadMaybeImpossible ::
    GHC.Read.Read a => GHC.Read.Read (PhonemeType2.MaybeImpossible a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a18 $dRead :: GHC.Read.Read a18.
                  @ (PhonemeType2.MaybeImpossible a18)
                  (PhonemeType2.$fReadMaybeImpossible_$creadsPrec @ a18 $dRead)
                  (PhonemeType2.$fReadMaybeImpossible_$creadList @ a18 $dRead)
                  (PhonemeType2.$fReadMaybeImpossible_$creadPrec @ a18 $dRead)
                  (PhonemeType2.$fReadMaybeImpossible_$creadListPrec @ a18 $dRead) -}
b13bbde41449c45003ef1026fa30364d
  $fReadMaybeImpossible1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.MaybeImpossible a]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a18
                   $dRead :: GHC.Read.Read a18
                   eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.MaybeImpossible a18]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (PhonemeType2.MaybeImpossible a18)
                   (PhonemeType2.$fReadMaybeImpossible2 @ a18 $dRead)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.MaybeImpossible a18>_R))
                   @ b
                   eta1) -}
8650e80162817fe79be4acc77e003de6
  $fReadMaybeImpossible10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Trill)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeImpossible12,
                  PhonemeType2.$fReadMaybeImpossible11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Trill>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Trill>_R))))) -}
8650e80162817fe79be4acc77e003de6
  $fReadMaybeImpossible11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Trill -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Trill -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NOTTRILLED) -}
bf788eda7e01090e8ffcf17826d6344a
  $fReadMaybeImpossible12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NOTTRILLED"#) -}
8650e80162817fe79be4acc77e003de6
  $fReadMaybeImpossible13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Trill)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeImpossible15,
                  PhonemeType2.$fReadMaybeImpossible14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Trill>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Trill>_R))))) -}
8650e80162817fe79be4acc77e003de6
  $fReadMaybeImpossible14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Trill -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Trill -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TRILLED) -}
478a98d022faba34792b700e14d4c6e1
  $fReadMaybeImpossible15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRILLED"#) -}
b13bbde41449c45003ef1026fa30364d
  $fReadMaybeImpossible2 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (PhonemeType2.MaybeImpossible a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: (\ @ a18
                   $dRead :: GHC.Read.Read a18
                   eta :: Text.ParserCombinators.ReadPrec.Prec ->
                 GHC.Read.$fReadDouble10
                   @ (PhonemeType2.MaybeImpossible a18)
                   (let {
                      ds :: Text.ParserCombinators.ReadPrec.ReadPrec a18
                      = GHC.Read.readPrec @ a18 $dRead
                    } in
                    (\ n :: Text.ParserCombinators.ReadPrec.Prec
                       @ b
                       eta1 :: PhonemeType2.MaybeImpossible a18
                               -> Text.ParserCombinators.ReadP.P b ->
                     let {
                       lvl115 :: Text.ParserCombinators.ReadP.P b
                       = let {
                           lvl116 :: Text.ParserCombinators.ReadP.P b
                           = eta1 (PhonemeType2.Impossible @ a18)
                         } in
                         Text.Read.Lex.expect2
                           @ b
                           (\ a98 :: Text.Read.Lex.Lexeme ->
                            case a98 of wild {
                              DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                              Text.Read.Lex.Ident a19
                              -> case GHC.Base.eqString
                                        a19
                                        PhonemeType2.$fReadMaybeImpossible4 of wild1 {
                                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                   GHC.Types.True -> lvl116 } })
                     } in
                     let {
                       k :: () -> Text.ParserCombinators.ReadP.P b
                         {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                            Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                       = \ w2 :: () -> lvl115
                     } in
                     Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                       @ b
                       (Text.ParserCombinators.ReadP.Look
                          @ b
                          (\ a98 :: GHC.Base.String ->
                           (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                             `cast`
                           (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                             @ b
                             k))
                       (case n of wild { GHC.Types.I# x ->
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<=# x 10) of wild2 {
                          GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                          GHC.Types.True
                          -> let {
                               lvl116 :: Text.ParserCombinators.ReadP.P b
                               = let {
                                   lvl117 :: Text.ParserCombinators.ReadP.P b
                                   = (ds
                                        `cast`
                                      (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0] <a18>_R)
                                        PhonemeType2.$fReadMaybeContour5)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <a18>_R)
                                       @ b
                                       (\ a19 :: a18 -> eta1 (PhonemeType2.Possible @ a18 a19))
                                 } in
                                 Text.Read.Lex.expect2
                                   @ b
                                   (\ a98 :: Text.Read.Lex.Lexeme ->
                                    case a98 of wild1 {
                                      DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                      Text.Read.Lex.Ident a19
                                      -> case GHC.Base.eqString
                                                a19
                                                PhonemeType2.$fReadMaybeImpossible3 of wild3 {
                                           GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                           GHC.Types.True -> lvl117 } })
                             } in
                             let {
                               k1 :: () -> Text.ParserCombinators.ReadP.P b
                                 {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                    Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl116) -}
                               = \ w2 :: () -> lvl116
                             } in
                             Text.ParserCombinators.ReadP.Look
                               @ b
                               (\ a98 :: GHC.Base.String ->
                                (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                                  `cast`
                                (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                                  @ b
                                  k1) } }))
                      `cast`
                    (Trans
                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                        <PhonemeType2.MaybeImpossible a18>_R))
                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                   <PhonemeType2.MaybeImpossible a18>_R))))
                   eta) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadMaybeImpossible20 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Silibance -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Silibance
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Silibance
                   PhonemeType2.$fReadMaybeImpossible21
                   eta
                   @ b
                   eta1) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadMaybeImpossible21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Silibance)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Silibance)
                   PhonemeType2.$fReadMaybeImpossible26
                   PhonemeType2.$fReadMaybeImpossible22) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadMaybeImpossible22 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Silibance)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Silibance)
                   PhonemeType2.$fReadMaybeImpossible23
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Silibance))) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadMaybeImpossible23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Silibance)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeImpossible25,
                  PhonemeType2.$fReadMaybeImpossible24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Silibance>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Silibance>_R))))) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadMaybeImpossible24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Silibance -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Silibance
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NONSILIBANT) -}
018c1c744ddad3dd0cd3cb70c142e74b
  $fReadMaybeImpossible25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NONSILIBANT"#) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadMaybeImpossible26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Silibance)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeImpossible28,
                  PhonemeType2.$fReadMaybeImpossible27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Silibance>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Silibance>_R))))) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadMaybeImpossible27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Silibance -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Silibance
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SILIBANT) -}
064c0cf616805f77d971da1b5ca5945b
  $fReadMaybeImpossible28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SILIBANT"#) -}
31dd802ff822a9b9362eed3bb04a7dbf
  $fReadMaybeImpossible3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Possible"#) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible31 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.VOT -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.VOT -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.VOT
                   PhonemeType2.$fReadMaybeImpossible32
                   eta
                   @ b
                   eta1) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible32 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)
                   PhonemeType2.$fReadMaybeImpossible41
                   PhonemeType2.$fReadMaybeImpossible33) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible33 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)
                   PhonemeType2.$fReadMaybeImpossible38
                   PhonemeType2.$fReadMaybeImpossible34) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible34 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)
                   PhonemeType2.$fReadMaybeImpossible35
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT))) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeImpossible37,
                  PhonemeType2.$fReadMaybeImpossible36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.VOT>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.VOT>_R))))) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.VOT -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.VOT -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEGATIVE) -}
34071fab46fce01a5e0b5e7a13da02f7
  $fReadMaybeImpossible37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEGATIVE"#) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeImpossible40,
                  PhonemeType2.$fReadMaybeImpossible39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.VOT>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.VOT>_R))))) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.VOT -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.VOT -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ZERO) -}
d460ea2ceead67b7e36a965ffcf779b6
  $fReadMaybeImpossible4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Impossible"#) -}
e9e702e6b5626c324161526e0f766d31
  $fReadMaybeImpossible40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ZERO"#) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadMaybeImpossible43,
                  PhonemeType2.$fReadMaybeImpossible42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.VOT>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.VOT>_R))))) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadMaybeImpossible42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.VOT -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.VOT -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.POSITIVE) -}
22b29a6bea4b6f0fbf7e1201d768e089
  $fReadMaybeImpossible43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POSITIVE"#) -}
8650e80162817fe79be4acc77e003de6
  $fReadMaybeImpossible7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Trill -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Trill -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Trill
                   PhonemeType2.$fReadMaybeImpossible8
                   eta
                   @ b
                   eta1) -}
8650e80162817fe79be4acc77e003de6
  $fReadMaybeImpossible8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Trill)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Trill)
                   PhonemeType2.$fReadMaybeImpossible13
                   PhonemeType2.$fReadMaybeImpossible9) -}
8650e80162817fe79be4acc77e003de6
  $fReadMaybeImpossible9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Trill)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Trill)
                   PhonemeType2.$fReadMaybeImpossible10
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Trill))) -}
b13bbde41449c45003ef1026fa30364d
  $fReadMaybeImpossible_$creadList ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.MaybeImpossible a]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a18 $dRead :: GHC.Read.Read a18 ->
                 Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.MaybeImpossible a18]
                   (GHC.Read.$wa
                      @ (PhonemeType2.MaybeImpossible a18)
                      (PhonemeType2.$fReadMaybeImpossible2 @ a18 $dRead)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                <PhonemeType2.MaybeImpossible a18>_R))
                      @ [PhonemeType2.MaybeImpossible a18]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.MaybeImpossible a18]))) -}
b13bbde41449c45003ef1026fa30364d
  $fReadMaybeImpossible_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType2.MaybeImpossible a]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadMaybeImpossible1
                  `cast`
                (forall a18.
                 <GHC.Read.Read a18>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                         <[PhonemeType2.MaybeImpossible a18]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                    <[PhonemeType2.MaybeImpossible a18]>_R))) -}
b13bbde41449c45003ef1026fa30364d
  $fReadMaybeImpossible_$creadPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      (PhonemeType2.MaybeImpossible a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadMaybeImpossible2
                  `cast`
                (forall a18.
                 <GHC.Read.Read a18>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <PhonemeType2.MaybeImpossible a18>_R)) -}
b13bbde41449c45003ef1026fa30364d
  $fReadMaybeImpossible_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (PhonemeType2.MaybeImpossible a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a18 $dRead :: GHC.Read.Read a18 eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType2.MaybeImpossible a18)
                   ((PhonemeType2.$fReadMaybeImpossible2 @ a18 $dRead eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType2.MaybeImpossible a18>_R)
                      @ (PhonemeType2.MaybeImpossible a18)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType2.MaybeImpossible a18)))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator ::
    GHC.Read.Read PhonemeType2.PassiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PassiveArticulator
                  PhonemeType2.$fReadPassiveArticulator_$s$dmreadsPrec
                  PhonemeType2.$fReadPassiveArticulator_$sreadListDefault
                  PhonemeType2.$fReadPassiveArticulator_$creadPrec
                  PhonemeType2.$fReadPassiveArticulator_$creadListPrec -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.PassiveArticulator]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.PassiveArticulator]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.PassiveArticulator
                   PhonemeType2.$fReadPassiveArticulator2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.PassiveArticulator>_R))
                   @ b
                   eta1) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator27
                   PhonemeType2.$fReadPassiveArticulator11) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator24
                   PhonemeType2.$fReadPassiveArticulator12) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator21
                   PhonemeType2.$fReadPassiveArticulator13) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator18
                   PhonemeType2.$fReadPassiveArticulator14) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator15
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.PassiveArticulator))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator17,
                  PhonemeType2.$fReadPassiveArticulator16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.GLOTTIS) -}
f353baf02c8e98d96b926962ac2d2cbc
  $fReadPassiveArticulator17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTIS"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator20,
                  PhonemeType2.$fReadPassiveArticulator19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.EPIGLOTTIS) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         PhonemeType2.PassiveArticulator
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.PassiveArticulator
                   PhonemeType2.$fReadPassiveArticulator3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.PassiveArticulator>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.PassiveArticulator>_R)))) -}
f815227f6c478a0748acc6e96709648d
  $fReadPassiveArticulator20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIGLOTTIS"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator23,
                  PhonemeType2.$fReadPassiveArticulator22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.PHARYNX) -}
2f4fb0d3d04b61a15b362faa357f5874
  $fReadPassiveArticulator23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PHARYNX"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator24 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator26,
                  PhonemeType2.$fReadPassiveArticulator25
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator25 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.UVULA) -}
340923d3fee4d2228107f1f9e4e572a1
  $fReadPassiveArticulator26 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVULA"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator27 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator29,
                  PhonemeType2.$fReadPassiveArticulator28
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator28 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SOFTPALATE) -}
b97562331199372a936ee7c1ed02608d
  $fReadPassiveArticulator29 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SOFTPALATE"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.PassiveArticulator
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.PassiveArticulator
                   PhonemeType2.$fReadPassiveArticulator4
                   eta
                   @ b
                   eta1) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator30 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator32,
                  PhonemeType2.$fReadPassiveArticulator31
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator31 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.HARDPALATE) -}
22b48c1f7142d10131909b9965d73c68
  $fReadPassiveArticulator32 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HARDPALATE"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator33 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator35,
                  PhonemeType2.$fReadPassiveArticulator34
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator34 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.BACKRIDGE) -}
5b6c4b3091899b1fcf189d4ca850bee5
  $fReadPassiveArticulator35 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACKRIDGE"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator36 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator38,
                  PhonemeType2.$fReadPassiveArticulator37
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator37 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.RIDGE) -}
a95fa478bbd5a8db1d1e869bd3dba609
  $fReadPassiveArticulator38 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RIDGE"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator39 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator41,
                  PhonemeType2.$fReadPassiveArticulator40
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator45
                   PhonemeType2.$fReadPassiveArticulator5) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator40 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TEETHRIDGE) -}
fc7b15b5f0d7677c79c48b8a999130bf
  $fReadPassiveArticulator41 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TEETHRIDGE"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator42 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator44,
                  PhonemeType2.$fReadPassiveArticulator43
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator43 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.UPPERTEETH) -}
448f06f3357d393135a5cd8b9671c5da
  $fReadPassiveArticulator44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UPPERTEETH"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator45 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType2.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPassiveArticulator47,
                  PhonemeType2.$fReadPassiveArticulator46
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.PassiveArticulator>_R))))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator46 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.UPPERLIP) -}
8cd1f9daadeeaa9aa7bb3f81a6b35bc2
  $fReadPassiveArticulator47 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UPPERLIP"#) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator42
                   PhonemeType2.$fReadPassiveArticulator6) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator39
                   PhonemeType2.$fReadPassiveArticulator7) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator36
                   PhonemeType2.$fReadPassiveArticulator8) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator33
                   PhonemeType2.$fReadPassiveArticulator9) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType2.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType2.PassiveArticulator)
                   PhonemeType2.$fReadPassiveArticulator30
                   PhonemeType2.$fReadPassiveArticulator10) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType2.PassiveArticulator]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPassiveArticulator1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.PassiveArticulator]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.PassiveArticulator]>_R))) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType2.PassiveArticulator
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPassiveArticulator2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.PassiveArticulator>_R)) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         PhonemeType2.PassiveArticulator
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.PassiveArticulator
                   PhonemeType2.$fReadPassiveArticulator_$creadPrec
                   eta) -}
b99e0542eafd4baafc4b7c93a8988262
  $fReadPassiveArticulator_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType2.PassiveArticulator]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.PassiveArticulator]
                   ((PhonemeType2.$fReadPassiveArticulator_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.PassiveArticulator]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.PassiveArticulator]>_R)
                      @ [PhonemeType2.PassiveArticulator]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.PassiveArticulator]))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadPhonation :: GHC.Read.Read PhonemeType2.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fReadPhonation_$s$dmreadsPrec
                  PhonemeType2.$fReadPhonation_$sreadListDefault
                  PhonemeType2.$fReadPhonation_$creadPrec
                  PhonemeType2.$fReadPhonation_$creadListPrec -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadPhonation1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Phonation] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Phonation]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Phonation
                   PhonemeType2.$fReadPhonation2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Phonation>_R))
                   @ b
                   eta1) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadPhonation2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Phonation
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Phonation
                   PhonemeType2.$fReadMaybeContour15
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Phonation>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Phonation>_R)))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadPhonation_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Phonation]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhonation1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Phonation]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Phonation]>_R))) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadPhonation_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhonation2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Phonation>_R)) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadPhonation_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Phonation
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Phonation
                   PhonemeType2.$fReadPhonation_$creadPrec
                   eta) -}
a4e0caad2d1174c9226145cc0019ed73
  $fReadPhonation_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Phonation]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Phonation]
                   ((PhonemeType2.$fReadPhonation_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Phonation]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Phonation]>_R)
                      @ [PhonemeType2.Phonation]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Phonation]))) -}
ce06e3a360ef67b905c70e56b1480a17
  $fReadPlace :: GHC.Read.Read PhonemeType2.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fReadPlace_$s$dmreadsPrec
                  PhonemeType2.$fReadPlace_$sreadListDefault
                  PhonemeType2.$fReadPlace_$creadPrec
                  PhonemeType2.$fReadPlace_$creadListPrec -}
ce06e3a360ef67b905c70e56b1480a17
  $fReadPlace1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Place] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Place] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Place>_R))
                   @ b
                   eta1) -}
ce06e3a360ef67b905c70e56b1480a17
  $fReadPlace2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Place
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadMaybeContour8
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Place>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Place>_R)))) -}
ce06e3a360ef67b905c70e56b1480a17
  $fReadPlace_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Place]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPlace1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Place]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Place]>_R))) -}
ce06e3a360ef67b905c70e56b1480a17
  $fReadPlace_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPlace2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Place>_R)) -}
ce06e3a360ef67b905c70e56b1480a17
  $fReadPlace_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Place
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace_$creadPrec
                   eta) -}
ce06e3a360ef67b905c70e56b1480a17
  $fReadPlace_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Place]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Place]
                   ((PhonemeType2.$fReadPlace_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Place]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Place]>_R)
                      @ [PhonemeType2.Place]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Place]))) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadRoundedness :: GHC.Read.Read PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fReadRoundedness_$s$dmreadsPrec
                  PhonemeType2.$fReadRoundedness_$sreadListDefault
                  PhonemeType2.$fReadRoundedness_$creadPrec
                  PhonemeType2.$fReadRoundedness_$creadListPrec -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadRoundedness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Roundedness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Roundedness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Roundedness>_R))
                   @ b
                   eta1) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadRoundedness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Roundedness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadMaybeContour50
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Roundedness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Roundedness>_R)))) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadRoundedness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadRoundedness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Roundedness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Roundedness]>_R))) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadRoundedness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadRoundedness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Roundedness>_R)) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadRoundedness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness_$creadPrec
                   eta) -}
e8a534a069fcf11d22fabc02549d84ae
  $fReadRoundedness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Roundedness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Roundedness]
                   ((PhonemeType2.$fReadRoundedness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Roundedness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Roundedness]>_R)
                      @ [PhonemeType2.Roundedness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Roundedness]))) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadSilibance :: GHC.Read.Read PhonemeType2.Silibance
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Silibance
                  PhonemeType2.$fReadSilibance_$s$dmreadsPrec
                  PhonemeType2.$fReadSilibance_$sreadListDefault
                  PhonemeType2.$fReadSilibance_$creadPrec
                  PhonemeType2.$fReadSilibance_$creadListPrec -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadSilibance1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Silibance] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Silibance]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Silibance
                   PhonemeType2.$fReadSilibance2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Silibance>_R))
                   @ b
                   eta1) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadSilibance2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Silibance
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Silibance
                   PhonemeType2.$fReadMaybeImpossible20
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Silibance>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Silibance>_R)))) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadSilibance_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Silibance]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadSilibance1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Silibance]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Silibance]>_R))) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadSilibance_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Silibance
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadSilibance2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Silibance>_R)) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadSilibance_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Silibance
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Silibance
                   PhonemeType2.$fReadSilibance_$creadPrec
                   eta) -}
6f56b9eb1985eff94cee6d9814538c86
  $fReadSilibance_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Silibance]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Silibance]
                   ((PhonemeType2.$fReadSilibance_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Silibance]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Silibance]>_R)
                      @ [PhonemeType2.Silibance]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Silibance]))) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture :: GHC.Read.Read PhonemeType2.Stricture
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Stricture
                  PhonemeType2.$fReadStricture_$s$dmreadsPrec
                  PhonemeType2.$fReadStricture_$sreadListDefault
                  PhonemeType2.$fReadStricture_$creadPrec
                  PhonemeType2.$fReadStricture_$creadListPrec -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Stricture] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Stricture]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Stricture
                   PhonemeType2.$fReadStricture2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Stricture>_R))
                   @ b
                   eta1) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadStricture12,
                  PhonemeType2.$fReadStricture11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Stricture>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Stricture>_R))))) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Stricture -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Stricture
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TURBULENT) -}
79fa6d6ddb4e0b54759ab94cdd38b090
  $fReadStricture12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TURBULENT"#) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadStricture15,
                  PhonemeType2.$fReadStricture14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Stricture>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Stricture>_R))))) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Stricture -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Stricture
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.OCCLUSION) -}
a69f4e52887d9dd35600ec1d923693fc
  $fReadStricture15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OCCLUSION"#) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Stricture
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Stricture
                   PhonemeType2.$fReadStricture3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Stricture>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Stricture>_R)))) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Stricture -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Stricture
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Stricture
                   PhonemeType2.$fReadStricture4
                   eta
                   @ b
                   eta1) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)
                   PhonemeType2.$fReadStricture13
                   PhonemeType2.$fReadStricture5) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)
                   PhonemeType2.$fReadStricture10
                   PhonemeType2.$fReadStricture6) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)
                   PhonemeType2.$fReadStricture7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Stricture))) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadStricture9,
                  PhonemeType2.$fReadStricture8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Stricture>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Stricture>_R))))) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Stricture -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Stricture
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SLIGHTTURBULENT) -}
1a5c5e03cfb2eff052eb782fb31eae22
  $fReadStricture9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SLIGHTTURBULENT"#) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Stricture]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadStricture1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Stricture]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Stricture]>_R))) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Stricture
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadStricture2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Stricture>_R)) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Stricture
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Stricture
                   PhonemeType2.$fReadStricture_$creadPrec
                   eta) -}
57e37fc45e7527176af3ce2952794c24
  $fReadStricture_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Stricture]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Stricture]
                   ((PhonemeType2.$fReadStricture_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Stricture]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Stricture]>_R)
                      @ [PhonemeType2.Stricture]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Stricture]))) -}
8650e80162817fe79be4acc77e003de6
  $fReadTrill :: GHC.Read.Read PhonemeType2.Trill
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Trill
                  PhonemeType2.$fReadTrill_$s$dmreadsPrec
                  PhonemeType2.$fReadTrill_$sreadListDefault
                  PhonemeType2.$fReadTrill_$creadPrec
                  PhonemeType2.$fReadTrill_$creadListPrec -}
8650e80162817fe79be4acc77e003de6
  $fReadTrill1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Trill] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Trill] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Trill
                   PhonemeType2.$fReadTrill2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Trill>_R))
                   @ b
                   eta1) -}
8650e80162817fe79be4acc77e003de6
  $fReadTrill2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Trill
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Trill
                   PhonemeType2.$fReadMaybeImpossible7
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Trill>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Trill>_R)))) -}
8650e80162817fe79be4acc77e003de6
  $fReadTrill_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Trill]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadTrill1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Trill]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Trill]>_R))) -}
8650e80162817fe79be4acc77e003de6
  $fReadTrill_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Trill
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadTrill2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Trill>_R)) -}
8650e80162817fe79be4acc77e003de6
  $fReadTrill_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Trill
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Trill
                   PhonemeType2.$fReadTrill_$creadPrec
                   eta) -}
8650e80162817fe79be4acc77e003de6
  $fReadTrill_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Trill]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Trill]
                   ((PhonemeType2.$fReadTrill_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Trill]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Trill]>_R)
                      @ [PhonemeType2.Trill]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Trill]))) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadVOT :: GHC.Read.Read PhonemeType2.VOT
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.VOT
                  PhonemeType2.$fReadVOT_$s$dmreadsPrec
                  PhonemeType2.$fReadVOT_$sreadListDefault
                  PhonemeType2.$fReadVOT_$creadPrec
                  PhonemeType2.$fReadVOT_$creadListPrec -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadVOT1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.VOT] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.VOT] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.VOT
                   PhonemeType2.$fReadVOT2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.VOT>_R))
                   @ b
                   eta1) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadVOT2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.VOT
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.VOT
                   PhonemeType2.$fReadMaybeImpossible31
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.VOT>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.VOT>_R)))) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadVOT_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.VOT]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadVOT1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.VOT]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.VOT]>_R))) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadVOT_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.VOT
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadVOT2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.VOT>_R)) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadVOT_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.VOT
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.VOT
                   PhonemeType2.$fReadVOT_$creadPrec
                   eta) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fReadVOT_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.VOT]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.VOT]
                   ((PhonemeType2.$fReadVOT_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.VOT]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <[PhonemeType2.VOT]>_R)
                      @ [PhonemeType2.VOT]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.VOT]))) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fReadVowel :: GHC.Read.Read PhonemeType2.Vowel
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Vowel
                  PhonemeType2.$fReadVowel_$s$dmreadsPrec
                  PhonemeType2.$fReadVowel_$sreadListDefault
                  PhonemeType2.$fReadVowel_$creadPrec
                  PhonemeType2.$fReadVowel_$creadListPrec -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fReadVowel1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Vowel] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Vowel] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Vowel
                   PhonemeType2.$fReadVowel2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Vowel>_R))
                   @ b
                   eta1) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fReadVowel2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Vowel
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Vowel
                   PhonemeType2.$fReadVowel3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Vowel>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Vowel>_R)))) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fReadVowel3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Vowel -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.Vowel -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa12 ww1 @ b w1 }) -}
836bde73953accb1955bda1c7bb62770
  $fReadVowelPhonemeInventory ::
    GHC.Read.Read PhonemeType2.VowelPhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.VowelPhonemeInventory
                  PhonemeType2.$fReadVowelPhonemeInventory_$creadsPrec
                  PhonemeType2.$fReadVowelPhonemeInventory_$sreadListDefault
                  PhonemeType2.$fReadVowelPhonemeInventory_$creadPrec
                  PhonemeType2.$fReadVowelPhonemeInventory_$creadListPrec -}
836bde73953accb1955bda1c7bb62770
  $fReadVowelPhonemeInventory1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.VowelPhonemeInventory]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.VowelPhonemeInventory]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.VowelPhonemeInventory
                   PhonemeType2.$fReadVowelPhonemeInventory2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.VowelPhonemeInventory>_R))
                   @ b
                   eta1) -}
836bde73953accb1955bda1c7bb62770
  $fReadVowelPhonemeInventory2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         PhonemeType2.VowelPhonemeInventory
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.VowelPhonemeInventory
                   PhonemeType2.$fReadVowelPhonemeInventory3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.VowelPhonemeInventory>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.VowelPhonemeInventory>_R)))) -}
836bde73953accb1955bda1c7bb62770
  $fReadVowelPhonemeInventory3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.VowelPhonemeInventory
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.VowelPhonemeInventory
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa13 ww1 @ b w1 }) -}
bcbfb7d7e13968d57bed6786099cd019
  $fReadVowelPhonemeInventory4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "VowelPhonemeInventory"#) -}
836bde73953accb1955bda1c7bb62770
  $fReadVowelPhonemeInventory_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType2.VowelPhonemeInventory]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadVowelPhonemeInventory1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.VowelPhonemeInventory]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.VowelPhonemeInventory]>_R))) -}
836bde73953accb1955bda1c7bb62770
  $fReadVowelPhonemeInventory_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType2.VowelPhonemeInventory
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadVowelPhonemeInventory2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.VowelPhonemeInventory>_R)) -}
836bde73953accb1955bda1c7bb62770
  $fReadVowelPhonemeInventory_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         PhonemeType2.VowelPhonemeInventory
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType2.VowelPhonemeInventory
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType2.VowelPhonemeInventory
                       PhonemeType2.$fReadVowelPhonemeInventory3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType2.VowelPhonemeInventory>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType2.VowelPhonemeInventory>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType2.VowelPhonemeInventory>_R)
                      @ PhonemeType2.VowelPhonemeInventory
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType2.VowelPhonemeInventory))) -}
836bde73953accb1955bda1c7bb62770
  $fReadVowelPhonemeInventory_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType2.VowelPhonemeInventory]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.VowelPhonemeInventory]
                   ((PhonemeType2.$fReadVowelPhonemeInventory_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.VowelPhonemeInventory]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.VowelPhonemeInventory]>_R)
                      @ [PhonemeType2.VowelPhonemeInventory]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.VowelPhonemeInventory]))) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fReadVowel_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Vowel]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadVowel1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Vowel]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Vowel]>_R))) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fReadVowel_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Vowel
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadVowel2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Vowel>_R)) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fReadVowel_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Vowel
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Vowel
                   PhonemeType2.$fReadVowel_$creadPrec
                   eta) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fReadVowel_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Vowel]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Vowel]
                   ((PhonemeType2.$fReadVowel_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Vowel]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Vowel]>_R)
                      @ [PhonemeType2.Vowel]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Vowel]))) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fShowActiveArticulator ::
    GHC.Show.Show PhonemeType2.ActiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.ActiveArticulator
                  PhonemeType2.$fShowActiveArticulator_$cshowsPrec
                  PhonemeType2.$fShowActiveArticulator_$cshow
                  PhonemeType2.$fShowActiveArticulator_$cshowList -}
d12400f0f662bae3ab829b7afc21c4a1
  $fShowActiveArticulator_$cshow ::
    PhonemeType2.ActiveArticulator -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.ActiveArticulator ->
                 PhonemeType2.$fShowActiveArticulator_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fShowActiveArticulator_$cshowList ::
    [PhonemeType2.ActiveArticulator] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.ActiveArticulator
                   PhonemeType2.$w$cshowsPrec) -}
d12400f0f662bae3ab829b7afc21c4a1
  $fShowActiveArticulator_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.ActiveArticulator -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.ActiveArticulator
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec w1 w2) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fShowAirEscape :: GHC.Show.Show PhonemeType2.AirEscape
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.AirEscape
                  PhonemeType2.$fShowAirEscape_$cshowsPrec
                  PhonemeType2.$fShowAirEscape_$cshow
                  PhonemeType2.$fShowAirEscape_$cshowList -}
e607fa7baa5310b2ce6a27a01c437a40
  $fShowAirEscape1 :: PhonemeType2.AirEscape -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.AirEscape eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.NASALIZED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadAirEscape11)
                        eta
                   PhonemeType2.ORAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadAirEscape8)
                        eta }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fShowAirEscape_$cshow :: PhonemeType2.AirEscape -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.AirEscape ->
                 case x of wild {
                   PhonemeType2.NASALIZED -> PhonemeType2.$fReadAirEscape11
                   PhonemeType2.ORAL -> PhonemeType2.$fReadAirEscape8 }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fShowAirEscape_$cshowList ::
    [PhonemeType2.AirEscape] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.AirEscape
                   PhonemeType2.$fShowAirEscape1) -}
e607fa7baa5310b2ce6a27a01c437a40
  $fShowAirEscape_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.AirEscape -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType2.AirEscape
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType2.NASALIZED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadAirEscape11)
                        eta
                   PhonemeType2.ORAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadAirEscape8)
                        eta }) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fShowAirstream :: GHC.Show.Show PhonemeType2.Airstream
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Airstream
                  PhonemeType2.$fShowAirstream_$cshowsPrec
                  PhonemeType2.$fShowAirstream_$cshow
                  PhonemeType2.$fShowAirstream_$cshowList -}
5c7b14d72f8f222b5cc058df80cd64de
  $fShowAirstream1 :: PhonemeType2.Airstream -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.Airstream w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.Airstream ww1 ww2 ->
                 PhonemeType2.$w$cshowsPrec1 0 ww1 ww2 w1 }) -}
bb8fe6c441eaff70d498ceea0f07fea6
  $fShowAirstream2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
eec68ea5efb0470c0478d9da2704f263
  $fShowAirstream3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "direction = "#) -}
4491a87a791da745afc2bfe6e70c91fa
  $fShowAirstream4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
4e43e47a465a4dc8101174c4872fa24c
  $fShowAirstream5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "initiator = "#) -}
c8bbe26cd89ec5cbd69d0a0536814b22
  $fShowAirstream6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Airstream {"#) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fShowAirstream_$cshow :: PhonemeType2.Airstream -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Airstream ->
                 PhonemeType2.$fShowAirstream_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fShowAirstream_$cshowList ::
    [PhonemeType2.Airstream] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Airstream
                   PhonemeType2.$fShowAirstream1) -}
5c7b14d72f8f222b5cc058df80cd64de
  $fShowAirstream_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Airstream -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Airstream
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.Airstream ww3 ww4 ->
                 PhonemeType2.$w$cshowsPrec1 ww1 ww3 ww4 w2 } }) -}
9918c87837d4f215d9649b53c1c134de
  $fShowBackness :: GHC.Show.Show PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fShowBackness_$cshowsPrec
                  PhonemeType2.$fShowBackness_$cshow
                  PhonemeType2.$fShowBackness_$cshowList -}
9918c87837d4f215d9649b53c1c134de
  $fShowBackness_$cshow :: PhonemeType2.Backness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Backness ->
                 PhonemeType2.$fShowBackness_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9918c87837d4f215d9649b53c1c134de
  $fShowBackness_$cshowList ::
    [PhonemeType2.Backness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Backness
                   PhonemeType2.$w$cshowsPrec2) -}
9918c87837d4f215d9649b53c1c134de
  $fShowBackness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Backness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Backness
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec2 w1 w2) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fShowConsonant :: GHC.Show.Show PhonemeType2.Consonant
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Consonant
                  PhonemeType2.$fShowConsonant_$cshowsPrec
                  PhonemeType2.$fShowConsonant_$cshow
                  PhonemeType2.$fShowConsonant_$cshowList -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fShowConsonant1 :: PhonemeType2.Consonant -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.Consonant w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.Consonant ww1 ww2 ww3 ww4 ->
                 PhonemeType2.$w$cshowsPrec3 0 ww1 ww2 ww3 ww4 w1 }) -}
50034e43e68d86ae4aadbfc709852ded
  $fShowConsonant10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "active = "#) -}
98f0c0fd520feef1bb03ae72493276b0
  $fShowConsonant11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "place = "#) -}
7dd7ce1face2ee41896e2a1e1ac948b1
  $fShowConsonant2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Consonant {"#) -}
20307362340dd583c4df901332bf644b
  $fShowConsonant3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Contour "#) -}
92010d9287d27617885f9aa0257a6fc5
  $fShowConsonant4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoContour "#) -}
267b04971a969fa7938de20203ae4b30
  $fShowConsonant5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "phonation = "#) -}
7949b8b19d9dc16188559b96049572a8
  $fShowConsonant6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "airstream = "#) -}
ad5e0e0d37b902970f1837788c199a57
  $fShowConsonant7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "manner = "#) -}
83b01bd3d0cbd63c6f48bfae89207a3f
  $fShowConsonant8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Place {"#) -}
2ea7c07c373ba994b38fe29bc98401c9
  $fShowConsonant9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "passive = "#) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fShowConsonantPhonemeInventory ::
    GHC.Show.Show PhonemeType2.ConsonantPhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.ConsonantPhonemeInventory
                  PhonemeType2.$fShowConsonantPhonemeInventory_$cshowsPrec
                  PhonemeType2.$fShowConsonantPhonemeInventory_$cshow
                  PhonemeType2.$fShowConsonantPhonemeInventory_$cshowList -}
498abb2d3230baf9073ff621a6aaa0e0
  $fShowConsonantPhonemeInventory1 ::
    PhonemeType2.ConsonantPhonemeInventory -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.ConsonantPhonemeInventory
                   w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.ConsonantPhonemeInventory ww1 ->
                 PhonemeType2.$w$cshowsPrec8 0 ww1 w1 }) -}
ef9830910c3a53e95369f6b0188af1b4
  $fShowConsonantPhonemeInventory2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "ConsonantPhonemeInventory "#) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fShowConsonantPhonemeInventory_$cshow ::
    PhonemeType2.ConsonantPhonemeInventory -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.ConsonantPhonemeInventory ->
                 PhonemeType2.$fShowConsonantPhonemeInventory_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fShowConsonantPhonemeInventory_$cshowList ::
    [PhonemeType2.ConsonantPhonemeInventory] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.ConsonantPhonemeInventory
                   PhonemeType2.$fShowConsonantPhonemeInventory1) -}
498abb2d3230baf9073ff621a6aaa0e0
  $fShowConsonantPhonemeInventory_$cshowsPrec ::
    GHC.Types.Int
    -> PhonemeType2.ConsonantPhonemeInventory -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.ConsonantPhonemeInventory
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.ConsonantPhonemeInventory ww3 ->
                 PhonemeType2.$w$cshowsPrec8 ww1 ww3 w2 } }) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fShowConsonant_$cshow :: PhonemeType2.Consonant -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Consonant ->
                 PhonemeType2.$fShowConsonant_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fShowConsonant_$cshowList ::
    [PhonemeType2.Consonant] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Consonant
                   PhonemeType2.$fShowConsonant1) -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $fShowConsonant_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Consonant -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Consonant
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.Consonant ww3 ww4 ww5 ww6 ->
                 PhonemeType2.$w$cshowsPrec3 ww1 ww3 ww4 ww5 ww6 w2 } }) -}
3de6396777539178df86bdf5ea849b5e
  $fShowDirection :: GHC.Show.Show PhonemeType2.Direction
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Direction
                  PhonemeType2.$fShowDirection_$cshowsPrec
                  PhonemeType2.$fShowDirection_$cshow
                  PhonemeType2.$fShowDirection_$cshowList -}
3de6396777539178df86bdf5ea849b5e
  $fShowDirection1 :: PhonemeType2.Direction -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Direction eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.INGRESSIVE
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadDirection11)
                        eta
                   PhonemeType2.EGRESSIVE
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadDirection8)
                        eta }) -}
3de6396777539178df86bdf5ea849b5e
  $fShowDirection_$cshow :: PhonemeType2.Direction -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Direction ->
                 case x of wild {
                   PhonemeType2.INGRESSIVE -> PhonemeType2.$fReadDirection11
                   PhonemeType2.EGRESSIVE -> PhonemeType2.$fReadDirection8 }) -}
3de6396777539178df86bdf5ea849b5e
  $fShowDirection_$cshowList ::
    [PhonemeType2.Direction] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Direction
                   PhonemeType2.$fShowDirection1) -}
3de6396777539178df86bdf5ea849b5e
  $fShowDirection_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Direction -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType2.Direction
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType2.INGRESSIVE
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadDirection11)
                        eta
                   PhonemeType2.EGRESSIVE
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadDirection8)
                        eta }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fShowHeight :: GHC.Show.Show PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fShowHeight_$cshowsPrec
                  PhonemeType2.$fShowHeight_$cshow
                  PhonemeType2.$fShowHeight_$cshowList -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fShowHeight_$cshow :: PhonemeType2.Height -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Height ->
                 PhonemeType2.$fShowHeight_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fShowHeight_$cshowList :: [PhonemeType2.Height] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Height
                   PhonemeType2.$w$cshowsPrec9) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $fShowHeight_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Height -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Height
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec9 w1 w2) -}
cf0efd186b87d1976dba6b7feef6e065
  $fShowInitiator :: GHC.Show.Show PhonemeType2.Initiator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Initiator
                  PhonemeType2.$fShowInitiator_$cshowsPrec
                  PhonemeType2.$fShowInitiator_$cshow
                  PhonemeType2.$fShowInitiator_$cshowList -}
cf0efd186b87d1976dba6b7feef6e065
  $fShowInitiator_$cshow :: PhonemeType2.Initiator -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Initiator ->
                 case x of wild {
                   PhonemeType2.LINGUAL -> PhonemeType2.$fReadInitiator15
                   PhonemeType2.GLOTTIC -> PhonemeType2.$fReadInitiator12
                   PhonemeType2.PULMONIC -> PhonemeType2.$fReadInitiator9 }) -}
cf0efd186b87d1976dba6b7feef6e065
  $fShowInitiator_$cshowList ::
    [PhonemeType2.Initiator] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Initiator
                   PhonemeType2.$w$cshowsPrec10) -}
cf0efd186b87d1976dba6b7feef6e065
  $fShowInitiator_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Initiator -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Initiator
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec10 w1 w2) -}
f28c4174999e39eea0edf7a94bde9432
  $fShowLaterality :: GHC.Show.Show PhonemeType2.Laterality
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Laterality
                  PhonemeType2.$fShowLaterality_$cshowsPrec
                  PhonemeType2.$fShowLaterality_$cshow
                  PhonemeType2.$fShowLaterality_$cshowList -}
f28c4174999e39eea0edf7a94bde9432
  $fShowLaterality1 :: PhonemeType2.Laterality -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Laterality eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.LATERAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadLaterality11)
                        eta
                   PhonemeType2.NONLATERAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadLaterality8)
                        eta }) -}
f28c4174999e39eea0edf7a94bde9432
  $fShowLaterality_$cshow ::
    PhonemeType2.Laterality -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Laterality ->
                 case x of wild {
                   PhonemeType2.LATERAL -> PhonemeType2.$fReadLaterality11
                   PhonemeType2.NONLATERAL -> PhonemeType2.$fReadLaterality8 }) -}
f28c4174999e39eea0edf7a94bde9432
  $fShowLaterality_$cshowList ::
    [PhonemeType2.Laterality] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Laterality
                   PhonemeType2.$fShowLaterality1) -}
f28c4174999e39eea0edf7a94bde9432
  $fShowLaterality_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Laterality -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType2.Laterality
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType2.LATERAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadLaterality11)
                        eta
                   PhonemeType2.NONLATERAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadLaterality8)
                        eta }) -}
195969ff33df4040ea1319692f018c08
  $fShowLength :: GHC.Show.Show PhonemeType2.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fShowLength_$cshowsPrec
                  PhonemeType2.$fShowLength_$cshow
                  PhonemeType2.$fShowLength_$cshowList -}
195969ff33df4040ea1319692f018c08
  $fShowLength_$cshow :: PhonemeType2.Length -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Length ->
                 case x of wild {
                   PhonemeType2.SHORT -> PhonemeType2.$fReadLength15
                   PhonemeType2.NORMAL -> PhonemeType2.$fReadLength12
                   PhonemeType2.LONG -> PhonemeType2.$fReadLength9 }) -}
195969ff33df4040ea1319692f018c08
  $fShowLength_$cshowList :: [PhonemeType2.Length] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Length
                   PhonemeType2.$w$cshowsPrec11) -}
195969ff33df4040ea1319692f018c08
  $fShowLength_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Length -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Length
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec11 w1 w2) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fShowManner :: GHC.Show.Show PhonemeType2.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fShowManner_$cshowsPrec
                  PhonemeType2.$fShowManner_$cshow
                  PhonemeType2.$fShowManner_$cshowList -}
ab5350f5942d71b67ea9edf6454c29d6
  $fShowManner1 :: PhonemeType2.Manner -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.Manner w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.Manner ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 PhonemeType2.$w$cshowsPrec5 0 ww1 ww2 ww3 ww4 ww5 ww6 ww7 w1 }) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fShowManner_$cshow :: PhonemeType2.Manner -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Manner ->
                 PhonemeType2.$fShowManner_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fShowManner_$cshowList :: [PhonemeType2.Manner] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Manner
                   PhonemeType2.$fShowManner1) -}
ab5350f5942d71b67ea9edf6454c29d6
  $fShowManner_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Manner -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Manner
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.Manner ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 PhonemeType2.$w$cshowsPrec5
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   w2 } }) -}
8143cb44533c9c903aac37b4f4a4473c
  $fShowMaybeContour ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Show.Show (PhonemeType2.MaybeContour a b)
  DFunId[0]
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a18
                      @ b
                      $dShow :: GHC.Show.Show a18
                      $dShow1 :: GHC.Show.Show b.
                  @ (PhonemeType2.MaybeContour a18 b)
                  (PhonemeType2.$fShowMaybeContour_$cshowsPrec
                     @ a18
                     @ b
                     $dShow
                     $dShow1)
                  (PhonemeType2.$fShowMaybeContour_$cshow @ a18 @ b $dShow $dShow1)
                  (PhonemeType2.$fShowMaybeContour_$cshowList
                     @ a18
                     @ b
                     $dShow
                     $dShow1) -}
c554ccc6dedf5dc5f5e23a821c8ac751
  $fShowMaybeContour1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
8143cb44533c9c903aac37b4f4a4473c
  $fShowMaybeContour_$cshow ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    PhonemeType2.MaybeContour a b -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a18
                   @ b
                   $dShow :: GHC.Show.Show a18
                   $dShow1 :: GHC.Show.Show b
                   x :: PhonemeType2.MaybeContour a18 b ->
                 PhonemeType2.$fShowMaybeContour_$cshowsPrec
                   @ a18
                   @ b
                   $dShow
                   $dShow1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8143cb44533c9c903aac37b4f4a4473c
  $fShowMaybeContour_$cshowList ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    [PhonemeType2.MaybeContour a b] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a18
                   @ b
                   $dShow :: GHC.Show.Show a18
                   $dShow1 :: GHC.Show.Show b
                   eta :: [PhonemeType2.MaybeContour a18 b]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (PhonemeType2.MaybeContour a18 b)
                   (PhonemeType2.$fShowMaybeContour_$cshowsPrec
                      @ a18
                      @ b
                      $dShow
                      $dShow1
                      PhonemeType2.$fShowMaybeContour1)
                   eta
                   eta1) -}
8143cb44533c9c903aac37b4f4a4473c
  $fShowMaybeContour_$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Types.Int -> PhonemeType2.MaybeContour a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a18
                   @ b
                   w :: GHC.Show.Show a18
                   w1 :: GHC.Show.Show b
                   w2 :: GHC.Types.Int
                   w3 :: PhonemeType2.MaybeContour a18 b ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$cshowsPrec12 @ a18 @ b w w1 ww1 w3 }) -}
b13bbde41449c45003ef1026fa30364d
  $fShowMaybeImpossible ::
    GHC.Show.Show a => GHC.Show.Show (PhonemeType2.MaybeImpossible a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a18 $dShow :: GHC.Show.Show a18.
                  @ (PhonemeType2.MaybeImpossible a18)
                  (PhonemeType2.$fShowMaybeImpossible_$cshowsPrec @ a18 $dShow)
                  (PhonemeType2.$fShowMaybeImpossible_$cshow @ a18 $dShow)
                  (PhonemeType2.$fShowMaybeImpossible_$cshowList @ a18 $dShow) -}
93a2d0c0d6139ae7bc71ffab4397711d
  $fShowMaybeImpossible1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Possible "#) -}
06e7b08f28dea468601f7c6dd96f12f4
  $fShowMaybeImpossible2 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   PhonemeType2.$fReadMaybeImpossible4) -}
b13bbde41449c45003ef1026fa30364d
  $fShowMaybeImpossible_$cshow ::
    GHC.Show.Show a =>
    PhonemeType2.MaybeImpossible a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a18
                   $dShow :: GHC.Show.Show a18
                   x :: PhonemeType2.MaybeImpossible a18 ->
                 case x of wild {
                   PhonemeType2.Possible b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fShowMaybeImpossible1
                        (GHC.Show.showsPrec
                           @ a18
                           $dShow
                           PhonemeType2.$fReadMaybeContour5
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   PhonemeType2.Impossible
                   -> PhonemeType2.$fReadMaybeImpossible4 }) -}
b13bbde41449c45003ef1026fa30364d
  $fShowMaybeImpossible_$cshowList ::
    GHC.Show.Show a =>
    [PhonemeType2.MaybeImpossible a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a18
                   $dShow :: GHC.Show.Show a18
                   eta :: [PhonemeType2.MaybeImpossible a18]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (PhonemeType2.MaybeImpossible a18)
                   (PhonemeType2.$fShowMaybeImpossible_$cshowsPrec
                      @ a18
                      $dShow
                      PhonemeType2.$fShowMaybeContour1)
                   eta
                   eta1) -}
b13bbde41449c45003ef1026fa30364d
  $fShowMaybeImpossible_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> PhonemeType2.MaybeImpossible a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a18
                   $dShow :: GHC.Show.Show a18
                   a19 :: GHC.Types.Int
                   ds :: PhonemeType2.MaybeImpossible a18 ->
                 case ds of wild {
                   PhonemeType2.Possible b1
                   -> case a19 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec
                            @ a18
                            $dShow
                            PhonemeType2.$fReadMaybeContour5
                            b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowMaybeImpossible1
                             (g x1)
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowMaybeImpossible1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))) } }
                   PhonemeType2.Impossible
                   -> PhonemeType2.$fShowMaybeImpossible2 }) -}
449be82b2558a93501314d6cd2a26aa8
  $fShowMaybeImpossible_$s$cshowsPrec ::
    GHC.Types.Int
    -> PhonemeType2.MaybeImpossible PhonemeType2.Trill
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a18 :: GHC.Types.Int
                   ds :: PhonemeType2.MaybeImpossible PhonemeType2.Trill
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.Possible b1
                   -> case a18 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType2.$fShowMaybeImpossible1
                            (case b1 of wild2 {
                               PhonemeType2.TRILLED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fReadMaybeImpossible15
                                    x1
                               PhonemeType2.NOTTRILLED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fReadMaybeImpossible12
                                    x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType2.Impossible
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeImpossible4
                        eta }) -}
26cd2d7b572bacd86a22a3c00e7c63ec
  $fShowMaybeImpossible_$s$cshowsPrec1 ::
    GHC.Types.Int
    -> PhonemeType2.MaybeImpossible PhonemeType2.Laterality
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a18 :: GHC.Types.Int
                   ds :: PhonemeType2.MaybeImpossible PhonemeType2.Laterality
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.Possible b1
                   -> case a18 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType2.$fShowMaybeImpossible1
                            (case b1 of wild2 {
                               PhonemeType2.LATERAL
                               -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadLaterality11 x1
                               PhonemeType2.NONLATERAL
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fReadLaterality8
                                    x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType2.Impossible
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeImpossible4
                        eta }) -}
9c9919655c026605880644549aa0b9e1
  $fShowMaybeImpossible_$s$cshowsPrec2 ::
    GHC.Types.Int
    -> PhonemeType2.MaybeImpossible PhonemeType2.Silibance
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a18 :: GHC.Types.Int
                   ds :: PhonemeType2.MaybeImpossible PhonemeType2.Silibance
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.Possible b1
                   -> case a18 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType2.$fShowMaybeImpossible1
                            (case b1 of wild2 {
                               PhonemeType2.SILIBANT
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fReadMaybeImpossible28
                                    x1
                               PhonemeType2.NONSILIBANT
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fReadMaybeImpossible25
                                    x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType2.Impossible
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeImpossible4
                        eta }) -}
89f3c72ee78f985a2d7a5b947c20cc61
  $fShowMaybeImpossible_$s$cshowsPrec3 ::
    GHC.Types.Int
    -> PhonemeType2.MaybeImpossible PhonemeType2.VOT -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a18 :: GHC.Types.Int
                   ds :: PhonemeType2.MaybeImpossible PhonemeType2.VOT
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.Possible b1
                   -> case a18 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ eta1 :: GHC.Base.String[OneShot] ->
                          case b1 of wild2 {
                            PhonemeType2.POSITIVE
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType2.$fReadMaybeImpossible43
                                 eta1
                            PhonemeType2.ZERO
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType2.$fReadMaybeImpossible40
                                 eta1
                            PhonemeType2.NEGATIVE
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType2.$fReadMaybeImpossible37
                                 eta1 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowMaybeImpossible1
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowMaybeImpossible1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType2.Impossible
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeImpossible4
                        eta }) -}
b99e0542eafd4baafc4b7c93a8988262
  $fShowPassiveArticulator ::
    GHC.Show.Show PhonemeType2.PassiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PassiveArticulator
                  PhonemeType2.$fShowPassiveArticulator_$cshowsPrec
                  PhonemeType2.$fShowPassiveArticulator_$cshow
                  PhonemeType2.$fShowPassiveArticulator_$cshowList -}
b99e0542eafd4baafc4b7c93a8988262
  $fShowPassiveArticulator_$cshow ::
    PhonemeType2.PassiveArticulator -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.PassiveArticulator ->
                 PhonemeType2.$fShowPassiveArticulator_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b99e0542eafd4baafc4b7c93a8988262
  $fShowPassiveArticulator_$cshowList ::
    [PhonemeType2.PassiveArticulator] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.PassiveArticulator
                   PhonemeType2.$w$cshowsPrec7) -}
b99e0542eafd4baafc4b7c93a8988262
  $fShowPassiveArticulator_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.PassiveArticulator -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.PassiveArticulator
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec7 w1 w2) -}
a4e0caad2d1174c9226145cc0019ed73
  $fShowPhonation :: GHC.Show.Show PhonemeType2.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fShowPhonation_$cshowsPrec
                  PhonemeType2.$fShowPhonation_$cshow
                  PhonemeType2.$fShowPhonation_$cshowList -}
a4e0caad2d1174c9226145cc0019ed73
  $fShowPhonation_$cshow :: PhonemeType2.Phonation -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Phonation ->
                 PhonemeType2.$fShowPhonation_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a4e0caad2d1174c9226145cc0019ed73
  $fShowPhonation_$cshowList ::
    [PhonemeType2.Phonation] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Phonation
                   PhonemeType2.$w$cshowsPrec4) -}
a4e0caad2d1174c9226145cc0019ed73
  $fShowPhonation_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Phonation -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Phonation
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec4 w1 w2) -}
ce06e3a360ef67b905c70e56b1480a17
  $fShowPlace :: GHC.Show.Show PhonemeType2.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fShowPlace_$cshowsPrec
                  PhonemeType2.$fShowPlace_$cshow
                  PhonemeType2.$fShowPlace_$cshowList -}
ce06e3a360ef67b905c70e56b1480a17
  $fShowPlace1 :: PhonemeType2.Place -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.Place w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.Place ww1 ww2 ->
                 PhonemeType2.$w$cshowsPrec6 0 ww1 ww2 w1 }) -}
ce06e3a360ef67b905c70e56b1480a17
  $fShowPlace_$cshow :: PhonemeType2.Place -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Place ->
                 PhonemeType2.$fShowPlace_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ce06e3a360ef67b905c70e56b1480a17
  $fShowPlace_$cshowList :: [PhonemeType2.Place] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Place
                   PhonemeType2.$fShowPlace1) -}
ce06e3a360ef67b905c70e56b1480a17
  $fShowPlace_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Place -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Place
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.Place ww3 ww4 ->
                 PhonemeType2.$w$cshowsPrec6 ww1 ww3 ww4 w2 } }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fShowRoundedness :: GHC.Show.Show PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fShowRoundedness_$cshowsPrec
                  PhonemeType2.$fShowRoundedness_$cshow
                  PhonemeType2.$fShowRoundedness_$cshowList -}
e8a534a069fcf11d22fabc02549d84ae
  $fShowRoundedness1 :: PhonemeType2.Roundedness -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Roundedness eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.UNROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeContour58)
                        eta
                   PhonemeType2.ROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeContour55)
                        eta }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fShowRoundedness_$cshow ::
    PhonemeType2.Roundedness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Roundedness ->
                 case x of wild {
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fReadMaybeContour58
                   PhonemeType2.ROUNDED -> PhonemeType2.$fReadMaybeContour55 }) -}
e8a534a069fcf11d22fabc02549d84ae
  $fShowRoundedness_$cshowList ::
    [PhonemeType2.Roundedness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fShowRoundedness1) -}
e8a534a069fcf11d22fabc02549d84ae
  $fShowRoundedness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Roundedness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType2.Roundedness
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType2.UNROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeContour58)
                        eta
                   PhonemeType2.ROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeContour55)
                        eta }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fShowSilibance :: GHC.Show.Show PhonemeType2.Silibance
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Silibance
                  PhonemeType2.$fShowSilibance_$cshowsPrec
                  PhonemeType2.$fShowSilibance_$cshow
                  PhonemeType2.$fShowSilibance_$cshowList -}
6f56b9eb1985eff94cee6d9814538c86
  $fShowSilibance1 :: PhonemeType2.Silibance -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Silibance eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.SILIBANT
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeImpossible28)
                        eta
                   PhonemeType2.NONSILIBANT
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeImpossible25)
                        eta }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fShowSilibance_$cshow :: PhonemeType2.Silibance -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Silibance ->
                 case x of wild {
                   PhonemeType2.SILIBANT -> PhonemeType2.$fReadMaybeImpossible28
                   PhonemeType2.NONSILIBANT
                   -> PhonemeType2.$fReadMaybeImpossible25 }) -}
6f56b9eb1985eff94cee6d9814538c86
  $fShowSilibance_$cshowList ::
    [PhonemeType2.Silibance] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Silibance
                   PhonemeType2.$fShowSilibance1) -}
6f56b9eb1985eff94cee6d9814538c86
  $fShowSilibance_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Silibance -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType2.Silibance
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType2.SILIBANT
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeImpossible28)
                        eta
                   PhonemeType2.NONSILIBANT
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeImpossible25)
                        eta }) -}
57e37fc45e7527176af3ce2952794c24
  $fShowStricture :: GHC.Show.Show PhonemeType2.Stricture
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Stricture
                  PhonemeType2.$fShowStricture_$cshowsPrec
                  PhonemeType2.$fShowStricture_$cshow
                  PhonemeType2.$fShowStricture_$cshowList -}
57e37fc45e7527176af3ce2952794c24
  $fShowStricture_$cshow :: PhonemeType2.Stricture -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Stricture ->
                 case x of wild {
                   PhonemeType2.OCCLUSION -> PhonemeType2.$fReadStricture15
                   PhonemeType2.TURBULENT -> PhonemeType2.$fReadStricture12
                   PhonemeType2.SLIGHTTURBULENT -> PhonemeType2.$fReadStricture9 }) -}
57e37fc45e7527176af3ce2952794c24
  $fShowStricture_$cshowList ::
    [PhonemeType2.Stricture] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Stricture
                   PhonemeType2.$w$cshowsPrec13) -}
57e37fc45e7527176af3ce2952794c24
  $fShowStricture_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Stricture -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Stricture
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec13 w1 w2) -}
8650e80162817fe79be4acc77e003de6
  $fShowTrill :: GHC.Show.Show PhonemeType2.Trill
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Trill
                  PhonemeType2.$fShowTrill_$cshowsPrec
                  PhonemeType2.$fShowTrill_$cshow
                  PhonemeType2.$fShowTrill_$cshowList -}
8650e80162817fe79be4acc77e003de6
  $fShowTrill1 :: PhonemeType2.Trill -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Trill eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.TRILLED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeImpossible15)
                        eta
                   PhonemeType2.NOTTRILLED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeImpossible12)
                        eta }) -}
8650e80162817fe79be4acc77e003de6
  $fShowTrill_$cshow :: PhonemeType2.Trill -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Trill ->
                 case x of wild {
                   PhonemeType2.TRILLED -> PhonemeType2.$fReadMaybeImpossible15
                   PhonemeType2.NOTTRILLED
                   -> PhonemeType2.$fReadMaybeImpossible12 }) -}
8650e80162817fe79be4acc77e003de6
  $fShowTrill_$cshowList :: [PhonemeType2.Trill] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Trill
                   PhonemeType2.$fShowTrill1) -}
8650e80162817fe79be4acc77e003de6
  $fShowTrill_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Trill -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType2.Trill
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType2.TRILLED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeImpossible15)
                        eta
                   PhonemeType2.NOTTRILLED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType2.$fReadMaybeImpossible12)
                        eta }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fShowVOT :: GHC.Show.Show PhonemeType2.VOT
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.VOT
                  PhonemeType2.$fShowVOT_$cshowsPrec
                  PhonemeType2.$fShowVOT_$cshow
                  PhonemeType2.$fShowVOT_$cshowList -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fShowVOT_$cshow :: PhonemeType2.VOT -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.VOT ->
                 case x of wild {
                   PhonemeType2.POSITIVE -> PhonemeType2.$fReadMaybeImpossible43
                   PhonemeType2.ZERO -> PhonemeType2.$fReadMaybeImpossible40
                   PhonemeType2.NEGATIVE -> PhonemeType2.$fReadMaybeImpossible37 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fShowVOT_$cshowList :: [PhonemeType2.VOT] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.VOT
                   PhonemeType2.$w$cshowsPrec14) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $fShowVOT_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.VOT -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.VOT
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec14 w1 w2) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fShowVowel :: GHC.Show.Show PhonemeType2.Vowel
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Vowel
                  PhonemeType2.$fShowVowel_$cshowsPrec
                  PhonemeType2.$fShowVowel_$cshow
                  PhonemeType2.$fShowVowel_$cshowList -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fShowVowel1 :: PhonemeType2.Vowel -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.Vowel w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.VowelFeaturesContour ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 PhonemeType2.$w$cshowsPrec15 0 ww1 ww2 ww3 ww4 ww5 ww6 ww7 w1 }) -}
836bde73953accb1955bda1c7bb62770
  $fShowVowelPhonemeInventory ::
    GHC.Show.Show PhonemeType2.VowelPhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.VowelPhonemeInventory
                  PhonemeType2.$fShowVowelPhonemeInventory_$cshowsPrec
                  PhonemeType2.$fShowVowelPhonemeInventory_$cshow
                  PhonemeType2.$fShowVowelPhonemeInventory_$cshowList -}
836bde73953accb1955bda1c7bb62770
  $fShowVowelPhonemeInventory1 ::
    PhonemeType2.VowelPhonemeInventory -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.VowelPhonemeInventory
                   w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.VowelPhonemeInventory ww1 ->
                 PhonemeType2.$w$cshowsPrec16 0 ww1 w1 }) -}
7b4ca550405483307692182ec68b64ce
  $fShowVowelPhonemeInventory2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "VowelPhonemeInventory "#) -}
836bde73953accb1955bda1c7bb62770
  $fShowVowelPhonemeInventory_$cshow ::
    PhonemeType2.VowelPhonemeInventory -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.VowelPhonemeInventory ->
                 PhonemeType2.$fShowVowelPhonemeInventory_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
836bde73953accb1955bda1c7bb62770
  $fShowVowelPhonemeInventory_$cshowList ::
    [PhonemeType2.VowelPhonemeInventory] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.VowelPhonemeInventory
                   PhonemeType2.$fShowVowelPhonemeInventory1) -}
836bde73953accb1955bda1c7bb62770
  $fShowVowelPhonemeInventory_$cshowsPrec ::
    GHC.Types.Int
    -> PhonemeType2.VowelPhonemeInventory -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.VowelPhonemeInventory
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.VowelPhonemeInventory ww3 ->
                 PhonemeType2.$w$cshowsPrec16 ww1 ww3 w2 } }) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fShowVowel_$cshow :: PhonemeType2.Vowel -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U,1*U(1*U,1*U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Vowel ->
                 PhonemeType2.$fShowVowel_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fShowVowel_$cshowList :: [PhonemeType2.Vowel] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Vowel
                   PhonemeType2.$fShowVowel1) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $fShowVowel_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Vowel -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U,1*U,1*U,1*U(1*U,1*U),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Vowel
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.VowelFeaturesContour ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 PhonemeType2.$w$cshowsPrec15
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   w2 } }) -}
8f1edf06abbfdef721c6392c1f4adc5f
  $w$c== ::
    PhonemeType2.Initiator
    -> PhonemeType2.Direction
    -> PhonemeType2.Initiator
    -> PhonemeType2.Direction
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: PhonemeType2.Initiator
                   ww1 :: PhonemeType2.Direction
                   ww2 :: PhonemeType2.Initiator
                   ww3 :: PhonemeType2.Direction ->
                 case ww of wild {
                   PhonemeType2.LINGUAL
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.LINGUAL -> PhonemeType2.$fEqAirstream_$c==1 ww1 ww3 }
                   PhonemeType2.GLOTTIC
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.GLOTTIC -> PhonemeType2.$fEqAirstream_$c==1 ww1 ww3 }
                   PhonemeType2.PULMONIC
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.PULMONIC
                        -> PhonemeType2.$fEqAirstream_$c==1 ww1 ww3 } }) -}
cc89a40e4d5aba083c55052cd1873605
  $w$c==1 ::
    PhonemeType2.MaybeContour PhonemeType2.Place PhonemeType2.Place
    -> PhonemeType2.MaybeContour
         PhonemeType2.Manner PhonemeType2.Manner
    -> PhonemeType2.MaybeContour
         PhonemeType2.Airstream PhonemeType2.Airstream
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
    -> PhonemeType2.MaybeContour PhonemeType2.Place PhonemeType2.Place
    -> PhonemeType2.MaybeContour
         PhonemeType2.Manner PhonemeType2.Manner
    -> PhonemeType2.MaybeContour
         PhonemeType2.Airstream PhonemeType2.Airstream
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
7fef8438d29b3d68174a4d9ef4064a89
  $w$c==2 ::
    PhonemeType2.Stricture
    -> PhonemeType2.MaybeImpossible PhonemeType2.Trill
    -> PhonemeType2.Length
    -> PhonemeType2.MaybeImpossible PhonemeType2.Laterality
    -> PhonemeType2.MaybeImpossible PhonemeType2.Silibance
    -> PhonemeType2.AirEscape
    -> PhonemeType2.MaybeImpossible PhonemeType2.VOT
    -> PhonemeType2.Stricture
    -> PhonemeType2.MaybeImpossible PhonemeType2.Trill
    -> PhonemeType2.Length
    -> PhonemeType2.MaybeImpossible PhonemeType2.Laterality
    -> PhonemeType2.MaybeImpossible PhonemeType2.Silibance
    -> PhonemeType2.AirEscape
    -> PhonemeType2.MaybeImpossible PhonemeType2.VOT
    -> GHC.Types.Bool
  {- Arity: 14, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
16f312bcb4b58e5e32ae2a3f82b38e16
  $w$c==3 ::
    PhonemeType2.ActiveArticulator
    -> PhonemeType2.PassiveArticulator
    -> PhonemeType2.ActiveArticulator
    -> PhonemeType2.PassiveArticulator
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: PhonemeType2.ActiveArticulator
                   ww1 :: PhonemeType2.PassiveArticulator
                   ww2 :: PhonemeType2.ActiveArticulator
                   ww3 :: PhonemeType2.PassiveArticulator ->
                 case ww of wild {
                   PhonemeType2.LOWERLIP
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.LOWERLIP
                        -> case ww1 of x1 { DEFAULT ->
                           case ww3 of x2 { DEFAULT ->
                           GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==#
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2)) } } }
                   PhonemeType2.TONGUEBLADE
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUEBLADE
                        -> case ww1 of x1 { DEFAULT ->
                           case ww3 of x2 { DEFAULT ->
                           GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==#
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2)) } } }
                   PhonemeType2.TONGUETIP
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUETIP
                        -> case ww1 of x1 { DEFAULT ->
                           case ww3 of x2 { DEFAULT ->
                           GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==#
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2)) } } }
                   PhonemeType2.TONGUEUNDER
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUEUNDER
                        -> case ww1 of x1 { DEFAULT ->
                           case ww3 of x2 { DEFAULT ->
                           GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==#
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2)) } } }
                   PhonemeType2.TONGUEBODY
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUEBODY
                        -> case ww1 of x1 { DEFAULT ->
                           case ww3 of x2 { DEFAULT ->
                           GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==#
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2)) } } }
                   PhonemeType2.TONGUEROOT
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.TONGUEROOT
                        -> case ww1 of x1 { DEFAULT ->
                           case ww3 of x2 { DEFAULT ->
                           GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==#
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x2)) } } }
                   PhonemeType2.LARYNX
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.LARYNX
                        -> case ww1 of x1 { DEFAULT ->
                           case ww3 of x2 { DEFAULT ->
                           GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==#
                                (GHC.Prim.dataToTag# @ PhonemeType2.PassiveArticulator x1)
                                (GHC.Prim.dataToTag#
                                   @ PhonemeType2.PassiveArticulator
                                   x2)) } } } }) -}
c5f64b3d1c458719d2f396e970b2917b
  $w$c==4 ::
    PhonemeType2.MaybeContour PhonemeType2.Height PhonemeType2.Height
    -> PhonemeType2.MaybeContour
         PhonemeType2.Backness PhonemeType2.Backness
    -> PhonemeType2.MaybeContour
         PhonemeType2.Roundedness PhonemeType2.Roundedness
    -> PhonemeType2.Length
    -> PhonemeType2.AirEscape
    -> PhonemeType2.Airstream
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
    -> PhonemeType2.MaybeContour
         PhonemeType2.Height PhonemeType2.Height
    -> PhonemeType2.MaybeContour
         PhonemeType2.Backness PhonemeType2.Backness
    -> PhonemeType2.MaybeContour
         PhonemeType2.Roundedness PhonemeType2.Roundedness
    -> PhonemeType2.Length
    -> PhonemeType2.AirEscape
    -> PhonemeType2.Airstream
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
    -> GHC.Types.Bool
  {- Arity: 14, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U(1*U,1*U)><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U(1*U,1*U)><L,1*U>,
     Inline: [0] -}
d12400f0f662bae3ab829b7afc21c4a1
  $w$cshowsPrec ::
    PhonemeType2.ActiveArticulator
    -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.ActiveArticulator
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.LOWERLIP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadActiveArticulator31
                        w1
                   PhonemeType2.TONGUEBLADE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadActiveArticulator28
                        w1
                   PhonemeType2.TONGUETIP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadActiveArticulator25
                        w1
                   PhonemeType2.TONGUEUNDER
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadActiveArticulator22
                        w1
                   PhonemeType2.TONGUEBODY
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadActiveArticulator19
                        w1
                   PhonemeType2.TONGUEROOT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadActiveArticulator16
                        w1
                   PhonemeType2.LARYNX
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadActiveArticulator13
                        w1 }) -}
6d94abdba98c083e24a430d3f4ac6308
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> PhonemeType2.Initiator
    -> PhonemeType2.Direction
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType2.Initiator
                   ww2 :: PhonemeType2.Direction
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType2.$fShowAirstream6
                       (GHC.Base.++
                          @ GHC.Types.Char
                          PhonemeType2.$fShowAirstream5
                          (let {
                             eta :: GHC.Base.String
                             = GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType2.$fShowAirstream4
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fShowAirstream3
                                    (case ww2 of wild {
                                       PhonemeType2.INGRESSIVE
                                       -> GHC.Base.++
                                            @ GHC.Types.Char
                                            PhonemeType2.$fReadDirection11
                                            (GHC.Base.++
                                               @ GHC.Types.Char
                                               PhonemeType2.$fShowAirstream2
                                               x)
                                       PhonemeType2.EGRESSIVE
                                       -> GHC.Base.++
                                            @ GHC.Types.Char
                                            PhonemeType2.$fReadDirection8
                                            (GHC.Base.++
                                               @ GHC.Types.Char
                                               PhonemeType2.$fShowAirstream2
                                               x) }))
                           } in
                           case ww1 of wild {
                             PhonemeType2.LINGUAL
                             -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadInitiator15 eta
                             PhonemeType2.GLOTTIC
                             -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadInitiator12 eta
                             PhonemeType2.PULMONIC
                             -> GHC.Base.++
                                  @ GHC.Types.Char
                                  PhonemeType2.$fReadInitiator9
                                  eta }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
cf0efd186b87d1976dba6b7feef6e065
  $w$cshowsPrec10 ::
    PhonemeType2.Initiator -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Initiator w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.LINGUAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadInitiator15 w1
                   PhonemeType2.GLOTTIC
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadInitiator12 w1
                   PhonemeType2.PULMONIC
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadInitiator9
                        w1 }) -}
195969ff33df4040ea1319692f018c08
  $w$cshowsPrec11 ::
    PhonemeType2.Length -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Length w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.SHORT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadLength15 w1
                   PhonemeType2.NORMAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadLength12 w1
                   PhonemeType2.LONG
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadLength9 w1 }) -}
8143cb44533c9c903aac37b4f4a4473c
  $w$cshowsPrec12 ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Prim.Int# -> PhonemeType2.MaybeContour a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a18
                   @ b
                   w :: GHC.Show.Show a18
                   w1 :: GHC.Show.Show b
                   ww :: GHC.Prim.Int#
                   w2 :: PhonemeType2.MaybeContour a18 b ->
                 case w2 of wild {
                   PhonemeType2.NoContour b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ b w1 PhonemeType2.$fReadMaybeContour5 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fShowConsonant4 (g x)
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }
                   PhonemeType2.Contour b1 b2
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a18 w PhonemeType2.$fReadMaybeContour5 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ b w1 PhonemeType2.$fReadMaybeContour5 b2
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant3
                             (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant3
                                (f (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            x))))) } }) -}
57e37fc45e7527176af3ce2952794c24
  $w$cshowsPrec13 ::
    PhonemeType2.Stricture -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Stricture w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.OCCLUSION
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadStricture15 w1
                   PhonemeType2.TURBULENT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadStricture12 w1
                   PhonemeType2.SLIGHTTURBULENT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadStricture9
                        w1 }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $w$cshowsPrec14 ::
    PhonemeType2.VOT -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.VOT w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.POSITIVE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeImpossible43
                        w1
                   PhonemeType2.ZERO
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeImpossible40
                        w1
                   PhonemeType2.NEGATIVE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeImpossible37
                        w1 }) -}
28cc042f29c1f66b777353e4a694a987
  $w$cshowsPrec15 ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour
         PhonemeType2.Height PhonemeType2.Height
    -> PhonemeType2.MaybeContour
         PhonemeType2.Backness PhonemeType2.Backness
    -> PhonemeType2.MaybeContour
         PhonemeType2.Roundedness PhonemeType2.Roundedness
    -> PhonemeType2.Length
    -> PhonemeType2.AirEscape
    -> PhonemeType2.Airstream
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 9,
     Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U(1*U,1*U)><L,1*U><L,U>,
     Inline: [0] -}
2ab52376457d3336f77db70cab51fe4d
  $w$cshowsPrec16 ::
    GHC.Prim.Int#
    -> [PhonemeType2.Vowel] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeType2.Vowel]
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fShowVowelPhonemeInventory2
                        (GHC.Show.showList__
                           @ PhonemeType2.Vowel
                           PhonemeType2.$fShowVowel1
                           ww1
                           w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType2.$fShowVowelPhonemeInventory2
                           (GHC.Show.showList__
                              @ PhonemeType2.Vowel
                              PhonemeType2.$fShowVowel1
                              ww1
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
9918c87837d4f215d9649b53c1c134de
  $w$cshowsPrec2 ::
    PhonemeType2.Backness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Backness w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.BACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness23 w1
                   PhonemeType2.NEARBACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness20 w1
                   PhonemeType2.CENTRAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness17 w1
                   PhonemeType2.NEARFRONT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness14 w1
                   PhonemeType2.FRONT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadBackness11
                        w1 }) -}
e4bfbb49be13691d9248a1578690fb20
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour PhonemeType2.Place PhonemeType2.Place
    -> PhonemeType2.MaybeContour
         PhonemeType2.Manner PhonemeType2.Manner
    -> PhonemeType2.MaybeContour
         PhonemeType2.Airstream PhonemeType2.Airstream
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 6, Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType2.MaybeContour
                            PhonemeType2.Place PhonemeType2.Place
                   ww2 :: PhonemeType2.MaybeContour
                            PhonemeType2.Manner PhonemeType2.Manner
                   ww3 :: PhonemeType2.MaybeContour
                            PhonemeType2.Airstream PhonemeType2.Airstream
                   ww4 :: PhonemeType2.MaybeContour
                            PhonemeType2.Phonation PhonemeType2.Phonation
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType2.$fShowConsonant11
                       (PhonemeType2.$w$s$cshowsPrec3
                          0
                          ww1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowAirstream4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant7
                                (PhonemeType2.$w$s$cshowsPrec2
                                   0
                                   ww2
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      PhonemeType2.$fShowAirstream4
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         PhonemeType2.$fShowConsonant6
                                         (PhonemeType2.$w$s$cshowsPrec1
                                            0
                                            ww3
                                            (GHC.Base.++
                                               @ GHC.Types.Char
                                               PhonemeType2.$fShowAirstream4
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  PhonemeType2.$fShowConsonant5
                                                  (PhonemeType2.$w$s$cshowsPrec
                                                     0
                                                     ww4
                                                     (GHC.Base.++
                                                        @ GHC.Types.Char
                                                        PhonemeType2.$fShowAirstream2
                                                        x)))))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fShowConsonant2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType2.$fShowConsonant2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
a4e0caad2d1174c9226145cc0019ed73
  $w$cshowsPrec4 ::
    PhonemeType2.Phonation -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Phonation w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.VOICELESS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeContour43
                        w1
                   PhonemeType2.BREATHY
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeContour40
                        w1
                   PhonemeType2.SLACK
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeContour37
                        w1
                   PhonemeType2.MODAL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeContour34
                        w1
                   PhonemeType2.STIFF
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeContour31
                        w1
                   PhonemeType2.CREAKY
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeContour28
                        w1
                   PhonemeType2.CLOSURE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadMaybeContour25
                        w1 }) -}
41b694294397b0b92be328b91640ff1f
  $w$cshowsPrec5 ::
    GHC.Prim.Int#
    -> PhonemeType2.Stricture
    -> PhonemeType2.MaybeImpossible PhonemeType2.Trill
    -> PhonemeType2.Length
    -> PhonemeType2.MaybeImpossible PhonemeType2.Laterality
    -> PhonemeType2.MaybeImpossible PhonemeType2.Silibance
    -> PhonemeType2.AirEscape
    -> PhonemeType2.MaybeImpossible PhonemeType2.VOT
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 9,
     Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0] -}
40ce57a679a93894658a595516ecb934
  $w$cshowsPrec6 ::
    GHC.Prim.Int#
    -> PhonemeType2.ActiveArticulator
    -> PhonemeType2.PassiveArticulator
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType2.ActiveArticulator
                   ww2 :: PhonemeType2.PassiveArticulator
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType2.$fShowConsonant10
                       (PhonemeType2.$w$cshowsPrec
                          ww1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowAirstream4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant9
                                (PhonemeType2.$w$cshowsPrec7
                                   ww2
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      PhonemeType2.$fShowAirstream2
                                      x)))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fShowConsonant8 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType2.$fShowConsonant8
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
b99e0542eafd4baafc4b7c93a8988262
  $w$cshowsPrec7 ::
    PhonemeType2.PassiveArticulator
    -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.PassiveArticulator
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.UPPERLIP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator47
                        w1
                   PhonemeType2.UPPERTEETH
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator44
                        w1
                   PhonemeType2.TEETHRIDGE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator41
                        w1
                   PhonemeType2.RIDGE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator38
                        w1
                   PhonemeType2.BACKRIDGE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator35
                        w1
                   PhonemeType2.HARDPALATE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator32
                        w1
                   PhonemeType2.SOFTPALATE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator29
                        w1
                   PhonemeType2.UVULA
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator26
                        w1
                   PhonemeType2.PHARYNX
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator23
                        w1
                   PhonemeType2.EPIGLOTTIS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator20
                        w1
                   PhonemeType2.GLOTTIS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPassiveArticulator17
                        w1 }) -}
a4f610e2297f07f486c2cd197311c573
  $w$cshowsPrec8 ::
    GHC.Prim.Int#
    -> [PhonemeType2.Consonant] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeType2.Consonant]
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fShowConsonantPhonemeInventory2
                        (GHC.Show.showList__
                           @ PhonemeType2.Consonant
                           PhonemeType2.$fShowConsonant1
                           ww1
                           w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType2.$fShowConsonantPhonemeInventory2
                           (GHC.Show.showList__
                              @ PhonemeType2.Consonant
                              PhonemeType2.$fShowConsonant1
                              ww1
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $w$cshowsPrec9 ::
    PhonemeType2.Height -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Height w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.CLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight31 w1
                   PhonemeType2.NEARCLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight28 w1
                   PhonemeType2.CLOSEMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight25 w1
                   PhonemeType2.MID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight22 w1
                   PhonemeType2.OPENMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight19 w1
                   PhonemeType2.NEAROPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight16 w1
                   PhonemeType2.OPEN
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadHeight13
                        w1 }) -}
d12400f0f662bae3ab829b7afc21c4a1
  $w$ctoEnum :: GHC.Prim.Int# -> PhonemeType2.ActiveArticulator
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumActiveArticulator8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.ActiveArticulator ww } }) -}
e607fa7baa5310b2ce6a27a01c437a40
  $w$ctoEnum1 :: GHC.Prim.Int# -> PhonemeType2.AirEscape
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumAirEscape1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumAirEscape1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.AirEscape ww } }) -}
e8a534a069fcf11d22fabc02549d84ae
  $w$ctoEnum10 :: GHC.Prim.Int# -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumRoundedness1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumRoundedness1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Roundedness ww } }) -}
6f56b9eb1985eff94cee6d9814538c86
  $w$ctoEnum11 :: GHC.Prim.Int# -> PhonemeType2.Silibance
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumSilibance1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumSilibance1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Silibance ww } }) -}
57e37fc45e7527176af3ce2952794c24
  $w$ctoEnum12 :: GHC.Prim.Int# -> PhonemeType2.Stricture
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumStricture1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumStricture1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Stricture ww } }) -}
8650e80162817fe79be4acc77e003de6
  $w$ctoEnum13 :: GHC.Prim.Int# -> PhonemeType2.Trill
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumTrill1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumTrill1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Trill ww } }) -}
71a6867a3ad0dfd866fd5fb4e97ee9a5
  $w$ctoEnum14 :: GHC.Prim.Int# -> PhonemeType2.VOT
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumVOT1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumVOT1 ww
                        GHC.Types.True -> GHC.Prim.tagToEnum# @ PhonemeType2.VOT ww } }) -}
9918c87837d4f215d9649b53c1c134de
  $w$ctoEnum2 :: GHC.Prim.Int# -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumBackness6 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 4) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumBackness6 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Backness ww } }) -}
3de6396777539178df86bdf5ea849b5e
  $w$ctoEnum3 :: GHC.Prim.Int# -> PhonemeType2.Direction
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumDirection1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumDirection1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Direction ww } }) -}
1c6d8ab2bcf13c05c64caf7fc4e8d223
  $w$ctoEnum4 :: GHC.Prim.Int# -> PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumHeight8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumHeight8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Height ww } }) -}
cf0efd186b87d1976dba6b7feef6e065
  $w$ctoEnum5 :: GHC.Prim.Int# -> PhonemeType2.Initiator
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumInitiator1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumInitiator1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Initiator ww } }) -}
f28c4174999e39eea0edf7a94bde9432
  $w$ctoEnum6 :: GHC.Prim.Int# -> PhonemeType2.Laterality
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumLaterality1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumLaterality1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Laterality ww } }) -}
195969ff33df4040ea1319692f018c08
  $w$ctoEnum7 :: GHC.Prim.Int# -> PhonemeType2.Length
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumLength1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumLength1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Length ww } }) -}
b99e0542eafd4baafc4b7c93a8988262
  $w$ctoEnum8 :: GHC.Prim.Int# -> PhonemeType2.PassiveArticulator
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumPassiveArticulator1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 10) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumPassiveArticulator1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.PassiveArticulator ww } }) -}
a4e0caad2d1174c9226145cc0019ed73
  $w$ctoEnum9 :: GHC.Prim.Int# -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumPhonation8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumPhonation8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Phonation ww } }) -}
e4433dab0808912500925df4b907d28a
  $w$s$cshowsPrec ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Phonation PhonemeType2.Phonation
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NoContour b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant4
                             (PhonemeType2.$w$cshowsPrec4 b1 w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant4
                                (PhonemeType2.$w$cshowsPrec4
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) }
                   PhonemeType2.Contour b1 b2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant3
                             (PhonemeType2.$w$cshowsPrec4
                                b1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (PhonemeType2.$w$cshowsPrec4 b2 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant3
                                (PhonemeType2.$w$cshowsPrec4
                                   b1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (PhonemeType2.$w$cshowsPrec4
                                         b2
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            w1))))) } }) -}
8b5d273f600f289d7a6dac0ec97e4256
  $w$s$cshowsPrec1 ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour
         PhonemeType2.Airstream PhonemeType2.Airstream
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Airstream PhonemeType2.Airstream
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NoContour b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant4
                             (case b1 of ww1 { PhonemeType2.Airstream ww2 ww3 ->
                              PhonemeType2.$w$cshowsPrec1 11 ww2 ww3 w1 })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant4
                                (case b1 of ww1 { PhonemeType2.Airstream ww2 ww3 ->
                                 PhonemeType2.$w$cshowsPrec1
                                   11
                                   ww2
                                   ww3
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1) })) }
                   PhonemeType2.Contour b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          case b1 of ww1 { PhonemeType2.Airstream ww2 ww3 ->
                          PhonemeType2.$w$cshowsPrec1
                            11
                            ww2
                            ww3
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (case b2 of ww4 { PhonemeType2.Airstream ww5 ww6 ->
                                PhonemeType2.$w$cshowsPrec1 11 ww5 ww6 x })) }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant3
                             (g w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) } }) -}
63380a8b848f698b9e90aa5971de027a
  $w$s$cshowsPrec2 ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour
         PhonemeType2.Manner PhonemeType2.Manner
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Manner PhonemeType2.Manner
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NoContour b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant4
                             (case b1 of ww1 { PhonemeType2.Manner ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                              PhonemeType2.$w$cshowsPrec5 11 ww2 ww3 ww4 ww5 ww6 ww7 ww8 w1 })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant4
                                (case b1 of ww1 { PhonemeType2.Manner ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                                 PhonemeType2.$w$cshowsPrec5
                                   11
                                   ww2
                                   ww3
                                   ww4
                                   ww5
                                   ww6
                                   ww7
                                   ww8
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1) })) }
                   PhonemeType2.Contour b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          case b1 of ww1 { PhonemeType2.Manner ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                          PhonemeType2.$w$cshowsPrec5
                            11
                            ww2
                            ww3
                            ww4
                            ww5
                            ww6
                            ww7
                            ww8
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (case b2 of ww9 { PhonemeType2.Manner ww10 ww11 ww12 ww13 ww14 ww15 ww16 ->
                                PhonemeType2.$w$cshowsPrec5
                                  11
                                  ww10
                                  ww11
                                  ww12
                                  ww13
                                  ww14
                                  ww15
                                  ww16
                                  x })) }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant3
                             (g w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) } }) -}
e7b0236a26c1334b83b0783aa2ed3c6a
  $w$s$cshowsPrec3 ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour PhonemeType2.Place PhonemeType2.Place
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Place PhonemeType2.Place
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NoContour b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant4
                             (case b1 of ww1 { PhonemeType2.Place ww2 ww3 ->
                              PhonemeType2.$w$cshowsPrec6 11 ww2 ww3 w1 })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant4
                                (case b1 of ww1 { PhonemeType2.Place ww2 ww3 ->
                                 PhonemeType2.$w$cshowsPrec6
                                   11
                                   ww2
                                   ww3
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1) })) }
                   PhonemeType2.Contour b1 b2
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          case b1 of ww1 { PhonemeType2.Place ww2 ww3 ->
                          PhonemeType2.$w$cshowsPrec6
                            11
                            ww2
                            ww3
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (case b2 of ww4 { PhonemeType2.Place ww5 ww6 ->
                                PhonemeType2.$w$cshowsPrec6 11 ww5 ww6 x })) }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant3
                             (g w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) } }) -}
85279702d44aa9c0e38eb519a741c592
  $w$s$cshowsPrec4 ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour
         PhonemeType2.Height PhonemeType2.Height
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Height PhonemeType2.Height
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NoContour b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant4
                             (PhonemeType2.$w$cshowsPrec9 b1 w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant4
                                (PhonemeType2.$w$cshowsPrec9
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) }
                   PhonemeType2.Contour b1 b2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant3
                             (PhonemeType2.$w$cshowsPrec9
                                b1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (PhonemeType2.$w$cshowsPrec9 b2 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant3
                                (PhonemeType2.$w$cshowsPrec9
                                   b1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (PhonemeType2.$w$cshowsPrec9
                                         b2
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            w1))))) } }) -}
abe66db1e10126960a71a04f77e96045
  $w$s$cshowsPrec5 ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour
         PhonemeType2.Backness PhonemeType2.Backness
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Backness PhonemeType2.Backness
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NoContour b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant4
                             (PhonemeType2.$w$cshowsPrec2 b1 w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant4
                                (PhonemeType2.$w$cshowsPrec2
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) }
                   PhonemeType2.Contour b1 b2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType2.$fShowConsonant3
                             (PhonemeType2.$w$cshowsPrec2
                                b1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (PhonemeType2.$w$cshowsPrec2 b2 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType2.$fShowConsonant3
                                (PhonemeType2.$w$cshowsPrec2
                                   b1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (PhonemeType2.$w$cshowsPrec2
                                         b2
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            w1))))) } }) -}
d9c7f22aeb90c92a34ff8224882c9d46
  $w$s$cshowsPrec6 ::
    GHC.Prim.Int#
    -> PhonemeType2.MaybeContour
         PhonemeType2.Roundedness PhonemeType2.Roundedness
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Roundedness PhonemeType2.Roundedness
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NoContour b1
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType2.$fShowConsonant4
                            (case b1 of wild1 {
                               PhonemeType2.UNROUNDED
                               -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadMaybeContour58 x
                               PhonemeType2.ROUNDED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fReadMaybeContour55
                                    x })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1)) }
                   PhonemeType2.Contour b1 b2
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType2.$fShowConsonant3
                            (let {
                               a18 :: GHC.Base.String
                               = case b2 of wild1 {
                                   PhonemeType2.UNROUNDED
                                   -> GHC.Base.++
                                        @ GHC.Types.Char
                                        PhonemeType2.$fReadMaybeContour58
                                        x
                                   PhonemeType2.ROUNDED
                                   -> GHC.Base.++
                                        @ GHC.Types.Char
                                        PhonemeType2.$fReadMaybeContour55
                                        x }
                             } in
                             case b1 of wild1 {
                               PhonemeType2.UNROUNDED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fReadMaybeContour58
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 a18)
                               PhonemeType2.ROUNDED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType2.$fReadMaybeContour55
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 a18) })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1)) } }) -}
5c7b14d72f8f222b5cc058df80cd64de
  $wa ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.Airstream -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
f02dffbdbfa6cabc3435ae9fcf1702dc
  $wa1 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.Consonant -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
d39f64274fc64af5ece54f5fde3aa500
  $wa10 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.MaybeContour
          PhonemeType2.Backness PhonemeType2.Backness
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Backness PhonemeType2.Backness
                        -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   a18 :: Text.ParserCombinators.ReadP.P b
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 10) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl115 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl116 :: Text.ParserCombinators.ReadP.P b
                                = (GHC.Read.$fReadDouble10
                                     @ PhonemeType2.Backness
                                     PhonemeType2.$fReadBackness3
                                       `cast`
                                     (Trans
                                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                         <PhonemeType2.Backness>_R))
                                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                    <PhonemeType2.Backness>_R)))
                                     PhonemeType2.$fReadMaybeContour5)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Backness>_R)
                                    @ b
                                    (\ a19 :: PhonemeType2.Backness ->
                                     (GHC.Read.$fReadDouble10
                                        @ PhonemeType2.Backness
                                        PhonemeType2.$fReadBackness3
                                          `cast`
                                        (Trans
                                             (<Text.ParserCombinators.ReadPrec.Prec>_R
                                              ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                            <PhonemeType2.Backness>_R))
                                             (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                       <PhonemeType2.Backness>_R)))
                                        PhonemeType2.$fReadMaybeContour5)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                          <PhonemeType2.Backness>_R)
                                       @ b
                                       (\ a20 :: PhonemeType2.Backness ->
                                        w (PhonemeType2.Contour
                                             @ PhonemeType2.Backness
                                             @ PhonemeType2.Backness
                                             a19
                                             a20)))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ a98 :: Text.Read.Lex.Lexeme ->
                                 case a98 of wild {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a19
                                   -> case GHC.Base.eqString
                                             a19
                                             PhonemeType2.$fReadMaybeContour4 of wild1 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl116 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                            = \ w2 :: () -> lvl115
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ a98 :: GHC.Base.String ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                               `cast`
                             (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                               @ b
                               k) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False
                   -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Fail @ b)
                        a18
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = (GHC.Read.$fReadDouble10
                                 @ PhonemeType2.Backness
                                 PhonemeType2.$fReadBackness3
                                   `cast`
                                 (Trans
                                      (<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                     <PhonemeType2.Backness>_R))
                                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                <PhonemeType2.Backness>_R)))
                                 PhonemeType2.$fReadMaybeContour5)
                                `cast`
                              (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                   <PhonemeType2.Backness>_R)
                                @ b
                                (\ a19 :: PhonemeType2.Backness ->
                                 w (PhonemeType2.NoContour
                                      @ PhonemeType2.Backness
                                      @ PhonemeType2.Backness
                                      a19))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a19
                               -> case GHC.Base.eqString
                                         a19
                                         PhonemeType2.$fReadMaybeContour3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k))
                        a18 }) -}
1c02204c0a8bd5ad8a4564439844a9ac
  $wa11 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.MaybeContour
          PhonemeType2.Roundedness PhonemeType2.Roundedness
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Roundedness PhonemeType2.Roundedness
                        -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   a18 :: Text.ParserCombinators.ReadP.P b
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 10) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl115 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl116 :: Text.ParserCombinators.ReadP.P b
                                = (GHC.Read.$fReadDouble10
                                     @ PhonemeType2.Roundedness
                                     PhonemeType2.$fReadMaybeContour50
                                       `cast`
                                     (Trans
                                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                         <PhonemeType2.Roundedness>_R))
                                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                    <PhonemeType2.Roundedness>_R)))
                                     PhonemeType2.$fReadMaybeContour5)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Roundedness>_R)
                                    @ b
                                    (\ a19 :: PhonemeType2.Roundedness ->
                                     (GHC.Read.$fReadDouble10
                                        @ PhonemeType2.Roundedness
                                        PhonemeType2.$fReadMaybeContour50
                                          `cast`
                                        (Trans
                                             (<Text.ParserCombinators.ReadPrec.Prec>_R
                                              ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                            <PhonemeType2.Roundedness>_R))
                                             (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                       <PhonemeType2.Roundedness>_R)))
                                        PhonemeType2.$fReadMaybeContour5)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                          <PhonemeType2.Roundedness>_R)
                                       @ b
                                       (\ a20 :: PhonemeType2.Roundedness ->
                                        w (PhonemeType2.Contour
                                             @ PhonemeType2.Roundedness
                                             @ PhonemeType2.Roundedness
                                             a19
                                             a20)))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ a98 :: Text.Read.Lex.Lexeme ->
                                 case a98 of wild {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a19
                                   -> case GHC.Base.eqString
                                             a19
                                             PhonemeType2.$fReadMaybeContour4 of wild1 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl116 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                            = \ w2 :: () -> lvl115
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ a98 :: GHC.Base.String ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                               `cast`
                             (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                               @ b
                               k) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False
                   -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Fail @ b)
                        a18
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = (GHC.Read.$fReadDouble10
                                 @ PhonemeType2.Roundedness
                                 PhonemeType2.$fReadMaybeContour50
                                   `cast`
                                 (Trans
                                      (<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                     <PhonemeType2.Roundedness>_R))
                                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                <PhonemeType2.Roundedness>_R)))
                                 PhonemeType2.$fReadMaybeContour5)
                                `cast`
                              (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                   <PhonemeType2.Roundedness>_R)
                                @ b
                                (\ a19 :: PhonemeType2.Roundedness ->
                                 w (PhonemeType2.NoContour
                                      @ PhonemeType2.Roundedness
                                      @ PhonemeType2.Roundedness
                                      a19))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a19
                               -> case GHC.Base.eqString
                                         a19
                                         PhonemeType2.$fReadMaybeContour3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k))
                        a18 }) -}
80a8a0b6ebd8d0e37ac9156db03bb4d4
  $wa12 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.Vowel -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
836bde73953accb1955bda1c7bb62770
  $wa13 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.VowelPhonemeInventory
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.VowelPhonemeInventory
                        -> Text.ParserCombinators.ReadP.P b ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = GHC.Read.$wa
                                @ PhonemeType2.Vowel
                                PhonemeType2.$fReadVowel2
                                  `cast`
                                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                          <PhonemeType2.Vowel>_R))
                                @ b
                                (\ a18 :: [PhonemeType2.Vowel] ->
                                 w (PhonemeType2.VowelPhonemeInventory a18))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a18
                               -> case GHC.Base.eqString
                                         a18
                                         PhonemeType2.$fReadVowelPhonemeInventory4 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ a98 :: GHC.Base.String ->
                         (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                           `cast`
                         (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                           @ b
                           k) }) -}
498abb2d3230baf9073ff621a6aaa0e0
  $wa2 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.ConsonantPhonemeInventory
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.ConsonantPhonemeInventory
                        -> Text.ParserCombinators.ReadP.P b ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = GHC.Read.$wa
                                @ PhonemeType2.Consonant
                                PhonemeType2.$fReadConsonant2
                                  `cast`
                                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                          <PhonemeType2.Consonant>_R))
                                @ b
                                (\ a18 :: [PhonemeType2.Consonant] ->
                                 w (PhonemeType2.ConsonantPhonemeInventory a18))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a18
                               -> case GHC.Base.eqString
                                         a18
                                         PhonemeType2.$fReadConsonantPhonemeInventory4 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ a98 :: GHC.Base.String ->
                         (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                           `cast`
                         (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                           @ b
                           k) }) -}
ab5350f5942d71b67ea9edf6454c29d6
  $wa3 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
d72683d01e6b185eba7d759463e8565d
  $wa4 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.MaybeContour PhonemeType2.Place PhonemeType2.Place
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Place PhonemeType2.Place
                        -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   a18 :: Text.ParserCombinators.ReadP.P b
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 10) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl115 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl116 :: Text.ParserCombinators.ReadP.P b
                                = (GHC.Read.$fReadDouble10
                                     @ PhonemeType2.Place
                                     PhonemeType2.$fReadMaybeContour8
                                       `cast`
                                     (Trans
                                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                         <PhonemeType2.Place>_R))
                                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                    <PhonemeType2.Place>_R)))
                                     PhonemeType2.$fReadMaybeContour5)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Place>_R)
                                    @ b
                                    (\ a19 :: PhonemeType2.Place ->
                                     (GHC.Read.$fReadDouble10
                                        @ PhonemeType2.Place
                                        PhonemeType2.$fReadMaybeContour8
                                          `cast`
                                        (Trans
                                             (<Text.ParserCombinators.ReadPrec.Prec>_R
                                              ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                            <PhonemeType2.Place>_R))
                                             (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                       <PhonemeType2.Place>_R)))
                                        PhonemeType2.$fReadMaybeContour5)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                          <PhonemeType2.Place>_R)
                                       @ b
                                       (\ a20 :: PhonemeType2.Place ->
                                        w (PhonemeType2.Contour
                                             @ PhonemeType2.Place
                                             @ PhonemeType2.Place
                                             a19
                                             a20)))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ a98 :: Text.Read.Lex.Lexeme ->
                                 case a98 of wild {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a19
                                   -> case GHC.Base.eqString
                                             a19
                                             PhonemeType2.$fReadMaybeContour4 of wild1 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl116 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                            = \ w2 :: () -> lvl115
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ a98 :: GHC.Base.String ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                               `cast`
                             (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                               @ b
                               k) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False
                   -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Fail @ b)
                        a18
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = (GHC.Read.$fReadDouble10
                                 @ PhonemeType2.Place
                                 PhonemeType2.$fReadMaybeContour8
                                   `cast`
                                 (Trans
                                      (<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                     <PhonemeType2.Place>_R))
                                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                <PhonemeType2.Place>_R)))
                                 PhonemeType2.$fReadMaybeContour5)
                                `cast`
                              (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <PhonemeType2.Place>_R)
                                @ b
                                (\ a19 :: PhonemeType2.Place ->
                                 w (PhonemeType2.NoContour
                                      @ PhonemeType2.Place
                                      @ PhonemeType2.Place
                                      a19))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a19
                               -> case GHC.Base.eqString
                                         a19
                                         PhonemeType2.$fReadMaybeContour3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k))
                        a18 }) -}
ce06e3a360ef67b905c70e56b1480a17
  $wa5 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
3ee487f1b20376777aabe5bc926048c2
  $wa6 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.MaybeContour PhonemeType2.Manner PhonemeType2.Manner
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Manner PhonemeType2.Manner
                        -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   a18 :: Text.ParserCombinators.ReadP.P b
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 10) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl115 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl116 :: Text.ParserCombinators.ReadP.P b
                                = (GHC.Read.$fReadDouble10
                                     @ PhonemeType2.Manner
                                     PhonemeType2.$fReadManner3
                                       `cast`
                                     (Trans
                                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                         <PhonemeType2.Manner>_R))
                                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                    <PhonemeType2.Manner>_R)))
                                     PhonemeType2.$fReadMaybeContour5)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Manner>_R)
                                    @ b
                                    (\ a19 :: PhonemeType2.Manner ->
                                     (GHC.Read.$fReadDouble10
                                        @ PhonemeType2.Manner
                                        PhonemeType2.$fReadManner3
                                          `cast`
                                        (Trans
                                             (<Text.ParserCombinators.ReadPrec.Prec>_R
                                              ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                            <PhonemeType2.Manner>_R))
                                             (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                       <PhonemeType2.Manner>_R)))
                                        PhonemeType2.$fReadMaybeContour5)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                          <PhonemeType2.Manner>_R)
                                       @ b
                                       (\ a20 :: PhonemeType2.Manner ->
                                        w (PhonemeType2.Contour
                                             @ PhonemeType2.Manner
                                             @ PhonemeType2.Manner
                                             a19
                                             a20)))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ a98 :: Text.Read.Lex.Lexeme ->
                                 case a98 of wild {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a19
                                   -> case GHC.Base.eqString
                                             a19
                                             PhonemeType2.$fReadMaybeContour4 of wild1 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl116 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                            = \ w2 :: () -> lvl115
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ a98 :: GHC.Base.String ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                               `cast`
                             (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                               @ b
                               k) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False
                   -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Fail @ b)
                        a18
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = (GHC.Read.$fReadDouble10
                                 @ PhonemeType2.Manner
                                 PhonemeType2.$fReadManner3
                                   `cast`
                                 (Trans
                                      (<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                     <PhonemeType2.Manner>_R))
                                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                <PhonemeType2.Manner>_R)))
                                 PhonemeType2.$fReadMaybeContour5)
                                `cast`
                              (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                   <PhonemeType2.Manner>_R)
                                @ b
                                (\ a19 :: PhonemeType2.Manner ->
                                 w (PhonemeType2.NoContour
                                      @ PhonemeType2.Manner
                                      @ PhonemeType2.Manner
                                      a19))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a19
                               -> case GHC.Base.eqString
                                         a19
                                         PhonemeType2.$fReadMaybeContour3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k))
                        a18 }) -}
19609885b1012702c89eeb79ae4b0654
  $wa7 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.MaybeContour
          PhonemeType2.Airstream PhonemeType2.Airstream
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Airstream PhonemeType2.Airstream
                        -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   a18 :: Text.ParserCombinators.ReadP.P b
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 10) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl115 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl116 :: Text.ParserCombinators.ReadP.P b
                                = (GHC.Read.$fReadDouble10
                                     @ PhonemeType2.Airstream
                                     PhonemeType2.$fReadAirstream3
                                       `cast`
                                     (Trans
                                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                         <PhonemeType2.Airstream>_R))
                                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                    <PhonemeType2.Airstream>_R)))
                                     PhonemeType2.$fReadMaybeContour5)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Airstream>_R)
                                    @ b
                                    (\ a19 :: PhonemeType2.Airstream ->
                                     (GHC.Read.$fReadDouble10
                                        @ PhonemeType2.Airstream
                                        PhonemeType2.$fReadAirstream3
                                          `cast`
                                        (Trans
                                             (<Text.ParserCombinators.ReadPrec.Prec>_R
                                              ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                            <PhonemeType2.Airstream>_R))
                                             (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                       <PhonemeType2.Airstream>_R)))
                                        PhonemeType2.$fReadMaybeContour5)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                          <PhonemeType2.Airstream>_R)
                                       @ b
                                       (\ a20 :: PhonemeType2.Airstream ->
                                        w (PhonemeType2.Contour
                                             @ PhonemeType2.Airstream
                                             @ PhonemeType2.Airstream
                                             a19
                                             a20)))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ a98 :: Text.Read.Lex.Lexeme ->
                                 case a98 of wild {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a19
                                   -> case GHC.Base.eqString
                                             a19
                                             PhonemeType2.$fReadMaybeContour4 of wild1 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl116 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                            = \ w2 :: () -> lvl115
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ a98 :: GHC.Base.String ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                               `cast`
                             (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                               @ b
                               k) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False
                   -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Fail @ b)
                        a18
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = (GHC.Read.$fReadDouble10
                                 @ PhonemeType2.Airstream
                                 PhonemeType2.$fReadAirstream3
                                   `cast`
                                 (Trans
                                      (<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                     <PhonemeType2.Airstream>_R))
                                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                <PhonemeType2.Airstream>_R)))
                                 PhonemeType2.$fReadMaybeContour5)
                                `cast`
                              (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                   <PhonemeType2.Airstream>_R)
                                @ b
                                (\ a19 :: PhonemeType2.Airstream ->
                                 w (PhonemeType2.NoContour
                                      @ PhonemeType2.Airstream
                                      @ PhonemeType2.Airstream
                                      a19))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a19
                               -> case GHC.Base.eqString
                                         a19
                                         PhonemeType2.$fReadMaybeContour3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k))
                        a18 }) -}
b40724f3527894df15fea9f9683b7282
  $wa8 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.MaybeContour
          PhonemeType2.Phonation PhonemeType2.Phonation
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Phonation PhonemeType2.Phonation
                        -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   a18 :: Text.ParserCombinators.ReadP.P b
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 10) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl115 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl116 :: Text.ParserCombinators.ReadP.P b
                                = (GHC.Read.$fReadDouble10
                                     @ PhonemeType2.Phonation
                                     PhonemeType2.$fReadMaybeContour15
                                       `cast`
                                     (Trans
                                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                         <PhonemeType2.Phonation>_R))
                                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                    <PhonemeType2.Phonation>_R)))
                                     PhonemeType2.$fReadMaybeContour5)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Phonation>_R)
                                    @ b
                                    (\ a19 :: PhonemeType2.Phonation ->
                                     (GHC.Read.$fReadDouble10
                                        @ PhonemeType2.Phonation
                                        PhonemeType2.$fReadMaybeContour15
                                          `cast`
                                        (Trans
                                             (<Text.ParserCombinators.ReadPrec.Prec>_R
                                              ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                            <PhonemeType2.Phonation>_R))
                                             (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                       <PhonemeType2.Phonation>_R)))
                                        PhonemeType2.$fReadMaybeContour5)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                          <PhonemeType2.Phonation>_R)
                                       @ b
                                       (\ a20 :: PhonemeType2.Phonation ->
                                        w (PhonemeType2.Contour
                                             @ PhonemeType2.Phonation
                                             @ PhonemeType2.Phonation
                                             a19
                                             a20)))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ a98 :: Text.Read.Lex.Lexeme ->
                                 case a98 of wild {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a19
                                   -> case GHC.Base.eqString
                                             a19
                                             PhonemeType2.$fReadMaybeContour4 of wild1 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl116 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                            = \ w2 :: () -> lvl115
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ a98 :: GHC.Base.String ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                               `cast`
                             (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                               @ b
                               k) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False
                   -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Fail @ b)
                        a18
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = (GHC.Read.$fReadDouble10
                                 @ PhonemeType2.Phonation
                                 PhonemeType2.$fReadMaybeContour15
                                   `cast`
                                 (Trans
                                      (<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                     <PhonemeType2.Phonation>_R))
                                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                <PhonemeType2.Phonation>_R)))
                                 PhonemeType2.$fReadMaybeContour5)
                                `cast`
                              (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                   <PhonemeType2.Phonation>_R)
                                @ b
                                (\ a19 :: PhonemeType2.Phonation ->
                                 w (PhonemeType2.NoContour
                                      @ PhonemeType2.Phonation
                                      @ PhonemeType2.Phonation
                                      a19))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a19
                               -> case GHC.Base.eqString
                                         a19
                                         PhonemeType2.$fReadMaybeContour3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k))
                        a18 }) -}
2c233f15d762a9e10ace31102f4afa3c
  $wa9 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.MaybeContour PhonemeType2.Height PhonemeType2.Height
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.MaybeContour
                          PhonemeType2.Height PhonemeType2.Height
                        -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   a18 :: Text.ParserCombinators.ReadP.P b
                   = case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# ww 10) of wild2 {
                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                       GHC.Types.True
                       -> let {
                            lvl115 :: Text.ParserCombinators.ReadP.P b
                            = let {
                                lvl116 :: Text.ParserCombinators.ReadP.P b
                                = (GHC.Read.$fReadDouble10
                                     @ PhonemeType2.Height
                                     PhonemeType2.$fReadHeight3
                                       `cast`
                                     (Trans
                                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                         <PhonemeType2.Height>_R))
                                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                    <PhonemeType2.Height>_R)))
                                     PhonemeType2.$fReadMaybeContour5)
                                    `cast`
                                  (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Height>_R)
                                    @ b
                                    (\ a19 :: PhonemeType2.Height ->
                                     (GHC.Read.$fReadDouble10
                                        @ PhonemeType2.Height
                                        PhonemeType2.$fReadHeight3
                                          `cast`
                                        (Trans
                                             (<Text.ParserCombinators.ReadPrec.Prec>_R
                                              ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                            <PhonemeType2.Height>_R))
                                             (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                       <PhonemeType2.Height>_R)))
                                        PhonemeType2.$fReadMaybeContour5)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                          <PhonemeType2.Height>_R)
                                       @ b
                                       (\ a20 :: PhonemeType2.Height ->
                                        w (PhonemeType2.Contour
                                             @ PhonemeType2.Height
                                             @ PhonemeType2.Height
                                             a19
                                             a20)))
                              } in
                              Text.Read.Lex.expect2
                                @ b
                                (\ a98 :: Text.Read.Lex.Lexeme ->
                                 case a98 of wild {
                                   DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                   Text.Read.Lex.Ident a19
                                   -> case GHC.Base.eqString
                                             a19
                                             PhonemeType2.$fReadMaybeContour4 of wild1 {
                                        GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                        GHC.Types.True -> lvl116 } })
                          } in
                          let {
                            k :: () -> Text.ParserCombinators.ReadP.P b
                              {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                 Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                            = \ w2 :: () -> lvl115
                          } in
                          Text.ParserCombinators.ReadP.Look
                            @ b
                            (\ a98 :: GHC.Base.String ->
                             (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                               `cast`
                             (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                               @ b
                               k) }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False
                   -> Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Fail @ b)
                        a18
                   GHC.Types.True
                   -> let {
                        lvl115 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl116 :: Text.ParserCombinators.ReadP.P b
                            = (GHC.Read.$fReadDouble10
                                 @ PhonemeType2.Height
                                 PhonemeType2.$fReadHeight3
                                   `cast`
                                 (Trans
                                      (<Text.ParserCombinators.ReadPrec.Prec>_R
                                       ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                     <PhonemeType2.Height>_R))
                                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                <PhonemeType2.Height>_R)))
                                 PhonemeType2.$fReadMaybeContour5)
                                `cast`
                              (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                   <PhonemeType2.Height>_R)
                                @ b
                                (\ a19 :: PhonemeType2.Height ->
                                 w (PhonemeType2.NoContour
                                      @ PhonemeType2.Height
                                      @ PhonemeType2.Height
                                      a19))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a19
                               -> case GHC.Base.eqString
                                         a19
                                         PhonemeType2.$fReadMaybeContour3 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl116 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl115) -}
                        = \ w2 :: () -> lvl115
                      } in
                      Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        @ b
                        (Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k))
                        a18 }) -}
d12400f0f662bae3ab829b7afc21c4a1
  data ActiveArticulator
    = LOWERLIP
    | TONGUEBLADE
    | TONGUETIP
    | TONGUEUNDER
    | TONGUEBODY
    | TONGUEROOT
    | LARYNX
    Promotable
e607fa7baa5310b2ce6a27a01c437a40
  data AirEscape = NASALIZED | ORAL
    Promotable
5c7b14d72f8f222b5cc058df80cd64de
  data Airstream
    = Airstream {initiator :: PhonemeType2.Initiator,
                 direction :: PhonemeType2.Direction}
    Promotable
9918c87837d4f215d9649b53c1c134de
  data Backness = BACK | NEARBACK | CENTRAL | NEARFRONT | FRONT
    Promotable
f02dffbdbfa6cabc3435ae9fcf1702dc
  data Consonant
    = Consonant {place :: PhonemeType2.MaybeContour
                            PhonemeType2.Place PhonemeType2.Place,
                 manner :: PhonemeType2.MaybeContour
                             PhonemeType2.Manner PhonemeType2.Manner,
                 airstream :: PhonemeType2.MaybeContour
                                PhonemeType2.Airstream PhonemeType2.Airstream,
                 phonation :: PhonemeType2.MaybeContour
                                PhonemeType2.Phonation PhonemeType2.Phonation}
    Promotable
498abb2d3230baf9073ff621a6aaa0e0
  data ConsonantPhonemeInventory
    = ConsonantPhonemeInventory [PhonemeType2.Consonant]
    Promotable
3de6396777539178df86bdf5ea849b5e
  data Direction = INGRESSIVE | EGRESSIVE
    Promotable
1c6d8ab2bcf13c05c64caf7fc4e8d223
  data Height
    = CLOSE | NEARCLOSE | CLOSEMID | MID | OPENMID | NEAROPEN | OPEN
    Promotable
cf0efd186b87d1976dba6b7feef6e065
  data Initiator = LINGUAL | GLOTTIC | PULMONIC
    Promotable
f28c4174999e39eea0edf7a94bde9432
  data Laterality = LATERAL | NONLATERAL
    Promotable
195969ff33df4040ea1319692f018c08
  data Length = SHORT | NORMAL | LONG
    Promotable
ab5350f5942d71b67ea9edf6454c29d6
  data Manner
    = Manner {stricture :: PhonemeType2.Stricture,
              trill :: PhonemeType2.MaybeImpossible PhonemeType2.Trill,
              mannerLength :: PhonemeType2.Length,
              laterality :: PhonemeType2.MaybeImpossible PhonemeType2.Laterality,
              silibance :: PhonemeType2.MaybeImpossible PhonemeType2.Silibance,
              airescape :: PhonemeType2.AirEscape,
              vot :: PhonemeType2.MaybeImpossible PhonemeType2.VOT}
    Promotable
8143cb44533c9c903aac37b4f4a4473c
  data MaybeContour a b = NoContour b | Contour a b
    Promotable
b13bbde41449c45003ef1026fa30364d
  data MaybeImpossible a = Possible a | Impossible
    Promotable
b99e0542eafd4baafc4b7c93a8988262
  data PassiveArticulator
    = UPPERLIP
    | UPPERTEETH
    | TEETHRIDGE
    | RIDGE
    | BACKRIDGE
    | HARDPALATE
    | SOFTPALATE
    | UVULA
    | PHARYNX
    | EPIGLOTTIS
    | GLOTTIS
    Promotable
a4e0caad2d1174c9226145cc0019ed73
  data Phonation
    = VOICELESS | BREATHY | SLACK | MODAL | STIFF | CREAKY | CLOSURE
    Promotable
ce06e3a360ef67b905c70e56b1480a17
  data Place
    = Place {active :: PhonemeType2.ActiveArticulator,
             passive :: PhonemeType2.PassiveArticulator}
    Promotable
e8a534a069fcf11d22fabc02549d84ae
  data Roundedness = UNROUNDED | ROUNDED
    Promotable
6f56b9eb1985eff94cee6d9814538c86
  data Silibance = SILIBANT | NONSILIBANT
    Promotable
57e37fc45e7527176af3ce2952794c24
  data Stricture = OCCLUSION | TURBULENT | SLIGHTTURBULENT
    Promotable
8650e80162817fe79be4acc77e003de6
  data Trill = TRILLED | NOTTRILLED
    Promotable
71a6867a3ad0dfd866fd5fb4e97ee9a5
  data VOT = POSITIVE | ZERO | NEGATIVE
    Promotable
80a8a0b6ebd8d0e37ac9156db03bb4d4
  data Vowel
    = VowelFeaturesContour {height :: PhonemeType2.MaybeContour
                                        PhonemeType2.Height PhonemeType2.Height,
                            backness :: PhonemeType2.MaybeContour
                                          PhonemeType2.Backness PhonemeType2.Backness,
                            roundedness :: PhonemeType2.MaybeContour
                                             PhonemeType2.Roundedness PhonemeType2.Roundedness,
                            vowelLength :: PhonemeType2.Length,
                            airescape2 :: PhonemeType2.AirEscape,
                            airstream2 :: PhonemeType2.Airstream,
                            phonation2 :: PhonemeType2.MaybeContour
                                            PhonemeType2.Phonation PhonemeType2.Phonation}
    Promotable
836bde73953accb1955bda1c7bb62770
  data VowelPhonemeInventory
    = VowelPhonemeInventory [PhonemeType2.Vowel]
    Promotable
ef7298bb1c6fff0e1669b16abff50dd4
  active :: PhonemeType2.Place -> PhonemeType2.ActiveArticulator
  RecSel PhonemeType2.Place
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Place ->
                 case ds of wild { PhonemeType2.Place ds1 ds2 -> ds1 }) -}
5cb23936ff88082b2237e9d16a88ac41
  airescape :: PhonemeType2.Manner -> PhonemeType2.AirEscape
  RecSel PhonemeType2.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSL),1*U(A,A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Manner ->
                 case ds of wild { PhonemeType2.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds6 }) -}
42c98a40433deb3d337a0774ad9efca6
  airescape2 :: PhonemeType2.Vowel -> PhonemeType2.AirEscape
  RecSel PhonemeType2.Vowel
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLL),1*U(A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Vowel ->
                 case ds of wild { PhonemeType2.VowelFeaturesContour ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds5 }) -}
26187bf32ea9fbf3dc8639435601647d
  airstream ::
    PhonemeType2.Consonant
    -> PhonemeType2.MaybeContour
         PhonemeType2.Airstream PhonemeType2.Airstream
  RecSel PhonemeType2.Consonant
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Consonant ->
                 case ds of wild { PhonemeType2.Consonant ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
b04e9d2224a3f26f6d3a3e2880f8fea0
  airstream2 :: PhonemeType2.Vowel -> PhonemeType2.Airstream
  RecSel PhonemeType2.Vowel
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSL),1*U(A,A,A,A,A,1*U(U,U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Vowel ->
                 case ds of wild { PhonemeType2.VowelFeaturesContour ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds6 }) -}
4a0990847e39c8f8de6aad850c3bde2f
  backness ::
    PhonemeType2.Vowel
    -> PhonemeType2.MaybeContour
         PhonemeType2.Backness PhonemeType2.Backness
  RecSel PhonemeType2.Vowel
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLL),1*U(A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Vowel ->
                 case ds of wild { PhonemeType2.VowelFeaturesContour ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds2 }) -}
caa464f10b190fa96350701aecccdb97
  direction :: PhonemeType2.Airstream -> PhonemeType2.Direction
  RecSel PhonemeType2.Airstream
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Airstream ->
                 case ds of wild { PhonemeType2.Airstream ds1 ds2 -> ds2 }) -}
89a9551037300526f6b8f727799a01c6
  height ::
    PhonemeType2.Vowel
    -> PhonemeType2.MaybeContour
         PhonemeType2.Height PhonemeType2.Height
  RecSel PhonemeType2.Vowel
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Vowel ->
                 case ds of wild { PhonemeType2.VowelFeaturesContour ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds1 }) -}
cc5f5a1cc8c62a6515dd6e843e4e1b31
  initiator :: PhonemeType2.Airstream -> PhonemeType2.Initiator
  RecSel PhonemeType2.Airstream
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Airstream ->
                 case ds of wild { PhonemeType2.Airstream ds1 ds2 -> ds1 }) -}
4b1abf59d4e4fd35c926d73eacdc7da0
  laterality ::
    PhonemeType2.Manner
    -> PhonemeType2.MaybeImpossible PhonemeType2.Laterality
  RecSel PhonemeType2.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLL),1*U(A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Manner ->
                 case ds of wild { PhonemeType2.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds4 }) -}
07056de16db8f3afae82e43150d0c448
  manner ::
    PhonemeType2.Consonant
    -> PhonemeType2.MaybeContour
         PhonemeType2.Manner PhonemeType2.Manner
  RecSel PhonemeType2.Consonant
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Consonant ->
                 case ds of wild { PhonemeType2.Consonant ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
4cef5bbbc8615ce7565b993caaae4285
  mannerLength :: PhonemeType2.Manner -> PhonemeType2.Length
  RecSel PhonemeType2.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLL),1*U(A,A,1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Manner ->
                 case ds of wild { PhonemeType2.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds3 }) -}
339392b054358275d4d9258f0e499139
  passive :: PhonemeType2.Place -> PhonemeType2.PassiveArticulator
  RecSel PhonemeType2.Place
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Place ->
                 case ds of wild { PhonemeType2.Place ds1 ds2 -> ds2 }) -}
d3b8aac1c3be646aae3d93d39c567bd6
  phonation ::
    PhonemeType2.Consonant
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
  RecSel PhonemeType2.Consonant
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Consonant ->
                 case ds of wild { PhonemeType2.Consonant ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
21aa0117262a6195c11a7fc6522bb09b
  phonation2 ::
    PhonemeType2.Vowel
    -> PhonemeType2.MaybeContour
         PhonemeType2.Phonation PhonemeType2.Phonation
  RecSel PhonemeType2.Vowel
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLS),1*U(A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Vowel ->
                 case ds of wild { PhonemeType2.VowelFeaturesContour ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds7 }) -}
b042e8490e7b954884c6ea94258b550e
  place ::
    PhonemeType2.Consonant
    -> PhonemeType2.MaybeContour PhonemeType2.Place PhonemeType2.Place
  RecSel PhonemeType2.Consonant
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Consonant ->
                 case ds of wild { PhonemeType2.Consonant ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
d5377bb65cede82d9e7800bead512f01
  roundedness ::
    PhonemeType2.Vowel
    -> PhonemeType2.MaybeContour
         PhonemeType2.Roundedness PhonemeType2.Roundedness
  RecSel PhonemeType2.Vowel
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLL),1*U(A,A,1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Vowel ->
                 case ds of wild { PhonemeType2.VowelFeaturesContour ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds3 }) -}
b43dd6ce835fdbe77fd627183ebd5157
  silibance ::
    PhonemeType2.Manner
    -> PhonemeType2.MaybeImpossible PhonemeType2.Silibance
  RecSel PhonemeType2.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLL),1*U(A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Manner ->
                 case ds of wild { PhonemeType2.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds5 }) -}
41bb4ada1e90bf397ef987ed9c89f5be
  stricture :: PhonemeType2.Manner -> PhonemeType2.Stricture
  RecSel PhonemeType2.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Manner ->
                 case ds of wild { PhonemeType2.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds1 }) -}
5aeae52ba2036cebb07153107c86aa61
  trill ::
    PhonemeType2.Manner
    -> PhonemeType2.MaybeImpossible PhonemeType2.Trill
  RecSel PhonemeType2.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLL),1*U(A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Manner ->
                 case ds of wild { PhonemeType2.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds2 }) -}
ba965648a0cb9bc9f518705fa511a6a5
  vot ::
    PhonemeType2.Manner
    -> PhonemeType2.MaybeImpossible PhonemeType2.VOT
  RecSel PhonemeType2.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLS),1*U(A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Manner ->
                 case ds of wild { PhonemeType2.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds7 }) -}
52990f4085b36c698b5cbf48bc3c1af7
  vowelLength :: PhonemeType2.Vowel -> PhonemeType2.Length
  RecSel PhonemeType2.Vowel
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLL),1*U(A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Vowel ->
                 case ds of wild { PhonemeType2.VowelFeaturesContour ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds4 }) -}
instance GHC.Enum.Bounded [PhonemeType2.ActiveArticulator]
  = PhonemeType2.$fBoundedActiveArticulator
instance GHC.Enum.Bounded [PhonemeType2.AirEscape]
  = PhonemeType2.$fBoundedAirEscape
instance GHC.Enum.Bounded [PhonemeType2.Backness]
  = PhonemeType2.$fBoundedBackness
instance GHC.Enum.Bounded [PhonemeType2.Direction]
  = PhonemeType2.$fBoundedDirection
instance GHC.Enum.Bounded [PhonemeType2.Height]
  = PhonemeType2.$fBoundedHeight
instance GHC.Enum.Bounded [PhonemeType2.Initiator]
  = PhonemeType2.$fBoundedInitiator
instance GHC.Enum.Bounded [PhonemeType2.Laterality]
  = PhonemeType2.$fBoundedLaterality
instance GHC.Enum.Bounded [PhonemeType2.Length]
  = PhonemeType2.$fBoundedLength
instance GHC.Enum.Bounded [PhonemeType2.PassiveArticulator]
  = PhonemeType2.$fBoundedPassiveArticulator
instance GHC.Enum.Bounded [PhonemeType2.Phonation]
  = PhonemeType2.$fBoundedPhonation
instance GHC.Enum.Bounded [PhonemeType2.Roundedness]
  = PhonemeType2.$fBoundedRoundedness
instance GHC.Enum.Bounded [PhonemeType2.Silibance]
  = PhonemeType2.$fBoundedSilibance
instance GHC.Enum.Bounded [PhonemeType2.Stricture]
  = PhonemeType2.$fBoundedStricture
instance GHC.Enum.Bounded [PhonemeType2.Trill]
  = PhonemeType2.$fBoundedTrill
instance GHC.Enum.Bounded [PhonemeType2.VOT]
  = PhonemeType2.$fBoundedVOT
instance GHC.Enum.Enum [PhonemeType2.ActiveArticulator]
  = PhonemeType2.$fEnumActiveArticulator
instance GHC.Enum.Enum [PhonemeType2.AirEscape]
  = PhonemeType2.$fEnumAirEscape
instance GHC.Enum.Enum [PhonemeType2.Backness]
  = PhonemeType2.$fEnumBackness
instance GHC.Enum.Enum [PhonemeType2.Direction]
  = PhonemeType2.$fEnumDirection
instance GHC.Enum.Enum [PhonemeType2.Height]
  = PhonemeType2.$fEnumHeight
instance GHC.Enum.Enum [PhonemeType2.Initiator]
  = PhonemeType2.$fEnumInitiator
instance GHC.Enum.Enum [PhonemeType2.Laterality]
  = PhonemeType2.$fEnumLaterality
instance GHC.Enum.Enum [PhonemeType2.Length]
  = PhonemeType2.$fEnumLength
instance GHC.Enum.Enum [PhonemeType2.PassiveArticulator]
  = PhonemeType2.$fEnumPassiveArticulator
instance GHC.Enum.Enum [PhonemeType2.Phonation]
  = PhonemeType2.$fEnumPhonation
instance GHC.Enum.Enum [PhonemeType2.Roundedness]
  = PhonemeType2.$fEnumRoundedness
instance GHC.Enum.Enum [PhonemeType2.Silibance]
  = PhonemeType2.$fEnumSilibance
instance GHC.Enum.Enum [PhonemeType2.Stricture]
  = PhonemeType2.$fEnumStricture
instance GHC.Enum.Enum [PhonemeType2.Trill]
  = PhonemeType2.$fEnumTrill
instance GHC.Enum.Enum [PhonemeType2.VOT] = PhonemeType2.$fEnumVOT
instance GHC.Classes.Eq [PhonemeType2.ActiveArticulator]
  = PhonemeType2.$fEqActiveArticulator
instance GHC.Classes.Eq [PhonemeType2.AirEscape]
  = PhonemeType2.$fEqAirEscape
instance GHC.Classes.Eq [PhonemeType2.Airstream]
  = PhonemeType2.$fEqAirstream
instance GHC.Classes.Eq [PhonemeType2.Backness]
  = PhonemeType2.$fEqBackness
instance GHC.Classes.Eq [PhonemeType2.Consonant]
  = PhonemeType2.$fEqConsonant
instance GHC.Classes.Eq [PhonemeType2.ConsonantPhonemeInventory]
  = PhonemeType2.$fEqConsonantPhonemeInventory
instance GHC.Classes.Eq [PhonemeType2.Direction]
  = PhonemeType2.$fEqDirection
instance GHC.Classes.Eq [PhonemeType2.Height]
  = PhonemeType2.$fEqHeight
instance GHC.Classes.Eq [PhonemeType2.Initiator]
  = PhonemeType2.$fEqInitiator
instance GHC.Classes.Eq [PhonemeType2.Laterality]
  = PhonemeType2.$fEqLaterality
instance GHC.Classes.Eq [PhonemeType2.Length]
  = PhonemeType2.$fEqLength
instance GHC.Classes.Eq [PhonemeType2.Manner]
  = PhonemeType2.$fEqManner
instance GHC.Classes.Eq [PhonemeType2.MaybeContour]
  = PhonemeType2.$fEqMaybeContour
instance GHC.Classes.Eq [PhonemeType2.MaybeImpossible]
  = PhonemeType2.$fEqMaybeImpossible
instance GHC.Classes.Eq [PhonemeType2.PassiveArticulator]
  = PhonemeType2.$fEqPassiveArticulator
instance GHC.Classes.Eq [PhonemeType2.Phonation]
  = PhonemeType2.$fEqPhonation
instance GHC.Classes.Eq [PhonemeType2.Place]
  = PhonemeType2.$fEqPlace
instance GHC.Classes.Eq [PhonemeType2.Roundedness]
  = PhonemeType2.$fEqRoundedness
instance GHC.Classes.Eq [PhonemeType2.Silibance]
  = PhonemeType2.$fEqSilibance
instance GHC.Classes.Eq [PhonemeType2.Stricture]
  = PhonemeType2.$fEqStricture
instance GHC.Classes.Eq [PhonemeType2.Trill]
  = PhonemeType2.$fEqTrill
instance GHC.Classes.Eq [PhonemeType2.VOT] = PhonemeType2.$fEqVOT
instance GHC.Classes.Eq [PhonemeType2.Vowel]
  = PhonemeType2.$fEqVowel
instance GHC.Classes.Eq [PhonemeType2.VowelPhonemeInventory]
  = PhonemeType2.$fEqVowelPhonemeInventory
instance GHC.Read.Read [PhonemeType2.ActiveArticulator]
  = PhonemeType2.$fReadActiveArticulator
instance GHC.Read.Read [PhonemeType2.AirEscape]
  = PhonemeType2.$fReadAirEscape
instance GHC.Read.Read [PhonemeType2.Airstream]
  = PhonemeType2.$fReadAirstream
instance GHC.Read.Read [PhonemeType2.Backness]
  = PhonemeType2.$fReadBackness
instance GHC.Read.Read [PhonemeType2.Consonant]
  = PhonemeType2.$fReadConsonant
instance GHC.Read.Read [PhonemeType2.ConsonantPhonemeInventory]
  = PhonemeType2.$fReadConsonantPhonemeInventory
instance GHC.Read.Read [PhonemeType2.Direction]
  = PhonemeType2.$fReadDirection
instance GHC.Read.Read [PhonemeType2.Height]
  = PhonemeType2.$fReadHeight
instance GHC.Read.Read [PhonemeType2.Initiator]
  = PhonemeType2.$fReadInitiator
instance GHC.Read.Read [PhonemeType2.Laterality]
  = PhonemeType2.$fReadLaterality
instance GHC.Read.Read [PhonemeType2.Length]
  = PhonemeType2.$fReadLength
instance GHC.Read.Read [PhonemeType2.Manner]
  = PhonemeType2.$fReadManner
instance GHC.Read.Read [PhonemeType2.MaybeContour]
  = PhonemeType2.$fReadMaybeContour
instance GHC.Read.Read [PhonemeType2.MaybeImpossible]
  = PhonemeType2.$fReadMaybeImpossible
instance GHC.Read.Read [PhonemeType2.PassiveArticulator]
  = PhonemeType2.$fReadPassiveArticulator
instance GHC.Read.Read [PhonemeType2.Phonation]
  = PhonemeType2.$fReadPhonation
instance GHC.Read.Read [PhonemeType2.Place]
  = PhonemeType2.$fReadPlace
instance GHC.Read.Read [PhonemeType2.Roundedness]
  = PhonemeType2.$fReadRoundedness
instance GHC.Read.Read [PhonemeType2.Silibance]
  = PhonemeType2.$fReadSilibance
instance GHC.Read.Read [PhonemeType2.Stricture]
  = PhonemeType2.$fReadStricture
instance GHC.Read.Read [PhonemeType2.Trill]
  = PhonemeType2.$fReadTrill
instance GHC.Read.Read [PhonemeType2.VOT] = PhonemeType2.$fReadVOT
instance GHC.Read.Read [PhonemeType2.Vowel]
  = PhonemeType2.$fReadVowel
instance GHC.Read.Read [PhonemeType2.VowelPhonemeInventory]
  = PhonemeType2.$fReadVowelPhonemeInventory
instance GHC.Show.Show [PhonemeType2.ActiveArticulator]
  = PhonemeType2.$fShowActiveArticulator
instance GHC.Show.Show [PhonemeType2.AirEscape]
  = PhonemeType2.$fShowAirEscape
instance GHC.Show.Show [PhonemeType2.Airstream]
  = PhonemeType2.$fShowAirstream
instance GHC.Show.Show [PhonemeType2.Backness]
  = PhonemeType2.$fShowBackness
instance GHC.Show.Show [PhonemeType2.Consonant]
  = PhonemeType2.$fShowConsonant
instance GHC.Show.Show [PhonemeType2.ConsonantPhonemeInventory]
  = PhonemeType2.$fShowConsonantPhonemeInventory
instance GHC.Show.Show [PhonemeType2.Direction]
  = PhonemeType2.$fShowDirection
instance GHC.Show.Show [PhonemeType2.Height]
  = PhonemeType2.$fShowHeight
instance GHC.Show.Show [PhonemeType2.Initiator]
  = PhonemeType2.$fShowInitiator
instance GHC.Show.Show [PhonemeType2.Laterality]
  = PhonemeType2.$fShowLaterality
instance GHC.Show.Show [PhonemeType2.Length]
  = PhonemeType2.$fShowLength
instance GHC.Show.Show [PhonemeType2.Manner]
  = PhonemeType2.$fShowManner
instance GHC.Show.Show [PhonemeType2.MaybeContour]
  = PhonemeType2.$fShowMaybeContour
instance GHC.Show.Show [PhonemeType2.MaybeImpossible]
  = PhonemeType2.$fShowMaybeImpossible
instance GHC.Show.Show [PhonemeType2.PassiveArticulator]
  = PhonemeType2.$fShowPassiveArticulator
instance GHC.Show.Show [PhonemeType2.Phonation]
  = PhonemeType2.$fShowPhonation
instance GHC.Show.Show [PhonemeType2.Place]
  = PhonemeType2.$fShowPlace
instance GHC.Show.Show [PhonemeType2.Roundedness]
  = PhonemeType2.$fShowRoundedness
instance GHC.Show.Show [PhonemeType2.Silibance]
  = PhonemeType2.$fShowSilibance
instance GHC.Show.Show [PhonemeType2.Stricture]
  = PhonemeType2.$fShowStricture
instance GHC.Show.Show [PhonemeType2.Trill]
  = PhonemeType2.$fShowTrill
instance GHC.Show.Show [PhonemeType2.VOT] = PhonemeType2.$fShowVOT
instance GHC.Show.Show [PhonemeType2.Vowel]
  = PhonemeType2.$fShowVowel
instance GHC.Show.Show [PhonemeType2.VowelPhonemeInventory]
  = PhonemeType2.$fShowVowelPhonemeInventory
"SPEC $cshowsPrec @ Laterality" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                            PhonemeType2.Laterality
  PhonemeType2.$fShowMaybeImpossible_$cshowsPrec @ PhonemeType2.Laterality
                                                 $dShow
  = PhonemeType2.$fShowMaybeImpossible_$s$cshowsPrec1
"SPEC $cshowsPrec @ Silibance" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                           PhonemeType2.Silibance
  PhonemeType2.$fShowMaybeImpossible_$cshowsPrec @ PhonemeType2.Silibance
                                                 $dShow
  = PhonemeType2.$fShowMaybeImpossible_$s$cshowsPrec2
"SPEC $cshowsPrec @ Trill" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                       PhonemeType2.Trill
  PhonemeType2.$fShowMaybeImpossible_$cshowsPrec @ PhonemeType2.Trill
                                                 $dShow
  = PhonemeType2.$fShowMaybeImpossible_$s$cshowsPrec
"SPEC $cshowsPrec @ VOT" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                     PhonemeType2.VOT
  PhonemeType2.$fShowMaybeImpossible_$cshowsPrec @ PhonemeType2.VOT
                                                 $dShow
  = PhonemeType2.$fShowMaybeImpossible_$s$cshowsPrec3
"SPEC/PhonemeType2 $dmreadsPrec @ ActiveArticulator" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                 PhonemeType2.ActiveArticulator
  GHC.Read.$dmreadsPrec @ PhonemeType2.ActiveArticulator $dRead
  = PhonemeType2.$fReadActiveArticulator_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ AirEscape" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.AirEscape
  GHC.Read.$dmreadsPrec @ PhonemeType2.AirEscape $dRead
  = PhonemeType2.$fReadAirEscape_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Airstream" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Airstream
  GHC.Read.$dmreadsPrec @ PhonemeType2.Airstream $dRead
  = PhonemeType2.$fReadAirstream_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Backness
  GHC.Read.$dmreadsPrec @ PhonemeType2.Backness $dRead
  = PhonemeType2.$fReadBackness_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Direction" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Direction
  GHC.Read.$dmreadsPrec @ PhonemeType2.Direction $dRead
  = PhonemeType2.$fReadDirection_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeType2.Height
  GHC.Read.$dmreadsPrec @ PhonemeType2.Height $dRead
  = PhonemeType2.$fReadHeight_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Initiator" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Initiator
  GHC.Read.$dmreadsPrec @ PhonemeType2.Initiator $dRead
  = PhonemeType2.$fReadInitiator_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Laterality" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          PhonemeType2.Laterality
  GHC.Read.$dmreadsPrec @ PhonemeType2.Laterality $dRead
  = PhonemeType2.$fReadLaterality_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Length" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeType2.Length
  GHC.Read.$dmreadsPrec @ PhonemeType2.Length $dRead
  = PhonemeType2.$fReadLength_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ PassiveArticulator" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                  PhonemeType2.PassiveArticulator
  GHC.Read.$dmreadsPrec @ PhonemeType2.PassiveArticulator $dRead
  = PhonemeType2.$fReadPassiveArticulator_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Phonation" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Phonation
  GHC.Read.$dmreadsPrec @ PhonemeType2.Phonation $dRead
  = PhonemeType2.$fReadPhonation_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeType2.Place
  GHC.Read.$dmreadsPrec @ PhonemeType2.Place $dRead
  = PhonemeType2.$fReadPlace_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                           PhonemeType2.Roundedness
  GHC.Read.$dmreadsPrec @ PhonemeType2.Roundedness $dRead
  = PhonemeType2.$fReadRoundedness_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Silibance" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Silibance
  GHC.Read.$dmreadsPrec @ PhonemeType2.Silibance $dRead
  = PhonemeType2.$fReadSilibance_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Stricture" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Stricture
  GHC.Read.$dmreadsPrec @ PhonemeType2.Stricture $dRead
  = PhonemeType2.$fReadStricture_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Trill" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeType2.Trill
  GHC.Read.$dmreadsPrec @ PhonemeType2.Trill $dRead
  = PhonemeType2.$fReadTrill_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ VOT" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                   PhonemeType2.VOT
  GHC.Read.$dmreadsPrec @ PhonemeType2.VOT $dRead
  = PhonemeType2.$fReadVOT_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Vowel" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeType2.Vowel
  GHC.Read.$dmreadsPrec @ PhonemeType2.Vowel $dRead
  = PhonemeType2.$fReadVowel_$s$dmreadsPrec
"SPEC/PhonemeType2 readListDefault @ ActiveArticulator" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                    PhonemeType2.ActiveArticulator
  GHC.Read.readListDefault @ PhonemeType2.ActiveArticulator $dRead
  = PhonemeType2.$fReadActiveArticulator_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ AirEscape" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.AirEscape
  GHC.Read.readListDefault @ PhonemeType2.AirEscape $dRead
  = PhonemeType2.$fReadAirEscape_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Airstream" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.Airstream
  GHC.Read.readListDefault @ PhonemeType2.Airstream $dRead
  = PhonemeType2.$fReadAirstream_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                           PhonemeType2.Backness
  GHC.Read.readListDefault @ PhonemeType2.Backness $dRead
  = PhonemeType2.$fReadBackness_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Consonant" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.Consonant
  GHC.Read.readListDefault @ PhonemeType2.Consonant $dRead
  = PhonemeType2.$fReadConsonant_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ ConsonantPhonemeInventory" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                            PhonemeType2.ConsonantPhonemeInventory
  GHC.Read.readListDefault @ PhonemeType2.ConsonantPhonemeInventory
                           $dRead
  = PhonemeType2.$fReadConsonantPhonemeInventory_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Direction" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.Direction
  GHC.Read.readListDefault @ PhonemeType2.Direction $dRead
  = PhonemeType2.$fReadDirection_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Height
  GHC.Read.readListDefault @ PhonemeType2.Height $dRead
  = PhonemeType2.$fReadHeight_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Initiator" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.Initiator
  GHC.Read.readListDefault @ PhonemeType2.Initiator $dRead
  = PhonemeType2.$fReadInitiator_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Laterality" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                             PhonemeType2.Laterality
  GHC.Read.readListDefault @ PhonemeType2.Laterality $dRead
  = PhonemeType2.$fReadLaterality_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Length" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Length
  GHC.Read.readListDefault @ PhonemeType2.Length $dRead
  = PhonemeType2.$fReadLength_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Manner
  GHC.Read.readListDefault @ PhonemeType2.Manner $dRead
  = PhonemeType2.$fReadManner_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ PassiveArticulator" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                     PhonemeType2.PassiveArticulator
  GHC.Read.readListDefault @ PhonemeType2.PassiveArticulator $dRead
  = PhonemeType2.$fReadPassiveArticulator_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Phonation" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.Phonation
  GHC.Read.readListDefault @ PhonemeType2.Phonation $dRead
  = PhonemeType2.$fReadPhonation_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Place
  GHC.Read.readListDefault @ PhonemeType2.Place $dRead
  = PhonemeType2.$fReadPlace_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                              PhonemeType2.Roundedness
  GHC.Read.readListDefault @ PhonemeType2.Roundedness $dRead
  = PhonemeType2.$fReadRoundedness_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Silibance" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.Silibance
  GHC.Read.readListDefault @ PhonemeType2.Silibance $dRead
  = PhonemeType2.$fReadSilibance_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Stricture" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.Stricture
  GHC.Read.readListDefault @ PhonemeType2.Stricture $dRead
  = PhonemeType2.$fReadStricture_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Trill" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Trill
  GHC.Read.readListDefault @ PhonemeType2.Trill $dRead
  = PhonemeType2.$fReadTrill_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ VOT" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeType2.VOT
  GHC.Read.readListDefault @ PhonemeType2.VOT $dRead
  = PhonemeType2.$fReadVOT_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Vowel" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Vowel
  GHC.Read.readListDefault @ PhonemeType2.Vowel $dRead
  = PhonemeType2.$fReadVowel_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ VowelPhonemeInventory" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                        PhonemeType2.VowelPhonemeInventory
  GHC.Read.readListDefault @ PhonemeType2.VowelPhonemeInventory
                           $dRead
  = PhonemeType2.$fReadVowelPhonemeInventory_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

