
==================== FINAL INTERFACE ====================
2016-10-17 20:49:36.053653 UTC

interface conla_1eA9qWUPH9nBowcXqqaV8r:PhonemeType2 7103
  interface hash: 1907558c30d2deb7f125eef8a4db18be
  ABI hash: a9247e25a5379dedeed4d4661db0033f
  export-list hash: 65413a119a4e8e15b6921e348e21398d
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  PhonemeType2.Backness{PhonemeType2.BACK PhonemeType2.CENTRAL PhonemeType2.FRONT PhonemeType2.NEARBACK PhonemeType2.NEARFRONT}
  PhonemeType2.Height{PhonemeType2.CLOSE PhonemeType2.CLOSEMID PhonemeType2.MID PhonemeType2.NEARCLOSE PhonemeType2.NEAROPEN PhonemeType2.OPEN PhonemeType2.OPENMID}
  PhonemeType2.Manner{PhonemeType2.AFFRICATE PhonemeType2.APPROXIMANT PhonemeType2.FLAP PhonemeType2.FRICATIVE PhonemeType2.LAFFRICATE PhonemeType2.LAPPROXIMANT PhonemeType2.LFLAP PhonemeType2.LFRICATIVE PhonemeType2.NASAL PhonemeType2.STOP PhonemeType2.TRILL}
  PhonemeType2.Phoneme{PhonemeType2.Blank PhonemeType2.Consonant PhonemeType2.Diphthong PhonemeType2.Vowel PhonemeType2.backness PhonemeType2.backness1 PhonemeType2.backness2 PhonemeType2.csymbol PhonemeType2.height PhonemeType2.height1 PhonemeType2.height2 PhonemeType2.manner PhonemeType2.place PhonemeType2.roundedness PhonemeType2.roundedness1 PhonemeType2.roundedness2 PhonemeType2.voice PhonemeType2.vsymbol PhonemeType2.vsymbol1 PhonemeType2.vsymbol2}
  PhonemeType2.PhonemeInventory{PhonemeType2.PhonemeInventory}
  PhonemeType2.Place{PhonemeType2.ALVEOLAR PhonemeType2.ALVEOLOPALATAL PhonemeType2.BILABIAL PhonemeType2.DENTAL PhonemeType2.DENTIALVEOLAR PhonemeType2.DORSAL PhonemeType2.EPIGLOTTAL PhonemeType2.EPIPHARYNGEAL PhonemeType2.GLOTTAL PhonemeType2.LABIAL PhonemeType2.LABIODENTAL PhonemeType2.LARYNGEAL PhonemeType2.PALATAL PhonemeType2.PHARYNGEAL PhonemeType2.POSTALVEOLAR PhonemeType2.RETROFLEX PhonemeType2.UVULAR PhonemeType2.VELAR}
  PhonemeType2.Roundedness{PhonemeType2.ROUNDED PhonemeType2.UNROUNDED}
  PhonemeType2.Voice{PhonemeType2.VOICED PhonemeType2.VOICELESS}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.ParserCombinators.ReadPrec 2590e0e0a57a86ac7c62727f4d868dd2
import  -/  base-4.8.2.0:Text.Read.Lex 724ca44ddd38ddc5f47a501d62736c26
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
2caa36e656e98f7ed18cd535a19498ef
  $fBoundedBackness :: GHC.Enum.Bounded PhonemeType2.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness PhonemeType2.BACK PhonemeType2.FRONT -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fBoundedHeight :: GHC.Enum.Bounded PhonemeType2.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height PhonemeType2.CLOSE PhonemeType2.OPEN -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fBoundedManner :: GHC.Enum.Bounded PhonemeType2.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner PhonemeType2.NASAL PhonemeType2.LFLAP -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fBoundedPlace :: GHC.Enum.Bounded PhonemeType2.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place PhonemeType2.LABIAL PhonemeType2.GLOTTAL -}
658976e686ad777c4bb2ae2c8073a4d9
  $fBoundedRoundedness :: GHC.Enum.Bounded PhonemeType2.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.ROUNDED
                  PhonemeType2.UNROUNDED -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fBoundedVoice :: GHC.Enum.Bounded PhonemeType2.Voice
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Voice PhonemeType2.VOICELESS PhonemeType2.VOICED -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness :: GHC.Enum.Enum PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fEnumBackness_$csucc
                  PhonemeType2.$fEnumBackness_$cpred
                  PhonemeType2.$fEnumBackness_$ctoEnum
                  PhonemeType2.$fEnumBackness_$cfromEnum
                  PhonemeType2.$fEnumBackness_$cenumFrom
                  PhonemeType2.$fEnumBackness_$cenumFromThen
                  PhonemeType2.$fEnumBackness_$cenumFromTo
                  PhonemeType2.$fEnumBackness_$cenumFromThenTo -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness1 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go5 4) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness2 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go6 3) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness3 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go7 2) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness4 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go8 1) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness5 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go9 0) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness6 :: GHC.Prim.Int# -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>b -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness7 :: PhonemeType2.Backness
  {- Strictness: b -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness8 :: PhonemeType2.Backness
  {- Strictness: b -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_$cenumFrom ::
    PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK -> PhonemeType2.$fEnumBackness5
                   PhonemeType2.NEARBACK -> PhonemeType2.$fEnumBackness4
                   PhonemeType2.CENTRAL -> PhonemeType2.$fEnumBackness3
                   PhonemeType2.NEARFRONT -> PhonemeType2.$fEnumBackness2
                   PhonemeType2.FRONT -> PhonemeType2.$fEnumBackness1 }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_$cenumFromThen ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Backness]
                                    PhonemeType2.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType2.Backness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Backness]
                                    PhonemeType2.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType2.Backness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 4 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.BACK -> $j1 0
                       PhonemeType2.NEARBACK -> $j1 1
                       PhonemeType2.CENTRAL -> $j1 2
                       PhonemeType2.NEARFRONT -> $j1 3
                       PhonemeType2.FRONT -> $j1 4 }
                 } in
                 case a7 of wild {
                   PhonemeType2.BACK -> $j 0
                   PhonemeType2.NEARBACK -> $j 1
                   PhonemeType2.CENTRAL -> $j 2
                   PhonemeType2.NEARFRONT -> $j 3
                   PhonemeType2.FRONT -> $j 4 }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_$cenumFromThenTo ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness
    -> PhonemeType2.Backness
    -> [PhonemeType2.Backness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_$cenumFromTo ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Backness
                   y :: PhonemeType2.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.BACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.NEARBACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.CENTRAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.NEARFRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.FRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness } }
                 } in
                 case x of wild {
                   PhonemeType2.BACK -> $j 0
                   PhonemeType2.NEARBACK -> $j 1
                   PhonemeType2.CENTRAL -> $j 2
                   PhonemeType2.NEARFRONT -> $j 3
                   PhonemeType2.FRONT -> $j 4 }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_$cfromEnum :: PhonemeType2.Backness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.Backness ->
                 case w of wild {
                   PhonemeType2.BACK -> GHC.Types.I# 0
                   PhonemeType2.NEARBACK -> GHC.Types.I# 1
                   PhonemeType2.CENTRAL -> GHC.Types.I# 2
                   PhonemeType2.NEARFRONT -> GHC.Types.I# 3
                   PhonemeType2.FRONT -> GHC.Types.I# 4 }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_$cpred ::
    PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK -> PhonemeType2.$fEnumBackness7
                   PhonemeType2.NEARBACK -> PhonemeType2.BACK
                   PhonemeType2.CENTRAL -> PhonemeType2.NEARBACK
                   PhonemeType2.NEARFRONT -> PhonemeType2.CENTRAL
                   PhonemeType2.FRONT -> PhonemeType2.NEARFRONT }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_$csucc ::
    PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK -> PhonemeType2.NEARBACK
                   PhonemeType2.NEARBACK -> PhonemeType2.CENTRAL
                   PhonemeType2.CENTRAL -> PhonemeType2.NEARFRONT
                   PhonemeType2.NEARFRONT -> PhonemeType2.FRONT
                   PhonemeType2.FRONT -> PhonemeType2.$fEnumBackness8 }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum ww1 }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_c ::
    GHC.Types.Int -> [PhonemeType2.Backness] -> [PhonemeType2.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Backness] ->
                 GHC.Types.:
                   @ PhonemeType2.Backness
                   (case x of wild { GHC.Types.I# a7 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Backness a7 })
                   ys) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go1 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go2 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go3 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go4 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go5 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go6 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go7 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go8 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEnumBackness_go9 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight :: GHC.Enum.Enum PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fEnumHeight_$csucc
                  PhonemeType2.$fEnumHeight_$cpred
                  PhonemeType2.$fEnumHeight_$ctoEnum
                  PhonemeType2.$fEnumHeight_$cfromEnum
                  PhonemeType2.$fEnumHeight_$cenumFrom
                  PhonemeType2.$fEnumHeight_$cenumFromThen
                  PhonemeType2.$fEnumHeight_$cenumFromTo
                  PhonemeType2.$fEnumHeight_$cenumFromThenTo -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight1 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go7 6) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight10 :: PhonemeType2.Height
  {- Strictness: b -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight2 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go8 5) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight3 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go9 4) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight4 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go10 3) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight5 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go11 2) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight6 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go12 1) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight7 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go13 0) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight8 :: GHC.Prim.Int# -> PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>b -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight9 :: PhonemeType2.Height
  {- Strictness: b -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_$cenumFrom ::
    PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Height ->
                 case a7 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.$fEnumHeight7
                   PhonemeType2.NEARCLOSE -> PhonemeType2.$fEnumHeight6
                   PhonemeType2.CLOSEMID -> PhonemeType2.$fEnumHeight5
                   PhonemeType2.MID -> PhonemeType2.$fEnumHeight4
                   PhonemeType2.OPENMID -> PhonemeType2.$fEnumHeight3
                   PhonemeType2.NEAROPEN -> PhonemeType2.$fEnumHeight2
                   PhonemeType2.OPEN -> PhonemeType2.$fEnumHeight1 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_$cenumFromThen ::
    PhonemeType2.Height -> PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Height]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Height]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Height]
                                    PhonemeType2.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType2.Height)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Height]
                                    PhonemeType2.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType2.Height)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.CLOSE -> $j1 0
                       PhonemeType2.NEARCLOSE -> $j1 1
                       PhonemeType2.CLOSEMID -> $j1 2
                       PhonemeType2.MID -> $j1 3
                       PhonemeType2.OPENMID -> $j1 4
                       PhonemeType2.NEAROPEN -> $j1 5
                       PhonemeType2.OPEN -> $j1 6 }
                 } in
                 case a7 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_$cenumFromThenTo ::
    PhonemeType2.Height
    -> PhonemeType2.Height
    -> PhonemeType2.Height
    -> [PhonemeType2.Height]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_$cenumFromTo ::
    PhonemeType2.Height -> PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Height y :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.CLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.NEARCLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.CLOSEMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.MID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.OPENMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.NEAROPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.OPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height } }
                 } in
                 case x of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_$cfromEnum :: PhonemeType2.Height -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.Height ->
                 case w of wild {
                   PhonemeType2.CLOSE -> GHC.Types.I# 0
                   PhonemeType2.NEARCLOSE -> GHC.Types.I# 1
                   PhonemeType2.CLOSEMID -> GHC.Types.I# 2
                   PhonemeType2.MID -> GHC.Types.I# 3
                   PhonemeType2.OPENMID -> GHC.Types.I# 4
                   PhonemeType2.NEAROPEN -> GHC.Types.I# 5
                   PhonemeType2.OPEN -> GHC.Types.I# 6 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_$cpred :: PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Height ->
                 case a7 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.$fEnumHeight9
                   PhonemeType2.NEARCLOSE -> PhonemeType2.CLOSE
                   PhonemeType2.CLOSEMID -> PhonemeType2.NEARCLOSE
                   PhonemeType2.MID -> PhonemeType2.CLOSEMID
                   PhonemeType2.OPENMID -> PhonemeType2.MID
                   PhonemeType2.NEAROPEN -> PhonemeType2.OPENMID
                   PhonemeType2.OPEN -> PhonemeType2.NEAROPEN }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_$csucc :: PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Height ->
                 case a7 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.NEARCLOSE
                   PhonemeType2.NEARCLOSE -> PhonemeType2.CLOSEMID
                   PhonemeType2.CLOSEMID -> PhonemeType2.MID
                   PhonemeType2.MID -> PhonemeType2.OPENMID
                   PhonemeType2.OPENMID -> PhonemeType2.NEAROPEN
                   PhonemeType2.NEAROPEN -> PhonemeType2.OPEN
                   PhonemeType2.OPEN -> PhonemeType2.$fEnumHeight10 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum1 ww1 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_c ::
    GHC.Types.Int -> [PhonemeType2.Height] -> [PhonemeType2.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Height] ->
                 GHC.Types.:
                   @ PhonemeType2.Height
                   (case x of wild { GHC.Types.I# a7 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Height a7 })
                   ys) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go1 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go10 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go11 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go12 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go13 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go2 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go3 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go4 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go5 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go6 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go7 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go8 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEnumHeight_go9 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner :: GHC.Enum.Enum PhonemeType2.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fEnumManner_$csucc
                  PhonemeType2.$fEnumManner_$cpred
                  PhonemeType2.$fEnumManner_$ctoEnum
                  PhonemeType2.$fEnumManner_$cfromEnum
                  PhonemeType2.$fEnumManner_$cenumFrom
                  PhonemeType2.$fEnumManner_$cenumFromThen
                  PhonemeType2.$fEnumManner_$cenumFromTo
                  PhonemeType2.$fEnumManner_$cenumFromThenTo -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner1 :: GHC.Prim.Int# -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <L,U>b -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner2 :: PhonemeType2.Manner
  {- Strictness: b -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner3 :: PhonemeType2.Manner
  {- Strictness: b -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_$cenumFrom ::
    PhonemeType2.Manner -> [PhonemeType2.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 10) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumManner_go x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Manner } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_$cenumFromThen ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> [PhonemeType2.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x1
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Manner]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeType2.Manner]
                            PhonemeType2.$fEnumManner_c1
                            (GHC.Types.[] @ PhonemeType2.Manner)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeType2.Manner]
                            PhonemeType2.$fEnumManner_c1
                            (GHC.Types.[] @ PhonemeType2.Manner)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 10 GHC.Types.True -> $j 0 } } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_$cenumFromThenTo ::
    PhonemeType2.Manner
    -> PhonemeType2.Manner
    -> PhonemeType2.Manner
    -> [PhonemeType2.Manner]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Manner
                   x2 :: PhonemeType2.Manner
                   y :: PhonemeType2.Manner ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeType2.Manner]
                        PhonemeType2.$fEnumManner_c
                        (GHC.Types.[] @ PhonemeType2.Manner)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.Manner x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeType2.Manner]
                        PhonemeType2.$fEnumManner_c
                        (GHC.Types.[] @ PhonemeType2.Manner)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.Manner x6) } } } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_$cenumFromTo ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> [PhonemeType2.Manner]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Manner y :: PhonemeType2.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go16 :: GHC.Prim.Int# -> [PhonemeType2.Manner]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeType2.Manner
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeType2.$fEnumManner1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 10) of wild2 {
                                    GHC.Types.False -> PhonemeType2.$fEnumManner1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeType2.Manner x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go16 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Manner })
                      } in
                      go16 x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Manner } } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_$cfromEnum :: PhonemeType2.Manner -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1) }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_$cpred :: PhonemeType2.Manner -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType2.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum#
                        @ PhonemeType2.Manner
                        (GHC.Prim.+# wild (-1))
                   0 -> PhonemeType2.$fEnumManner2 } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_$csucc :: PhonemeType2.Manner -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType2.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType2.Manner (GHC.Prim.+# wild 1)
                   10 -> PhonemeType2.$fEnumManner3 } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum2 ww1 }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_c ::
    GHC.Types.Int -> [PhonemeType2.Manner] -> [PhonemeType2.Manner]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Manner] ->
                 GHC.Types.:
                   @ PhonemeType2.Manner
                   (PhonemeType2.$fEnumManner_$ctoEnum x)
                   ys) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_c1 ::
    GHC.Types.Int -> [PhonemeType2.Manner] -> [PhonemeType2.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Manner] ->
                 GHC.Types.:
                   @ PhonemeType2.Manner
                   (case x of wild { GHC.Types.I# a7 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Manner a7 })
                   ys) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEnumManner_go :: GHC.Prim.Int# -> [PhonemeType2.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace :: GHC.Enum.Enum PhonemeType2.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fEnumPlace_$csucc
                  PhonemeType2.$fEnumPlace_$cpred
                  PhonemeType2.$fEnumPlace_$ctoEnum
                  PhonemeType2.$fEnumPlace_$cfromEnum
                  PhonemeType2.$fEnumPlace_$cenumFrom
                  PhonemeType2.$fEnumPlace_$cenumFromThen
                  PhonemeType2.$fEnumPlace_$cenumFromTo
                  PhonemeType2.$fEnumPlace_$cenumFromThenTo -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace1 :: GHC.Prim.Int# -> PhonemeType2.Place
  {- Arity: 1, Strictness: <L,U>b -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace2 :: PhonemeType2.Place
  {- Strictness: b -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace3 :: PhonemeType2.Place
  {- Strictness: b -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_$cenumFrom ::
    PhonemeType2.Place -> [PhonemeType2.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 17) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumPlace_go x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Place } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_$cenumFromThen ::
    PhonemeType2.Place -> PhonemeType2.Place -> [PhonemeType2.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x1
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Place]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeType2.Place]
                            PhonemeType2.$fEnumPlace_c1
                            (GHC.Types.[] @ PhonemeType2.Place)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeType2.Place]
                            PhonemeType2.$fEnumPlace_c1
                            (GHC.Types.[] @ PhonemeType2.Place)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 17 GHC.Types.True -> $j 0 } } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_$cenumFromThenTo ::
    PhonemeType2.Place
    -> PhonemeType2.Place -> PhonemeType2.Place -> [PhonemeType2.Place]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Place
                   x2 :: PhonemeType2.Place
                   y :: PhonemeType2.Place ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeType2.Place]
                        PhonemeType2.$fEnumPlace_c
                        (GHC.Types.[] @ PhonemeType2.Place)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.Place x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeType2.Place]
                        PhonemeType2.$fEnumPlace_c
                        (GHC.Types.[] @ PhonemeType2.Place)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.Place x6) } } } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_$cenumFromTo ::
    PhonemeType2.Place -> PhonemeType2.Place -> [PhonemeType2.Place]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Place y :: PhonemeType2.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go16 :: GHC.Prim.Int# -> [PhonemeType2.Place]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeType2.Place
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeType2.$fEnumPlace1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 17) of wild2 {
                                    GHC.Types.False -> PhonemeType2.$fEnumPlace1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeType2.Place x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go16 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Place })
                      } in
                      go16 x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Place } } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_$cfromEnum :: PhonemeType2.Place -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ PhonemeType2.Place x1) }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_$cpred :: PhonemeType2.Place -> PhonemeType2.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType2.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType2.Place (GHC.Prim.+# wild (-1))
                   0 -> PhonemeType2.$fEnumPlace2 } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_$csucc :: PhonemeType2.Place -> PhonemeType2.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType2.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType2.Place (GHC.Prim.+# wild 1)
                   17 -> PhonemeType2.$fEnumPlace3 } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Place
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum3 ww1 }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_c ::
    GHC.Types.Int -> [PhonemeType2.Place] -> [PhonemeType2.Place]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Place] ->
                 GHC.Types.:
                   @ PhonemeType2.Place
                   (PhonemeType2.$fEnumPlace_$ctoEnum x)
                   ys) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_c1 ::
    GHC.Types.Int -> [PhonemeType2.Place] -> [PhonemeType2.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Place] ->
                 GHC.Types.:
                   @ PhonemeType2.Place
                   (case x of wild { GHC.Types.I# a7 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Place a7 })
                   ys) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEnumPlace_go :: GHC.Prim.Int# -> [PhonemeType2.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness :: GHC.Enum.Enum PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fEnumRoundedness_$csucc
                  PhonemeType2.$fEnumRoundedness_$cpred
                  PhonemeType2.$fEnumRoundedness_$ctoEnum
                  PhonemeType2.$fEnumRoundedness_$cfromEnum
                  PhonemeType2.$fEnumRoundedness_$cenumFrom
                  PhonemeType2.$fEnumRoundedness_$cenumFromThen
                  PhonemeType2.$fEnumRoundedness_$cenumFromTo
                  PhonemeType2.$fEnumRoundedness_$cenumFromThenTo -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness1 :: GHC.Prim.Int# -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>b -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness2 :: [PhonemeType2.Roundedness]
  {- Unfolding: (PhonemeType2.$fEnumRoundedness_go2 1) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness3 :: [PhonemeType2.Roundedness]
  {- Unfolding: (PhonemeType2.$fEnumRoundedness_go3 0) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness4 :: PhonemeType2.Roundedness
  {- Strictness: b -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness5 :: PhonemeType2.Roundedness
  {- Strictness: b -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_$cenumFrom ::
    PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED -> PhonemeType2.$fEnumRoundedness3
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fEnumRoundedness2 }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_$cenumFromThen ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Roundedness
                   b :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Roundedness]
                                    PhonemeType2.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType2.Roundedness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Roundedness]
                                    PhonemeType2.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType2.Roundedness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.ROUNDED -> $j1 0 PhonemeType2.UNROUNDED -> $j1 1 }
                 } in
                 case a7 of wild {
                   PhonemeType2.ROUNDED -> $j 0 PhonemeType2.UNROUNDED -> $j 1 }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_$cenumFromThenTo ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness
    -> [PhonemeType2.Roundedness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Roundedness
                   x2 :: PhonemeType2.Roundedness
                   y :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.ROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.UNROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.ROUNDED -> $j1 0 PhonemeType2.UNROUNDED -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType2.ROUNDED -> $j 0 PhonemeType2.UNROUNDED -> $j 1 }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_$cenumFromTo ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Roundedness
                   y :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.ROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumRoundedness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Roundedness }
                       PhonemeType2.UNROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumRoundedness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Roundedness } }
                 } in
                 case x of wild {
                   PhonemeType2.ROUNDED -> $j 0 PhonemeType2.UNROUNDED -> $j 1 }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_$cfromEnum ::
    PhonemeType2.Roundedness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED -> GHC.Types.I# 0
                   PhonemeType2.UNROUNDED -> GHC.Types.I# 1 }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_$cpred ::
    PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED -> PhonemeType2.$fEnumRoundedness4
                   PhonemeType2.UNROUNDED -> PhonemeType2.ROUNDED }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_$csucc ::
    PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED -> PhonemeType2.UNROUNDED
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fEnumRoundedness5 }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_$ctoEnum ::
    GHC.Types.Int -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum4 ww1 }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_c ::
    GHC.Types.Int
    -> [PhonemeType2.Roundedness] -> [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType2.Roundedness
                   (PhonemeType2.$fEnumRoundedness_$ctoEnum x)
                   ys) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.Roundedness] -> [PhonemeType2.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType2.Roundedness
                   (case x of wild { GHC.Types.I# a7 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Roundedness a7 })
                   ys) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_go :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_go1 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_go2 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEnumRoundedness_go3 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice :: GHC.Enum.Enum PhonemeType2.Voice
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Voice
                  PhonemeType2.$fEnumVoice_$csucc
                  PhonemeType2.$fEnumVoice_$cpred
                  PhonemeType2.$fEnumVoice_$ctoEnum
                  PhonemeType2.$fEnumVoice_$cfromEnum
                  PhonemeType2.$fEnumVoice_$cenumFrom
                  PhonemeType2.$fEnumVoice_$cenumFromThen
                  PhonemeType2.$fEnumVoice_$cenumFromTo
                  PhonemeType2.$fEnumVoice_$cenumFromThenTo -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice1 :: GHC.Prim.Int# -> PhonemeType2.Voice
  {- Arity: 1, Strictness: <L,U>b -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice2 :: [PhonemeType2.Voice]
  {- Unfolding: (PhonemeType2.$fEnumVoice_go2 1) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice3 :: [PhonemeType2.Voice]
  {- Unfolding: (PhonemeType2.$fEnumVoice_go3 0) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice4 :: PhonemeType2.Voice
  {- Strictness: b -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice5 :: PhonemeType2.Voice
  {- Strictness: b -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_$cenumFrom ::
    PhonemeType2.Voice -> [PhonemeType2.Voice]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.$fEnumVoice3
                   PhonemeType2.VOICED -> PhonemeType2.$fEnumVoice2 }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_$cenumFromThen ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> [PhonemeType2.Voice]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Voice b :: PhonemeType2.Voice ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Voice]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Voice]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Voice]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Voice]
                                    PhonemeType2.$fEnumVoice_c1
                                    (GHC.Types.[] @ PhonemeType2.Voice)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Voice]
                                    PhonemeType2.$fEnumVoice_c1
                                    (GHC.Types.[] @ PhonemeType2.Voice)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.VOICELESS -> $j1 0 PhonemeType2.VOICED -> $j1 1 }
                 } in
                 case a7 of wild {
                   PhonemeType2.VOICELESS -> $j 0 PhonemeType2.VOICED -> $j 1 }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_$cenumFromThenTo ::
    PhonemeType2.Voice
    -> PhonemeType2.Voice -> PhonemeType2.Voice -> [PhonemeType2.Voice]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Voice
                   x2 :: PhonemeType2.Voice
                   y :: PhonemeType2.Voice ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Voice]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Voice]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.VOICELESS
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Voice]
                                     PhonemeType2.$fEnumVoice_c
                                     (GHC.Types.[] @ PhonemeType2.Voice)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Voice]
                                     PhonemeType2.$fEnumVoice_c
                                     (GHC.Types.[] @ PhonemeType2.Voice)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.VOICED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Voice]
                                     PhonemeType2.$fEnumVoice_c
                                     (GHC.Types.[] @ PhonemeType2.Voice)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Voice]
                                     PhonemeType2.$fEnumVoice_c
                                     (GHC.Types.[] @ PhonemeType2.Voice)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.VOICELESS -> $j1 0 PhonemeType2.VOICED -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType2.VOICELESS -> $j 0 PhonemeType2.VOICED -> $j 1 }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_$cenumFromTo ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> [PhonemeType2.Voice]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Voice y :: PhonemeType2.Voice ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Voice]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.VOICELESS
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumVoice_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Voice }
                       PhonemeType2.VOICED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumVoice_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Voice } }
                 } in
                 case x of wild {
                   PhonemeType2.VOICELESS -> $j 0 PhonemeType2.VOICED -> $j 1 }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_$cfromEnum :: PhonemeType2.Voice -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS -> GHC.Types.I# 0
                   PhonemeType2.VOICED -> GHC.Types.I# 1 }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_$cpred :: PhonemeType2.Voice -> PhonemeType2.Voice
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.$fEnumVoice4
                   PhonemeType2.VOICED -> PhonemeType2.VOICELESS }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_$csucc :: PhonemeType2.Voice -> PhonemeType2.Voice
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a7 :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.VOICED
                   PhonemeType2.VOICED -> PhonemeType2.$fEnumVoice5 }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Voice
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum5 ww1 }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_c ::
    GHC.Types.Int -> [PhonemeType2.Voice] -> [PhonemeType2.Voice]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Voice] ->
                 GHC.Types.:
                   @ PhonemeType2.Voice
                   (PhonemeType2.$fEnumVoice_$ctoEnum x)
                   ys) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_c1 ::
    GHC.Types.Int -> [PhonemeType2.Voice] -> [PhonemeType2.Voice]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Voice] ->
                 GHC.Types.:
                   @ PhonemeType2.Voice
                   (case x of wild { GHC.Types.I# a7 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Voice a7 })
                   ys) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_go :: GHC.Prim.Int# -> [PhonemeType2.Voice]
  {- Arity: 1, Strictness: <L,U> -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_go1 :: GHC.Prim.Int# -> [PhonemeType2.Voice]
  {- Arity: 1, Strictness: <L,U> -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_go2 :: GHC.Prim.Int# -> [PhonemeType2.Voice]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEnumVoice_go3 :: GHC.Prim.Int# -> [PhonemeType2.Voice]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
2caa36e656e98f7ed18cd535a19498ef
  $fEqBackness :: GHC.Classes.Eq PhonemeType2.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fEqBackness_$c==
                  PhonemeType2.$fEqBackness_$c/= -}
2caa36e656e98f7ed18cd535a19498ef
  $fEqBackness_$c/= ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.BACK -> GHC.Types.False }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARBACK -> GHC.Types.False }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.CENTRAL -> GHC.Types.False }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.False }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.False } }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fEqBackness_$c== ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.Backness
                   ds1 :: PhonemeType2.Backness ->
                 case ds of wild {
                   PhonemeType2.BACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.BACK -> GHC.Types.True }
                   PhonemeType2.NEARBACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARBACK -> GHC.Types.True }
                   PhonemeType2.CENTRAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.CENTRAL -> GHC.Types.True }
                   PhonemeType2.NEARFRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.True }
                   PhonemeType2.FRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.True } }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEqHeight :: GHC.Classes.Eq PhonemeType2.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fEqHeight_$c==
                  PhonemeType2.$fEqHeight_$c/= -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEqHeight_$c/= ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 case a7 of wild {
                   PhonemeType2.CLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.CLOSE -> GHC.Types.False }
                   PhonemeType2.NEARCLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARCLOSE -> GHC.Types.False }
                   PhonemeType2.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.CLOSEMID -> GHC.Types.False }
                   PhonemeType2.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.MID -> GHC.Types.False }
                   PhonemeType2.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.OPENMID -> GHC.Types.False }
                   PhonemeType2.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEAROPEN -> GHC.Types.False }
                   PhonemeType2.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.OPEN -> GHC.Types.False } }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fEqHeight_$c== ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.Height
                   ds1 :: PhonemeType2.Height ->
                 case ds of wild {
                   PhonemeType2.CLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.CLOSE -> GHC.Types.True }
                   PhonemeType2.NEARCLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARCLOSE -> GHC.Types.True }
                   PhonemeType2.CLOSEMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.CLOSEMID -> GHC.Types.True }
                   PhonemeType2.MID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.MID -> GHC.Types.True }
                   PhonemeType2.OPENMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.OPENMID -> GHC.Types.True }
                   PhonemeType2.NEAROPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEAROPEN -> GHC.Types.True }
                   PhonemeType2.OPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.OPEN -> GHC.Types.True } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEqManner :: GHC.Classes.Eq PhonemeType2.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fEqManner_$c==
                  PhonemeType2.$fEqManner_$c/= -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEqManner_$c/= ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fEqManner_$c== ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fEqPhoneme :: GHC.Classes.Eq PhonemeType2.Phoneme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phoneme
                  PhonemeType2.$fEqPhoneme_$c==
                  PhonemeType2.$fEqPhoneme_$c/= -}
8927f4cd51fe892095db657b7e6f52e6
  $fEqPhonemeInventory ::
    GHC.Classes.Eq PhonemeType2.PhonemeInventory
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PhonemeInventory
                  PhonemeType2.$fEqPhonemeInventory_$c==
                  PhonemeType2.$fEqPhonemeInventory_$c/= -}
8927f4cd51fe892095db657b7e6f52e6
  $fEqPhonemeInventory_$c/= ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.PhonemeInventory
                   b :: PhonemeType2.PhonemeInventory ->
                 case a7 of wild { PhonemeType2.PhonemeInventory a8 ->
                 case b of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeType2.Phoneme
                        PhonemeType2.$fEqPhoneme
                        a8
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
8927f4cd51fe892095db657b7e6f52e6
  $fEqPhonemeInventory_$c== ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.PhonemeInventory
                   ds1 :: PhonemeType2.PhonemeInventory ->
                 case ds of wild { PhonemeType2.PhonemeInventory a7 ->
                 case ds1 of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fEqPhoneme
                   a7
                   b1 } }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fEqPhoneme_$c/= ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Phoneme b :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fEqPhoneme_$c== a7 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fEqPhoneme_$c== ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEqPlace :: GHC.Classes.Eq PhonemeType2.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fEqPlace_$c==
                  PhonemeType2.$fEqPlace_$c/= -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEqPlace_$c/= ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fEqPlace_$c== ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEqRoundedness :: GHC.Classes.Eq PhonemeType2.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fEqRoundedness_$c==
                  PhonemeType2.$fEqRoundedness_$c/= -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEqRoundedness_$c/= ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.True }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.False } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fEqRoundedness_$c== ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Roundedness
                   ds1 :: PhonemeType2.Roundedness ->
                 case ds of wild {
                   PhonemeType2.ROUNDED
                   -> case ds1 of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.False }
                   PhonemeType2.UNROUNDED
                   -> case ds1 of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.True } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEqVoice :: GHC.Classes.Eq PhonemeType2.Voice
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Voice
                  PhonemeType2.$fEqVoice_$c==
                  PhonemeType2.$fEqVoice_$c/= -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEqVoice_$c/= ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Voice b :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.False
                        PhonemeType2.VOICED -> GHC.Types.True }
                   PhonemeType2.VOICED
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.True
                        PhonemeType2.VOICED -> GHC.Types.False } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fEqVoice_$c== ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Voice ds1 :: PhonemeType2.Voice ->
                 case ds of wild {
                   PhonemeType2.VOICELESS
                   -> case ds1 of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.True
                        PhonemeType2.VOICED -> GHC.Types.False }
                   PhonemeType2.VOICED
                   -> case ds1 of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.False
                        PhonemeType2.VOICED -> GHC.Types.True } }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fOrdBackness :: GHC.Classes.Ord PhonemeType2.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fEqBackness
                  PhonemeType2.$fOrdBackness_$ccompare
                  PhonemeType2.$fOrdBackness_$c<
                  PhonemeType2.$fOrdBackness_$c<=
                  PhonemeType2.$fOrdBackness_$c>
                  PhonemeType2.$fOrdBackness_$c>=
                  PhonemeType2.$fOrdBackness_$cmax
                  PhonemeType2.$fOrdBackness_$cmin -}
2caa36e656e98f7ed18cd535a19498ef
  $fOrdBackness_$c< ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.False
                        PhonemeType2.NEARBACK -> GHC.Types.True
                        PhonemeType2.CENTRAL -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.CENTRAL -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fOrdBackness_$c<= ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.False
                        PhonemeType2.NEARBACK -> GHC.Types.True
                        PhonemeType2.CENTRAL -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.CENTRAL -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.True } }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fOrdBackness_$c> ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.True
                        PhonemeType2.NEARBACK -> GHC.Types.False
                        PhonemeType2.CENTRAL -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.CENTRAL -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.False } }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fOrdBackness_$c>= ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.True
                        PhonemeType2.NEARBACK -> GHC.Types.False
                        PhonemeType2.CENTRAL -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.CENTRAL -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fOrdBackness_$ccompare ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a7 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.EQ
                        PhonemeType2.NEARBACK -> GHC.Types.LT
                        PhonemeType2.CENTRAL -> GHC.Types.LT
                        PhonemeType2.NEARFRONT -> GHC.Types.LT
                        PhonemeType2.FRONT -> GHC.Types.LT }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.GT
                        PhonemeType2.NEARBACK -> GHC.Types.EQ
                        PhonemeType2.CENTRAL -> GHC.Types.LT
                        PhonemeType2.NEARFRONT -> GHC.Types.LT
                        PhonemeType2.FRONT -> GHC.Types.LT }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.CENTRAL -> GHC.Types.EQ
                        PhonemeType2.NEARFRONT -> GHC.Types.LT
                        PhonemeType2.FRONT -> GHC.Types.LT }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.NEARFRONT -> GHC.Types.EQ
                        PhonemeType2.FRONT -> GHC.Types.LT }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeType2.FRONT -> GHC.Types.EQ } }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fOrdBackness_$cmax ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Backness
                   y :: PhonemeType2.Backness ->
                 case x of wild {
                   PhonemeType2.BACK -> y
                   PhonemeType2.NEARBACK
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType2.NEARBACK
                        PhonemeType2.CENTRAL -> PhonemeType2.CENTRAL
                        PhonemeType2.NEARFRONT -> PhonemeType2.NEARFRONT
                        PhonemeType2.FRONT -> PhonemeType2.FRONT }
                   PhonemeType2.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType2.CENTRAL
                        PhonemeType2.NEARFRONT -> PhonemeType2.NEARFRONT
                        PhonemeType2.FRONT -> PhonemeType2.FRONT }
                   PhonemeType2.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType2.NEARFRONT
                        PhonemeType2.FRONT -> PhonemeType2.FRONT }
                   PhonemeType2.FRONT
                   -> case y of wild1 { DEFAULT -> PhonemeType2.FRONT } }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fOrdBackness_$cmin ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Backness
                   y :: PhonemeType2.Backness ->
                 case x of wild {
                   PhonemeType2.BACK
                   -> case y of wild1 { DEFAULT -> PhonemeType2.BACK }
                   PhonemeType2.NEARBACK
                   -> case y of wild1 {
                        PhonemeType2.BACK -> PhonemeType2.BACK
                        PhonemeType2.NEARBACK -> PhonemeType2.NEARBACK
                        PhonemeType2.CENTRAL -> PhonemeType2.NEARBACK
                        PhonemeType2.NEARFRONT -> PhonemeType2.NEARBACK
                        PhonemeType2.FRONT -> PhonemeType2.NEARBACK }
                   PhonemeType2.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        PhonemeType2.CENTRAL -> PhonemeType2.CENTRAL
                        PhonemeType2.NEARFRONT -> PhonemeType2.CENTRAL
                        PhonemeType2.FRONT -> PhonemeType2.CENTRAL }
                   PhonemeType2.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        PhonemeType2.NEARFRONT -> PhonemeType2.NEARFRONT
                        PhonemeType2.FRONT -> PhonemeType2.NEARFRONT }
                   PhonemeType2.FRONT -> y }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fOrdHeight :: GHC.Classes.Ord PhonemeType2.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fEqHeight
                  PhonemeType2.$fOrdHeight_$ccompare
                  PhonemeType2.$fOrdHeight_$c<
                  PhonemeType2.$fOrdHeight_$c<=
                  PhonemeType2.$fOrdHeight_$c>
                  PhonemeType2.$fOrdHeight_$c>=
                  PhonemeType2.$fOrdHeight_$cmax
                  PhonemeType2.$fOrdHeight_$cmin -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fOrdHeight_$c< ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0)
                       PhonemeType2.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1)
                       PhonemeType2.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2)
                       PhonemeType2.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3)
                       PhonemeType2.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4)
                       PhonemeType2.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5)
                       PhonemeType2.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6) }
                 } in
                 case a7 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fOrdHeight_$c<= ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0)
                       PhonemeType2.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1)
                       PhonemeType2.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2)
                       PhonemeType2.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3)
                       PhonemeType2.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4)
                       PhonemeType2.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5)
                       PhonemeType2.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6) }
                 } in
                 case a7 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fOrdHeight_$c> ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0)
                       PhonemeType2.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1)
                       PhonemeType2.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2)
                       PhonemeType2.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3)
                       PhonemeType2.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4)
                       PhonemeType2.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5)
                       PhonemeType2.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6) }
                 } in
                 case a7 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fOrdHeight_$c>= ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0)
                       PhonemeType2.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1)
                       PhonemeType2.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2)
                       PhonemeType2.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3)
                       PhonemeType2.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4)
                       PhonemeType2.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5)
                       PhonemeType2.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6) }
                 } in
                 case a7 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fOrdHeight_$ccompare ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a7 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 case a7 of wild {
                   PhonemeType2.CLOSE
                   -> case b of wild1 {
                        PhonemeType2.CLOSE -> GHC.Types.EQ
                        PhonemeType2.NEARCLOSE -> GHC.Types.LT
                        PhonemeType2.CLOSEMID -> GHC.Types.LT
                        PhonemeType2.MID -> GHC.Types.LT
                        PhonemeType2.OPENMID -> GHC.Types.LT
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.NEARCLOSE
                   -> case b of wild1 {
                        PhonemeType2.CLOSE -> GHC.Types.GT
                        PhonemeType2.NEARCLOSE -> GHC.Types.EQ
                        PhonemeType2.CLOSEMID -> GHC.Types.LT
                        PhonemeType2.MID -> GHC.Types.LT
                        PhonemeType2.OPENMID -> GHC.Types.LT
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.CLOSEMID -> GHC.Types.EQ
                        PhonemeType2.MID -> GHC.Types.LT
                        PhonemeType2.OPENMID -> GHC.Types.LT
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.MID -> GHC.Types.EQ
                        PhonemeType2.OPENMID -> GHC.Types.LT
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.OPENMID -> GHC.Types.EQ
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.NEAROPEN -> GHC.Types.EQ
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeType2.OPEN -> GHC.Types.EQ } }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fOrdHeight_$cmax ::
    PhonemeType2.Height -> PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Height y :: PhonemeType2.Height ->
                 case PhonemeType2.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fOrdHeight_$cmin ::
    PhonemeType2.Height -> PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Height y :: PhonemeType2.Height ->
                 case PhonemeType2.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fOrdManner :: GHC.Classes.Ord PhonemeType2.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fEqManner
                  PhonemeType2.$fOrdManner_$ccompare
                  PhonemeType2.$fOrdManner_$c<
                  PhonemeType2.$fOrdManner_$c<=
                  PhonemeType2.$fOrdManner_$c>
                  PhonemeType2.$fOrdManner_$c>=
                  PhonemeType2.$fOrdManner_$cmax
                  PhonemeType2.$fOrdManner_$cmin -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fOrdManner_$c< ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fOrdManner_$c<= ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fOrdManner_$c> ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fOrdManner_$c>= ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fOrdManner_$ccompare ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fOrdManner_$cmax ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> PhonemeType2.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Manner y :: PhonemeType2.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fOrdManner_$cmin ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> PhonemeType2.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Manner y :: PhonemeType2.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fOrdPhoneme :: GHC.Classes.Ord PhonemeType2.Phoneme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phoneme
                  PhonemeType2.$fEqPhoneme
                  PhonemeType2.$fOrdPhoneme_$ccompare
                  PhonemeType2.$fOrdPhoneme_$c<
                  PhonemeType2.$fOrdPhoneme_$c<=
                  PhonemeType2.$fOrdPhoneme_$c>
                  PhonemeType2.$fOrdPhoneme_$c>=
                  PhonemeType2.$fOrdPhoneme_$cmax
                  PhonemeType2.$fOrdPhoneme_$cmin -}
8927f4cd51fe892095db657b7e6f52e6
  $fOrdPhonemeInventory ::
    GHC.Classes.Ord PhonemeType2.PhonemeInventory
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PhonemeInventory
                  PhonemeType2.$fEqPhonemeInventory
                  PhonemeType2.$fOrdPhonemeInventory_$ccompare
                  PhonemeType2.$fOrdPhonemeInventory_$c<
                  PhonemeType2.$fOrdPhonemeInventory_$c<=
                  PhonemeType2.$fOrdPhonemeInventory_$c>
                  PhonemeType2.$fOrdPhonemeInventory_$c>=
                  PhonemeType2.$fOrdPhonemeInventory_$cmax
                  PhonemeType2.$fOrdPhonemeInventory_$cmin -}
8927f4cd51fe892095db657b7e6f52e6
  $fOrdPhonemeInventory_$c< ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.PhonemeInventory
                   b :: PhonemeType2.PhonemeInventory ->
                 case a7 of wild { PhonemeType2.PhonemeInventory a8 ->
                 case b of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType2.Phoneme
                        PhonemeType2.$fOrdPhoneme
                        a8
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True } } }) -}
8927f4cd51fe892095db657b7e6f52e6
  $fOrdPhonemeInventory_$c<= ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.PhonemeInventory
                   b :: PhonemeType2.PhonemeInventory ->
                 case a7 of wild { PhonemeType2.PhonemeInventory a8 ->
                 case b of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType2.Phoneme
                        PhonemeType2.$fOrdPhoneme
                        a8
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } } }) -}
8927f4cd51fe892095db657b7e6f52e6
  $fOrdPhonemeInventory_$c> ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.PhonemeInventory
                   b :: PhonemeType2.PhonemeInventory ->
                 case a7 of wild { PhonemeType2.PhonemeInventory a8 ->
                 case b of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType2.Phoneme
                        PhonemeType2.$fOrdPhoneme
                        a8
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } } }) -}
8927f4cd51fe892095db657b7e6f52e6
  $fOrdPhonemeInventory_$c>= ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.PhonemeInventory
                   b :: PhonemeType2.PhonemeInventory ->
                 case a7 of wild { PhonemeType2.PhonemeInventory a8 ->
                 case b of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType2.Phoneme
                        PhonemeType2.$fOrdPhoneme
                        a8
                        b1 of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
8927f4cd51fe892095db657b7e6f52e6
  $fOrdPhonemeInventory_$ccompare ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.PhonemeInventory
                   b :: PhonemeType2.PhonemeInventory ->
                 case a7 of wild { PhonemeType2.PhonemeInventory a8 ->
                 case b of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 GHC.Classes.$w$ccompare14
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fOrdPhoneme
                   a8
                   b1 } }) -}
8927f4cd51fe892095db657b7e6f52e6
  $fOrdPhonemeInventory_$cmax ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> PhonemeType2.PhonemeInventory
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.PhonemeInventory
                   y :: PhonemeType2.PhonemeInventory ->
                 case x of wild { PhonemeType2.PhonemeInventory a7 ->
                 case y of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType2.Phoneme
                        PhonemeType2.$fOrdPhoneme
                        a7
                        b1 of wild2 {
                   DEFAULT -> wild1 GHC.Types.GT -> wild } } }) -}
8927f4cd51fe892095db657b7e6f52e6
  $fOrdPhonemeInventory_$cmin ::
    PhonemeType2.PhonemeInventory
    -> PhonemeType2.PhonemeInventory -> PhonemeType2.PhonemeInventory
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.PhonemeInventory
                   y :: PhonemeType2.PhonemeInventory ->
                 case x of wild { PhonemeType2.PhonemeInventory a7 ->
                 case y of wild1 { PhonemeType2.PhonemeInventory b1 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType2.Phoneme
                        PhonemeType2.$fOrdPhoneme
                        a7
                        b1 of wild2 {
                   DEFAULT -> wild GHC.Types.GT -> wild1 } } }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fOrdPhoneme_$c< ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fOrdPhoneme_$c<= ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fOrdPhoneme_$c> ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fOrdPhoneme_$c>= ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fOrdPhoneme_$ccompare ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
3abb4073c17ef07e2eb6d2446d16852f
  $fOrdPhoneme_$cmax ::
    PhonemeType2.Phoneme
    -> PhonemeType2.Phoneme -> PhonemeType2.Phoneme
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fOrdPhoneme_$cmin ::
    PhonemeType2.Phoneme
    -> PhonemeType2.Phoneme -> PhonemeType2.Phoneme
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fOrdPlace :: GHC.Classes.Ord PhonemeType2.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fEqPlace
                  PhonemeType2.$fOrdPlace_$ccompare
                  PhonemeType2.$fOrdPlace_$c<
                  PhonemeType2.$fOrdPlace_$c<=
                  PhonemeType2.$fOrdPlace_$c>
                  PhonemeType2.$fOrdPlace_$c>=
                  PhonemeType2.$fOrdPlace_$cmax
                  PhonemeType2.$fOrdPlace_$cmin -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fOrdPlace_$c< ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fOrdPlace_$c<= ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fOrdPlace_$c> ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fOrdPlace_$c>= ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fOrdPlace_$ccompare ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a7 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fOrdPlace_$cmax ::
    PhonemeType2.Place -> PhonemeType2.Place -> PhonemeType2.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Place y :: PhonemeType2.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fOrdPlace_$cmin ::
    PhonemeType2.Place -> PhonemeType2.Place -> PhonemeType2.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Place y :: PhonemeType2.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fOrdRoundedness :: GHC.Classes.Ord PhonemeType2.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fEqRoundedness
                  PhonemeType2.$fOrdRoundedness_$ccompare
                  PhonemeType2.$fOrdRoundedness_$c<
                  PhonemeType2.$fOrdRoundedness_$c<=
                  PhonemeType2.$fOrdRoundedness_$c>
                  PhonemeType2.$fOrdRoundedness_$c>=
                  PhonemeType2.$fOrdRoundedness_$cmax
                  PhonemeType2.$fOrdRoundedness_$cmin -}
658976e686ad777c4bb2ae2c8073a4d9
  $fOrdRoundedness_$c< ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.True }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fOrdRoundedness_$c<= ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.True } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fOrdRoundedness_$c> ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.False } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fOrdRoundedness_$c>= ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.False }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fOrdRoundedness_$ccompare ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a7 of wild {
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.EQ
                        PhonemeType2.UNROUNDED -> GHC.Types.LT }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType2.ROUNDED -> GHC.Types.GT
                        PhonemeType2.UNROUNDED -> GHC.Types.EQ } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fOrdRoundedness_$cmax ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Roundedness y :: PhonemeType2.Roundedness ->
                 case x of wild {
                   PhonemeType2.ROUNDED -> y
                   PhonemeType2.UNROUNDED
                   -> case y of wild1 { DEFAULT -> PhonemeType2.UNROUNDED } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fOrdRoundedness_$cmin ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Roundedness y :: PhonemeType2.Roundedness ->
                 case x of wild {
                   PhonemeType2.ROUNDED
                   -> case y of wild1 { DEFAULT -> PhonemeType2.ROUNDED }
                   PhonemeType2.UNROUNDED -> y }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fOrdVoice :: GHC.Classes.Ord PhonemeType2.Voice
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Voice
                  PhonemeType2.$fEqVoice
                  PhonemeType2.$fOrdVoice_$ccompare
                  PhonemeType2.$fOrdVoice_$c<
                  PhonemeType2.$fOrdVoice_$c<=
                  PhonemeType2.$fOrdVoice_$c>
                  PhonemeType2.$fOrdVoice_$c>=
                  PhonemeType2.$fOrdVoice_$cmax
                  PhonemeType2.$fOrdVoice_$cmin -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fOrdVoice_$c< ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Voice b :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.False
                        PhonemeType2.VOICED -> GHC.Types.True }
                   PhonemeType2.VOICED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fOrdVoice_$c<= ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Voice b :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType2.VOICED
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.False
                        PhonemeType2.VOICED -> GHC.Types.True } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fOrdVoice_$c> ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Voice b :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType2.VOICED
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.True
                        PhonemeType2.VOICED -> GHC.Types.False } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fOrdVoice_$c>= ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Voice b :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.True
                        PhonemeType2.VOICED -> GHC.Types.False }
                   PhonemeType2.VOICED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fOrdVoice_$ccompare ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a7 :: PhonemeType2.Voice b :: PhonemeType2.Voice ->
                 case a7 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.EQ
                        PhonemeType2.VOICED -> GHC.Types.LT }
                   PhonemeType2.VOICED
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.GT
                        PhonemeType2.VOICED -> GHC.Types.EQ } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fOrdVoice_$cmax ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> PhonemeType2.Voice
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Voice y :: PhonemeType2.Voice ->
                 case x of wild {
                   PhonemeType2.VOICELESS -> y
                   PhonemeType2.VOICED
                   -> case y of wild1 { DEFAULT -> PhonemeType2.VOICED } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fOrdVoice_$cmin ::
    PhonemeType2.Voice -> PhonemeType2.Voice -> PhonemeType2.Voice
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Voice y :: PhonemeType2.Voice ->
                 case x of wild {
                   PhonemeType2.VOICELESS
                   -> case y of wild1 { DEFAULT -> PhonemeType2.VOICELESS }
                   PhonemeType2.VOICED -> y }) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness :: GHC.Read.Read PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fReadBackness_$s$dmreadsPrec
                  PhonemeType2.$fReadBackness_$sreadListDefault
                  PhonemeType2.$fReadBackness_$creadPrec
                  PhonemeType2.$fReadBackness_$creadListPrec -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Backness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Backness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Backness>_R))
                   @ b
                   eta1) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.FRONT) -}
6f0e5466d147260e7268f47de7dbf8fd
  $fReadBackness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRONT"#) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness14,
                  PhonemeType2.$fReadBackness13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARFRONT) -}
42e184bc0571b7102459f03f8b28a778
  $fReadBackness14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARFRONT"#) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness17,
                  PhonemeType2.$fReadBackness16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CENTRAL) -}
ab11279b8eef3e42f6d640c3d6419cfe
  $fReadBackness17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CENTRAL"#) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness20,
                  PhonemeType2.$fReadBackness19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARBACK) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Backness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Backness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Backness>_R)))) -}
51228f36a1f0fd3bd1a55b3aaaf90d90
  $fReadBackness20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARBACK"#) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness23,
                  PhonemeType2.$fReadBackness22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.BACK) -}
cfa895842fb289c96d68a9218daadc0c
  $fReadBackness23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACK"#) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Backness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness4
                   eta
                   @ b
                   eta1) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness21
                   PhonemeType2.$fReadBackness5) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness18
                   PhonemeType2.$fReadBackness6) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness15
                   PhonemeType2.$fReadBackness7) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness12
                   PhonemeType2.$fReadBackness8) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness9
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Backness))) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness11,
                  PhonemeType2.$fReadBackness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Backness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadBackness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Backness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Backness]>_R))) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadBackness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Backness>_R)) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness_$creadPrec
                   eta) -}
2caa36e656e98f7ed18cd535a19498ef
  $fReadBackness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Backness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Backness]
                   ((PhonemeType2.$fReadBackness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Backness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Backness]>_R)
                      @ [PhonemeType2.Backness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Backness]))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight :: GHC.Read.Read PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fReadHeight_$s$dmreadsPrec
                  PhonemeType2.$fReadHeight_$sreadListDefault
                  PhonemeType2.$fReadHeight_$creadPrec
                  PhonemeType2.$fReadHeight_$creadListPrec -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Height] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Height]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Height>_R))
                   @ b
                   eta1) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight13,
                  PhonemeType2.$fReadHeight12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.OPEN) -}
438e01717e85acac456af7e311e6c648
  $fReadHeight13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPEN"#) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight16,
                  PhonemeType2.$fReadHeight15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEAROPEN) -}
d2467871fbea20ee5e8dc723889d4006
  $fReadHeight16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEAROPEN"#) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight19,
                  PhonemeType2.$fReadHeight18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.OPENMID) -}
479f8004c54c52c50264c4adafb45de8
  $fReadHeight19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPENMID"#) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Height
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Height>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Height>_R)))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight22,
                  PhonemeType2.$fReadHeight21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.MID) -}
483c415b6669fc4b3b4a33a8d6d47657
  $fReadHeight22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MID"#) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight25,
                  PhonemeType2.$fReadHeight24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CLOSEMID) -}
e718878d48b72fb68c9c503db6617a27
  $fReadHeight25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSEMID"#) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight28,
                  PhonemeType2.$fReadHeight27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARCLOSE) -}
e5c2b5a24e9c2a6be3444a6e1c56ebb5
  $fReadHeight28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARCLOSE"#) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight31,
                  PhonemeType2.$fReadHeight30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight4
                   eta
                   @ b
                   eta1) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CLOSE) -}
2a0b1d4baa955f92d548eb77180f187c
  $fReadHeight31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSE"#) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight29
                   PhonemeType2.$fReadHeight5) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight26
                   PhonemeType2.$fReadHeight6) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight23
                   PhonemeType2.$fReadHeight7) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight20
                   PhonemeType2.$fReadHeight8) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight17
                   PhonemeType2.$fReadHeight9) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight14
                   PhonemeType2.$fReadHeight10) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Height]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadHeight1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Height]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Height]>_R))) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadHeight2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Height>_R)) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight_$creadPrec
                   eta) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fReadHeight_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Height]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Height]
                   ((PhonemeType2.$fReadHeight_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Height]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Height]>_R)
                      @ [PhonemeType2.Height]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Height]))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner :: GHC.Read.Read PhonemeType2.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fReadManner_$s$dmreadsPrec
                  PhonemeType2.$fReadManner_$sreadListDefault
                  PhonemeType2.$fReadManner_$creadPrec
                  PhonemeType2.$fReadManner_$creadListPrec -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Manner] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Manner]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Manner>_R))
                   @ b
                   eta1) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner27
                   PhonemeType2.$fReadManner11) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner24
                   PhonemeType2.$fReadManner12) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner21
                   PhonemeType2.$fReadManner13) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner18
                   PhonemeType2.$fReadManner14) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner15
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner17,
                  PhonemeType2.$fReadManner16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LFLAP) -}
3ebf48680ee25b27b36988dd73a54a35
  $fReadManner17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFLAP"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner20,
                  PhonemeType2.$fReadManner19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LAPPROXIMANT) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Manner
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Manner>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Manner>_R)))) -}
7eedc24ef143259c4ee3e99e4f26fb5c
  $fReadManner20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAPPROXIMANT"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner23,
                  PhonemeType2.$fReadManner22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LFRICATIVE) -}
cf48e26b93c2a8528652c9591a2d9afa
  $fReadManner23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFRICATIVE"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner24 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner26,
                  PhonemeType2.$fReadManner25
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner25 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LAFFRICATE) -}
fa807c4afadb6a90252a36f586c0cbef
  $fReadManner26 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAFFRICATE"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner27 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner29,
                  PhonemeType2.$fReadManner28
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner28 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TRILL) -}
2e16877cac2dc33b939ce4e576d284eb
  $fReadManner29 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRILL"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner4
                   eta
                   @ b
                   eta1) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner30 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner32,
                  PhonemeType2.$fReadManner31
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner31 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.FLAP) -}
5dc8ea7f57ab980f874f5b74e3bb91bf
  $fReadManner32 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FLAP"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner33 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner35,
                  PhonemeType2.$fReadManner34
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner34 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.APPROXIMANT) -}
3869c8fc983b9c7ae64dece0af71b36b
  $fReadManner35 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "APPROXIMANT"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner36 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner38,
                  PhonemeType2.$fReadManner37
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner37 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.FRICATIVE) -}
d6635c03b14792437bb8027aa8333079
  $fReadManner38 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRICATIVE"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner39 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner41,
                  PhonemeType2.$fReadManner40
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner45
                   PhonemeType2.$fReadManner5) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner40 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.AFFRICATE) -}
7ed6c487f8b872b6aa5dd0fa84d5b5db
  $fReadManner41 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFFRICATE"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner42 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner44,
                  PhonemeType2.$fReadManner43
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner43 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.STOP) -}
6c410bc36044b275f51357653b1e4146
  $fReadManner44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STOP"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner45 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner47,
                  PhonemeType2.$fReadManner46
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner46 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NASAL) -}
9ff480987b7ee50265e03512656ab222
  $fReadManner47 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NASAL"#) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner42
                   PhonemeType2.$fReadManner6) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner39
                   PhonemeType2.$fReadManner7) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner36
                   PhonemeType2.$fReadManner8) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner33
                   PhonemeType2.$fReadManner9) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner30
                   PhonemeType2.$fReadManner10) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Manner]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadManner1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Manner]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Manner]>_R))) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadManner2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Manner>_R)) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Manner
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner_$creadPrec
                   eta) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fReadManner_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Manner]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Manner]
                   ((PhonemeType2.$fReadManner_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Manner]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Manner]>_R)
                      @ [PhonemeType2.Manner]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Manner]))) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fReadPhoneme :: GHC.Read.Read PhonemeType2.Phoneme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phoneme
                  PhonemeType2.$fReadPhoneme_$s$dmreadsPrec
                  PhonemeType2.$fReadPhoneme_$sreadListDefault
                  PhonemeType2.$fReadPhoneme_$creadPrec
                  PhonemeType2.$fReadPhoneme_$creadListPrec -}
3abb4073c17ef07e2eb6d2446d16852f
  $fReadPhoneme1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Phoneme] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Phoneme]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fReadPhoneme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Phoneme>_R))
                   @ b
                   eta1) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fReadPhoneme2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Phoneme
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fReadPhoneme3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Phoneme>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Phoneme>_R)))) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fReadPhoneme3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phoneme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)> -}
8927f4cd51fe892095db657b7e6f52e6
  $fReadPhonemeInventory ::
    GHC.Read.Read PhonemeType2.PhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PhonemeInventory
                  PhonemeType2.$fReadPhonemeInventory_$creadsPrec
                  PhonemeType2.$fReadPhonemeInventory_$sreadListDefault
                  PhonemeType2.$fReadPhonemeInventory_$creadPrec
                  PhonemeType2.$fReadPhonemeInventory_$creadListPrec -}
8927f4cd51fe892095db657b7e6f52e6
  $fReadPhonemeInventory1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.PhonemeInventory]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.PhonemeInventory]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.PhonemeInventory
                   PhonemeType2.$fReadPhonemeInventory2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.PhonemeInventory>_R))
                   @ b
                   eta1) -}
8927f4cd51fe892095db657b7e6f52e6
  $fReadPhonemeInventory2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.PhonemeInventory
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.PhonemeInventory
                   PhonemeType2.$fReadPhonemeInventory3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.PhonemeInventory>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.PhonemeInventory>_R)))) -}
8927f4cd51fe892095db657b7e6f52e6
  $fReadPhonemeInventory3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.PhonemeInventory -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.PhonemeInventory
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa ww1 @ b w1 }) -}
c7c4204b3cf0af9816ac8abdd3c487cc
  $fReadPhonemeInventory4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PhonemeInventory"#) -}
8927f4cd51fe892095db657b7e6f52e6
  $fReadPhonemeInventory_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType2.PhonemeInventory]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhonemeInventory1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.PhonemeInventory]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.PhonemeInventory]>_R))) -}
8927f4cd51fe892095db657b7e6f52e6
  $fReadPhonemeInventory_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType2.PhonemeInventory
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhonemeInventory2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.PhonemeInventory>_R)) -}
8927f4cd51fe892095db657b7e6f52e6
  $fReadPhonemeInventory_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.PhonemeInventory
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType2.PhonemeInventory
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType2.PhonemeInventory
                       PhonemeType2.$fReadPhonemeInventory3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType2.PhonemeInventory>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType2.PhonemeInventory>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType2.PhonemeInventory>_R)
                      @ PhonemeType2.PhonemeInventory
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType2.PhonemeInventory))) -}
8927f4cd51fe892095db657b7e6f52e6
  $fReadPhonemeInventory_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.PhonemeInventory]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.PhonemeInventory]
                   ((PhonemeType2.$fReadPhonemeInventory_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.PhonemeInventory]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.PhonemeInventory]>_R)
                      @ [PhonemeType2.PhonemeInventory]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.PhonemeInventory]))) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fReadPhoneme_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Phoneme]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhoneme1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Phoneme]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Phoneme]>_R))) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fReadPhoneme_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phoneme
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhoneme2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Phoneme>_R)) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fReadPhoneme_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fReadPhoneme_$creadPrec
                   eta) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fReadPhoneme_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Phoneme]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Phoneme]
                   ((PhonemeType2.$fReadPhoneme_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Phoneme]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Phoneme]>_R)
                      @ [PhonemeType2.Phoneme]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Phoneme]))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace :: GHC.Read.Read PhonemeType2.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fReadPlace_$s$dmreadsPrec
                  PhonemeType2.$fReadPlace_$sreadListDefault
                  PhonemeType2.$fReadPlace_$creadPrec
                  PhonemeType2.$fReadPlace_$creadListPrec -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Place] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Place] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Place>_R))
                   @ b
                   eta1) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace55
                   PhonemeType2.$fReadPlace11) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace52
                   PhonemeType2.$fReadPlace12) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace49
                   PhonemeType2.$fReadPlace13) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace46
                   PhonemeType2.$fReadPlace14) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace43
                   PhonemeType2.$fReadPlace15) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace40
                   PhonemeType2.$fReadPlace16) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace37
                   PhonemeType2.$fReadPlace17) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace17 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace34
                   PhonemeType2.$fReadPlace18) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace18 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace31
                   PhonemeType2.$fReadPlace19) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace19 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace28
                   PhonemeType2.$fReadPlace20) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Place
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Place>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Place>_R)))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace20 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace25
                   PhonemeType2.$fReadPlace21) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace22
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace22 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace24,
                  PhonemeType2.$fReadPlace23
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace23 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.GLOTTAL) -}
15c3ffe05e96d1067dc73fe3270da89f
  $fReadPlace24 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace25 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace27,
                  PhonemeType2.$fReadPlace26
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace26 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.EPIGLOTTAL) -}
4103ddf3293d6b36511ab9b126e8a4e3
  $fReadPlace27 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIGLOTTAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace28 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace30,
                  PhonemeType2.$fReadPlace29
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace29 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.PHARYNGEAL) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace4
                   eta
                   @ b
                   eta1) -}
1841b31f4980c5e453b931443bd0372e
  $fReadPlace30 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PHARYNGEAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace31 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace33,
                  PhonemeType2.$fReadPlace32
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace32 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.EPIPHARYNGEAL) -}
524f63d595a38e93f0176d015061ae51
  $fReadPlace33 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIPHARYNGEAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace34 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace36,
                  PhonemeType2.$fReadPlace35
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace35 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LARYNGEAL) -}
59e56eb3829de6ea8e39b24326e5d82a
  $fReadPlace36 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LARYNGEAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace37 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace39,
                  PhonemeType2.$fReadPlace38
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace38 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.UVULAR) -}
68897628cee562e4c61f11a229b7c039
  $fReadPlace39 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVULAR"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace73
                   PhonemeType2.$fReadPlace5) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace40 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace42,
                  PhonemeType2.$fReadPlace41
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace41 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.VELAR) -}
36dabedb02310193b686aa2fafecfe93
  $fReadPlace42 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VELAR"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace43 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace45,
                  PhonemeType2.$fReadPlace44
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace44 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.PALATAL) -}
ea890712a4c4c527d4eeca75c2bacf54
  $fReadPlace45 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PALATAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace46 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace48,
                  PhonemeType2.$fReadPlace47
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace47 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ALVEOLOPALATAL) -}
76225fc0fbf13b300ae442594f6732a3
  $fReadPlace48 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLOPALATAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace49 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace51,
                  PhonemeType2.$fReadPlace50
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace70
                   PhonemeType2.$fReadPlace6) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace50 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.DORSAL) -}
87d082a361103a7fb68e996a2d5606a7
  $fReadPlace51 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DORSAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace52 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace54,
                  PhonemeType2.$fReadPlace53
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace53 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.RETROFLEX) -}
c7a8bf390a47fd7b805efce822ae1ea1
  $fReadPlace54 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RETROFLEX"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace55 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace57,
                  PhonemeType2.$fReadPlace56
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace56 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.POSTALVEOLAR) -}
8da52263bae5127c9b1105f76f20730a
  $fReadPlace57 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POSTALVEOLAR"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace58 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace60,
                  PhonemeType2.$fReadPlace59
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace59 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ALVEOLAR) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace67
                   PhonemeType2.$fReadPlace7) -}
bdef6c112137a960a35b9a4306f08f4e
  $fReadPlace60 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLAR"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace61 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace63,
                  PhonemeType2.$fReadPlace62
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace62 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.DENTAL) -}
b5c3d3963dcd99b7c1a2ede65c4d956d
  $fReadPlace63 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace64 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace66,
                  PhonemeType2.$fReadPlace65
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace65 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.DENTIALVEOLAR) -}
41e502196b8458365c25c0406455716a
  $fReadPlace66 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTIALVEOLAR"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace67 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace69,
                  PhonemeType2.$fReadPlace68
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace68 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LABIODENTAL) -}
fa83022d4084fc273ea4c3d7335a7a1e
  $fReadPlace69 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIODENTAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace64
                   PhonemeType2.$fReadPlace8) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace70 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace72,
                  PhonemeType2.$fReadPlace71
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace71 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.BILABIAL) -}
e3bd29c427d07f6c7fb604fe88b1facb
  $fReadPlace72 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BILABIAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace73 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace75,
                  PhonemeType2.$fReadPlace74
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace74 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LABIAL) -}
97a74f4235788bfb705ca85a0b2e5b7b
  $fReadPlace75 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIAL"#) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace61
                   PhonemeType2.$fReadPlace9) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace58
                   PhonemeType2.$fReadPlace10) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Place]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPlace1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Place]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Place]>_R))) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPlace2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Place>_R)) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Place
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace_$creadPrec
                   eta) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fReadPlace_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Place]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Place]
                   ((PhonemeType2.$fReadPlace_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Place]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Place]>_R)
                      @ [PhonemeType2.Place]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Place]))) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness :: GHC.Read.Read PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fReadRoundedness_$s$dmreadsPrec
                  PhonemeType2.$fReadRoundedness_$sreadListDefault
                  PhonemeType2.$fReadRoundedness_$creadPrec
                  PhonemeType2.$fReadRoundedness_$creadListPrec -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Roundedness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Roundedness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Roundedness>_R))
                   @ b
                   eta1) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ROUNDED) -}
653568e8984edbb53264b0449171403e
  $fReadRoundedness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ROUNDED"#) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Roundedness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Roundedness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Roundedness>_R)))) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Roundedness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness4
                   eta
                   @ b
                   eta1) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
                   PhonemeType2.$fReadRoundedness9
                   PhonemeType2.$fReadRoundedness5) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
                   PhonemeType2.$fReadRoundedness6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Roundedness))) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadRoundedness8,
                  PhonemeType2.$fReadRoundedness7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Roundedness>_R))))) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.UNROUNDED) -}
125442bb0b38585afb7fc6d85f9a67e1
  $fReadRoundedness8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UNROUNDED"#) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadRoundedness11,
                  PhonemeType2.$fReadRoundedness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Roundedness>_R))))) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadRoundedness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Roundedness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Roundedness]>_R))) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadRoundedness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Roundedness>_R)) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness_$creadPrec
                   eta) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fReadRoundedness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Roundedness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Roundedness]
                   ((PhonemeType2.$fReadRoundedness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Roundedness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Roundedness]>_R)
                      @ [PhonemeType2.Roundedness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Roundedness]))) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice :: GHC.Read.Read PhonemeType2.Voice
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Voice
                  PhonemeType2.$fReadVoice_$s$dmreadsPrec
                  PhonemeType2.$fReadVoice_$sreadListDefault
                  PhonemeType2.$fReadVoice_$creadPrec
                  PhonemeType2.$fReadVoice_$creadListPrec -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Voice] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Voice] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Voice
                   PhonemeType2.$fReadVoice2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Voice>_R))
                   @ b
                   eta1) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Voice -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.VOICELESS) -}
031b353ef93cd6e6a9a8589bb5158145
  $fReadVoice11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICELESS"#) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Voice
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Voice
                   PhonemeType2.$fReadVoice3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Voice>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Voice>_R)))) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Voice -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Voice
                   PhonemeType2.$fReadVoice4
                   eta
                   @ b
                   eta1) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Voice)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Voice)
                   PhonemeType2.$fReadVoice9
                   PhonemeType2.$fReadVoice5) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Voice)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Voice)
                   PhonemeType2.$fReadVoice6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Voice))) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Voice)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadVoice8,
                  PhonemeType2.$fReadVoice7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Voice>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Voice>_R))))) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Voice -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.VOICED) -}
3f05b885df04be6187487b22b3a314cb
  $fReadVoice8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICED"#) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Voice)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadVoice11,
                  PhonemeType2.$fReadVoice10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Voice>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Voice>_R))))) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Voice]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadVoice1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Voice]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Voice]>_R))) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Voice
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadVoice2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Voice>_R)) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Voice
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Voice
                   PhonemeType2.$fReadVoice_$creadPrec
                   eta) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fReadVoice_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Voice]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Voice]
                   ((PhonemeType2.$fReadVoice_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Voice]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Voice]>_R)
                      @ [PhonemeType2.Voice]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Voice]))) -}
2caa36e656e98f7ed18cd535a19498ef
  $fShowBackness :: GHC.Show.Show PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fShowBackness_$cshowsPrec
                  PhonemeType2.$fShowBackness_$cshow
                  PhonemeType2.$fShowBackness_$cshowList -}
2caa36e656e98f7ed18cd535a19498ef
  $fShowBackness_$cshow :: PhonemeType2.Backness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Backness ->
                 PhonemeType2.$fShowBackness_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2caa36e656e98f7ed18cd535a19498ef
  $fShowBackness_$cshowList ::
    [PhonemeType2.Backness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Backness
                   PhonemeType2.$w$cshowsPrec) -}
2caa36e656e98f7ed18cd535a19498ef
  $fShowBackness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Backness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Backness
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec w1 w2) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fShowHeight :: GHC.Show.Show PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fShowHeight_$cshowsPrec
                  PhonemeType2.$fShowHeight_$cshow
                  PhonemeType2.$fShowHeight_$cshowList -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fShowHeight_$cshow :: PhonemeType2.Height -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Height ->
                 PhonemeType2.$fShowHeight_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fShowHeight_$cshowList :: [PhonemeType2.Height] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Height
                   PhonemeType2.$w$cshowsPrec1) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $fShowHeight_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Height -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Height
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec1 w1 w2) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fShowManner :: GHC.Show.Show PhonemeType2.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fShowManner_$cshowsPrec
                  PhonemeType2.$fShowManner_$cshow
                  PhonemeType2.$fShowManner_$cshowList -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fShowManner_$cshow :: PhonemeType2.Manner -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Manner ->
                 PhonemeType2.$fShowManner_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fShowManner_$cshowList :: [PhonemeType2.Manner] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Manner
                   PhonemeType2.$w$cshowsPrec2) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $fShowManner_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Manner -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Manner
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec2 w1 w2) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fShowPhoneme :: GHC.Show.Show PhonemeType2.Phoneme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phoneme
                  PhonemeType2.$fShowPhoneme_$cshowsPrec
                  PhonemeType2.$fShowPhoneme_$cshow
                  PhonemeType2.$fShowPhoneme_$cshowList -}
3abb4073c17ef07e2eb6d2446d16852f
  $fShowPhoneme1 :: PhonemeType2.Phoneme -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (PhonemeType2.$fShowPhoneme_$cshowsPrec
                   PhonemeType2.$fShowPhoneme2) -}
d2f304ea7150fb06c61ac0f8213339bc
  $fShowPhoneme2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
8927f4cd51fe892095db657b7e6f52e6
  $fShowPhonemeInventory ::
    GHC.Show.Show PhonemeType2.PhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.PhonemeInventory
                  PhonemeType2.$fShowPhonemeInventory_$cshowsPrec
                  PhonemeType2.$fShowPhonemeInventory_$cshow
                  PhonemeType2.$fShowPhonemeInventory_$cshowList -}
8927f4cd51fe892095db657b7e6f52e6
  $fShowPhonemeInventory1 ::
    PhonemeType2.PhonemeInventory -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.PhonemeInventory
                   w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.PhonemeInventory ww1 ->
                 PhonemeType2.$w$cshowsPrec3 0 ww1 w1 }) -}
2b3e3ecbc5f3745b0bb15a4f1a55e40b
  $fShowPhonemeInventory2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PhonemeInventory "#) -}
8927f4cd51fe892095db657b7e6f52e6
  $fShowPhonemeInventory_$cshow ::
    PhonemeType2.PhonemeInventory -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.PhonemeInventory ->
                 PhonemeType2.$fShowPhonemeInventory_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8927f4cd51fe892095db657b7e6f52e6
  $fShowPhonemeInventory_$cshowList ::
    [PhonemeType2.PhonemeInventory] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.PhonemeInventory
                   PhonemeType2.$fShowPhonemeInventory1) -}
8927f4cd51fe892095db657b7e6f52e6
  $fShowPhonemeInventory_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.PhonemeInventory -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.PhonemeInventory
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.PhonemeInventory ww3 ->
                 PhonemeType2.$w$cshowsPrec3 ww1 ww3 w2 } }) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fShowPhoneme_$cshow :: PhonemeType2.Phoneme -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Phoneme ->
                 PhonemeType2.$fShowPhoneme_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fShowPhoneme_$cshowList ::
    [PhonemeType2.Phoneme] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fShowPhoneme1) -}
3abb4073c17ef07e2eb6d2446d16852f
  $fShowPhoneme_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Phoneme -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fShowPlace :: GHC.Show.Show PhonemeType2.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fShowPlace_$cshowsPrec
                  PhonemeType2.$fShowPlace_$cshow
                  PhonemeType2.$fShowPlace_$cshowList -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fShowPlace_$cshow :: PhonemeType2.Place -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Place ->
                 PhonemeType2.$fShowPlace_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fShowPlace_$cshowList :: [PhonemeType2.Place] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Place
                   PhonemeType2.$w$cshowsPrec4) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $fShowPlace_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Place -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Place
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec4 w1 w2) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fShowRoundedness :: GHC.Show.Show PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fShowRoundedness_$cshowsPrec
                  PhonemeType2.$fShowRoundedness_$cshow
                  PhonemeType2.$fShowRoundedness_$cshowList -}
658976e686ad777c4bb2ae2c8073a4d9
  $fShowRoundedness1 :: PhonemeType2.Roundedness -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Roundedness eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.ROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType2.$fReadRoundedness11)
                        eta
                   PhonemeType2.UNROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType2.$fReadRoundedness8)
                        eta }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fShowRoundedness_$cshow ::
    PhonemeType2.Roundedness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Roundedness ->
                 case x of wild {
                   PhonemeType2.ROUNDED -> PhonemeType2.$fReadRoundedness11
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fReadRoundedness8 }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fShowRoundedness_$cshowList ::
    [PhonemeType2.Roundedness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fShowRoundedness1) -}
658976e686ad777c4bb2ae2c8073a4d9
  $fShowRoundedness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Roundedness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType2.Roundedness
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType2.ROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType2.$fReadRoundedness11)
                        eta
                   PhonemeType2.UNROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType2.$fReadRoundedness8)
                        eta }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fShowVoice :: GHC.Show.Show PhonemeType2.Voice
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Voice
                  PhonemeType2.$fShowVoice_$cshowsPrec
                  PhonemeType2.$fShowVoice_$cshow
                  PhonemeType2.$fShowVoice_$cshowList -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fShowVoice1 :: PhonemeType2.Voice -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Voice eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType2.VOICELESS
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType2.$fReadVoice11)
                        eta
                   PhonemeType2.VOICED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c2 n PhonemeType2.$fReadVoice8)
                        eta }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fShowVoice_$cshow :: PhonemeType2.Voice -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Voice ->
                 case x of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.$fReadVoice11
                   PhonemeType2.VOICED -> PhonemeType2.$fReadVoice8 }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fShowVoice_$cshowList :: [PhonemeType2.Voice] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Voice
                   PhonemeType2.$fShowVoice1) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $fShowVoice_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Voice -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType2.Voice
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType2.VOICELESS
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType2.$fReadVoice11)
                        eta
                   PhonemeType2.VOICED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c2 n PhonemeType2.$fReadVoice8)
                        eta }) -}
2caa36e656e98f7ed18cd535a19498ef
  $w$cshowsPrec ::
    PhonemeType2.Backness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Backness w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.BACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness23 w1
                   PhonemeType2.NEARBACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness20 w1
                   PhonemeType2.CENTRAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness17 w1
                   PhonemeType2.NEARFRONT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness14 w1
                   PhonemeType2.FRONT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadBackness11
                        w1 }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $w$cshowsPrec1 ::
    PhonemeType2.Height -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Height w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.CLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight31 w1
                   PhonemeType2.NEARCLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight28 w1
                   PhonemeType2.CLOSEMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight25 w1
                   PhonemeType2.MID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight22 w1
                   PhonemeType2.OPENMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight19 w1
                   PhonemeType2.NEAROPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight16 w1
                   PhonemeType2.OPEN
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadHeight13
                        w1 }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $w$cshowsPrec2 ::
    PhonemeType2.Manner -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Manner w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NASAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner47 w1
                   PhonemeType2.STOP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner44 w1
                   PhonemeType2.AFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner41 w1
                   PhonemeType2.FRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner38 w1
                   PhonemeType2.APPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner35 w1
                   PhonemeType2.FLAP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner32 w1
                   PhonemeType2.TRILL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner29 w1
                   PhonemeType2.LAFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner26 w1
                   PhonemeType2.LFRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner23 w1
                   PhonemeType2.LAPPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner20 w1
                   PhonemeType2.LFLAP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadManner17
                        w1 }) -}
a76365aa45eec21a8bdc325ad04043b9
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> [PhonemeType2.Phoneme] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeType2.Phoneme]
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fShowPhonemeInventory2
                        (GHC.Show.showList__
                           @ PhonemeType2.Phoneme
                           PhonemeType2.$fShowPhoneme1
                           ww1
                           w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType2.$fShowPhonemeInventory2
                           (GHC.Show.showList__
                              @ PhonemeType2.Phoneme
                              PhonemeType2.$fShowPhoneme1
                              ww1
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $w$cshowsPrec4 ::
    PhonemeType2.Place -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Place w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.LABIAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace75 w1
                   PhonemeType2.BILABIAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace72 w1
                   PhonemeType2.LABIODENTAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace69 w1
                   PhonemeType2.DENTIALVEOLAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace66 w1
                   PhonemeType2.DENTAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace63 w1
                   PhonemeType2.ALVEOLAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace60 w1
                   PhonemeType2.POSTALVEOLAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace57 w1
                   PhonemeType2.RETROFLEX
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace54 w1
                   PhonemeType2.DORSAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace51 w1
                   PhonemeType2.ALVEOLOPALATAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace48 w1
                   PhonemeType2.PALATAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace45 w1
                   PhonemeType2.VELAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace42 w1
                   PhonemeType2.UVULAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace39 w1
                   PhonemeType2.LARYNGEAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace36 w1
                   PhonemeType2.EPIPHARYNGEAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace33 w1
                   PhonemeType2.PHARYNGEAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace30 w1
                   PhonemeType2.EPIGLOTTAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace27 w1
                   PhonemeType2.GLOTTAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPlace24 w1 }) -}
2caa36e656e98f7ed18cd535a19498ef
  $w$ctoEnum :: GHC.Prim.Int# -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumBackness6 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 4) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumBackness6 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Backness ww } }) -}
6f5dfa392900caa9cd7f86cdd4d5b2b4
  $w$ctoEnum1 :: GHC.Prim.Int# -> PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumHeight8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumHeight8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Height ww } }) -}
3ecc0ac841e5712e8e83ad55cfdad3ab
  $w$ctoEnum2 :: GHC.Prim.Int# -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumManner1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 10) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumManner1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Manner ww } }) -}
ba073b2e278b834da5cabaa9d37f0e1a
  $w$ctoEnum3 :: GHC.Prim.Int# -> PhonemeType2.Place
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumPlace1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 17) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumPlace1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Place ww } }) -}
658976e686ad777c4bb2ae2c8073a4d9
  $w$ctoEnum4 :: GHC.Prim.Int# -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumRoundedness1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumRoundedness1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Roundedness ww } }) -}
d6ac4c3656cd4f523eb0aeca95eb04af
  $w$ctoEnum5 :: GHC.Prim.Int# -> PhonemeType2.Voice
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumVoice1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumVoice1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Voice ww } }) -}
8927f4cd51fe892095db657b7e6f52e6
  $wa ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.PhonemeInventory -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType2.PhonemeInventory
                        -> Text.ParserCombinators.ReadP.P b ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                   GHC.Types.True
                   -> let {
                        lvl82 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl83 :: Text.ParserCombinators.ReadP.P b
                            = GHC.Read.$wa
                                @ PhonemeType2.Phoneme
                                PhonemeType2.$fReadPhoneme2
                                  `cast`
                                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                          <PhonemeType2.Phoneme>_R))
                                @ b
                                (\ a7 :: [PhonemeType2.Phoneme] ->
                                 w (PhonemeType2.PhonemeInventory a7))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a7
                               -> case GHC.Base.eqString
                                         a7
                                         PhonemeType2.$fReadPhonemeInventory4 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl83 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl82) -}
                        = \ w2 :: () -> lvl82
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ a98 :: GHC.Base.String ->
                         (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                           `cast`
                         (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                           @ b
                           k) }) -}
2caa36e656e98f7ed18cd535a19498ef
  data Backness = BACK | NEARBACK | CENTRAL | NEARFRONT | FRONT
    Promotable
6f5dfa392900caa9cd7f86cdd4d5b2b4
  data Height
    = CLOSE | NEARCLOSE | CLOSEMID | MID | OPENMID | NEAROPEN | OPEN
    Promotable
3ecc0ac841e5712e8e83ad55cfdad3ab
  data Manner
    = NASAL
    | STOP
    | AFFRICATE
    | FRICATIVE
    | APPROXIMANT
    | FLAP
    | TRILL
    | LAFFRICATE
    | LFRICATIVE
    | LAPPROXIMANT
    | LFLAP
    Promotable
3abb4073c17ef07e2eb6d2446d16852f
  data Phoneme
    = Consonant {place :: PhonemeType2.Place,
                 manner :: PhonemeType2.Manner,
                 voice :: PhonemeType2.Voice,
                 csymbol :: GHC.Base.String}
    | Vowel {height :: PhonemeType2.Height,
             backness :: PhonemeType2.Backness,
             roundedness :: PhonemeType2.Roundedness,
             vsymbol :: GHC.Base.String}
    | Diphthong {height1 :: PhonemeType2.Height,
                 backness1 :: PhonemeType2.Backness,
                 roundedness1 :: PhonemeType2.Roundedness,
                 vsymbol1 :: GHC.Base.String,
                 height2 :: PhonemeType2.Height,
                 backness2 :: PhonemeType2.Backness,
                 roundedness2 :: PhonemeType2.Roundedness,
                 vsymbol2 :: GHC.Base.String}
    | Blank
8927f4cd51fe892095db657b7e6f52e6
  data PhonemeInventory = PhonemeInventory [PhonemeType2.Phoneme]
ba073b2e278b834da5cabaa9d37f0e1a
  data Place
    = LABIAL
    | BILABIAL
    | LABIODENTAL
    | DENTIALVEOLAR
    | DENTAL
    | ALVEOLAR
    | POSTALVEOLAR
    | RETROFLEX
    | DORSAL
    | ALVEOLOPALATAL
    | PALATAL
    | VELAR
    | UVULAR
    | LARYNGEAL
    | EPIPHARYNGEAL
    | PHARYNGEAL
    | EPIGLOTTAL
    | GLOTTAL
    Promotable
658976e686ad777c4bb2ae2c8073a4d9
  data Roundedness = ROUNDED | UNROUNDED
    Promotable
d6ac4c3656cd4f523eb0aeca95eb04af
  data Voice = VOICELESS | VOICED
    Promotable
cdf767fbc53f1e9cfa12293500eb40d2
  backness :: PhonemeType2.Phoneme -> PhonemeType2.Backness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.backness4
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 -> ds2 }) -}
0f79276c9e7bc9240a7c24bf5152ce5a
  backness1 :: PhonemeType2.Phoneme -> PhonemeType2.Backness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.backness5
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds2 }) -}
092b9c85b83a2a78f810ce3626bc533f
  backness2 :: PhonemeType2.Phoneme -> PhonemeType2.Backness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.backness6
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds6 }) -}
33d39343e32da3e8776a380a96e7fab1
  backness4 :: PhonemeType2.Backness
  {- Strictness: b -}
23eb00b9bef26a06fcf2dec05834a2cd
  backness5 :: PhonemeType2.Backness
  {- Strictness: b -}
f57d505d722ee63d11eb1b135ecb2387
  backness6 :: PhonemeType2.Backness
  {- Strictness: b -}
ec64622ce26a5e11cb86ae7458cf8399
  csymbol :: PhonemeType2.Phoneme -> GHC.Base.String
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.csymbol1
                   PhonemeType2.Consonant ds1 ds2 ds3 ds4 -> ds4 }) -}
220a8c5de8785be4c8e71ab151b9c271
  csymbol1 :: GHC.Base.String
  {- Strictness: b -}
366a13e7f23c7aad0336dcae2255134a
  height :: PhonemeType2.Phoneme -> PhonemeType2.Height
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.height4
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 -> ds1 }) -}
b82b35df591291e98596f98b29fb46ea
  height1 :: PhonemeType2.Phoneme -> PhonemeType2.Height
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.height5
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds1 }) -}
53aba8d93639393323eb982e50a5d35e
  height2 :: PhonemeType2.Phoneme -> PhonemeType2.Height
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.height6
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds5 }) -}
f73abf39c2066738332e11d220dc3b06
  height4 :: PhonemeType2.Height
  {- Strictness: b -}
4b909504a413f114bc4298ee48885ecd
  height5 :: PhonemeType2.Height
  {- Strictness: b -}
bbe33d79673b612507f4b1481397860d
  height6 :: PhonemeType2.Height
  {- Strictness: b -}
02f7ce6247e618afbd29f9dad29c7dd6
  manner :: PhonemeType2.Phoneme -> PhonemeType2.Manner
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.manner1
                   PhonemeType2.Consonant ds1 ds2 ds3 ds4 -> ds2 }) -}
996089bdf2696b2ca7c6fb20d15c2937
  manner1 :: PhonemeType2.Manner
  {- Strictness: b -}
8d658c2b83d84d3d6a3dfbf6f77f5a55
  place :: PhonemeType2.Phoneme -> PhonemeType2.Place
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.place1
                   PhonemeType2.Consonant ds1 ds2 ds3 ds4 -> ds1 }) -}
4bb25a67e6ddd88e86ea49fd4e0eada9
  place1 :: PhonemeType2.Place
  {- Strictness: b -}
c99c482e97bd9cb7e12b818213716849
  roundedness :: PhonemeType2.Phoneme -> PhonemeType2.Roundedness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.roundedness4
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 -> ds3 }) -}
8939712a48c4a30aaf5a2447e370362f
  roundedness1 :: PhonemeType2.Phoneme -> PhonemeType2.Roundedness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.roundedness5
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds3 }) -}
d6b55d9e2e50f89f6559044ef53b5d32
  roundedness2 :: PhonemeType2.Phoneme -> PhonemeType2.Roundedness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.roundedness6
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds7 }) -}
0a5d7dc594b84b0bf1471e55ade70a08
  roundedness4 :: PhonemeType2.Roundedness
  {- Strictness: b -}
5bdad9b00820978c54c472bd210bf6d3
  roundedness5 :: PhonemeType2.Roundedness
  {- Strictness: b -}
3826365410d1034d61074da8854db271
  roundedness6 :: PhonemeType2.Roundedness
  {- Strictness: b -}
d346cef6f5bf42a1643e1479aa72c3d1
  voice :: PhonemeType2.Phoneme -> PhonemeType2.Voice
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.voice1
                   PhonemeType2.Consonant ds1 ds2 ds3 ds4 -> ds3 }) -}
849dbd02d490112ac2961a0c54872c44
  voice1 :: PhonemeType2.Voice
  {- Strictness: b -}
f33a9bb47e9919c1889ad4530f4933f3
  vsymbol :: PhonemeType2.Phoneme -> GHC.Base.String
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.vsymbol4
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 -> ds4 }) -}
64da8ed1fb7bc6ecc4e9e1c771940572
  vsymbol1 :: PhonemeType2.Phoneme -> GHC.Base.String
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.vsymbol5
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds4 }) -}
307137e7156b6e74ac23d3b7e5b82060
  vsymbol2 :: PhonemeType2.Phoneme -> GHC.Base.String
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.vsymbol6
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 -> ds8 }) -}
d97ce7f335ab73e6fd577fee982a4f1e
  vsymbol4 :: GHC.Base.String
  {- Strictness: b -}
9ec4b8b701b92e1801001753e5477c0b
  vsymbol5 :: GHC.Base.String
  {- Strictness: b -}
b6e7f0a18e5fcdc23d27b7223cec8923
  vsymbol6 :: GHC.Base.String
  {- Strictness: b -}
instance GHC.Enum.Bounded [PhonemeType2.Backness]
  = PhonemeType2.$fBoundedBackness
instance GHC.Enum.Bounded [PhonemeType2.Height]
  = PhonemeType2.$fBoundedHeight
instance GHC.Enum.Bounded [PhonemeType2.Manner]
  = PhonemeType2.$fBoundedManner
instance GHC.Enum.Bounded [PhonemeType2.Place]
  = PhonemeType2.$fBoundedPlace
instance GHC.Enum.Bounded [PhonemeType2.Roundedness]
  = PhonemeType2.$fBoundedRoundedness
instance GHC.Enum.Bounded [PhonemeType2.Voice]
  = PhonemeType2.$fBoundedVoice
instance GHC.Enum.Enum [PhonemeType2.Backness]
  = PhonemeType2.$fEnumBackness
instance GHC.Enum.Enum [PhonemeType2.Height]
  = PhonemeType2.$fEnumHeight
instance GHC.Enum.Enum [PhonemeType2.Manner]
  = PhonemeType2.$fEnumManner
instance GHC.Enum.Enum [PhonemeType2.Place]
  = PhonemeType2.$fEnumPlace
instance GHC.Enum.Enum [PhonemeType2.Roundedness]
  = PhonemeType2.$fEnumRoundedness
instance GHC.Enum.Enum [PhonemeType2.Voice]
  = PhonemeType2.$fEnumVoice
instance GHC.Classes.Eq [PhonemeType2.Backness]
  = PhonemeType2.$fEqBackness
instance GHC.Classes.Eq [PhonemeType2.Height]
  = PhonemeType2.$fEqHeight
instance GHC.Classes.Eq [PhonemeType2.Manner]
  = PhonemeType2.$fEqManner
instance GHC.Classes.Eq [PhonemeType2.Phoneme]
  = PhonemeType2.$fEqPhoneme
instance GHC.Classes.Eq [PhonemeType2.PhonemeInventory]
  = PhonemeType2.$fEqPhonemeInventory
instance GHC.Classes.Eq [PhonemeType2.Place]
  = PhonemeType2.$fEqPlace
instance GHC.Classes.Eq [PhonemeType2.Roundedness]
  = PhonemeType2.$fEqRoundedness
instance GHC.Classes.Eq [PhonemeType2.Voice]
  = PhonemeType2.$fEqVoice
instance GHC.Classes.Ord [PhonemeType2.Backness]
  = PhonemeType2.$fOrdBackness
instance GHC.Classes.Ord [PhonemeType2.Height]
  = PhonemeType2.$fOrdHeight
instance GHC.Classes.Ord [PhonemeType2.Manner]
  = PhonemeType2.$fOrdManner
instance GHC.Classes.Ord [PhonemeType2.Phoneme]
  = PhonemeType2.$fOrdPhoneme
instance GHC.Classes.Ord [PhonemeType2.PhonemeInventory]
  = PhonemeType2.$fOrdPhonemeInventory
instance GHC.Classes.Ord [PhonemeType2.Place]
  = PhonemeType2.$fOrdPlace
instance GHC.Classes.Ord [PhonemeType2.Roundedness]
  = PhonemeType2.$fOrdRoundedness
instance GHC.Classes.Ord [PhonemeType2.Voice]
  = PhonemeType2.$fOrdVoice
instance GHC.Read.Read [PhonemeType2.Backness]
  = PhonemeType2.$fReadBackness
instance GHC.Read.Read [PhonemeType2.Height]
  = PhonemeType2.$fReadHeight
instance GHC.Read.Read [PhonemeType2.Manner]
  = PhonemeType2.$fReadManner
instance GHC.Read.Read [PhonemeType2.Phoneme]
  = PhonemeType2.$fReadPhoneme
instance GHC.Read.Read [PhonemeType2.PhonemeInventory]
  = PhonemeType2.$fReadPhonemeInventory
instance GHC.Read.Read [PhonemeType2.Place]
  = PhonemeType2.$fReadPlace
instance GHC.Read.Read [PhonemeType2.Roundedness]
  = PhonemeType2.$fReadRoundedness
instance GHC.Read.Read [PhonemeType2.Voice]
  = PhonemeType2.$fReadVoice
instance GHC.Show.Show [PhonemeType2.Backness]
  = PhonemeType2.$fShowBackness
instance GHC.Show.Show [PhonemeType2.Height]
  = PhonemeType2.$fShowHeight
instance GHC.Show.Show [PhonemeType2.Manner]
  = PhonemeType2.$fShowManner
instance GHC.Show.Show [PhonemeType2.Phoneme]
  = PhonemeType2.$fShowPhoneme
instance GHC.Show.Show [PhonemeType2.PhonemeInventory]
  = PhonemeType2.$fShowPhonemeInventory
instance GHC.Show.Show [PhonemeType2.Place]
  = PhonemeType2.$fShowPlace
instance GHC.Show.Show [PhonemeType2.Roundedness]
  = PhonemeType2.$fShowRoundedness
instance GHC.Show.Show [PhonemeType2.Voice]
  = PhonemeType2.$fShowVoice
"SPEC/PhonemeType2 $dmreadsPrec @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Backness
  GHC.Read.$dmreadsPrec @ PhonemeType2.Backness $dRead
  = PhonemeType2.$fReadBackness_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeType2.Height
  GHC.Read.$dmreadsPrec @ PhonemeType2.Height $dRead
  = PhonemeType2.$fReadHeight_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeType2.Manner
  GHC.Read.$dmreadsPrec @ PhonemeType2.Manner $dRead
  = PhonemeType2.$fReadManner_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Phoneme" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeType2.Phoneme
  GHC.Read.$dmreadsPrec @ PhonemeType2.Phoneme $dRead
  = PhonemeType2.$fReadPhoneme_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeType2.Place
  GHC.Read.$dmreadsPrec @ PhonemeType2.Place $dRead
  = PhonemeType2.$fReadPlace_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                           PhonemeType2.Roundedness
  GHC.Read.$dmreadsPrec @ PhonemeType2.Roundedness $dRead
  = PhonemeType2.$fReadRoundedness_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Voice" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeType2.Voice
  GHC.Read.$dmreadsPrec @ PhonemeType2.Voice $dRead
  = PhonemeType2.$fReadVoice_$s$dmreadsPrec
"SPEC/PhonemeType2 readListDefault @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                           PhonemeType2.Backness
  GHC.Read.readListDefault @ PhonemeType2.Backness $dRead
  = PhonemeType2.$fReadBackness_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Height
  GHC.Read.readListDefault @ PhonemeType2.Height $dRead
  = PhonemeType2.$fReadHeight_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Manner
  GHC.Read.readListDefault @ PhonemeType2.Manner $dRead
  = PhonemeType2.$fReadManner_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Phoneme" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          PhonemeType2.Phoneme
  GHC.Read.readListDefault @ PhonemeType2.Phoneme $dRead
  = PhonemeType2.$fReadPhoneme_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ PhonemeInventory" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                   PhonemeType2.PhonemeInventory
  GHC.Read.readListDefault @ PhonemeType2.PhonemeInventory $dRead
  = PhonemeType2.$fReadPhonemeInventory_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Place
  GHC.Read.readListDefault @ PhonemeType2.Place $dRead
  = PhonemeType2.$fReadPlace_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                              PhonemeType2.Roundedness
  GHC.Read.readListDefault @ PhonemeType2.Roundedness $dRead
  = PhonemeType2.$fReadRoundedness_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Voice" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Voice
  GHC.Read.readListDefault @ PhonemeType2.Voice $dRead
  = PhonemeType2.$fReadVoice_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

