
==================== FINAL INTERFACE ====================
2016-10-22 02:55:59.828631 UTC

interface conla_1eA9qWUPH9nBowcXqqaV8r:PhonemeType2 7103
  interface hash: 54bcd47982c5406b9c61271d38b5fae5
  ABI hash: 197339ce6b16abf97787f114b13340ff
  export-list hash: df9b2faa8257842f4b45d50bfdeb2c0c
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  PhonemeType2.Backness{PhonemeType2.BACK PhonemeType2.CENTRAL PhonemeType2.FRONT PhonemeType2.NEARBACK PhonemeType2.NEARFRONT}
  PhonemeType2.Height{PhonemeType2.CLOSE PhonemeType2.CLOSEMID PhonemeType2.MID PhonemeType2.NEARCLOSE PhonemeType2.NEAROPEN PhonemeType2.OPEN PhonemeType2.OPENMID}
  PhonemeType2.Length{PhonemeType2.LONG PhonemeType2.NORMAL PhonemeType2.SHORT}
  PhonemeType2.Manner{PhonemeType2.AFFRICATE PhonemeType2.APPROXIMANT PhonemeType2.FLAP PhonemeType2.FRICATIVE PhonemeType2.LAFFRICATE PhonemeType2.LAPPROXIMANT PhonemeType2.LFLAP PhonemeType2.LFRICATIVE PhonemeType2.NASAL PhonemeType2.SAFFRICATE PhonemeType2.SILIBANT PhonemeType2.STOP PhonemeType2.TRILL}
  PhonemeType2.Morpheme{PhonemeType2.Morpheme PhonemeType2.getPhonemes}
  PhonemeType2.Phonation{PhonemeType2.ASPIRATED PhonemeType2.BREATHY PhonemeType2.CREAKY PhonemeType2.MODAL PhonemeType2.SLACK PhonemeType2.STIFF PhonemeType2.VOICELESS}
  PhonemeType2.Phoneme{PhonemeType2.Blank PhonemeType2.Consonant PhonemeType2.Diphthong PhonemeType2.Vowel PhonemeType2.cmanner PhonemeType2.cplace PhonemeType2.csymbol PhonemeType2.cvoice PhonemeType2.dbackness1 PhonemeType2.dbackness2 PhonemeType2.dheight1 PhonemeType2.dheight2 PhonemeType2.dlength1 PhonemeType2.dlength2 PhonemeType2.droundedness1 PhonemeType2.droundedness2 PhonemeType2.dsymbol PhonemeType2.vbackness PhonemeType2.vheight PhonemeType2.vlength PhonemeType2.vroundedness PhonemeType2.vsymbol}
  PhonemeType2.Place{PhonemeType2.ALVEOLAR PhonemeType2.ALVEOLOPALATAL PhonemeType2.BILABIAL PhonemeType2.CORONAL PhonemeType2.DENTAL PhonemeType2.DENTIALVEOLAR PhonemeType2.DORSAL PhonemeType2.EPIGLOTTAL PhonemeType2.EPIPHARYNGEAL PhonemeType2.GLOTTAL PhonemeType2.LABIAL PhonemeType2.LABIODENTAL PhonemeType2.LARYNGEAL PhonemeType2.PALATAL PhonemeType2.PHARYNGEAL PhonemeType2.POSTALVEOLAR PhonemeType2.RETROFLEX PhonemeType2.UVULAR PhonemeType2.VELAR}
  PhonemeType2.Roundedness{PhonemeType2.DEFAULT PhonemeType2.ROUNDED PhonemeType2.UNROUNDED}
  PhonemeType2.Word{PhonemeType2.Word PhonemeType2.getMorphemes}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.ParserCombinators.ReadPrec 2590e0e0a57a86ac7c62727f4d868dd2
import  -/  base-4.8.2.0:Text.Read.Lex 724ca44ddd38ddc5f47a501d62736c26
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
ca97fc28a82e78e4c561f0291cfc5413
  $fBoundedBackness :: GHC.Enum.Bounded PhonemeType2.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness PhonemeType2.BACK PhonemeType2.FRONT -}
259830e3ec94d1ed981c032991c75e25
  $fBoundedHeight :: GHC.Enum.Bounded PhonemeType2.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height PhonemeType2.CLOSE PhonemeType2.OPEN -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fBoundedLength :: GHC.Enum.Bounded PhonemeType2.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length PhonemeType2.SHORT PhonemeType2.LONG -}
9412c45cd95f18b011a2b8e64ee99754
  $fBoundedManner :: GHC.Enum.Bounded PhonemeType2.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner PhonemeType2.NASAL PhonemeType2.LFLAP -}
784f1f65fce67f349dccdb2a747dd13a
  $fBoundedPhonation :: GHC.Enum.Bounded PhonemeType2.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.VOICELESS
                  PhonemeType2.ASPIRATED -}
f8e121d7060ad8a0878087af8ae85de9
  $fBoundedPlace :: GHC.Enum.Bounded PhonemeType2.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place PhonemeType2.LABIAL PhonemeType2.GLOTTAL -}
142ff138328e86990b904685ecd67f0e
  $fBoundedRoundedness :: GHC.Enum.Bounded PhonemeType2.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.DEFAULT
                  PhonemeType2.UNROUNDED -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness :: GHC.Enum.Enum PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fEnumBackness_$csucc
                  PhonemeType2.$fEnumBackness_$cpred
                  PhonemeType2.$fEnumBackness_$ctoEnum
                  PhonemeType2.$fEnumBackness_$cfromEnum
                  PhonemeType2.$fEnumBackness_$cenumFrom
                  PhonemeType2.$fEnumBackness_$cenumFromThen
                  PhonemeType2.$fEnumBackness_$cenumFromTo
                  PhonemeType2.$fEnumBackness_$cenumFromThenTo -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness1 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go5 4) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness2 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go6 3) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness3 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go7 2) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness4 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go8 1) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness5 :: [PhonemeType2.Backness]
  {- Unfolding: (PhonemeType2.$fEnumBackness_go9 0) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness6 :: GHC.Prim.Int# -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>b -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness7 :: PhonemeType2.Backness
  {- Strictness: b -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness8 :: PhonemeType2.Backness
  {- Strictness: b -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_$cenumFrom ::
    PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK -> PhonemeType2.$fEnumBackness5
                   PhonemeType2.NEARBACK -> PhonemeType2.$fEnumBackness4
                   PhonemeType2.CENTRAL -> PhonemeType2.$fEnumBackness3
                   PhonemeType2.NEARFRONT -> PhonemeType2.$fEnumBackness2
                   PhonemeType2.FRONT -> PhonemeType2.$fEnumBackness1 }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_$cenumFromThen ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Backness]
                                    PhonemeType2.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType2.Backness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Backness]
                                    PhonemeType2.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType2.Backness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 4 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.BACK -> $j1 0
                       PhonemeType2.NEARBACK -> $j1 1
                       PhonemeType2.CENTRAL -> $j1 2
                       PhonemeType2.NEARFRONT -> $j1 3
                       PhonemeType2.FRONT -> $j1 4 }
                 } in
                 case a8 of wild {
                   PhonemeType2.BACK -> $j 0
                   PhonemeType2.NEARBACK -> $j 1
                   PhonemeType2.CENTRAL -> $j 2
                   PhonemeType2.NEARFRONT -> $j 3
                   PhonemeType2.FRONT -> $j 4 }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_$cenumFromThenTo ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness
    -> PhonemeType2.Backness
    -> [PhonemeType2.Backness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_$cenumFromTo ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> [PhonemeType2.Backness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Backness
                   y :: PhonemeType2.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.BACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.NEARBACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.CENTRAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.NEARFRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness }
                       PhonemeType2.FRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumBackness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Backness } }
                 } in
                 case x of wild {
                   PhonemeType2.BACK -> $j 0
                   PhonemeType2.NEARBACK -> $j 1
                   PhonemeType2.CENTRAL -> $j 2
                   PhonemeType2.NEARFRONT -> $j 3
                   PhonemeType2.FRONT -> $j 4 }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_$cfromEnum :: PhonemeType2.Backness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.Backness ->
                 case w of wild {
                   PhonemeType2.BACK -> GHC.Types.I# 0
                   PhonemeType2.NEARBACK -> GHC.Types.I# 1
                   PhonemeType2.CENTRAL -> GHC.Types.I# 2
                   PhonemeType2.NEARFRONT -> GHC.Types.I# 3
                   PhonemeType2.FRONT -> GHC.Types.I# 4 }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_$cpred ::
    PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK -> PhonemeType2.$fEnumBackness7
                   PhonemeType2.NEARBACK -> PhonemeType2.BACK
                   PhonemeType2.CENTRAL -> PhonemeType2.NEARBACK
                   PhonemeType2.NEARFRONT -> PhonemeType2.CENTRAL
                   PhonemeType2.FRONT -> PhonemeType2.NEARFRONT }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_$csucc ::
    PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK -> PhonemeType2.NEARBACK
                   PhonemeType2.NEARBACK -> PhonemeType2.CENTRAL
                   PhonemeType2.CENTRAL -> PhonemeType2.NEARFRONT
                   PhonemeType2.NEARFRONT -> PhonemeType2.FRONT
                   PhonemeType2.FRONT -> PhonemeType2.$fEnumBackness8 }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum ww1 }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_c ::
    GHC.Types.Int -> [PhonemeType2.Backness] -> [PhonemeType2.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Backness] ->
                 GHC.Types.:
                   @ PhonemeType2.Backness
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Backness a8 })
                   ys) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go1 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go2 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go3 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go4 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go5 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go6 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go7 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go8 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEnumBackness_go9 :: GHC.Prim.Int# -> [PhonemeType2.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight :: GHC.Enum.Enum PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fEnumHeight_$csucc
                  PhonemeType2.$fEnumHeight_$cpred
                  PhonemeType2.$fEnumHeight_$ctoEnum
                  PhonemeType2.$fEnumHeight_$cfromEnum
                  PhonemeType2.$fEnumHeight_$cenumFrom
                  PhonemeType2.$fEnumHeight_$cenumFromThen
                  PhonemeType2.$fEnumHeight_$cenumFromTo
                  PhonemeType2.$fEnumHeight_$cenumFromThenTo -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight1 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go7 6) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight10 :: PhonemeType2.Height
  {- Strictness: b -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight2 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go8 5) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight3 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go9 4) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight4 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go10 3) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight5 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go11 2) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight6 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go12 1) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight7 :: [PhonemeType2.Height]
  {- Unfolding: (PhonemeType2.$fEnumHeight_go13 0) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight8 :: GHC.Prim.Int# -> PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>b -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight9 :: PhonemeType2.Height
  {- Strictness: b -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_$cenumFrom ::
    PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Height ->
                 case a8 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.$fEnumHeight7
                   PhonemeType2.NEARCLOSE -> PhonemeType2.$fEnumHeight6
                   PhonemeType2.CLOSEMID -> PhonemeType2.$fEnumHeight5
                   PhonemeType2.MID -> PhonemeType2.$fEnumHeight4
                   PhonemeType2.OPENMID -> PhonemeType2.$fEnumHeight3
                   PhonemeType2.NEAROPEN -> PhonemeType2.$fEnumHeight2
                   PhonemeType2.OPEN -> PhonemeType2.$fEnumHeight1 }) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_$cenumFromThen ::
    PhonemeType2.Height -> PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Height]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Height]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Height]
                                    PhonemeType2.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType2.Height)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Height]
                                    PhonemeType2.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType2.Height)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.CLOSE -> $j1 0
                       PhonemeType2.NEARCLOSE -> $j1 1
                       PhonemeType2.CLOSEMID -> $j1 2
                       PhonemeType2.MID -> $j1 3
                       PhonemeType2.OPENMID -> $j1 4
                       PhonemeType2.NEAROPEN -> $j1 5
                       PhonemeType2.OPEN -> $j1 6 }
                 } in
                 case a8 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_$cenumFromThenTo ::
    PhonemeType2.Height
    -> PhonemeType2.Height
    -> PhonemeType2.Height
    -> [PhonemeType2.Height]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_$cenumFromTo ::
    PhonemeType2.Height -> PhonemeType2.Height -> [PhonemeType2.Height]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Height y :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.CLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.NEARCLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.CLOSEMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.MID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.OPENMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.NEAROPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height }
                       PhonemeType2.OPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumHeight_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Height } }
                 } in
                 case x of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_$cfromEnum :: PhonemeType2.Height -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.Height ->
                 case w of wild {
                   PhonemeType2.CLOSE -> GHC.Types.I# 0
                   PhonemeType2.NEARCLOSE -> GHC.Types.I# 1
                   PhonemeType2.CLOSEMID -> GHC.Types.I# 2
                   PhonemeType2.MID -> GHC.Types.I# 3
                   PhonemeType2.OPENMID -> GHC.Types.I# 4
                   PhonemeType2.NEAROPEN -> GHC.Types.I# 5
                   PhonemeType2.OPEN -> GHC.Types.I# 6 }) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_$cpred :: PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Height ->
                 case a8 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.$fEnumHeight9
                   PhonemeType2.NEARCLOSE -> PhonemeType2.CLOSE
                   PhonemeType2.CLOSEMID -> PhonemeType2.NEARCLOSE
                   PhonemeType2.MID -> PhonemeType2.CLOSEMID
                   PhonemeType2.OPENMID -> PhonemeType2.MID
                   PhonemeType2.NEAROPEN -> PhonemeType2.OPENMID
                   PhonemeType2.OPEN -> PhonemeType2.NEAROPEN }) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_$csucc :: PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Height ->
                 case a8 of wild {
                   PhonemeType2.CLOSE -> PhonemeType2.NEARCLOSE
                   PhonemeType2.NEARCLOSE -> PhonemeType2.CLOSEMID
                   PhonemeType2.CLOSEMID -> PhonemeType2.MID
                   PhonemeType2.MID -> PhonemeType2.OPENMID
                   PhonemeType2.OPENMID -> PhonemeType2.NEAROPEN
                   PhonemeType2.NEAROPEN -> PhonemeType2.OPEN
                   PhonemeType2.OPEN -> PhonemeType2.$fEnumHeight10 }) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Height
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum1 ww1 }) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_c ::
    GHC.Types.Int -> [PhonemeType2.Height] -> [PhonemeType2.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Height] ->
                 GHC.Types.:
                   @ PhonemeType2.Height
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Height a8 })
                   ys) -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go1 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go10 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go11 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go12 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go13 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go2 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go3 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go4 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go5 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go6 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go7 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go8 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
259830e3ec94d1ed981c032991c75e25
  $fEnumHeight_go9 :: GHC.Prim.Int# -> [PhonemeType2.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength :: GHC.Enum.Enum PhonemeType2.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fEnumLength_$csucc
                  PhonemeType2.$fEnumLength_$cpred
                  PhonemeType2.$fEnumLength_$ctoEnum
                  PhonemeType2.$fEnumLength_$cfromEnum
                  PhonemeType2.$fEnumLength_$cenumFrom
                  PhonemeType2.$fEnumLength_$cenumFromThen
                  PhonemeType2.$fEnumLength_$cenumFromTo
                  PhonemeType2.$fEnumLength_$cenumFromThenTo -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength1 :: GHC.Prim.Int# -> PhonemeType2.Length
  {- Arity: 1, Strictness: <L,U>b -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength2 :: [PhonemeType2.Length]
  {- Unfolding: (PhonemeType2.$fEnumLength_go3 2) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength3 :: [PhonemeType2.Length]
  {- Unfolding: (PhonemeType2.$fEnumLength_go4 1) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength4 :: [PhonemeType2.Length]
  {- Unfolding: (PhonemeType2.$fEnumLength_go5 0) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength5 :: PhonemeType2.Length
  {- Strictness: b -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength6 :: PhonemeType2.Length
  {- Strictness: b -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_$cenumFrom ::
    PhonemeType2.Length -> [PhonemeType2.Length]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT -> PhonemeType2.$fEnumLength4
                   PhonemeType2.NORMAL -> PhonemeType2.$fEnumLength3
                   PhonemeType2.LONG -> PhonemeType2.$fEnumLength2 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_$cenumFromThen ::
    PhonemeType2.Length -> PhonemeType2.Length -> [PhonemeType2.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Length b :: PhonemeType2.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Length]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Length]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Length]
                                    PhonemeType2.$fEnumLength_c1
                                    (GHC.Types.[] @ PhonemeType2.Length)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Length]
                                    PhonemeType2.$fEnumLength_c1
                                    (GHC.Types.[] @ PhonemeType2.Length)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.SHORT -> $j1 0
                       PhonemeType2.NORMAL -> $j1 1
                       PhonemeType2.LONG -> $j1 2 }
                 } in
                 case a8 of wild {
                   PhonemeType2.SHORT -> $j 0
                   PhonemeType2.NORMAL -> $j 1
                   PhonemeType2.LONG -> $j 2 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_$cenumFromThenTo ::
    PhonemeType2.Length
    -> PhonemeType2.Length
    -> PhonemeType2.Length
    -> [PhonemeType2.Length]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Length
                   x2 :: PhonemeType2.Length
                   y :: PhonemeType2.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Length]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.SHORT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.NORMAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     1 }
                           PhonemeType2.LONG
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Length]
                                     PhonemeType2.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType2.Length)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.SHORT -> $j1 0
                       PhonemeType2.NORMAL -> $j1 1
                       PhonemeType2.LONG -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType2.SHORT -> $j 0
                   PhonemeType2.NORMAL -> $j 1
                   PhonemeType2.LONG -> $j 2 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_$cenumFromTo ::
    PhonemeType2.Length -> PhonemeType2.Length -> [PhonemeType2.Length]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Length y :: PhonemeType2.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.SHORT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumLength_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Length }
                       PhonemeType2.NORMAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumLength_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Length }
                       PhonemeType2.LONG
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumLength_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Length } }
                 } in
                 case x of wild {
                   PhonemeType2.SHORT -> $j 0
                   PhonemeType2.NORMAL -> $j 1
                   PhonemeType2.LONG -> $j 2 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_$cfromEnum :: PhonemeType2.Length -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT -> GHC.Types.I# 0
                   PhonemeType2.NORMAL -> GHC.Types.I# 1
                   PhonemeType2.LONG -> GHC.Types.I# 2 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_$cpred :: PhonemeType2.Length -> PhonemeType2.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT -> PhonemeType2.$fEnumLength5
                   PhonemeType2.NORMAL -> PhonemeType2.SHORT
                   PhonemeType2.LONG -> PhonemeType2.NORMAL }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_$csucc :: PhonemeType2.Length -> PhonemeType2.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT -> PhonemeType2.NORMAL
                   PhonemeType2.NORMAL -> PhonemeType2.LONG
                   PhonemeType2.LONG -> PhonemeType2.$fEnumLength6 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Length
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum2 ww1 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_c ::
    GHC.Types.Int -> [PhonemeType2.Length] -> [PhonemeType2.Length]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Length] ->
                 GHC.Types.:
                   @ PhonemeType2.Length
                   (PhonemeType2.$fEnumLength_$ctoEnum x)
                   ys) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_c1 ::
    GHC.Types.Int -> [PhonemeType2.Length] -> [PhonemeType2.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Length] ->
                 GHC.Types.:
                   @ PhonemeType2.Length
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Length a8 })
                   ys) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_go :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, Strictness: <L,U> -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_go1 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, Strictness: <L,U> -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_go2 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, Strictness: <L,U> -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_go3 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_go4 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEnumLength_go5 :: GHC.Prim.Int# -> [PhonemeType2.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner :: GHC.Enum.Enum PhonemeType2.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fEnumManner_$csucc
                  PhonemeType2.$fEnumManner_$cpred
                  PhonemeType2.$fEnumManner_$ctoEnum
                  PhonemeType2.$fEnumManner_$cfromEnum
                  PhonemeType2.$fEnumManner_$cenumFrom
                  PhonemeType2.$fEnumManner_$cenumFromThen
                  PhonemeType2.$fEnumManner_$cenumFromTo
                  PhonemeType2.$fEnumManner_$cenumFromThenTo -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner1 :: GHC.Prim.Int# -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <L,U>b -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner2 :: PhonemeType2.Manner
  {- Strictness: b -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner3 :: PhonemeType2.Manner
  {- Strictness: b -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_$cenumFrom ::
    PhonemeType2.Manner -> [PhonemeType2.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 12) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumManner_go x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Manner } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_$cenumFromThen ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> [PhonemeType2.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x1
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Manner]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeType2.Manner]
                            PhonemeType2.$fEnumManner_c1
                            (GHC.Types.[] @ PhonemeType2.Manner)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeType2.Manner]
                            PhonemeType2.$fEnumManner_c1
                            (GHC.Types.[] @ PhonemeType2.Manner)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 12 GHC.Types.True -> $j 0 } } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_$cenumFromThenTo ::
    PhonemeType2.Manner
    -> PhonemeType2.Manner
    -> PhonemeType2.Manner
    -> [PhonemeType2.Manner]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Manner
                   x2 :: PhonemeType2.Manner
                   y :: PhonemeType2.Manner ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeType2.Manner]
                        PhonemeType2.$fEnumManner_c
                        (GHC.Types.[] @ PhonemeType2.Manner)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.Manner x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeType2.Manner]
                        PhonemeType2.$fEnumManner_c
                        (GHC.Types.[] @ PhonemeType2.Manner)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.Manner x6) } } } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_$cenumFromTo ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> [PhonemeType2.Manner]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Manner y :: PhonemeType2.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go25 :: GHC.Prim.Int# -> [PhonemeType2.Manner]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeType2.Manner
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeType2.$fEnumManner1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 12) of wild2 {
                                    GHC.Types.False -> PhonemeType2.$fEnumManner1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeType2.Manner x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go25 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Manner })
                      } in
                      go25 x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Manner } } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_$cfromEnum :: PhonemeType2.Manner -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1) }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_$cpred :: PhonemeType2.Manner -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType2.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum#
                        @ PhonemeType2.Manner
                        (GHC.Prim.+# wild (-1))
                   0 -> PhonemeType2.$fEnumManner2 } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_$csucc :: PhonemeType2.Manner -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType2.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType2.Manner (GHC.Prim.+# wild 1)
                   12 -> PhonemeType2.$fEnumManner3 } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum3 ww1 }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_c ::
    GHC.Types.Int -> [PhonemeType2.Manner] -> [PhonemeType2.Manner]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Manner] ->
                 GHC.Types.:
                   @ PhonemeType2.Manner
                   (PhonemeType2.$fEnumManner_$ctoEnum x)
                   ys) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_c1 ::
    GHC.Types.Int -> [PhonemeType2.Manner] -> [PhonemeType2.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Manner] ->
                 GHC.Types.:
                   @ PhonemeType2.Manner
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Manner a8 })
                   ys) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEnumManner_go :: GHC.Prim.Int# -> [PhonemeType2.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation :: GHC.Enum.Enum PhonemeType2.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fEnumPhonation_$csucc
                  PhonemeType2.$fEnumPhonation_$cpred
                  PhonemeType2.$fEnumPhonation_$ctoEnum
                  PhonemeType2.$fEnumPhonation_$cfromEnum
                  PhonemeType2.$fEnumPhonation_$cenumFrom
                  PhonemeType2.$fEnumPhonation_$cenumFromThen
                  PhonemeType2.$fEnumPhonation_$cenumFromTo
                  PhonemeType2.$fEnumPhonation_$cenumFromThenTo -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation1 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go7 6) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation10 :: PhonemeType2.Phonation
  {- Strictness: b -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation2 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go8 5) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation3 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go9 4) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation4 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go10 3) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation5 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go11 2) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation6 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go12 1) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation7 :: [PhonemeType2.Phonation]
  {- Unfolding: (PhonemeType2.$fEnumPhonation_go13 0) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation8 :: GHC.Prim.Int# -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <L,U>b -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation9 :: PhonemeType2.Phonation
  {- Strictness: b -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_$cenumFrom ::
    PhonemeType2.Phonation -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Phonation ->
                 case a8 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.$fEnumPhonation7
                   PhonemeType2.BREATHY -> PhonemeType2.$fEnumPhonation6
                   PhonemeType2.SLACK -> PhonemeType2.$fEnumPhonation5
                   PhonemeType2.MODAL -> PhonemeType2.$fEnumPhonation4
                   PhonemeType2.STIFF -> PhonemeType2.$fEnumPhonation3
                   PhonemeType2.CREAKY -> PhonemeType2.$fEnumPhonation2
                   PhonemeType2.ASPIRATED -> PhonemeType2.$fEnumPhonation1 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_$cenumFromThen ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation -> [PhonemeType2.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Phonation]
                                    PhonemeType2.$fEnumPhonation_c
                                    (GHC.Types.[] @ PhonemeType2.Phonation)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Phonation]
                                    PhonemeType2.$fEnumPhonation_c
                                    (GHC.Types.[] @ PhonemeType2.Phonation)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.VOICELESS -> $j1 0
                       PhonemeType2.BREATHY -> $j1 1
                       PhonemeType2.SLACK -> $j1 2
                       PhonemeType2.MODAL -> $j1 3
                       PhonemeType2.STIFF -> $j1 4
                       PhonemeType2.CREAKY -> $j1 5
                       PhonemeType2.ASPIRATED -> $j1 6 }
                 } in
                 case a8 of wild {
                   PhonemeType2.VOICELESS -> $j 0
                   PhonemeType2.BREATHY -> $j 1
                   PhonemeType2.SLACK -> $j 2
                   PhonemeType2.MODAL -> $j 3
                   PhonemeType2.STIFF -> $j 4
                   PhonemeType2.CREAKY -> $j 5
                   PhonemeType2.ASPIRATED -> $j 6 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_$cenumFromThenTo ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation
    -> PhonemeType2.Phonation
    -> [PhonemeType2.Phonation]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_$cenumFromTo ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation -> [PhonemeType2.Phonation]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Phonation
                   y :: PhonemeType2.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.VOICELESS
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.BREATHY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.SLACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.MODAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.STIFF
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.CREAKY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation }
                       PhonemeType2.ASPIRATED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumPhonation_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Phonation } }
                 } in
                 case x of wild {
                   PhonemeType2.VOICELESS -> $j 0
                   PhonemeType2.BREATHY -> $j 1
                   PhonemeType2.SLACK -> $j 2
                   PhonemeType2.MODAL -> $j 3
                   PhonemeType2.STIFF -> $j 4
                   PhonemeType2.CREAKY -> $j 5
                   PhonemeType2.ASPIRATED -> $j 6 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_$cfromEnum ::
    PhonemeType2.Phonation -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType2.Phonation ->
                 case w of wild {
                   PhonemeType2.VOICELESS -> GHC.Types.I# 0
                   PhonemeType2.BREATHY -> GHC.Types.I# 1
                   PhonemeType2.SLACK -> GHC.Types.I# 2
                   PhonemeType2.MODAL -> GHC.Types.I# 3
                   PhonemeType2.STIFF -> GHC.Types.I# 4
                   PhonemeType2.CREAKY -> GHC.Types.I# 5
                   PhonemeType2.ASPIRATED -> GHC.Types.I# 6 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_$cpred ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Phonation ->
                 case a8 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.$fEnumPhonation9
                   PhonemeType2.BREATHY -> PhonemeType2.VOICELESS
                   PhonemeType2.SLACK -> PhonemeType2.BREATHY
                   PhonemeType2.MODAL -> PhonemeType2.SLACK
                   PhonemeType2.STIFF -> PhonemeType2.MODAL
                   PhonemeType2.CREAKY -> PhonemeType2.STIFF
                   PhonemeType2.ASPIRATED -> PhonemeType2.CREAKY }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_$csucc ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Phonation ->
                 case a8 of wild {
                   PhonemeType2.VOICELESS -> PhonemeType2.BREATHY
                   PhonemeType2.BREATHY -> PhonemeType2.SLACK
                   PhonemeType2.SLACK -> PhonemeType2.MODAL
                   PhonemeType2.MODAL -> PhonemeType2.STIFF
                   PhonemeType2.STIFF -> PhonemeType2.CREAKY
                   PhonemeType2.CREAKY -> PhonemeType2.ASPIRATED
                   PhonemeType2.ASPIRATED -> PhonemeType2.$fEnumPhonation10 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum4 ww1 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_c ::
    GHC.Types.Int
    -> [PhonemeType2.Phonation] -> [PhonemeType2.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Phonation] ->
                 GHC.Types.:
                   @ PhonemeType2.Phonation
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Phonation a8 })
                   ys) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go1 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go10 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go11 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go12 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go13 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go2 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go3 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go4 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go5 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go6 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go7 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go8 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
784f1f65fce67f349dccdb2a747dd13a
  $fEnumPhonation_go9 :: GHC.Prim.Int# -> [PhonemeType2.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace :: GHC.Enum.Enum PhonemeType2.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fEnumPlace_$csucc
                  PhonemeType2.$fEnumPlace_$cpred
                  PhonemeType2.$fEnumPlace_$ctoEnum
                  PhonemeType2.$fEnumPlace_$cfromEnum
                  PhonemeType2.$fEnumPlace_$cenumFrom
                  PhonemeType2.$fEnumPlace_$cenumFromThen
                  PhonemeType2.$fEnumPlace_$cenumFromTo
                  PhonemeType2.$fEnumPlace_$cenumFromThenTo -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace1 :: GHC.Prim.Int# -> PhonemeType2.Place
  {- Arity: 1, Strictness: <L,U>b -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace2 :: PhonemeType2.Place
  {- Strictness: b -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace3 :: PhonemeType2.Place
  {- Strictness: b -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_$cenumFrom ::
    PhonemeType2.Place -> [PhonemeType2.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 18) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumPlace_go x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Place } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_$cenumFromThen ::
    PhonemeType2.Place -> PhonemeType2.Place -> [PhonemeType2.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x1
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Place]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeType2.Place]
                            PhonemeType2.$fEnumPlace_c1
                            (GHC.Types.[] @ PhonemeType2.Place)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeType2.Place]
                            PhonemeType2.$fEnumPlace_c1
                            (GHC.Types.[] @ PhonemeType2.Place)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 18 GHC.Types.True -> $j 0 } } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_$cenumFromThenTo ::
    PhonemeType2.Place
    -> PhonemeType2.Place -> PhonemeType2.Place -> [PhonemeType2.Place]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Place
                   x2 :: PhonemeType2.Place
                   y :: PhonemeType2.Place ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeType2.Place]
                        PhonemeType2.$fEnumPlace_c
                        (GHC.Types.[] @ PhonemeType2.Place)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.Place x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeType2.Place]
                        PhonemeType2.$fEnumPlace_c
                        (GHC.Types.[] @ PhonemeType2.Place)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType2.Place x6) } } } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_$cenumFromTo ::
    PhonemeType2.Place -> PhonemeType2.Place -> [PhonemeType2.Place]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Place y :: PhonemeType2.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go25 :: GHC.Prim.Int# -> [PhonemeType2.Place]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeType2.Place
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeType2.$fEnumPlace1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 18) of wild2 {
                                    GHC.Types.False -> PhonemeType2.$fEnumPlace1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeType2.Place x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go25 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Place })
                      } in
                      go25 x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Place } } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_$cfromEnum :: PhonemeType2.Place -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ PhonemeType2.Place x1) }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_$cpred :: PhonemeType2.Place -> PhonemeType2.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType2.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType2.Place (GHC.Prim.+# wild (-1))
                   0 -> PhonemeType2.$fEnumPlace2 } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_$csucc :: PhonemeType2.Place -> PhonemeType2.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType2.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType2.Place (GHC.Prim.+# wild 1)
                   18 -> PhonemeType2.$fEnumPlace3 } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_$ctoEnum :: GHC.Types.Int -> PhonemeType2.Place
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum5 ww1 }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_c ::
    GHC.Types.Int -> [PhonemeType2.Place] -> [PhonemeType2.Place]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Place] ->
                 GHC.Types.:
                   @ PhonemeType2.Place
                   (PhonemeType2.$fEnumPlace_$ctoEnum x)
                   ys) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_c1 ::
    GHC.Types.Int -> [PhonemeType2.Place] -> [PhonemeType2.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Place] ->
                 GHC.Types.:
                   @ PhonemeType2.Place
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Place a8 })
                   ys) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEnumPlace_go :: GHC.Prim.Int# -> [PhonemeType2.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness :: GHC.Enum.Enum PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fEnumRoundedness_$csucc
                  PhonemeType2.$fEnumRoundedness_$cpred
                  PhonemeType2.$fEnumRoundedness_$ctoEnum
                  PhonemeType2.$fEnumRoundedness_$cfromEnum
                  PhonemeType2.$fEnumRoundedness_$cenumFrom
                  PhonemeType2.$fEnumRoundedness_$cenumFromThen
                  PhonemeType2.$fEnumRoundedness_$cenumFromTo
                  PhonemeType2.$fEnumRoundedness_$cenumFromThenTo -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness1 :: GHC.Prim.Int# -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>b -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness2 :: [PhonemeType2.Roundedness]
  {- Unfolding: (PhonemeType2.$fEnumRoundedness_go3 2) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness3 :: [PhonemeType2.Roundedness]
  {- Unfolding: (PhonemeType2.$fEnumRoundedness_go4 1) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness4 :: [PhonemeType2.Roundedness]
  {- Unfolding: (PhonemeType2.$fEnumRoundedness_go5 0) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness5 :: PhonemeType2.Roundedness
  {- Strictness: b -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness6 :: PhonemeType2.Roundedness
  {- Strictness: b -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_$cenumFrom ::
    PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT -> PhonemeType2.$fEnumRoundedness4
                   PhonemeType2.ROUNDED -> PhonemeType2.$fEnumRoundedness3
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fEnumRoundedness2 }) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_$cenumFromThen ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Roundedness
                   b :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType2.Roundedness]
                                    PhonemeType2.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType2.Roundedness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType2.Roundedness]
                                    PhonemeType2.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType2.Roundedness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType2.DEFAULT -> $j1 0
                       PhonemeType2.ROUNDED -> $j1 1
                       PhonemeType2.UNROUNDED -> $j1 2 }
                 } in
                 case a8 of wild {
                   PhonemeType2.DEFAULT -> $j 0
                   PhonemeType2.ROUNDED -> $j 1
                   PhonemeType2.UNROUNDED -> $j 2 }) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_$cenumFromThenTo ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness
    -> [PhonemeType2.Roundedness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType2.Roundedness
                   x2 :: PhonemeType2.Roundedness
                   y :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType2.DEFAULT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     0 }
                           PhonemeType2.ROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     1 }
                           PhonemeType2.UNROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType2.Roundedness]
                                     PhonemeType2.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType2.Roundedness)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType2.DEFAULT -> $j1 0
                       PhonemeType2.ROUNDED -> $j1 1
                       PhonemeType2.UNROUNDED -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType2.DEFAULT -> $j 0
                   PhonemeType2.ROUNDED -> $j 1
                   PhonemeType2.UNROUNDED -> $j 2 }) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_$cenumFromTo ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Roundedness
                   y :: PhonemeType2.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType2.DEFAULT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumRoundedness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Roundedness }
                       PhonemeType2.ROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumRoundedness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Roundedness }
                       PhonemeType2.UNROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType2.$fEnumRoundedness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType2.Roundedness } }
                 } in
                 case x of wild {
                   PhonemeType2.DEFAULT -> $j 0
                   PhonemeType2.ROUNDED -> $j 1
                   PhonemeType2.UNROUNDED -> $j 2 }) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_$cfromEnum ::
    PhonemeType2.Roundedness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT -> GHC.Types.I# 0
                   PhonemeType2.ROUNDED -> GHC.Types.I# 1
                   PhonemeType2.UNROUNDED -> GHC.Types.I# 2 }) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_$cpred ::
    PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT -> PhonemeType2.$fEnumRoundedness5
                   PhonemeType2.ROUNDED -> PhonemeType2.DEFAULT
                   PhonemeType2.UNROUNDED -> PhonemeType2.ROUNDED }) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_$csucc ::
    PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT -> PhonemeType2.ROUNDED
                   PhonemeType2.ROUNDED -> PhonemeType2.UNROUNDED
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fEnumRoundedness6 }) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_$ctoEnum ::
    GHC.Types.Int -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$w$ctoEnum6 ww1 }) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_c ::
    GHC.Types.Int
    -> [PhonemeType2.Roundedness] -> [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType2.Roundedness
                   (PhonemeType2.$fEnumRoundedness_$ctoEnum x)
                   ys) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_c1 ::
    GHC.Types.Int
    -> [PhonemeType2.Roundedness] -> [PhonemeType2.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType2.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType2.Roundedness
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType2.Roundedness a8 })
                   ys) -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_go :: GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_go1 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_go2 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_go3 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_go4 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
142ff138328e86990b904685ecd67f0e
  $fEnumRoundedness_go5 ::
    GHC.Prim.Int# -> [PhonemeType2.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEqBackness :: GHC.Classes.Eq PhonemeType2.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fEqBackness_$c==
                  PhonemeType2.$fEqBackness_$c/= -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEqBackness_$c/= ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.BACK -> GHC.Types.False }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARBACK -> GHC.Types.False }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.CENTRAL -> GHC.Types.False }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.False }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.False } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fEqBackness_$c== ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.Backness
                   ds1 :: PhonemeType2.Backness ->
                 case ds of wild {
                   PhonemeType2.BACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.BACK -> GHC.Types.True }
                   PhonemeType2.NEARBACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARBACK -> GHC.Types.True }
                   PhonemeType2.CENTRAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.CENTRAL -> GHC.Types.True }
                   PhonemeType2.NEARFRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.True }
                   PhonemeType2.FRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.True } }) -}
259830e3ec94d1ed981c032991c75e25
  $fEqHeight :: GHC.Classes.Eq PhonemeType2.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fEqHeight_$c==
                  PhonemeType2.$fEqHeight_$c/= -}
259830e3ec94d1ed981c032991c75e25
  $fEqHeight_$c/= ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 case a8 of wild {
                   PhonemeType2.CLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.CLOSE -> GHC.Types.False }
                   PhonemeType2.NEARCLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARCLOSE -> GHC.Types.False }
                   PhonemeType2.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.CLOSEMID -> GHC.Types.False }
                   PhonemeType2.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.MID -> GHC.Types.False }
                   PhonemeType2.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.OPENMID -> GHC.Types.False }
                   PhonemeType2.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEAROPEN -> GHC.Types.False }
                   PhonemeType2.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.OPEN -> GHC.Types.False } }) -}
259830e3ec94d1ed981c032991c75e25
  $fEqHeight_$c== ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.Height
                   ds1 :: PhonemeType2.Height ->
                 case ds of wild {
                   PhonemeType2.CLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.CLOSE -> GHC.Types.True }
                   PhonemeType2.NEARCLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARCLOSE -> GHC.Types.True }
                   PhonemeType2.CLOSEMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.CLOSEMID -> GHC.Types.True }
                   PhonemeType2.MID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.MID -> GHC.Types.True }
                   PhonemeType2.OPENMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.OPENMID -> GHC.Types.True }
                   PhonemeType2.NEAROPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEAROPEN -> GHC.Types.True }
                   PhonemeType2.OPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.OPEN -> GHC.Types.True } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEqLength :: GHC.Classes.Eq PhonemeType2.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fEqLength_$c==
                  PhonemeType2.$fEqLength_$c/= -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEqLength_$c/= ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Length b :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.SHORT -> GHC.Types.False }
                   PhonemeType2.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.NORMAL -> GHC.Types.False }
                   PhonemeType2.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.LONG -> GHC.Types.False } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fEqLength_$c== ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Length ds1 :: PhonemeType2.Length ->
                 case ds of wild {
                   PhonemeType2.SHORT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.SHORT -> GHC.Types.True }
                   PhonemeType2.NORMAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.NORMAL -> GHC.Types.True }
                   PhonemeType2.LONG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.LONG -> GHC.Types.True } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEqManner :: GHC.Classes.Eq PhonemeType2.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fEqManner_$c==
                  PhonemeType2.$fEqManner_$c/= -}
9412c45cd95f18b011a2b8e64ee99754
  $fEqManner_$c/= ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fEqManner_$c== ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fEqMorpheme :: GHC.Classes.Eq PhonemeType2.Morpheme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Morpheme
                  PhonemeType2.$fEqMorpheme_$c==
                  PhonemeType2.$fEqMorpheme_$c/= -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fEqMorpheme_$c/= ::
    PhonemeType2.Morpheme -> PhonemeType2.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Morpheme b :: PhonemeType2.Morpheme ->
                 case a8 of wild { PhonemeType2.Morpheme a9 ->
                 case b of wild1 { PhonemeType2.Morpheme b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeType2.Phoneme
                        PhonemeType2.$fEqPhoneme
                        a9
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fEqMorpheme_$c== ::
    PhonemeType2.Morpheme -> PhonemeType2.Morpheme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Morpheme ds1 :: PhonemeType2.Morpheme ->
                 case ds of wild { PhonemeType2.Morpheme a8 ->
                 case ds1 of wild1 { PhonemeType2.Morpheme b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fEqPhoneme
                   a8
                   b1 } }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEqPhonation :: GHC.Classes.Eq PhonemeType2.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fEqPhonation_$c==
                  PhonemeType2.$fEqPhonation_$c/= -}
784f1f65fce67f349dccdb2a747dd13a
  $fEqPhonation_$c/= ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 case a8 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.VOICELESS -> GHC.Types.False }
                   PhonemeType2.BREATHY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.BREATHY -> GHC.Types.False }
                   PhonemeType2.SLACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.SLACK -> GHC.Types.False }
                   PhonemeType2.MODAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.MODAL -> GHC.Types.False }
                   PhonemeType2.STIFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.STIFF -> GHC.Types.False }
                   PhonemeType2.CREAKY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.CREAKY -> GHC.Types.False }
                   PhonemeType2.ASPIRATED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.ASPIRATED -> GHC.Types.False } }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fEqPhonation_$c== ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType2.Phonation
                   ds1 :: PhonemeType2.Phonation ->
                 case ds of wild {
                   PhonemeType2.VOICELESS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.VOICELESS -> GHC.Types.True }
                   PhonemeType2.BREATHY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.BREATHY -> GHC.Types.True }
                   PhonemeType2.SLACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.SLACK -> GHC.Types.True }
                   PhonemeType2.MODAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.MODAL -> GHC.Types.True }
                   PhonemeType2.STIFF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.STIFF -> GHC.Types.True }
                   PhonemeType2.CREAKY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.CREAKY -> GHC.Types.True }
                   PhonemeType2.ASPIRATED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.ASPIRATED -> GHC.Types.True } }) -}
20569906d69b1b60892d82b112a7f488
  $fEqPhoneme :: GHC.Classes.Eq PhonemeType2.Phoneme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phoneme
                  PhonemeType2.$fEqPhoneme_$c==
                  PhonemeType2.$fEqPhoneme_$c/= -}
20569906d69b1b60892d82b112a7f488
  $fEqPhoneme_$c/= ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Phoneme b :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fEqPhoneme_$c== a8 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
20569906d69b1b60892d82b112a7f488
  $fEqPhoneme_$c== ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
f8e121d7060ad8a0878087af8ae85de9
  $fEqPlace :: GHC.Classes.Eq PhonemeType2.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fEqPlace_$c==
                  PhonemeType2.$fEqPlace_$c/= -}
f8e121d7060ad8a0878087af8ae85de9
  $fEqPlace_$c/= ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fEqPlace_$c== ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
142ff138328e86990b904685ecd67f0e
  $fEqRoundedness :: GHC.Classes.Eq PhonemeType2.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fEqRoundedness_$c==
                  PhonemeType2.$fEqRoundedness_$c/= -}
142ff138328e86990b904685ecd67f0e
  $fEqRoundedness_$c/= ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.DEFAULT -> GHC.Types.False }
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.ROUNDED -> GHC.Types.False }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.False } }) -}
142ff138328e86990b904685ecd67f0e
  $fEqRoundedness_$c== ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Roundedness
                   ds1 :: PhonemeType2.Roundedness ->
                 case ds of wild {
                   PhonemeType2.DEFAULT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.DEFAULT -> GHC.Types.True }
                   PhonemeType2.ROUNDED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.ROUNDED -> GHC.Types.True }
                   PhonemeType2.UNROUNDED
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.True } }) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fEqWord :: GHC.Classes.Eq PhonemeType2.Word
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Word
                  PhonemeType2.$fEqWord_$c==
                  PhonemeType2.$fEqWord_$c/= -}
f66ce21cdfbfcba844a4da9e51d16345
  $fEqWord_$c/= ::
    PhonemeType2.Word -> PhonemeType2.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Word b :: PhonemeType2.Word ->
                 case a8 of wild { PhonemeType2.Word a9 ->
                 case b of wild1 { PhonemeType2.Word b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeType2.Morpheme
                        PhonemeType2.$fEqMorpheme
                        a9
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fEqWord_$c== ::
    PhonemeType2.Word -> PhonemeType2.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType2.Word ds1 :: PhonemeType2.Word ->
                 case ds of wild { PhonemeType2.Word a8 ->
                 case ds1 of wild1 { PhonemeType2.Word b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ PhonemeType2.Morpheme
                   PhonemeType2.$fEqMorpheme
                   a8
                   b1 } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fOrdBackness :: GHC.Classes.Ord PhonemeType2.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fEqBackness
                  PhonemeType2.$fOrdBackness_$ccompare
                  PhonemeType2.$fOrdBackness_$c<
                  PhonemeType2.$fOrdBackness_$c<=
                  PhonemeType2.$fOrdBackness_$c>
                  PhonemeType2.$fOrdBackness_$c>=
                  PhonemeType2.$fOrdBackness_$cmax
                  PhonemeType2.$fOrdBackness_$cmin -}
ca97fc28a82e78e4c561f0291cfc5413
  $fOrdBackness_$c< ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.False
                        PhonemeType2.NEARBACK -> GHC.Types.True
                        PhonemeType2.CENTRAL -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.CENTRAL -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fOrdBackness_$c<= ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.False
                        PhonemeType2.NEARBACK -> GHC.Types.True
                        PhonemeType2.CENTRAL -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.CENTRAL -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.True }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.True } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fOrdBackness_$c> ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.True
                        PhonemeType2.NEARBACK -> GHC.Types.False
                        PhonemeType2.CENTRAL -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.CENTRAL -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.FRONT -> GHC.Types.False } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fOrdBackness_$c>= ::
    PhonemeType2.Backness -> PhonemeType2.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.True
                        PhonemeType2.NEARBACK -> GHC.Types.False
                        PhonemeType2.CENTRAL -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.CENTRAL -> GHC.Types.False
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.NEARFRONT -> GHC.Types.False
                        PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.FRONT -> GHC.Types.False }
                   PhonemeType2.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fOrdBackness_$ccompare ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Backness
                   b :: PhonemeType2.Backness ->
                 case a8 of wild {
                   PhonemeType2.BACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.EQ
                        PhonemeType2.NEARBACK -> GHC.Types.LT
                        PhonemeType2.CENTRAL -> GHC.Types.LT
                        PhonemeType2.NEARFRONT -> GHC.Types.LT
                        PhonemeType2.FRONT -> GHC.Types.LT }
                   PhonemeType2.NEARBACK
                   -> case b of wild1 {
                        PhonemeType2.BACK -> GHC.Types.GT
                        PhonemeType2.NEARBACK -> GHC.Types.EQ
                        PhonemeType2.CENTRAL -> GHC.Types.LT
                        PhonemeType2.NEARFRONT -> GHC.Types.LT
                        PhonemeType2.FRONT -> GHC.Types.LT }
                   PhonemeType2.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.CENTRAL -> GHC.Types.EQ
                        PhonemeType2.NEARFRONT -> GHC.Types.LT
                        PhonemeType2.FRONT -> GHC.Types.LT }
                   PhonemeType2.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.NEARFRONT -> GHC.Types.EQ
                        PhonemeType2.FRONT -> GHC.Types.LT }
                   PhonemeType2.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeType2.FRONT -> GHC.Types.EQ } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fOrdBackness_$cmax ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Backness
                   y :: PhonemeType2.Backness ->
                 case x of wild {
                   PhonemeType2.BACK -> y
                   PhonemeType2.NEARBACK
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType2.NEARBACK
                        PhonemeType2.CENTRAL -> PhonemeType2.CENTRAL
                        PhonemeType2.NEARFRONT -> PhonemeType2.NEARFRONT
                        PhonemeType2.FRONT -> PhonemeType2.FRONT }
                   PhonemeType2.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType2.CENTRAL
                        PhonemeType2.NEARFRONT -> PhonemeType2.NEARFRONT
                        PhonemeType2.FRONT -> PhonemeType2.FRONT }
                   PhonemeType2.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType2.NEARFRONT
                        PhonemeType2.FRONT -> PhonemeType2.FRONT }
                   PhonemeType2.FRONT
                   -> case y of wild1 { DEFAULT -> PhonemeType2.FRONT } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fOrdBackness_$cmin ::
    PhonemeType2.Backness
    -> PhonemeType2.Backness -> PhonemeType2.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType2.Backness
                   y :: PhonemeType2.Backness ->
                 case x of wild {
                   PhonemeType2.BACK
                   -> case y of wild1 { DEFAULT -> PhonemeType2.BACK }
                   PhonemeType2.NEARBACK
                   -> case y of wild1 {
                        PhonemeType2.BACK -> PhonemeType2.BACK
                        PhonemeType2.NEARBACK -> PhonemeType2.NEARBACK
                        PhonemeType2.CENTRAL -> PhonemeType2.NEARBACK
                        PhonemeType2.NEARFRONT -> PhonemeType2.NEARBACK
                        PhonemeType2.FRONT -> PhonemeType2.NEARBACK }
                   PhonemeType2.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        PhonemeType2.CENTRAL -> PhonemeType2.CENTRAL
                        PhonemeType2.NEARFRONT -> PhonemeType2.CENTRAL
                        PhonemeType2.FRONT -> PhonemeType2.CENTRAL }
                   PhonemeType2.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        PhonemeType2.NEARFRONT -> PhonemeType2.NEARFRONT
                        PhonemeType2.FRONT -> PhonemeType2.NEARFRONT }
                   PhonemeType2.FRONT -> y }) -}
259830e3ec94d1ed981c032991c75e25
  $fOrdHeight :: GHC.Classes.Ord PhonemeType2.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fEqHeight
                  PhonemeType2.$fOrdHeight_$ccompare
                  PhonemeType2.$fOrdHeight_$c<
                  PhonemeType2.$fOrdHeight_$c<=
                  PhonemeType2.$fOrdHeight_$c>
                  PhonemeType2.$fOrdHeight_$c>=
                  PhonemeType2.$fOrdHeight_$cmax
                  PhonemeType2.$fOrdHeight_$cmin -}
259830e3ec94d1ed981c032991c75e25
  $fOrdHeight_$c< ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0)
                       PhonemeType2.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1)
                       PhonemeType2.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2)
                       PhonemeType2.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3)
                       PhonemeType2.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4)
                       PhonemeType2.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5)
                       PhonemeType2.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
259830e3ec94d1ed981c032991c75e25
  $fOrdHeight_$c<= ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0)
                       PhonemeType2.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1)
                       PhonemeType2.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2)
                       PhonemeType2.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3)
                       PhonemeType2.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4)
                       PhonemeType2.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5)
                       PhonemeType2.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
259830e3ec94d1ed981c032991c75e25
  $fOrdHeight_$c> ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0)
                       PhonemeType2.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1)
                       PhonemeType2.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2)
                       PhonemeType2.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3)
                       PhonemeType2.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4)
                       PhonemeType2.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5)
                       PhonemeType2.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
259830e3ec94d1ed981c032991c75e25
  $fOrdHeight_$c>= ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0)
                       PhonemeType2.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1)
                       PhonemeType2.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2)
                       PhonemeType2.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3)
                       PhonemeType2.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4)
                       PhonemeType2.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5)
                       PhonemeType2.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType2.CLOSE -> $j 0
                   PhonemeType2.NEARCLOSE -> $j 1
                   PhonemeType2.CLOSEMID -> $j 2
                   PhonemeType2.MID -> $j 3
                   PhonemeType2.OPENMID -> $j 4
                   PhonemeType2.NEAROPEN -> $j 5
                   PhonemeType2.OPEN -> $j 6 }) -}
259830e3ec94d1ed981c032991c75e25
  $fOrdHeight_$ccompare ::
    PhonemeType2.Height -> PhonemeType2.Height -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Height b :: PhonemeType2.Height ->
                 case a8 of wild {
                   PhonemeType2.CLOSE
                   -> case b of wild1 {
                        PhonemeType2.CLOSE -> GHC.Types.EQ
                        PhonemeType2.NEARCLOSE -> GHC.Types.LT
                        PhonemeType2.CLOSEMID -> GHC.Types.LT
                        PhonemeType2.MID -> GHC.Types.LT
                        PhonemeType2.OPENMID -> GHC.Types.LT
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.NEARCLOSE
                   -> case b of wild1 {
                        PhonemeType2.CLOSE -> GHC.Types.GT
                        PhonemeType2.NEARCLOSE -> GHC.Types.EQ
                        PhonemeType2.CLOSEMID -> GHC.Types.LT
                        PhonemeType2.MID -> GHC.Types.LT
                        PhonemeType2.OPENMID -> GHC.Types.LT
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.CLOSEMID -> GHC.Types.EQ
                        PhonemeType2.MID -> GHC.Types.LT
                        PhonemeType2.OPENMID -> GHC.Types.LT
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.MID -> GHC.Types.EQ
                        PhonemeType2.OPENMID -> GHC.Types.LT
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.OPENMID -> GHC.Types.EQ
                        PhonemeType2.NEAROPEN -> GHC.Types.LT
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.NEAROPEN -> GHC.Types.EQ
                        PhonemeType2.OPEN -> GHC.Types.LT }
                   PhonemeType2.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeType2.OPEN -> GHC.Types.EQ } }) -}
259830e3ec94d1ed981c032991c75e25
  $fOrdHeight_$cmax ::
    PhonemeType2.Height -> PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Height y :: PhonemeType2.Height ->
                 case PhonemeType2.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
259830e3ec94d1ed981c032991c75e25
  $fOrdHeight_$cmin ::
    PhonemeType2.Height -> PhonemeType2.Height -> PhonemeType2.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Height y :: PhonemeType2.Height ->
                 case PhonemeType2.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fOrdLength :: GHC.Classes.Ord PhonemeType2.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fEqLength
                  PhonemeType2.$fOrdLength_$ccompare
                  PhonemeType2.$fOrdLength_$c<
                  PhonemeType2.$fOrdLength_$c<=
                  PhonemeType2.$fOrdLength_$c>
                  PhonemeType2.$fOrdLength_$c>=
                  PhonemeType2.$fOrdLength_$cmax
                  PhonemeType2.$fOrdLength_$cmin -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fOrdLength_$c< ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Length b :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT
                   -> case b of wild1 {
                        PhonemeType2.SHORT -> GHC.Types.False
                        PhonemeType2.NORMAL -> GHC.Types.True
                        PhonemeType2.LONG -> GHC.Types.True }
                   PhonemeType2.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType2.LONG -> GHC.Types.True }
                   PhonemeType2.LONG
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fOrdLength_$c<= ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Length b :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType2.NORMAL
                   -> case b of wild1 {
                        PhonemeType2.SHORT -> GHC.Types.False
                        PhonemeType2.NORMAL -> GHC.Types.True
                        PhonemeType2.LONG -> GHC.Types.True }
                   PhonemeType2.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.LONG -> GHC.Types.True } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fOrdLength_$c> ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Length b :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType2.NORMAL
                   -> case b of wild1 {
                        PhonemeType2.SHORT -> GHC.Types.True
                        PhonemeType2.NORMAL -> GHC.Types.False
                        PhonemeType2.LONG -> GHC.Types.False }
                   PhonemeType2.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.LONG -> GHC.Types.False } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fOrdLength_$c>= ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Length b :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT
                   -> case b of wild1 {
                        PhonemeType2.SHORT -> GHC.Types.True
                        PhonemeType2.NORMAL -> GHC.Types.False
                        PhonemeType2.LONG -> GHC.Types.False }
                   PhonemeType2.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType2.LONG -> GHC.Types.False }
                   PhonemeType2.LONG
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fOrdLength_$ccompare ::
    PhonemeType2.Length -> PhonemeType2.Length -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Length b :: PhonemeType2.Length ->
                 case a8 of wild {
                   PhonemeType2.SHORT
                   -> case b of wild1 {
                        PhonemeType2.SHORT -> GHC.Types.EQ
                        PhonemeType2.NORMAL -> GHC.Types.LT
                        PhonemeType2.LONG -> GHC.Types.LT }
                   PhonemeType2.NORMAL
                   -> case b of wild1 {
                        PhonemeType2.SHORT -> GHC.Types.GT
                        PhonemeType2.NORMAL -> GHC.Types.EQ
                        PhonemeType2.LONG -> GHC.Types.LT }
                   PhonemeType2.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeType2.LONG -> GHC.Types.EQ } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fOrdLength_$cmax ::
    PhonemeType2.Length -> PhonemeType2.Length -> PhonemeType2.Length
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Length y :: PhonemeType2.Length ->
                 case x of wild {
                   PhonemeType2.SHORT -> y
                   PhonemeType2.NORMAL
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType2.NORMAL
                        PhonemeType2.LONG -> PhonemeType2.LONG }
                   PhonemeType2.LONG
                   -> case y of wild1 { DEFAULT -> PhonemeType2.LONG } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fOrdLength_$cmin ::
    PhonemeType2.Length -> PhonemeType2.Length -> PhonemeType2.Length
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Length y :: PhonemeType2.Length ->
                 case x of wild {
                   PhonemeType2.SHORT
                   -> case y of wild1 { DEFAULT -> PhonemeType2.SHORT }
                   PhonemeType2.NORMAL
                   -> case y of wild1 {
                        PhonemeType2.SHORT -> PhonemeType2.SHORT
                        PhonemeType2.NORMAL -> PhonemeType2.NORMAL
                        PhonemeType2.LONG -> PhonemeType2.NORMAL }
                   PhonemeType2.LONG -> y }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fOrdManner :: GHC.Classes.Ord PhonemeType2.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fEqManner
                  PhonemeType2.$fOrdManner_$ccompare
                  PhonemeType2.$fOrdManner_$c<
                  PhonemeType2.$fOrdManner_$c<=
                  PhonemeType2.$fOrdManner_$c>
                  PhonemeType2.$fOrdManner_$c>=
                  PhonemeType2.$fOrdManner_$cmax
                  PhonemeType2.$fOrdManner_$cmin -}
9412c45cd95f18b011a2b8e64ee99754
  $fOrdManner_$c< ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fOrdManner_$c<= ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fOrdManner_$c> ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fOrdManner_$c>= ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fOrdManner_$ccompare ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Manner b :: PhonemeType2.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fOrdManner_$cmax ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> PhonemeType2.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Manner y :: PhonemeType2.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $fOrdManner_$cmin ::
    PhonemeType2.Manner -> PhonemeType2.Manner -> PhonemeType2.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Manner y :: PhonemeType2.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Manner x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fOrdPhonation :: GHC.Classes.Ord PhonemeType2.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fEqPhonation
                  PhonemeType2.$fOrdPhonation_$ccompare
                  PhonemeType2.$fOrdPhonation_$c<
                  PhonemeType2.$fOrdPhonation_$c<=
                  PhonemeType2.$fOrdPhonation_$c>
                  PhonemeType2.$fOrdPhonation_$c>=
                  PhonemeType2.$fOrdPhonation_$cmax
                  PhonemeType2.$fOrdPhonation_$cmin -}
784f1f65fce67f349dccdb2a747dd13a
  $fOrdPhonation_$c< ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0)
                       PhonemeType2.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1)
                       PhonemeType2.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2)
                       PhonemeType2.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3)
                       PhonemeType2.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4)
                       PhonemeType2.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5)
                       PhonemeType2.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType2.VOICELESS -> $j 0
                   PhonemeType2.BREATHY -> $j 1
                   PhonemeType2.SLACK -> $j 2
                   PhonemeType2.MODAL -> $j 3
                   PhonemeType2.STIFF -> $j 4
                   PhonemeType2.CREAKY -> $j 5
                   PhonemeType2.ASPIRATED -> $j 6 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fOrdPhonation_$c<= ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0)
                       PhonemeType2.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1)
                       PhonemeType2.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2)
                       PhonemeType2.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3)
                       PhonemeType2.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4)
                       PhonemeType2.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5)
                       PhonemeType2.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType2.VOICELESS -> $j 0
                   PhonemeType2.BREATHY -> $j 1
                   PhonemeType2.SLACK -> $j 2
                   PhonemeType2.MODAL -> $j 3
                   PhonemeType2.STIFF -> $j 4
                   PhonemeType2.CREAKY -> $j 5
                   PhonemeType2.ASPIRATED -> $j 6 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fOrdPhonation_$c> ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0)
                       PhonemeType2.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1)
                       PhonemeType2.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2)
                       PhonemeType2.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3)
                       PhonemeType2.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4)
                       PhonemeType2.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5)
                       PhonemeType2.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType2.VOICELESS -> $j 0
                   PhonemeType2.BREATHY -> $j 1
                   PhonemeType2.SLACK -> $j 2
                   PhonemeType2.MODAL -> $j 3
                   PhonemeType2.STIFF -> $j 4
                   PhonemeType2.CREAKY -> $j 5
                   PhonemeType2.ASPIRATED -> $j 6 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fOrdPhonation_$c>= ::
    PhonemeType2.Phonation -> PhonemeType2.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType2.VOICELESS
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0)
                       PhonemeType2.BREATHY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1)
                       PhonemeType2.SLACK
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2)
                       PhonemeType2.MODAL
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3)
                       PhonemeType2.STIFF
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4)
                       PhonemeType2.CREAKY
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5)
                       PhonemeType2.ASPIRATED
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType2.VOICELESS -> $j 0
                   PhonemeType2.BREATHY -> $j 1
                   PhonemeType2.SLACK -> $j 2
                   PhonemeType2.MODAL -> $j 3
                   PhonemeType2.STIFF -> $j 4
                   PhonemeType2.CREAKY -> $j 5
                   PhonemeType2.ASPIRATED -> $j 6 }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fOrdPhonation_$ccompare ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Phonation
                   b :: PhonemeType2.Phonation ->
                 case a8 of wild {
                   PhonemeType2.VOICELESS
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.EQ
                        PhonemeType2.BREATHY -> GHC.Types.LT
                        PhonemeType2.SLACK -> GHC.Types.LT
                        PhonemeType2.MODAL -> GHC.Types.LT
                        PhonemeType2.STIFF -> GHC.Types.LT
                        PhonemeType2.CREAKY -> GHC.Types.LT
                        PhonemeType2.ASPIRATED -> GHC.Types.LT }
                   PhonemeType2.BREATHY
                   -> case b of wild1 {
                        PhonemeType2.VOICELESS -> GHC.Types.GT
                        PhonemeType2.BREATHY -> GHC.Types.EQ
                        PhonemeType2.SLACK -> GHC.Types.LT
                        PhonemeType2.MODAL -> GHC.Types.LT
                        PhonemeType2.STIFF -> GHC.Types.LT
                        PhonemeType2.CREAKY -> GHC.Types.LT
                        PhonemeType2.ASPIRATED -> GHC.Types.LT }
                   PhonemeType2.SLACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.SLACK -> GHC.Types.EQ
                        PhonemeType2.MODAL -> GHC.Types.LT
                        PhonemeType2.STIFF -> GHC.Types.LT
                        PhonemeType2.CREAKY -> GHC.Types.LT
                        PhonemeType2.ASPIRATED -> GHC.Types.LT }
                   PhonemeType2.MODAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.MODAL -> GHC.Types.EQ
                        PhonemeType2.STIFF -> GHC.Types.LT
                        PhonemeType2.CREAKY -> GHC.Types.LT
                        PhonemeType2.ASPIRATED -> GHC.Types.LT }
                   PhonemeType2.STIFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.STIFF -> GHC.Types.EQ
                        PhonemeType2.CREAKY -> GHC.Types.LT
                        PhonemeType2.ASPIRATED -> GHC.Types.LT }
                   PhonemeType2.CREAKY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.CREAKY -> GHC.Types.EQ
                        PhonemeType2.ASPIRATED -> GHC.Types.LT }
                   PhonemeType2.ASPIRATED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.ASPIRATED -> GHC.Types.EQ } }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fOrdPhonation_$cmax ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation -> PhonemeType2.Phonation
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phonation y :: PhonemeType2.Phonation ->
                 case PhonemeType2.$fOrdPhonation_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fOrdPhonation_$cmin ::
    PhonemeType2.Phonation
    -> PhonemeType2.Phonation -> PhonemeType2.Phonation
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phonation y :: PhonemeType2.Phonation ->
                 case PhonemeType2.$fOrdPhonation_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
20569906d69b1b60892d82b112a7f488
  $fOrdPhoneme :: GHC.Classes.Ord PhonemeType2.Phoneme
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phoneme
                  PhonemeType2.$fEqPhoneme
                  PhonemeType2.$fOrdPhoneme_$ccompare
                  PhonemeType2.$fOrdPhoneme_$c<
                  PhonemeType2.$fOrdPhoneme_$c<=
                  PhonemeType2.$fOrdPhoneme_$c>
                  PhonemeType2.$fOrdPhoneme_$c>=
                  PhonemeType2.$fOrdPhoneme_$cmax
                  PhonemeType2.$fOrdPhoneme_$cmin -}
20569906d69b1b60892d82b112a7f488
  $fOrdPhoneme_$c< ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
20569906d69b1b60892d82b112a7f488
  $fOrdPhoneme_$c<= ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
20569906d69b1b60892d82b112a7f488
  $fOrdPhoneme_$c> ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
20569906d69b1b60892d82b112a7f488
  $fOrdPhoneme_$c>= ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
20569906d69b1b60892d82b112a7f488
  $fOrdPhoneme_$ccompare ::
    PhonemeType2.Phoneme -> PhonemeType2.Phoneme -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
20569906d69b1b60892d82b112a7f488
  $fOrdPhoneme_$cmax ::
    PhonemeType2.Phoneme
    -> PhonemeType2.Phoneme -> PhonemeType2.Phoneme
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
20569906d69b1b60892d82b112a7f488
  $fOrdPhoneme_$cmin ::
    PhonemeType2.Phoneme
    -> PhonemeType2.Phoneme -> PhonemeType2.Phoneme
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Phoneme y :: PhonemeType2.Phoneme ->
                 case PhonemeType2.$fOrdPhoneme_$ccompare x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fOrdPlace :: GHC.Classes.Ord PhonemeType2.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fEqPlace
                  PhonemeType2.$fOrdPlace_$ccompare
                  PhonemeType2.$fOrdPlace_$c<
                  PhonemeType2.$fOrdPlace_$c<=
                  PhonemeType2.$fOrdPlace_$c>
                  PhonemeType2.$fOrdPlace_$c>=
                  PhonemeType2.$fOrdPlace_$cmax
                  PhonemeType2.$fOrdPlace_$cmin -}
f8e121d7060ad8a0878087af8ae85de9
  $fOrdPlace_$c< ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fOrdPlace_$c<= ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fOrdPlace_$c> ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fOrdPlace_$c>= ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fOrdPlace_$ccompare ::
    PhonemeType2.Place -> PhonemeType2.Place -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Place b :: PhonemeType2.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType2.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fOrdPlace_$cmax ::
    PhonemeType2.Place -> PhonemeType2.Place -> PhonemeType2.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Place y :: PhonemeType2.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $fOrdPlace_$cmin ::
    PhonemeType2.Place -> PhonemeType2.Place -> PhonemeType2.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Place y :: PhonemeType2.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType2.Place x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
142ff138328e86990b904685ecd67f0e
  $fOrdRoundedness :: GHC.Classes.Ord PhonemeType2.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fEqRoundedness
                  PhonemeType2.$fOrdRoundedness_$ccompare
                  PhonemeType2.$fOrdRoundedness_$c<
                  PhonemeType2.$fOrdRoundedness_$c<=
                  PhonemeType2.$fOrdRoundedness_$c>
                  PhonemeType2.$fOrdRoundedness_$c>=
                  PhonemeType2.$fOrdRoundedness_$cmax
                  PhonemeType2.$fOrdRoundedness_$cmin -}
142ff138328e86990b904685ecd67f0e
  $fOrdRoundedness_$c< ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT
                   -> case b of wild1 {
                        PhonemeType2.DEFAULT -> GHC.Types.False
                        PhonemeType2.ROUNDED -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.True }
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.True }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
142ff138328e86990b904685ecd67f0e
  $fOrdRoundedness_$c<= ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT
                   -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        PhonemeType2.DEFAULT -> GHC.Types.False
                        PhonemeType2.ROUNDED -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.True }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.True } }) -}
142ff138328e86990b904685ecd67f0e
  $fOrdRoundedness_$c> ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        PhonemeType2.DEFAULT -> GHC.Types.True
                        PhonemeType2.ROUNDED -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.False }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.False } }) -}
142ff138328e86990b904685ecd67f0e
  $fOrdRoundedness_$c>= ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType2.Roundedness b :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT
                   -> case b of wild1 {
                        PhonemeType2.DEFAULT -> GHC.Types.True
                        PhonemeType2.ROUNDED -> GHC.Types.False
                        PhonemeType2.UNROUNDED -> GHC.Types.False }
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType2.UNROUNDED -> GHC.Types.False }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
142ff138328e86990b904685ecd67f0e
  $fOrdRoundedness_$ccompare ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType2.Roundedness
                   b :: PhonemeType2.Roundedness ->
                 case a8 of wild {
                   PhonemeType2.DEFAULT
                   -> case b of wild1 {
                        PhonemeType2.DEFAULT -> GHC.Types.EQ
                        PhonemeType2.ROUNDED -> GHC.Types.LT
                        PhonemeType2.UNROUNDED -> GHC.Types.LT }
                   PhonemeType2.ROUNDED
                   -> case b of wild1 {
                        PhonemeType2.DEFAULT -> GHC.Types.GT
                        PhonemeType2.ROUNDED -> GHC.Types.EQ
                        PhonemeType2.UNROUNDED -> GHC.Types.LT }
                   PhonemeType2.UNROUNDED
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType2.UNROUNDED -> GHC.Types.EQ } }) -}
142ff138328e86990b904685ecd67f0e
  $fOrdRoundedness_$cmax ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Roundedness y :: PhonemeType2.Roundedness ->
                 case x of wild {
                   PhonemeType2.DEFAULT -> y
                   PhonemeType2.ROUNDED
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType2.ROUNDED
                        PhonemeType2.UNROUNDED -> PhonemeType2.UNROUNDED }
                   PhonemeType2.UNROUNDED
                   -> case y of wild1 { DEFAULT -> PhonemeType2.UNROUNDED } }) -}
142ff138328e86990b904685ecd67f0e
  $fOrdRoundedness_$cmin ::
    PhonemeType2.Roundedness
    -> PhonemeType2.Roundedness -> PhonemeType2.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType2.Roundedness y :: PhonemeType2.Roundedness ->
                 case x of wild {
                   PhonemeType2.DEFAULT
                   -> case y of wild1 { DEFAULT -> PhonemeType2.DEFAULT }
                   PhonemeType2.ROUNDED
                   -> case y of wild1 {
                        PhonemeType2.DEFAULT -> PhonemeType2.DEFAULT
                        PhonemeType2.ROUNDED -> PhonemeType2.ROUNDED
                        PhonemeType2.UNROUNDED -> PhonemeType2.ROUNDED }
                   PhonemeType2.UNROUNDED -> y }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness :: GHC.Read.Read PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fReadBackness_$s$dmreadsPrec
                  PhonemeType2.$fReadBackness_$sreadListDefault
                  PhonemeType2.$fReadBackness_$creadPrec
                  PhonemeType2.$fReadBackness_$creadListPrec -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Backness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Backness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Backness>_R))
                   @ b
                   eta1) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.FRONT) -}
6f0e5466d147260e7268f47de7dbf8fd
  $fReadBackness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRONT"#) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness14,
                  PhonemeType2.$fReadBackness13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARFRONT) -}
42e184bc0571b7102459f03f8b28a778
  $fReadBackness14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARFRONT"#) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness17,
                  PhonemeType2.$fReadBackness16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CENTRAL) -}
ab11279b8eef3e42f6d640c3d6419cfe
  $fReadBackness17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CENTRAL"#) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness20,
                  PhonemeType2.$fReadBackness19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARBACK) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Backness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Backness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Backness>_R)))) -}
51228f36a1f0fd3bd1a55b3aaaf90d90
  $fReadBackness20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARBACK"#) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness23,
                  PhonemeType2.$fReadBackness22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.BACK) -}
cfa895842fb289c96d68a9218daadc0c
  $fReadBackness23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACK"#) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Backness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness4
                   eta
                   @ b
                   eta1) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness21
                   PhonemeType2.$fReadBackness5) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness18
                   PhonemeType2.$fReadBackness6) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness15
                   PhonemeType2.$fReadBackness7) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness12
                   PhonemeType2.$fReadBackness8) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
                   PhonemeType2.$fReadBackness9
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Backness))) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadBackness11,
                  PhonemeType2.$fReadBackness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Backness>_R))))) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Backness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadBackness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Backness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Backness]>_R))) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Backness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadBackness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Backness>_R)) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Backness
                   PhonemeType2.$fReadBackness_$creadPrec
                   eta) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fReadBackness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Backness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Backness]
                   ((PhonemeType2.$fReadBackness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Backness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Backness]>_R)
                      @ [PhonemeType2.Backness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Backness]))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight :: GHC.Read.Read PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fReadHeight_$s$dmreadsPrec
                  PhonemeType2.$fReadHeight_$sreadListDefault
                  PhonemeType2.$fReadHeight_$creadPrec
                  PhonemeType2.$fReadHeight_$creadListPrec -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Height] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Height]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Height>_R))
                   @ b
                   eta1) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight13,
                  PhonemeType2.$fReadHeight12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.OPEN) -}
438e01717e85acac456af7e311e6c648
  $fReadHeight13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPEN"#) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight16,
                  PhonemeType2.$fReadHeight15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEAROPEN) -}
d2467871fbea20ee5e8dc723889d4006
  $fReadHeight16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEAROPEN"#) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight19,
                  PhonemeType2.$fReadHeight18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.OPENMID) -}
479f8004c54c52c50264c4adafb45de8
  $fReadHeight19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPENMID"#) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Height
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Height>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Height>_R)))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight22,
                  PhonemeType2.$fReadHeight21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.MID) -}
483c415b6669fc4b3b4a33a8d6d47657
  $fReadHeight22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MID"#) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight25,
                  PhonemeType2.$fReadHeight24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CLOSEMID) -}
e718878d48b72fb68c9c503db6617a27
  $fReadHeight25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSEMID"#) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight28,
                  PhonemeType2.$fReadHeight27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NEARCLOSE) -}
e5c2b5a24e9c2a6be3444a6e1c56ebb5
  $fReadHeight28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARCLOSE"#) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadHeight31,
                  PhonemeType2.$fReadHeight30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Height>_R))))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight4
                   eta
                   @ b
                   eta1) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CLOSE) -}
2a0b1d4baa955f92d548eb77180f187c
  $fReadHeight31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSE"#) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight29
                   PhonemeType2.$fReadHeight5) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight26
                   PhonemeType2.$fReadHeight6) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight23
                   PhonemeType2.$fReadHeight7) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight20
                   PhonemeType2.$fReadHeight8) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight17
                   PhonemeType2.$fReadHeight9) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height)
                   PhonemeType2.$fReadHeight14
                   PhonemeType2.$fReadHeight10) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Height]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadHeight1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Height]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Height]>_R))) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Height
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadHeight2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Height>_R)) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Height
                   PhonemeType2.$fReadHeight_$creadPrec
                   eta) -}
259830e3ec94d1ed981c032991c75e25
  $fReadHeight_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Height]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Height]
                   ((PhonemeType2.$fReadHeight_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Height]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Height]>_R)
                      @ [PhonemeType2.Height]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Height]))) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength :: GHC.Read.Read PhonemeType2.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fReadLength_$s$dmreadsPrec
                  PhonemeType2.$fReadLength_$sreadListDefault
                  PhonemeType2.$fReadLength_$creadPrec
                  PhonemeType2.$fReadLength_$creadListPrec -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Length] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Length]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Length
                   PhonemeType2.$fReadLength2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Length>_R))
                   @ b
                   eta1) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadLength12,
                  PhonemeType2.$fReadLength11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Length>_R))))) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NORMAL) -}
67065f56c999887c8f34137e35a6b750
  $fReadLength12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NORMAL"#) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadLength15,
                  PhonemeType2.$fReadLength14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Length>_R))))) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SHORT) -}
18a4efe4e0a500bc63fc4bed29d9dd51
  $fReadLength15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SHORT"#) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Length
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Length
                   PhonemeType2.$fReadLength3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Length>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Length>_R)))) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Length
                   PhonemeType2.$fReadLength4
                   eta
                   @ b
                   eta1) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
                   PhonemeType2.$fReadLength13
                   PhonemeType2.$fReadLength5) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
                   PhonemeType2.$fReadLength10
                   PhonemeType2.$fReadLength6) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
                   PhonemeType2.$fReadLength7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length))) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadLength9,
                  PhonemeType2.$fReadLength8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Length>_R))))) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LONG) -}
b92c456b0d86d36c143062d3914ac9b3
  $fReadLength9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LONG"#) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Length]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadLength1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Length]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Length]>_R))) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Length
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadLength2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Length>_R)) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Length
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Length
                   PhonemeType2.$fReadLength_$creadPrec
                   eta) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fReadLength_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Length]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Length]
                   ((PhonemeType2.$fReadLength_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Length]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Length]>_R)
                      @ [PhonemeType2.Length]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Length]))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner :: GHC.Read.Read PhonemeType2.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fReadManner_$s$dmreadsPrec
                  PhonemeType2.$fReadManner_$sreadListDefault
                  PhonemeType2.$fReadManner_$creadPrec
                  PhonemeType2.$fReadManner_$creadListPrec -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Manner] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Manner]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Manner>_R))
                   @ b
                   eta1) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner35
                   PhonemeType2.$fReadManner11) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner32
                   PhonemeType2.$fReadManner12) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner29
                   PhonemeType2.$fReadManner13) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner26
                   PhonemeType2.$fReadManner14) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner23
                   PhonemeType2.$fReadManner15) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner20
                   PhonemeType2.$fReadManner16) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner17
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner19,
                  PhonemeType2.$fReadManner18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LFLAP) -}
7589e63740c8ff1d5f6fb7ed64d4d03b
  $fReadManner19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFLAP"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Manner
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Manner>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Manner>_R)))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner22,
                  PhonemeType2.$fReadManner21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LAPPROXIMANT) -}
2ec2f645d2801b1b80507be191206574
  $fReadManner22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAPPROXIMANT"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner25,
                  PhonemeType2.$fReadManner24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LFRICATIVE) -}
17b096b4628d190f763fded889b11329
  $fReadManner25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFRICATIVE"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner28,
                  PhonemeType2.$fReadManner27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LAFFRICATE) -}
a82c81b58bd1bacaea2cfe757b6fb043
  $fReadManner28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAFFRICATE"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner31,
                  PhonemeType2.$fReadManner30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner4
                   eta
                   @ b
                   eta1) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.TRILL) -}
a1027757e293a554222fe84595fd786f
  $fReadManner31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRILL"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner34,
                  PhonemeType2.$fReadManner33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.FLAP) -}
9a595a835b8679dca43ec089ed2c830f
  $fReadManner34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FLAP"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner37,
                  PhonemeType2.$fReadManner36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.APPROXIMANT) -}
5e2958fc85eef76196293b9601c665d9
  $fReadManner37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "APPROXIMANT"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner40,
                  PhonemeType2.$fReadManner39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.FRICATIVE) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner53
                   PhonemeType2.$fReadManner5) -}
8be95cf9026c3cd538a1f24be35138dd
  $fReadManner40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRICATIVE"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner43,
                  PhonemeType2.$fReadManner42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SILIBANT) -}
6927692ba38a7dcc76421f0cbcd21532
  $fReadManner43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SILIBANT"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner44 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner46,
                  PhonemeType2.$fReadManner45
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.AFFRICATE) -}
e77130741995d1fd03640a57603c7316
  $fReadManner46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFFRICATE"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner47 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner49,
                  PhonemeType2.$fReadManner48
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner48 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SAFFRICATE) -}
045a614f739f86d14dcc4b92544ae4c0
  $fReadManner49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SAFFRICATE"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner50
                   PhonemeType2.$fReadManner6) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner50 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner52,
                  PhonemeType2.$fReadManner51
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner51 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.STOP) -}
adece403b6cf927a51d5ff2613ab5a2f
  $fReadManner52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STOP"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadManner55,
                  PhonemeType2.$fReadManner54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Manner>_R))))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.NASAL) -}
160baca6307547c5ac53b021a15b414d
  $fReadManner55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NASAL"#) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner47
                   PhonemeType2.$fReadManner7) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner44
                   PhonemeType2.$fReadManner8) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner41
                   PhonemeType2.$fReadManner9) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner)
                   PhonemeType2.$fReadManner38
                   PhonemeType2.$fReadManner10) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Manner]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadManner1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Manner]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Manner]>_R))) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Manner
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadManner2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Manner>_R)) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Manner
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Manner
                   PhonemeType2.$fReadManner_$creadPrec
                   eta) -}
9412c45cd95f18b011a2b8e64ee99754
  $fReadManner_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Manner]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Manner]
                   ((PhonemeType2.$fReadManner_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Manner]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Manner]>_R)
                      @ [PhonemeType2.Manner]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Manner]))) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fReadMorpheme :: GHC.Read.Read PhonemeType2.Morpheme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Morpheme
                  PhonemeType2.$fReadMorpheme_$creadsPrec
                  PhonemeType2.$fReadMorpheme_$sreadListDefault
                  PhonemeType2.$fReadMorpheme_$creadPrec
                  PhonemeType2.$fReadMorpheme_$creadListPrec -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fReadMorpheme1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Morpheme] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Morpheme]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Morpheme
                   PhonemeType2.$fReadMorpheme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Morpheme>_R))
                   @ b
                   eta1) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fReadMorpheme2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Morpheme
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Morpheme
                   PhonemeType2.$fReadMorpheme3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Morpheme>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Morpheme>_R)))) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fReadMorpheme3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Morpheme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.Morpheme -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa ww1 @ b w1 }) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fReadMorpheme_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Morpheme]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadMorpheme1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Morpheme]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Morpheme]>_R))) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fReadMorpheme_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Morpheme
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadMorpheme2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Morpheme>_R)) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fReadMorpheme_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Morpheme
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType2.Morpheme
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType2.Morpheme
                       PhonemeType2.$fReadMorpheme3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType2.Morpheme>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType2.Morpheme>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType2.Morpheme>_R)
                      @ PhonemeType2.Morpheme
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType2.Morpheme))) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fReadMorpheme_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Morpheme]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Morpheme]
                   ((PhonemeType2.$fReadMorpheme_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Morpheme]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Morpheme]>_R)
                      @ [PhonemeType2.Morpheme]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Morpheme]))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation :: GHC.Read.Read PhonemeType2.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fReadPhonation_$s$dmreadsPrec
                  PhonemeType2.$fReadPhonation_$sreadListDefault
                  PhonemeType2.$fReadPhonation_$creadPrec
                  PhonemeType2.$fReadPhonation_$creadListPrec -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Phonation] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Phonation]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Phonation
                   PhonemeType2.$fReadPhonation2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Phonation>_R))
                   @ b
                   eta1) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadPhonation11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Phonation))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPhonation13,
                  PhonemeType2.$fReadPhonation12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ASPIRATED) -}
a2c9a4add0ed0606cb4df6c1123704d8
  $fReadPhonation13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ASPIRATED"#) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPhonation16,
                  PhonemeType2.$fReadPhonation15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CREAKY) -}
4dcaa54000b30438e4b6180632245a51
  $fReadPhonation16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CREAKY"#) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPhonation19,
                  PhonemeType2.$fReadPhonation18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.STIFF) -}
42607b4b5521d8e754ae5dc1559a7a41
  $fReadPhonation19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STIFF"#) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Phonation
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Phonation
                   PhonemeType2.$fReadPhonation3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Phonation>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Phonation>_R)))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPhonation22,
                  PhonemeType2.$fReadPhonation21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.MODAL) -}
0f72cfddfd4d14aef677bd4e8c03fffe
  $fReadPhonation22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MODAL"#) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPhonation25,
                  PhonemeType2.$fReadPhonation24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.SLACK) -}
ef73fc5c652bc19f15ca3940a595ac61
  $fReadPhonation25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SLACK"#) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPhonation28,
                  PhonemeType2.$fReadPhonation27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.BREATHY) -}
ac06c72a5e6a72497858f9e55a5e32c2
  $fReadPhonation28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BREATHY"#) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPhonation31,
                  PhonemeType2.$fReadPhonation30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Phonation>_R))))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Phonation
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Phonation
                   PhonemeType2.$fReadPhonation4
                   eta
                   @ b
                   eta1) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Phonation
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.VOICELESS) -}
da62c58c705e547722fc14922835f90c
  $fReadPhonation31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICELESS"#) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadPhonation29
                   PhonemeType2.$fReadPhonation5) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadPhonation26
                   PhonemeType2.$fReadPhonation6) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadPhonation23
                   PhonemeType2.$fReadPhonation7) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadPhonation20
                   PhonemeType2.$fReadPhonation8) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadPhonation17
                   PhonemeType2.$fReadPhonation9) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation)
                   PhonemeType2.$fReadPhonation14
                   PhonemeType2.$fReadPhonation10) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Phonation]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhonation1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Phonation]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Phonation]>_R))) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phonation
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhonation2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Phonation>_R)) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Phonation
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Phonation
                   PhonemeType2.$fReadPhonation_$creadPrec
                   eta) -}
784f1f65fce67f349dccdb2a747dd13a
  $fReadPhonation_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Phonation]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Phonation]
                   ((PhonemeType2.$fReadPhonation_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Phonation]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Phonation]>_R)
                      @ [PhonemeType2.Phonation]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Phonation]))) -}
20569906d69b1b60892d82b112a7f488
  $fReadPhoneme :: GHC.Read.Read PhonemeType2.Phoneme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phoneme
                  PhonemeType2.$fReadPhoneme_$s$dmreadsPrec
                  PhonemeType2.$fReadPhoneme_$sreadListDefault
                  PhonemeType2.$fReadPhoneme_$creadPrec
                  PhonemeType2.$fReadPhoneme_$creadListPrec -}
20569906d69b1b60892d82b112a7f488
  $fReadPhoneme1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Phoneme] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Phoneme]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fReadPhoneme2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Phoneme>_R))
                   @ b
                   eta1) -}
20569906d69b1b60892d82b112a7f488
  $fReadPhoneme2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Phoneme
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fReadPhoneme3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Phoneme>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Phoneme>_R)))) -}
20569906d69b1b60892d82b112a7f488
  $fReadPhoneme3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Phoneme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)> -}
20569906d69b1b60892d82b112a7f488
  $fReadPhoneme_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Phoneme]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhoneme1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Phoneme]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Phoneme]>_R))) -}
20569906d69b1b60892d82b112a7f488
  $fReadPhoneme_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Phoneme
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPhoneme2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Phoneme>_R)) -}
20569906d69b1b60892d82b112a7f488
  $fReadPhoneme_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fReadPhoneme_$creadPrec
                   eta) -}
20569906d69b1b60892d82b112a7f488
  $fReadPhoneme_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Phoneme]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Phoneme]
                   ((PhonemeType2.$fReadPhoneme_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Phoneme]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Phoneme]>_R)
                      @ [PhonemeType2.Phoneme]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Phoneme]))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace :: GHC.Read.Read PhonemeType2.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fReadPlace_$s$dmreadsPrec
                  PhonemeType2.$fReadPlace_$sreadListDefault
                  PhonemeType2.$fReadPlace_$creadPrec
                  PhonemeType2.$fReadPlace_$creadListPrec -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Place] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Place] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Place>_R))
                   @ b
                   eta1) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace59
                   PhonemeType2.$fReadPlace11) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace56
                   PhonemeType2.$fReadPlace12) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace53
                   PhonemeType2.$fReadPlace13) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace50
                   PhonemeType2.$fReadPlace14) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace47
                   PhonemeType2.$fReadPlace15) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace44
                   PhonemeType2.$fReadPlace16) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace41
                   PhonemeType2.$fReadPlace17) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace17 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace38
                   PhonemeType2.$fReadPlace18) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace18 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace35
                   PhonemeType2.$fReadPlace19) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace19 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace32
                   PhonemeType2.$fReadPlace20) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Place
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Place>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Place>_R)))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace20 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace29
                   PhonemeType2.$fReadPlace21) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace26
                   PhonemeType2.$fReadPlace22) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace22 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace23
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace25,
                  PhonemeType2.$fReadPlace24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.GLOTTAL) -}
110c3134197ea590969cfcf2d5a35982
  $fReadPlace25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace28,
                  PhonemeType2.$fReadPlace27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.EPIGLOTTAL) -}
c0cbab5cb5d519dd09b9a57891f849e5
  $fReadPlace28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIGLOTTAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace31,
                  PhonemeType2.$fReadPlace30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace4
                   eta
                   @ b
                   eta1) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.PHARYNGEAL) -}
836cc8ffe8e5ce46fddcacca47b92a08
  $fReadPlace31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PHARYNGEAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace34,
                  PhonemeType2.$fReadPlace33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.EPIPHARYNGEAL) -}
47f64ac680b1726ce509315011ee7dea
  $fReadPlace34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIPHARYNGEAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace37,
                  PhonemeType2.$fReadPlace36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LARYNGEAL) -}
4a22d88609a8afa18634d5415260b135
  $fReadPlace37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LARYNGEAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace40,
                  PhonemeType2.$fReadPlace39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.UVULAR) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace77
                   PhonemeType2.$fReadPlace5) -}
74d0d7eb3f15d911590899b27b2262e2
  $fReadPlace40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVULAR"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace43,
                  PhonemeType2.$fReadPlace42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.VELAR) -}
73da62d83bffd13f49f12eb783eac1e2
  $fReadPlace43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VELAR"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace44 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace46,
                  PhonemeType2.$fReadPlace45
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.PALATAL) -}
c05bee3b5962adc326cd590f1461c845
  $fReadPlace46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PALATAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace47 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace49,
                  PhonemeType2.$fReadPlace48
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace48 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ALVEOLOPALATAL) -}
5660d445a7f40fee62eff09e9fe19888
  $fReadPlace49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLOPALATAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace74
                   PhonemeType2.$fReadPlace6) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace50 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace52,
                  PhonemeType2.$fReadPlace51
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace51 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.DORSAL) -}
956f7e2dd33b75e6fa01c041c05f71b3
  $fReadPlace52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DORSAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace55,
                  PhonemeType2.$fReadPlace54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.RETROFLEX) -}
6fb702e9d7323b6271778bbaa4ef9822
  $fReadPlace55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RETROFLEX"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace56 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace58,
                  PhonemeType2.$fReadPlace57
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace57 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.POSTALVEOLAR) -}
c3bc37be77888cdbb0ff81f683880f5f
  $fReadPlace58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POSTALVEOLAR"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace59 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace61,
                  PhonemeType2.$fReadPlace60
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace71
                   PhonemeType2.$fReadPlace7) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace60 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ALVEOLAR) -}
6254a95e617a1b6a1cadc5a5517ae493
  $fReadPlace61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLAR"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace62 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace64,
                  PhonemeType2.$fReadPlace63
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace63 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.DENTAL) -}
45feb730b09c15af4a5b0f0b721d7e56
  $fReadPlace64 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace65 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace67,
                  PhonemeType2.$fReadPlace66
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace66 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.DENTIALVEOLAR) -}
7a8f62fd32ff187b2bb14a35341cdfd2
  $fReadPlace67 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTIALVEOLAR"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace68 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace70,
                  PhonemeType2.$fReadPlace69
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace69 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.CORONAL) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace68
                   PhonemeType2.$fReadPlace8) -}
a452075a5a43c15de10ba0a91de7c979
  $fReadPlace70 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CORONAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace71 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace73,
                  PhonemeType2.$fReadPlace72
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace72 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LABIODENTAL) -}
136084e99f3c6bd32336873939ee445c
  $fReadPlace73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIODENTAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace74 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace76,
                  PhonemeType2.$fReadPlace75
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace75 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.BILABIAL) -}
90a0fc95ed0e1f82142c0bb1d1d86666
  $fReadPlace76 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BILABIAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace77 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadPlace79,
                  PhonemeType2.$fReadPlace78
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Place>_R))))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace78 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.LABIAL) -}
a2f1ee67a482cf267ce77d719d790c83
  $fReadPlace79 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIAL"#) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace65
                   PhonemeType2.$fReadPlace9) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place)
                   PhonemeType2.$fReadPlace62
                   PhonemeType2.$fReadPlace10) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Place]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPlace1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Place]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Place]>_R))) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Place
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadPlace2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Place>_R)) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Place
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Place
                   PhonemeType2.$fReadPlace_$creadPrec
                   eta) -}
f8e121d7060ad8a0878087af8ae85de9
  $fReadPlace_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Place]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Place]
                   ((PhonemeType2.$fReadPlace_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Place]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Place]>_R)
                      @ [PhonemeType2.Place]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Place]))) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness :: GHC.Read.Read PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fReadRoundedness_$s$dmreadsPrec
                  PhonemeType2.$fReadRoundedness_$sreadListDefault
                  PhonemeType2.$fReadRoundedness_$creadPrec
                  PhonemeType2.$fReadRoundedness_$creadListPrec -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Roundedness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Roundedness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Roundedness>_R))
                   @ b
                   eta1) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadRoundedness12,
                  PhonemeType2.$fReadRoundedness11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Roundedness>_R))))) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.ROUNDED) -}
a93daa76950c55d72aa1c9f4df484e1a
  $fReadRoundedness12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ROUNDED"#) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadRoundedness15,
                  PhonemeType2.$fReadRoundedness14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Roundedness>_R))))) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.DEFAULT) -}
ba0dde45d34173d054bcebb9497cf5de
  $fReadRoundedness15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DEFAULT"#) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Roundedness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Roundedness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Roundedness>_R)))) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType2.Roundedness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness4
                   eta
                   @ b
                   eta1) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
                   PhonemeType2.$fReadRoundedness13
                   PhonemeType2.$fReadRoundedness5) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
                   PhonemeType2.$fReadRoundedness10
                   PhonemeType2.$fReadRoundedness6) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
                   PhonemeType2.$fReadRoundedness7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType2.Roundedness))) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType2.$fReadRoundedness9,
                  PhonemeType2.$fReadRoundedness8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType2.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType2.Roundedness>_R))))) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType2.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType2.UNROUNDED) -}
73f63c12589a31408190bd15854348ee
  $fReadRoundedness9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UNROUNDED"#) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Roundedness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadRoundedness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Roundedness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Roundedness]>_R))) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Roundedness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadRoundedness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Roundedness>_R)) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$fReadRoundedness_$creadPrec
                   eta) -}
142ff138328e86990b904685ecd67f0e
  $fReadRoundedness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Roundedness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Roundedness]
                   ((PhonemeType2.$fReadRoundedness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Roundedness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Roundedness]>_R)
                      @ [PhonemeType2.Roundedness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Roundedness]))) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fReadWord :: GHC.Read.Read PhonemeType2.Word
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Word
                  PhonemeType2.$fReadWord_$creadsPrec
                  PhonemeType2.$fReadWord_$sreadListDefault
                  PhonemeType2.$fReadWord_$creadPrec
                  PhonemeType2.$fReadWord_$creadListPrec -}
f66ce21cdfbfcba844a4da9e51d16345
  $fReadWord1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType2.Word] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType2.Word] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType2.Word
                   PhonemeType2.$fReadWord2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType2.Word>_R))
                   @ b
                   eta1) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fReadWord2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType2.Word
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType2.Word
                   PhonemeType2.$fReadWord3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType2.Word>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType2.Word>_R)))) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fReadWord3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType2.Word -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType2.Word -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType2.$wa1 ww1 @ b w1 }) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fReadWord_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType2.Word]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadWord1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType2.Word]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType2.Word]>_R))) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fReadWord_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType2.Word
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType2.$fReadWord2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType2.Word>_R)) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fReadWord_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType2.Word
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType2.Word
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType2.Word
                       PhonemeType2.$fReadWord3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType2.Word>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType2.Word>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <PhonemeType2.Word>_R)
                      @ PhonemeType2.Word
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType2.Word))) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fReadWord_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType2.Word]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType2.Word]
                   ((PhonemeType2.$fReadWord_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType2.Word]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType2.Word]>_R)
                      @ [PhonemeType2.Word]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType2.Word]))) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fShowBackness :: GHC.Show.Show PhonemeType2.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Backness
                  PhonemeType2.$fShowBackness_$cshowsPrec
                  PhonemeType2.$fShowBackness_$cshow
                  PhonemeType2.$fShowBackness_$cshowList -}
ca97fc28a82e78e4c561f0291cfc5413
  $fShowBackness_$cshow :: PhonemeType2.Backness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Backness ->
                 PhonemeType2.$fShowBackness_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fShowBackness_$cshowList ::
    [PhonemeType2.Backness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Backness
                   PhonemeType2.$w$cshowsPrec) -}
ca97fc28a82e78e4c561f0291cfc5413
  $fShowBackness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Backness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Backness
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec w1 w2) -}
259830e3ec94d1ed981c032991c75e25
  $fShowHeight :: GHC.Show.Show PhonemeType2.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Height
                  PhonemeType2.$fShowHeight_$cshowsPrec
                  PhonemeType2.$fShowHeight_$cshow
                  PhonemeType2.$fShowHeight_$cshowList -}
259830e3ec94d1ed981c032991c75e25
  $fShowHeight_$cshow :: PhonemeType2.Height -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Height ->
                 PhonemeType2.$fShowHeight_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
259830e3ec94d1ed981c032991c75e25
  $fShowHeight_$cshowList :: [PhonemeType2.Height] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Height
                   PhonemeType2.$w$cshowsPrec1) -}
259830e3ec94d1ed981c032991c75e25
  $fShowHeight_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Height -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Height
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec1 w1 w2) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fShowLength :: GHC.Show.Show PhonemeType2.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Length
                  PhonemeType2.$fShowLength_$cshowsPrec
                  PhonemeType2.$fShowLength_$cshow
                  PhonemeType2.$fShowLength_$cshowList -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fShowLength_$cshow :: PhonemeType2.Length -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Length ->
                 case x of wild {
                   PhonemeType2.SHORT -> PhonemeType2.$fReadLength15
                   PhonemeType2.NORMAL -> PhonemeType2.$fReadLength12
                   PhonemeType2.LONG -> PhonemeType2.$fReadLength9 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fShowLength_$cshowList :: [PhonemeType2.Length] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Length
                   PhonemeType2.$w$cshowsPrec2) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $fShowLength_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Length -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Length
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec2 w1 w2) -}
9412c45cd95f18b011a2b8e64ee99754
  $fShowManner :: GHC.Show.Show PhonemeType2.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Manner
                  PhonemeType2.$fShowManner_$cshowsPrec
                  PhonemeType2.$fShowManner_$cshow
                  PhonemeType2.$fShowManner_$cshowList -}
9412c45cd95f18b011a2b8e64ee99754
  $fShowManner_$cshow :: PhonemeType2.Manner -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Manner ->
                 PhonemeType2.$fShowManner_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9412c45cd95f18b011a2b8e64ee99754
  $fShowManner_$cshowList :: [PhonemeType2.Manner] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Manner
                   PhonemeType2.$w$cshowsPrec3) -}
9412c45cd95f18b011a2b8e64ee99754
  $fShowManner_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Manner -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Manner
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec3 w1 w2) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fShowMorpheme :: GHC.Show.Show PhonemeType2.Morpheme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Morpheme
                  PhonemeType2.$fShowMorpheme_$cshowsPrec1
                  PhonemeType2.$fShowMorpheme_$cshow
                  PhonemeType2.$fShowMorpheme_$cshowList -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fShowMorpheme1 :: PhonemeType2.Morpheme -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.Morpheme w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.Morpheme ww1 ->
                 PhonemeType2.$w$cshowsPrec4 0 ww1 w1 }) -}
fe6e731e8edbff9cce041c2518ea7b33
  $fShowMorpheme2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
d16c5dfb98d462306eefc63f32bddfe3
  $fShowMorpheme3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
b6ccc55abd61eb29b76f9b803caea61d
  $fShowMorpheme4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getPhonemes = "#) -}
108fd17ae9b849d38c598f2b944de593
  $fShowMorpheme5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Morpheme {"#) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fShowMorpheme_$cshow :: PhonemeType2.Morpheme -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Morpheme ->
                 PhonemeType2.$fShowMorpheme_$cshowsPrec1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fShowMorpheme_$cshowList ::
    [PhonemeType2.Morpheme] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Morpheme
                   PhonemeType2.$fShowMorpheme1) -}
20569906d69b1b60892d82b112a7f488
  $fShowMorpheme_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Phoneme -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
2ae9d5e2279d7aff2754760a9a3abd27
  $fShowMorpheme_$cshowsPrec1 ::
    GHC.Types.Int -> PhonemeType2.Morpheme -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Morpheme
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.Morpheme ww3 ->
                 PhonemeType2.$w$cshowsPrec4 ww1 ww3 w2 } }) -}
784f1f65fce67f349dccdb2a747dd13a
  $fShowPhonation :: GHC.Show.Show PhonemeType2.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phonation
                  PhonemeType2.$fShowPhonation_$cshowsPrec
                  PhonemeType2.$fShowPhonation_$cshow
                  PhonemeType2.$fShowPhonation_$cshowList -}
784f1f65fce67f349dccdb2a747dd13a
  $fShowPhonation_$cshow :: PhonemeType2.Phonation -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Phonation ->
                 PhonemeType2.$fShowPhonation_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
784f1f65fce67f349dccdb2a747dd13a
  $fShowPhonation_$cshowList ::
    [PhonemeType2.Phonation] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Phonation
                   PhonemeType2.$w$cshowsPrec5) -}
784f1f65fce67f349dccdb2a747dd13a
  $fShowPhonation_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Phonation -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Phonation
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec5 w1 w2) -}
20569906d69b1b60892d82b112a7f488
  $fShowPhoneme :: GHC.Show.Show PhonemeType2.Phoneme
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Phoneme
                  PhonemeType2.$fShowMorpheme_$cshowsPrec
                  PhonemeType2.$fShowPhoneme_$cshow
                  PhonemeType2.$fShowPhoneme_$cshowList -}
20569906d69b1b60892d82b112a7f488
  $fShowPhoneme1 :: PhonemeType2.Phoneme -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (PhonemeType2.$fShowMorpheme_$cshowsPrec
                   PhonemeType2.$fShowMorpheme2) -}
20569906d69b1b60892d82b112a7f488
  $fShowPhoneme_$cshow :: PhonemeType2.Phoneme -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Phoneme ->
                 PhonemeType2.$fShowMorpheme_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
20569906d69b1b60892d82b112a7f488
  $fShowPhoneme_$cshowList ::
    [PhonemeType2.Phoneme] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Phoneme
                   PhonemeType2.$fShowPhoneme1) -}
f8e121d7060ad8a0878087af8ae85de9
  $fShowPlace :: GHC.Show.Show PhonemeType2.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Place
                  PhonemeType2.$fShowPlace_$cshowsPrec
                  PhonemeType2.$fShowPlace_$cshow
                  PhonemeType2.$fShowPlace_$cshowList -}
f8e121d7060ad8a0878087af8ae85de9
  $fShowPlace_$cshow :: PhonemeType2.Place -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Place ->
                 PhonemeType2.$fShowPlace_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f8e121d7060ad8a0878087af8ae85de9
  $fShowPlace_$cshowList :: [PhonemeType2.Place] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Place
                   PhonemeType2.$w$cshowsPrec6) -}
f8e121d7060ad8a0878087af8ae85de9
  $fShowPlace_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Place -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Place
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec6 w1 w2) -}
142ff138328e86990b904685ecd67f0e
  $fShowRoundedness :: GHC.Show.Show PhonemeType2.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Roundedness
                  PhonemeType2.$fShowRoundedness_$cshowsPrec
                  PhonemeType2.$fShowRoundedness_$cshow
                  PhonemeType2.$fShowRoundedness_$cshowList -}
142ff138328e86990b904685ecd67f0e
  $fShowRoundedness_$cshow ::
    PhonemeType2.Roundedness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Roundedness ->
                 case x of wild {
                   PhonemeType2.DEFAULT -> PhonemeType2.$fReadRoundedness15
                   PhonemeType2.ROUNDED -> PhonemeType2.$fReadRoundedness12
                   PhonemeType2.UNROUNDED -> PhonemeType2.$fReadRoundedness9 }) -}
142ff138328e86990b904685ecd67f0e
  $fShowRoundedness_$cshowList ::
    [PhonemeType2.Roundedness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Roundedness
                   PhonemeType2.$w$cshowsPrec7) -}
142ff138328e86990b904685ecd67f0e
  $fShowRoundedness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Roundedness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Roundedness
                   w2 :: GHC.Base.String ->
                 PhonemeType2.$w$cshowsPrec7 w1 w2) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fShowWord :: GHC.Show.Show PhonemeType2.Word
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType2.Word
                  PhonemeType2.$fShowWord_$cshowsPrec
                  PhonemeType2.$fShowWord_$cshow
                  PhonemeType2.$fShowWord_$cshowList -}
f66ce21cdfbfcba844a4da9e51d16345
  $fShowWord1 :: PhonemeType2.Word -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType2.Word w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType2.Word ww1 ->
                 PhonemeType2.$w$cshowsPrec8 0 ww1 w1 }) -}
e2f8b6d75c94e9d79b30a17def8ec977
  $fShowWord2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getMorphemes = "#) -}
298b67f68e4f8738df2ef4e4c0fe947d
  $fShowWord3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Word {"#) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fShowWord_$cshow :: PhonemeType2.Word -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType2.Word ->
                 PhonemeType2.$fShowWord_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fShowWord_$cshowList :: [PhonemeType2.Word] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType2.Word
                   PhonemeType2.$fShowWord1) -}
f66ce21cdfbfcba844a4da9e51d16345
  $fShowWord_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType2.Word -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType2.Word
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType2.Word ww3 ->
                 PhonemeType2.$w$cshowsPrec8 ww1 ww3 w2 } }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $w$cshowsPrec ::
    PhonemeType2.Backness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Backness w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.BACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness23 w1
                   PhonemeType2.NEARBACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness20 w1
                   PhonemeType2.CENTRAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness17 w1
                   PhonemeType2.NEARFRONT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadBackness14 w1
                   PhonemeType2.FRONT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadBackness11
                        w1 }) -}
259830e3ec94d1ed981c032991c75e25
  $w$cshowsPrec1 ::
    PhonemeType2.Height -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Height w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.CLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight31 w1
                   PhonemeType2.NEARCLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight28 w1
                   PhonemeType2.CLOSEMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight25 w1
                   PhonemeType2.MID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight22 w1
                   PhonemeType2.OPENMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight19 w1
                   PhonemeType2.NEAROPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadHeight16 w1
                   PhonemeType2.OPEN
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadHeight13
                        w1 }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $w$cshowsPrec2 ::
    PhonemeType2.Length -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Length w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.SHORT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadLength15 w1
                   PhonemeType2.NORMAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadLength12 w1
                   PhonemeType2.LONG
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadLength9 w1 }) -}
9412c45cd95f18b011a2b8e64ee99754
  $w$cshowsPrec3 ::
    PhonemeType2.Manner -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Manner w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.NASAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner55 w1
                   PhonemeType2.STOP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner52 w1
                   PhonemeType2.SAFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner49 w1
                   PhonemeType2.AFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner46 w1
                   PhonemeType2.SILIBANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner43 w1
                   PhonemeType2.FRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner40 w1
                   PhonemeType2.APPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner37 w1
                   PhonemeType2.FLAP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner34 w1
                   PhonemeType2.TRILL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner31 w1
                   PhonemeType2.LAFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner28 w1
                   PhonemeType2.LFRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner25 w1
                   PhonemeType2.LAPPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadManner22 w1
                   PhonemeType2.LFLAP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadManner19
                        w1 }) -}
b699698e486d48c4ccb96a39af2b23bc
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> [PhonemeType2.Phoneme] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeType2.Phoneme]
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType2.$fShowMorpheme5
                       (GHC.Base.++
                          @ GHC.Types.Char
                          PhonemeType2.$fShowMorpheme4
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fShowMorpheme3 x
                           } in
                           case ww1 of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (PhonemeType2.$fShowMorpheme_$cshowsPrec
                                     PhonemeType2.$fShowMorpheme2
                                     x1
                                     (let {
                                        lvl92 :: [GHC.Types.Char]
                                        = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s
                                      } in
                                      letrec {
                                        showl :: [PhonemeType2.Phoneme] -> [GHC.Types.Char]
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ ds2 :: [PhonemeType2.Phoneme] ->
                                          case ds2 of wild1 {
                                            [] -> lvl92
                                            : y ys
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.showList__1
                                                 (PhonemeType2.$fShowMorpheme_$cshowsPrec
                                                    PhonemeType2.$fShowMorpheme2
                                                    y
                                                    (showl ys)) }
                                      } in
                                      showl xs)) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
784f1f65fce67f349dccdb2a747dd13a
  $w$cshowsPrec5 ::
    PhonemeType2.Phonation -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Phonation w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.VOICELESS
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPhonation31 w1
                   PhonemeType2.BREATHY
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPhonation28 w1
                   PhonemeType2.SLACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPhonation25 w1
                   PhonemeType2.MODAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPhonation22 w1
                   PhonemeType2.STIFF
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPhonation19 w1
                   PhonemeType2.CREAKY
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadPhonation16 w1
                   PhonemeType2.ASPIRATED
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadPhonation13
                        w1 }) -}
f8e121d7060ad8a0878087af8ae85de9
  $w$cshowsPrec6 ::
    PhonemeType2.Place -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
142ff138328e86990b904685ecd67f0e
  $w$cshowsPrec7 ::
    PhonemeType2.Roundedness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType2.Roundedness
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType2.DEFAULT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadRoundedness15 w1
                   PhonemeType2.ROUNDED
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fReadRoundedness12 w1
                   PhonemeType2.UNROUNDED
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType2.$fReadRoundedness9
                        w1 }) -}
5cd7d05fd2b7910f2bd32eb8171b3cd7
  $w$cshowsPrec8 ::
    GHC.Prim.Int#
    -> [PhonemeType2.Morpheme] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeType2.Morpheme]
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType2.$fShowWord3
                       (GHC.Base.++
                          @ GHC.Types.Char
                          PhonemeType2.$fShowWord2
                          (let {
                             s :: GHC.Base.String
                             = GHC.Base.++ @ GHC.Types.Char PhonemeType2.$fShowMorpheme3 x
                           } in
                           case ww1 of wild {
                             [] -> GHC.CString.unpackAppendCString# "[]"# s
                             : x1 xs
                             -> GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showList__3
                                  (case x1 of ww2 { PhonemeType2.Morpheme ww3 ->
                                   PhonemeType2.$w$cshowsPrec4
                                     0
                                     ww3
                                     (let {
                                        lvl92 :: [GHC.Types.Char]
                                        = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s
                                      } in
                                      letrec {
                                        showl :: [PhonemeType2.Morpheme] -> [GHC.Types.Char]
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ ds2 :: [PhonemeType2.Morpheme] ->
                                          case ds2 of wild1 {
                                            [] -> lvl92
                                            : y ys
                                            -> GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.showList__1
                                                 (case y of ww4 { PhonemeType2.Morpheme ww5 ->
                                                  PhonemeType2.$w$cshowsPrec4 0 ww5 (showl ys) }) }
                                      } in
                                      showl xs) }) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
ca97fc28a82e78e4c561f0291cfc5413
  $w$ctoEnum :: GHC.Prim.Int# -> PhonemeType2.Backness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumBackness6 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 4) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumBackness6 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Backness ww } }) -}
259830e3ec94d1ed981c032991c75e25
  $w$ctoEnum1 :: GHC.Prim.Int# -> PhonemeType2.Height
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumHeight8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumHeight8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Height ww } }) -}
f70a5441da9178aaaa0d5d40e666f6d3
  $w$ctoEnum2 :: GHC.Prim.Int# -> PhonemeType2.Length
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumLength1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumLength1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Length ww } }) -}
9412c45cd95f18b011a2b8e64ee99754
  $w$ctoEnum3 :: GHC.Prim.Int# -> PhonemeType2.Manner
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumManner1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 12) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumManner1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Manner ww } }) -}
784f1f65fce67f349dccdb2a747dd13a
  $w$ctoEnum4 :: GHC.Prim.Int# -> PhonemeType2.Phonation
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumPhonation8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumPhonation8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Phonation ww } }) -}
f8e121d7060ad8a0878087af8ae85de9
  $w$ctoEnum5 :: GHC.Prim.Int# -> PhonemeType2.Place
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumPlace1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 18) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumPlace1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Place ww } }) -}
142ff138328e86990b904685ecd67f0e
  $w$ctoEnum6 :: GHC.Prim.Int# -> PhonemeType2.Roundedness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType2.$fEnumRoundedness1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType2.$fEnumRoundedness1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType2.Roundedness ww } }) -}
2ae9d5e2279d7aff2754760a9a3abd27
  $wa ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.Morpheme -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
f66ce21cdfbfcba844a4da9e51d16345
  $wa1 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType2.Word -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
ca97fc28a82e78e4c561f0291cfc5413
  data Backness = BACK | NEARBACK | CENTRAL | NEARFRONT | FRONT
    Promotable
259830e3ec94d1ed981c032991c75e25
  data Height
    = CLOSE | NEARCLOSE | CLOSEMID | MID | OPENMID | NEAROPEN | OPEN
    Promotable
f70a5441da9178aaaa0d5d40e666f6d3
  data Length = SHORT | NORMAL | LONG
    Promotable
9412c45cd95f18b011a2b8e64ee99754
  data Manner
    = NASAL
    | STOP
    | SAFFRICATE
    | AFFRICATE
    | SILIBANT
    | FRICATIVE
    | APPROXIMANT
    | FLAP
    | TRILL
    | LAFFRICATE
    | LFRICATIVE
    | LAPPROXIMANT
    | LFLAP
    Promotable
2ae9d5e2279d7aff2754760a9a3abd27
  data Morpheme = Morpheme {getPhonemes :: [PhonemeType2.Phoneme]}
784f1f65fce67f349dccdb2a747dd13a
  data Phonation
    = VOICELESS | BREATHY | SLACK | MODAL | STIFF | CREAKY | ASPIRATED
    Promotable
20569906d69b1b60892d82b112a7f488
  data Phoneme
    = Consonant {cplace :: PhonemeType2.Place,
                 cmanner :: PhonemeType2.Manner,
                 cvoice :: PhonemeType2.Phonation,
                 csymbol :: GHC.Base.String}
    | Vowel {vheight :: PhonemeType2.Height,
             vbackness :: PhonemeType2.Backness,
             vroundedness :: PhonemeType2.Roundedness,
             vlength :: PhonemeType2.Length,
             vsymbol :: GHC.Base.String}
    | Diphthong {dheight1 :: PhonemeType2.Height,
                 dbackness1 :: PhonemeType2.Backness,
                 droundedness1 :: PhonemeType2.Roundedness,
                 dlength1 :: PhonemeType2.Length,
                 dheight2 :: PhonemeType2.Height,
                 dbackness2 :: PhonemeType2.Backness,
                 droundedness2 :: PhonemeType2.Roundedness,
                 dlength2 :: PhonemeType2.Length,
                 dsymbol :: GHC.Base.String}
    | Blank
f8e121d7060ad8a0878087af8ae85de9
  data Place
    = LABIAL
    | BILABIAL
    | LABIODENTAL
    | CORONAL
    | DENTIALVEOLAR
    | DENTAL
    | ALVEOLAR
    | POSTALVEOLAR
    | RETROFLEX
    | DORSAL
    | ALVEOLOPALATAL
    | PALATAL
    | VELAR
    | UVULAR
    | LARYNGEAL
    | EPIPHARYNGEAL
    | PHARYNGEAL
    | EPIGLOTTAL
    | GLOTTAL
    Promotable
142ff138328e86990b904685ecd67f0e
  data Roundedness = DEFAULT | ROUNDED | UNROUNDED
    Promotable
f66ce21cdfbfcba844a4da9e51d16345
  data Word = Word {getMorphemes :: [PhonemeType2.Morpheme]}
5e52ece4b8401f167d25be0a7c4443cc
  cmanner :: PhonemeType2.Phoneme -> PhonemeType2.Manner
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.cmanner1
                   PhonemeType2.Consonant ds1 ds2 ds3 ds4 -> ds2 }) -}
ae95831c147910c80531d2dc69d440c8
  cmanner1 :: PhonemeType2.Manner
  {- Strictness: b -}
6aa92e5397db80d98535c96cabe05571
  cplace :: PhonemeType2.Phoneme -> PhonemeType2.Place
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.cplace1
                   PhonemeType2.Consonant ds1 ds2 ds3 ds4 -> ds1 }) -}
59769344dfa06643132c02ad71109b6e
  cplace1 :: PhonemeType2.Place
  {- Strictness: b -}
30ee196a1b2ab856dfeafcf6c7f1e4de
  csymbol :: PhonemeType2.Phoneme -> GHC.Base.String
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.csymbol1
                   PhonemeType2.Consonant ds1 ds2 ds3 ds4 -> ds4 }) -}
220a8c5de8785be4c8e71ab151b9c271
  csymbol1 :: GHC.Base.String
  {- Strictness: b -}
a545a475ce96c41cb4ecdcc5be479cd4
  cvoice :: PhonemeType2.Phoneme -> PhonemeType2.Phonation
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.cvoice1
                   PhonemeType2.Consonant ds1 ds2 ds3 ds4 -> ds3 }) -}
6f3dd59a7561957a0288b56b443552f4
  cvoice1 :: PhonemeType2.Phonation
  {- Strictness: b -}
711bbb81b42fd4741a2d7cd931e8345b
  dbackness1 :: PhonemeType2.Phoneme -> PhonemeType2.Backness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.dbackness4
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds2 }) -}
1a2163e3ded2598c7cc2204e4cea32f9
  dbackness2 :: PhonemeType2.Phoneme -> PhonemeType2.Backness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.dbackness5
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds6 }) -}
53a0cbecf67db5147168ef22ab37293c
  dbackness4 :: PhonemeType2.Backness
  {- Strictness: b -}
8c102d1b11c479e8660ef96d511b1c79
  dbackness5 :: PhonemeType2.Backness
  {- Strictness: b -}
c7568f370aae1c8f43fd6029aa5ce0c8
  dheight1 :: PhonemeType2.Phoneme -> PhonemeType2.Height
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.dheight4
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds1 }) -}
2238df5f2cc6e121bb0a7788ae0c374e
  dheight2 :: PhonemeType2.Phoneme -> PhonemeType2.Height
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.dheight5
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds5 }) -}
de1018ce7cc8e3064fcfb85d09493423
  dheight4 :: PhonemeType2.Height
  {- Strictness: b -}
86137a2749f0fda4e5772b58825486f2
  dheight5 :: PhonemeType2.Height
  {- Strictness: b -}
6da4638edb4c95e42f13f6e1808abdfd
  dlength1 :: PhonemeType2.Phoneme -> PhonemeType2.Length
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.dlength4
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds4 }) -}
508e1e73ac7a60a812ea67be9d4e53ed
  dlength2 :: PhonemeType2.Phoneme -> PhonemeType2.Length
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.dlength5
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds8 }) -}
e3b5d9658f9453a209cb725410a986ed
  dlength4 :: PhonemeType2.Length
  {- Strictness: b -}
bed02000024b43493bd5c22ba2371930
  dlength5 :: PhonemeType2.Length
  {- Strictness: b -}
09b543ab89f6069fcdf3e9669e43945d
  droundedness1 :: PhonemeType2.Phoneme -> PhonemeType2.Roundedness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.droundedness4
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds3 }) -}
01910cb2c47cbb9664b84f25d255da9f
  droundedness2 :: PhonemeType2.Phoneme -> PhonemeType2.Roundedness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.droundedness5
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds7 }) -}
8e487aa56e288b17c88f387129c19212
  droundedness4 :: PhonemeType2.Roundedness
  {- Strictness: b -}
29664856fe85cf8a8577b099cd74e8b4
  droundedness5 :: PhonemeType2.Roundedness
  {- Strictness: b -}
e44fc4477e0f0ae957d99b5ac25548d0
  dsymbol :: PhonemeType2.Phoneme -> GHC.Base.String
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.dsymbol1
                   PhonemeType2.Diphthong ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9
                   -> ds9 }) -}
9e16cf0ece1667a4931af271374f3b07
  dsymbol1 :: GHC.Base.String
  {- Strictness: b -}
8888ada7ecc01febf8587283fa5111ae
  getMorphemes :: PhonemeType2.Word -> [PhonemeType2.Morpheme]
  RecSel PhonemeType2.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Word ->
                 case ds of wild { PhonemeType2.Word ds1 -> ds1 }) -}
e6dcd411bfd7433c411b0864e87f8fcc
  getPhonemes :: PhonemeType2.Morpheme -> [PhonemeType2.Phoneme]
  RecSel PhonemeType2.Morpheme
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Morpheme ->
                 case ds of wild { PhonemeType2.Morpheme ds1 -> ds1 }) -}
43940230b63682313b298431f2cab7c8
  vbackness :: PhonemeType2.Phoneme -> PhonemeType2.Backness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.vbackness1
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 ds5 -> ds2 }) -}
bd07ad183d0ab2cde0956a6ba0fc7e0b
  vbackness1 :: PhonemeType2.Backness
  {- Strictness: b -}
4a6140aa1decacc8b8b6adad22e6bcfe
  vheight :: PhonemeType2.Phoneme -> PhonemeType2.Height
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.vheight1
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 ds5 -> ds1 }) -}
fcdf50ca6c8937ebd485d6b7748f5d58
  vheight1 :: PhonemeType2.Height
  {- Strictness: b -}
785a2f32836bebb1af8a2bce09f752e5
  vlength :: PhonemeType2.Phoneme -> PhonemeType2.Length
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.vlength1
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 ds5 -> ds4 }) -}
ca8ec92073e430405350086b8bd47b18
  vlength1 :: PhonemeType2.Length
  {- Strictness: b -}
0b4e4e2cefff7ef83125d7355dbe2c81
  vroundedness :: PhonemeType2.Phoneme -> PhonemeType2.Roundedness
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.vroundedness1
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 ds5 -> ds3 }) -}
49afbc41b51b4f00ab0770107273a422
  vroundedness1 :: PhonemeType2.Roundedness
  {- Strictness: b -}
04e5c1e7290d5155773319b75f6b2e4a
  vsymbol :: PhonemeType2.Phoneme -> GHC.Base.String
  RecSel PhonemeType2.Phoneme
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType2.Phoneme ->
                 case ds of wild {
                   DEFAULT -> PhonemeType2.vsymbol1
                   PhonemeType2.Vowel ds1 ds2 ds3 ds4 ds5 -> ds5 }) -}
6cbc0a16daaad9b6f40e6fda97729f25
  vsymbol1 :: GHC.Base.String
  {- Strictness: b -}
instance GHC.Enum.Bounded [PhonemeType2.Backness]
  = PhonemeType2.$fBoundedBackness
instance GHC.Enum.Bounded [PhonemeType2.Height]
  = PhonemeType2.$fBoundedHeight
instance GHC.Enum.Bounded [PhonemeType2.Length]
  = PhonemeType2.$fBoundedLength
instance GHC.Enum.Bounded [PhonemeType2.Manner]
  = PhonemeType2.$fBoundedManner
instance GHC.Enum.Bounded [PhonemeType2.Phonation]
  = PhonemeType2.$fBoundedPhonation
instance GHC.Enum.Bounded [PhonemeType2.Place]
  = PhonemeType2.$fBoundedPlace
instance GHC.Enum.Bounded [PhonemeType2.Roundedness]
  = PhonemeType2.$fBoundedRoundedness
instance GHC.Enum.Enum [PhonemeType2.Backness]
  = PhonemeType2.$fEnumBackness
instance GHC.Enum.Enum [PhonemeType2.Height]
  = PhonemeType2.$fEnumHeight
instance GHC.Enum.Enum [PhonemeType2.Length]
  = PhonemeType2.$fEnumLength
instance GHC.Enum.Enum [PhonemeType2.Manner]
  = PhonemeType2.$fEnumManner
instance GHC.Enum.Enum [PhonemeType2.Phonation]
  = PhonemeType2.$fEnumPhonation
instance GHC.Enum.Enum [PhonemeType2.Place]
  = PhonemeType2.$fEnumPlace
instance GHC.Enum.Enum [PhonemeType2.Roundedness]
  = PhonemeType2.$fEnumRoundedness
instance GHC.Classes.Eq [PhonemeType2.Backness]
  = PhonemeType2.$fEqBackness
instance GHC.Classes.Eq [PhonemeType2.Height]
  = PhonemeType2.$fEqHeight
instance GHC.Classes.Eq [PhonemeType2.Length]
  = PhonemeType2.$fEqLength
instance GHC.Classes.Eq [PhonemeType2.Manner]
  = PhonemeType2.$fEqManner
instance GHC.Classes.Eq [PhonemeType2.Morpheme]
  = PhonemeType2.$fEqMorpheme
instance GHC.Classes.Eq [PhonemeType2.Phonation]
  = PhonemeType2.$fEqPhonation
instance GHC.Classes.Eq [PhonemeType2.Phoneme]
  = PhonemeType2.$fEqPhoneme
instance GHC.Classes.Eq [PhonemeType2.Place]
  = PhonemeType2.$fEqPlace
instance GHC.Classes.Eq [PhonemeType2.Roundedness]
  = PhonemeType2.$fEqRoundedness
instance GHC.Classes.Eq [PhonemeType2.Word] = PhonemeType2.$fEqWord
instance GHC.Classes.Ord [PhonemeType2.Backness]
  = PhonemeType2.$fOrdBackness
instance GHC.Classes.Ord [PhonemeType2.Height]
  = PhonemeType2.$fOrdHeight
instance GHC.Classes.Ord [PhonemeType2.Length]
  = PhonemeType2.$fOrdLength
instance GHC.Classes.Ord [PhonemeType2.Manner]
  = PhonemeType2.$fOrdManner
instance GHC.Classes.Ord [PhonemeType2.Phonation]
  = PhonemeType2.$fOrdPhonation
instance GHC.Classes.Ord [PhonemeType2.Phoneme]
  = PhonemeType2.$fOrdPhoneme
instance GHC.Classes.Ord [PhonemeType2.Place]
  = PhonemeType2.$fOrdPlace
instance GHC.Classes.Ord [PhonemeType2.Roundedness]
  = PhonemeType2.$fOrdRoundedness
instance GHC.Read.Read [PhonemeType2.Backness]
  = PhonemeType2.$fReadBackness
instance GHC.Read.Read [PhonemeType2.Height]
  = PhonemeType2.$fReadHeight
instance GHC.Read.Read [PhonemeType2.Length]
  = PhonemeType2.$fReadLength
instance GHC.Read.Read [PhonemeType2.Manner]
  = PhonemeType2.$fReadManner
instance GHC.Read.Read [PhonemeType2.Morpheme]
  = PhonemeType2.$fReadMorpheme
instance GHC.Read.Read [PhonemeType2.Phonation]
  = PhonemeType2.$fReadPhonation
instance GHC.Read.Read [PhonemeType2.Phoneme]
  = PhonemeType2.$fReadPhoneme
instance GHC.Read.Read [PhonemeType2.Place]
  = PhonemeType2.$fReadPlace
instance GHC.Read.Read [PhonemeType2.Roundedness]
  = PhonemeType2.$fReadRoundedness
instance GHC.Read.Read [PhonemeType2.Word]
  = PhonemeType2.$fReadWord
instance GHC.Show.Show [PhonemeType2.Backness]
  = PhonemeType2.$fShowBackness
instance GHC.Show.Show [PhonemeType2.Height]
  = PhonemeType2.$fShowHeight
instance GHC.Show.Show [PhonemeType2.Length]
  = PhonemeType2.$fShowLength
instance GHC.Show.Show [PhonemeType2.Manner]
  = PhonemeType2.$fShowManner
instance GHC.Show.Show [PhonemeType2.Morpheme]
  = PhonemeType2.$fShowMorpheme
instance GHC.Show.Show [PhonemeType2.Phonation]
  = PhonemeType2.$fShowPhonation
instance GHC.Show.Show [PhonemeType2.Phoneme]
  = PhonemeType2.$fShowPhoneme
instance GHC.Show.Show [PhonemeType2.Place]
  = PhonemeType2.$fShowPlace
instance GHC.Show.Show [PhonemeType2.Roundedness]
  = PhonemeType2.$fShowRoundedness
instance GHC.Show.Show [PhonemeType2.Word]
  = PhonemeType2.$fShowWord
"SPEC/PhonemeType2 $dmreadsPrec @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Backness
  GHC.Read.$dmreadsPrec @ PhonemeType2.Backness $dRead
  = PhonemeType2.$fReadBackness_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeType2.Height
  GHC.Read.$dmreadsPrec @ PhonemeType2.Height $dRead
  = PhonemeType2.$fReadHeight_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Length" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeType2.Length
  GHC.Read.$dmreadsPrec @ PhonemeType2.Length $dRead
  = PhonemeType2.$fReadLength_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                      PhonemeType2.Manner
  GHC.Read.$dmreadsPrec @ PhonemeType2.Manner $dRead
  = PhonemeType2.$fReadManner_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Phonation" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Phonation
  GHC.Read.$dmreadsPrec @ PhonemeType2.Phonation $dRead
  = PhonemeType2.$fReadPhonation_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Phoneme" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeType2.Phoneme
  GHC.Read.$dmreadsPrec @ PhonemeType2.Phoneme $dRead
  = PhonemeType2.$fReadPhoneme_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeType2.Place
  GHC.Read.$dmreadsPrec @ PhonemeType2.Place $dRead
  = PhonemeType2.$fReadPlace_$s$dmreadsPrec
"SPEC/PhonemeType2 $dmreadsPrec @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                           PhonemeType2.Roundedness
  GHC.Read.$dmreadsPrec @ PhonemeType2.Roundedness $dRead
  = PhonemeType2.$fReadRoundedness_$s$dmreadsPrec
"SPEC/PhonemeType2 readListDefault @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                           PhonemeType2.Backness
  GHC.Read.readListDefault @ PhonemeType2.Backness $dRead
  = PhonemeType2.$fReadBackness_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Height
  GHC.Read.readListDefault @ PhonemeType2.Height $dRead
  = PhonemeType2.$fReadHeight_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Length" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Length
  GHC.Read.readListDefault @ PhonemeType2.Length $dRead
  = PhonemeType2.$fReadLength_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                         PhonemeType2.Manner
  GHC.Read.readListDefault @ PhonemeType2.Manner $dRead
  = PhonemeType2.$fReadManner_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Morpheme" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                           PhonemeType2.Morpheme
  GHC.Read.readListDefault @ PhonemeType2.Morpheme $dRead
  = PhonemeType2.$fReadMorpheme_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Phonation" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                            PhonemeType2.Phonation
  GHC.Read.readListDefault @ PhonemeType2.Phonation $dRead
  = PhonemeType2.$fReadPhonation_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Phoneme" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          PhonemeType2.Phoneme
  GHC.Read.readListDefault @ PhonemeType2.Phoneme $dRead
  = PhonemeType2.$fReadPhoneme_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType2.Place
  GHC.Read.readListDefault @ PhonemeType2.Place $dRead
  = PhonemeType2.$fReadPlace_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                              PhonemeType2.Roundedness
  GHC.Read.readListDefault @ PhonemeType2.Roundedness $dRead
  = PhonemeType2.$fReadRoundedness_$sreadListDefault
"SPEC/PhonemeType2 readListDefault @ Word" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeType2.Word
  GHC.Read.readListDefault @ PhonemeType2.Word $dRead
  = PhonemeType2.$fReadWord_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

