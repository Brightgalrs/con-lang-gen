
==================== FINAL INTERFACE ====================
2016-09-18 06:09:00.052726 UTC

interface conla_1eA9qWUPH9nBowcXqqaV8r:PhonemeType 7103
  interface hash: f4f4b7bb7cd74fd619bbf3e0c7ea908c
  ABI hash: ae499e04429789f68b804baafd2bc506
  export-list hash: 3ba39fd360b81c89e4deec0e37d35fd4
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  PhonemeType.Backness{PhonemeType.BACK PhonemeType.CENTRAL PhonemeType.FRONT PhonemeType.NEARBACK PhonemeType.NEARFRONT}
  PhonemeType.Height{PhonemeType.CLOSE PhonemeType.CLOSEMID PhonemeType.MID PhonemeType.NEARCLOSE PhonemeType.NEAROPEN PhonemeType.OPEN PhonemeType.OPENMID}
  PhonemeType.Manner{PhonemeType.AFFRICATE PhonemeType.APPROXIMANT PhonemeType.FLAP PhonemeType.FRICATIVE PhonemeType.LAFFRICATE PhonemeType.LAPPROXIMANT PhonemeType.LFLAP PhonemeType.LFRICATIVE PhonemeType.NASAL PhonemeType.STOP PhonemeType.TRILL}
  PhonemeType.MaybeConsonant{PhonemeType.Blank PhonemeType.Consonant PhonemeType.csymbol PhonemeType.manner PhonemeType.place PhonemeType.voice}
  PhonemeType.PhonemeInventory{PhonemeType.PhonemeInventory}
  PhonemeType.Place{PhonemeType.ALVEOLAR PhonemeType.ALVEOLOPALATAL PhonemeType.BILABIAL PhonemeType.DENTAL PhonemeType.GLOTTAL PhonemeType.LABIODENTAL PhonemeType.PALATAL PhonemeType.PALATOALVEOLAR PhonemeType.PHARYNGEAL PhonemeType.RETROFLEX PhonemeType.UVULAR PhonemeType.VELAR}
  PhonemeType.Roundedness{PhonemeType.ROUNDED PhonemeType.UNROUNDED}
  PhonemeType.Voice{PhonemeType.VOICED PhonemeType.VOICELESS}
  PhonemeType.Vowel{PhonemeType.Vowel PhonemeType.backness PhonemeType.height PhonemeType.roundedness PhonemeType.vsymbol}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.ParserCombinators.ReadPrec 2590e0e0a57a86ac7c62727f4d868dd2
import  -/  base-4.8.2.0:Text.Read.Lex 724ca44ddd38ddc5f47a501d62736c26
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
b87c0c3ee94d9a9392430cfc9b970753
  $fBoundedBackness :: GHC.Enum.Bounded PhonemeType.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness PhonemeType.BACK PhonemeType.FRONT -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fBoundedHeight :: GHC.Enum.Bounded PhonemeType.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height PhonemeType.CLOSE PhonemeType.OPEN -}
ad2ca82feee9cd68bab57395bd7db297
  $fBoundedManner :: GHC.Enum.Bounded PhonemeType.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner PhonemeType.NASAL PhonemeType.LFLAP -}
75666487cf3af3760456cef495e6a332
  $fBoundedPlace :: GHC.Enum.Bounded PhonemeType.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place PhonemeType.BILABIAL PhonemeType.GLOTTAL -}
731583abbaff278fb0f2c55475c6f2cd
  $fBoundedRoundedness :: GHC.Enum.Bounded PhonemeType.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.ROUNDED
                  PhonemeType.UNROUNDED -}
555397b244896c50401e55d764c2ad9e
  $fBoundedVoice :: GHC.Enum.Bounded PhonemeType.Voice
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Voice PhonemeType.VOICELESS PhonemeType.VOICED -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness :: GHC.Enum.Enum PhonemeType.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fEnumBackness_$csucc
                  PhonemeType.$fEnumBackness_$cpred
                  PhonemeType.$fEnumBackness_$ctoEnum
                  PhonemeType.$fEnumBackness_$cfromEnum
                  PhonemeType.$fEnumBackness_$cenumFrom
                  PhonemeType.$fEnumBackness_$cenumFromThen
                  PhonemeType.$fEnumBackness_$cenumFromTo
                  PhonemeType.$fEnumBackness_$cenumFromThenTo -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness1 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go5 4) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness2 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go6 3) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness3 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go7 2) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness4 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go8 1) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness5 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go9 0) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness6 :: GHC.Prim.Int# -> PhonemeType.Backness
  {- Arity: 1, Strictness: <L,U>b -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness7 :: PhonemeType.Backness
  {- Strictness: b -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness8 :: PhonemeType.Backness
  {- Strictness: b -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_$cenumFrom ::
    PhonemeType.Backness -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK -> PhonemeType.$fEnumBackness5
                   PhonemeType.NEARBACK -> PhonemeType.$fEnumBackness4
                   PhonemeType.CENTRAL -> PhonemeType.$fEnumBackness3
                   PhonemeType.NEARFRONT -> PhonemeType.$fEnumBackness2
                   PhonemeType.FRONT -> PhonemeType.$fEnumBackness1 }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_$cenumFromThen ::
    PhonemeType.Backness
    -> PhonemeType.Backness -> [PhonemeType.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Backness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Backness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Backness]
                                    PhonemeType.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType.Backness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Backness]
                                    PhonemeType.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType.Backness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 4 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.BACK -> $j1 0
                       PhonemeType.NEARBACK -> $j1 1
                       PhonemeType.CENTRAL -> $j1 2
                       PhonemeType.NEARFRONT -> $j1 3
                       PhonemeType.FRONT -> $j1 4 }
                 } in
                 case a8 of wild {
                   PhonemeType.BACK -> $j 0
                   PhonemeType.NEARBACK -> $j 1
                   PhonemeType.CENTRAL -> $j 2
                   PhonemeType.NEARFRONT -> $j 3
                   PhonemeType.FRONT -> $j 4 }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_$cenumFromThenTo ::
    PhonemeType.Backness
    -> PhonemeType.Backness
    -> PhonemeType.Backness
    -> [PhonemeType.Backness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_$cenumFromTo ::
    PhonemeType.Backness
    -> PhonemeType.Backness -> [PhonemeType.Backness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Backness
                   y :: PhonemeType.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.BACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness }
                       PhonemeType.NEARBACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness }
                       PhonemeType.CENTRAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness }
                       PhonemeType.NEARFRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness }
                       PhonemeType.FRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness } }
                 } in
                 case x of wild {
                   PhonemeType.BACK -> $j 0
                   PhonemeType.NEARBACK -> $j 1
                   PhonemeType.CENTRAL -> $j 2
                   PhonemeType.NEARFRONT -> $j 3
                   PhonemeType.FRONT -> $j 4 }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_$cfromEnum :: PhonemeType.Backness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType.Backness ->
                 case w of wild {
                   PhonemeType.BACK -> GHC.Types.I# 0
                   PhonemeType.NEARBACK -> GHC.Types.I# 1
                   PhonemeType.CENTRAL -> GHC.Types.I# 2
                   PhonemeType.NEARFRONT -> GHC.Types.I# 3
                   PhonemeType.FRONT -> GHC.Types.I# 4 }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_$cpred ::
    PhonemeType.Backness -> PhonemeType.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK -> PhonemeType.$fEnumBackness7
                   PhonemeType.NEARBACK -> PhonemeType.BACK
                   PhonemeType.CENTRAL -> PhonemeType.NEARBACK
                   PhonemeType.NEARFRONT -> PhonemeType.CENTRAL
                   PhonemeType.FRONT -> PhonemeType.NEARFRONT }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_$csucc ::
    PhonemeType.Backness -> PhonemeType.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK -> PhonemeType.NEARBACK
                   PhonemeType.NEARBACK -> PhonemeType.CENTRAL
                   PhonemeType.CENTRAL -> PhonemeType.NEARFRONT
                   PhonemeType.NEARFRONT -> PhonemeType.FRONT
                   PhonemeType.FRONT -> PhonemeType.$fEnumBackness8 }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_$ctoEnum :: GHC.Types.Int -> PhonemeType.Backness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 -> PhonemeType.$w$ctoEnum ww1 }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_c ::
    GHC.Types.Int -> [PhonemeType.Backness] -> [PhonemeType.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Backness] ->
                 GHC.Types.:
                   @ PhonemeType.Backness
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Backness a8 })
                   ys) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go1 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go2 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go3 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go4 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go5 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go6 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go7 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go8 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEnumBackness_go9 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight :: GHC.Enum.Enum PhonemeType.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fEnumHeight_$csucc
                  PhonemeType.$fEnumHeight_$cpred
                  PhonemeType.$fEnumHeight_$ctoEnum
                  PhonemeType.$fEnumHeight_$cfromEnum
                  PhonemeType.$fEnumHeight_$cenumFrom
                  PhonemeType.$fEnumHeight_$cenumFromThen
                  PhonemeType.$fEnumHeight_$cenumFromTo
                  PhonemeType.$fEnumHeight_$cenumFromThenTo -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight1 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go7 6) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight10 :: PhonemeType.Height
  {- Strictness: b -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight2 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go8 5) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight3 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go9 4) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight4 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go10 3) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight5 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go11 2) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight6 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go12 1) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight7 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go13 0) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight8 :: GHC.Prim.Int# -> PhonemeType.Height
  {- Arity: 1, Strictness: <L,U>b -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight9 :: PhonemeType.Height
  {- Strictness: b -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_$cenumFrom ::
    PhonemeType.Height -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Height ->
                 case a8 of wild {
                   PhonemeType.CLOSE -> PhonemeType.$fEnumHeight7
                   PhonemeType.NEARCLOSE -> PhonemeType.$fEnumHeight6
                   PhonemeType.CLOSEMID -> PhonemeType.$fEnumHeight5
                   PhonemeType.MID -> PhonemeType.$fEnumHeight4
                   PhonemeType.OPENMID -> PhonemeType.$fEnumHeight3
                   PhonemeType.NEAROPEN -> PhonemeType.$fEnumHeight2
                   PhonemeType.OPEN -> PhonemeType.$fEnumHeight1 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_$cenumFromThen ::
    PhonemeType.Height -> PhonemeType.Height -> [PhonemeType.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Height b :: PhonemeType.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Height]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Height]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Height]
                                    PhonemeType.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType.Height)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Height]
                                    PhonemeType.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType.Height)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.CLOSE -> $j1 0
                       PhonemeType.NEARCLOSE -> $j1 1
                       PhonemeType.CLOSEMID -> $j1 2
                       PhonemeType.MID -> $j1 3
                       PhonemeType.OPENMID -> $j1 4
                       PhonemeType.NEAROPEN -> $j1 5
                       PhonemeType.OPEN -> $j1 6 }
                 } in
                 case a8 of wild {
                   PhonemeType.CLOSE -> $j 0
                   PhonemeType.NEARCLOSE -> $j 1
                   PhonemeType.CLOSEMID -> $j 2
                   PhonemeType.MID -> $j 3
                   PhonemeType.OPENMID -> $j 4
                   PhonemeType.NEAROPEN -> $j 5
                   PhonemeType.OPEN -> $j 6 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_$cenumFromThenTo ::
    PhonemeType.Height
    -> PhonemeType.Height -> PhonemeType.Height -> [PhonemeType.Height]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_$cenumFromTo ::
    PhonemeType.Height -> PhonemeType.Height -> [PhonemeType.Height]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Height y :: PhonemeType.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.CLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.NEARCLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.CLOSEMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.MID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.OPENMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.NEAROPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.OPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height } }
                 } in
                 case x of wild {
                   PhonemeType.CLOSE -> $j 0
                   PhonemeType.NEARCLOSE -> $j 1
                   PhonemeType.CLOSEMID -> $j 2
                   PhonemeType.MID -> $j 3
                   PhonemeType.OPENMID -> $j 4
                   PhonemeType.NEAROPEN -> $j 5
                   PhonemeType.OPEN -> $j 6 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_$cfromEnum :: PhonemeType.Height -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType.Height ->
                 case w of wild {
                   PhonemeType.CLOSE -> GHC.Types.I# 0
                   PhonemeType.NEARCLOSE -> GHC.Types.I# 1
                   PhonemeType.CLOSEMID -> GHC.Types.I# 2
                   PhonemeType.MID -> GHC.Types.I# 3
                   PhonemeType.OPENMID -> GHC.Types.I# 4
                   PhonemeType.NEAROPEN -> GHC.Types.I# 5
                   PhonemeType.OPEN -> GHC.Types.I# 6 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_$cpred :: PhonemeType.Height -> PhonemeType.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Height ->
                 case a8 of wild {
                   PhonemeType.CLOSE -> PhonemeType.$fEnumHeight9
                   PhonemeType.NEARCLOSE -> PhonemeType.CLOSE
                   PhonemeType.CLOSEMID -> PhonemeType.NEARCLOSE
                   PhonemeType.MID -> PhonemeType.CLOSEMID
                   PhonemeType.OPENMID -> PhonemeType.MID
                   PhonemeType.NEAROPEN -> PhonemeType.OPENMID
                   PhonemeType.OPEN -> PhonemeType.NEAROPEN }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_$csucc :: PhonemeType.Height -> PhonemeType.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Height ->
                 case a8 of wild {
                   PhonemeType.CLOSE -> PhonemeType.NEARCLOSE
                   PhonemeType.NEARCLOSE -> PhonemeType.CLOSEMID
                   PhonemeType.CLOSEMID -> PhonemeType.MID
                   PhonemeType.MID -> PhonemeType.OPENMID
                   PhonemeType.OPENMID -> PhonemeType.NEAROPEN
                   PhonemeType.NEAROPEN -> PhonemeType.OPEN
                   PhonemeType.OPEN -> PhonemeType.$fEnumHeight10 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_$ctoEnum :: GHC.Types.Int -> PhonemeType.Height
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum1 ww1 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_c ::
    GHC.Types.Int -> [PhonemeType.Height] -> [PhonemeType.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Height] ->
                 GHC.Types.:
                   @ PhonemeType.Height
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Height a8 })
                   ys) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go1 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go10 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go11 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go12 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go13 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go2 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go3 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go4 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go5 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go6 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go7 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go8 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEnumHeight_go9 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner :: GHC.Enum.Enum PhonemeType.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner
                  PhonemeType.$fEnumManner_$csucc
                  PhonemeType.$fEnumManner_$cpred
                  PhonemeType.$fEnumManner_$ctoEnum
                  PhonemeType.$fEnumManner_$cfromEnum
                  PhonemeType.$fEnumManner_$cenumFrom
                  PhonemeType.$fEnumManner_$cenumFromThen
                  PhonemeType.$fEnumManner_$cenumFromTo
                  PhonemeType.$fEnumManner_$cenumFromThenTo -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner1 :: GHC.Prim.Int# -> PhonemeType.Manner
  {- Arity: 1, Strictness: <L,U>b -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner2 :: PhonemeType.Manner
  {- Strictness: b -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner3 :: PhonemeType.Manner
  {- Strictness: b -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_$cenumFrom ::
    PhonemeType.Manner -> [PhonemeType.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 10) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumManner_go x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType.Manner } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_$cenumFromThen ::
    PhonemeType.Manner -> PhonemeType.Manner -> [PhonemeType.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x1
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Manner]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeType.Manner]
                            PhonemeType.$fEnumManner_c1
                            (GHC.Types.[] @ PhonemeType.Manner)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeType.Manner]
                            PhonemeType.$fEnumManner_c1
                            (GHC.Types.[] @ PhonemeType.Manner)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 10 GHC.Types.True -> $j 0 } } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_$cenumFromThenTo ::
    PhonemeType.Manner
    -> PhonemeType.Manner -> PhonemeType.Manner -> [PhonemeType.Manner]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Manner
                   x2 :: PhonemeType.Manner
                   y :: PhonemeType.Manner ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeType.Manner]
                        PhonemeType.$fEnumManner_c
                        (GHC.Types.[] @ PhonemeType.Manner)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType.Manner x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeType.Manner]
                        PhonemeType.$fEnumManner_c
                        (GHC.Types.[] @ PhonemeType.Manner)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType.Manner x6) } } } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_$cenumFromTo ::
    PhonemeType.Manner -> PhonemeType.Manner -> [PhonemeType.Manner]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Manner y :: PhonemeType.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go16 :: GHC.Prim.Int# -> [PhonemeType.Manner]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeType.Manner
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeType.$fEnumManner1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 10) of wild2 {
                                    GHC.Types.False -> PhonemeType.$fEnumManner1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeType.Manner x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go16 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeType.Manner })
                      } in
                      go16 x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType.Manner } } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_$cfromEnum :: PhonemeType.Manner -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ PhonemeType.Manner x1) }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_$cpred :: PhonemeType.Manner -> PhonemeType.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType.Manner (GHC.Prim.+# wild (-1))
                   0 -> PhonemeType.$fEnumManner2 } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_$csucc :: PhonemeType.Manner -> PhonemeType.Manner
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType.Manner x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType.Manner (GHC.Prim.+# wild 1)
                   10 -> PhonemeType.$fEnumManner3 } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_$ctoEnum :: GHC.Types.Int -> PhonemeType.Manner
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum2 ww1 }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_c ::
    GHC.Types.Int -> [PhonemeType.Manner] -> [PhonemeType.Manner]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Manner] ->
                 GHC.Types.:
                   @ PhonemeType.Manner
                   (PhonemeType.$fEnumManner_$ctoEnum x)
                   ys) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_c1 ::
    GHC.Types.Int -> [PhonemeType.Manner] -> [PhonemeType.Manner]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Manner] ->
                 GHC.Types.:
                   @ PhonemeType.Manner
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Manner a8 })
                   ys) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEnumManner_go :: GHC.Prim.Int# -> [PhonemeType.Manner]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace :: GHC.Enum.Enum PhonemeType.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place
                  PhonemeType.$fEnumPlace_$csucc
                  PhonemeType.$fEnumPlace_$cpred
                  PhonemeType.$fEnumPlace_$ctoEnum
                  PhonemeType.$fEnumPlace_$cfromEnum
                  PhonemeType.$fEnumPlace_$cenumFrom
                  PhonemeType.$fEnumPlace_$cenumFromThen
                  PhonemeType.$fEnumPlace_$cenumFromTo
                  PhonemeType.$fEnumPlace_$cenumFromThenTo -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace1 :: GHC.Prim.Int# -> PhonemeType.Place
  {- Arity: 1, Strictness: <L,U>b -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace2 :: PhonemeType.Place
  {- Strictness: b -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace3 :: PhonemeType.Place
  {- Strictness: b -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_$cenumFrom :: PhonemeType.Place -> [PhonemeType.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 11) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumPlace_go x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType.Place } }) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_$cenumFromThen ::
    PhonemeType.Place -> PhonemeType.Place -> [PhonemeType.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                 } in
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Place]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeType.Place]
                            PhonemeType.$fEnumPlace_c1
                            (GHC.Types.[] @ PhonemeType.Place)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeType.Place]
                            PhonemeType.$fEnumPlace_c1
                            (GHC.Types.[] @ PhonemeType.Place)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 11 GHC.Types.True -> $j 0 } } }) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_$cenumFromThenTo ::
    PhonemeType.Place
    -> PhonemeType.Place -> PhonemeType.Place -> [PhonemeType.Place]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Place
                   x2 :: PhonemeType.Place
                   y :: PhonemeType.Place ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeType.Place]
                        PhonemeType.$fEnumPlace_c
                        (GHC.Types.[] @ PhonemeType.Place)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType.Place x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeType.Place]
                        PhonemeType.$fEnumPlace_c
                        (GHC.Types.[] @ PhonemeType.Place)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType.Place x6) } } } }) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_$cenumFromTo ::
    PhonemeType.Place -> PhonemeType.Place -> [PhonemeType.Place]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Place y :: PhonemeType.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go16 :: GHC.Prim.Int# -> [PhonemeType.Place]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeType.Place
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeType.$fEnumPlace1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 11) of wild2 {
                                    GHC.Types.False -> PhonemeType.$fEnumPlace1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeType.Place x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go16 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeType.Place })
                      } in
                      go16 x0
                   GHC.Types.True -> GHC.Types.[] @ PhonemeType.Place } } }) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_$cfromEnum :: PhonemeType.Place -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.dataToTag# @ PhonemeType.Place x1) }) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_$cpred :: PhonemeType.Place -> PhonemeType.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType.Place (GHC.Prim.+# wild (-1))
                   0 -> PhonemeType.$fEnumPlace2 } }) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_$csucc :: PhonemeType.Place -> PhonemeType.Place
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag# @ PhonemeType.Place x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum# @ PhonemeType.Place (GHC.Prim.+# wild 1)
                   11 -> PhonemeType.$fEnumPlace3 } }) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_$ctoEnum :: GHC.Types.Int -> PhonemeType.Place
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum3 ww1 }) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_c ::
    GHC.Types.Int -> [PhonemeType.Place] -> [PhonemeType.Place]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Place] ->
                 GHC.Types.:
                   @ PhonemeType.Place
                   (PhonemeType.$fEnumPlace_$ctoEnum x)
                   ys) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_c1 ::
    GHC.Types.Int -> [PhonemeType.Place] -> [PhonemeType.Place]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Place] ->
                 GHC.Types.:
                   @ PhonemeType.Place
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Place a8 })
                   ys) -}
75666487cf3af3760456cef495e6a332
  $fEnumPlace_go :: GHC.Prim.Int# -> [PhonemeType.Place]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness :: GHC.Enum.Enum PhonemeType.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fEnumRoundedness_$csucc
                  PhonemeType.$fEnumRoundedness_$cpred
                  PhonemeType.$fEnumRoundedness_$ctoEnum
                  PhonemeType.$fEnumRoundedness_$cfromEnum
                  PhonemeType.$fEnumRoundedness_$cenumFrom
                  PhonemeType.$fEnumRoundedness_$cenumFromThen
                  PhonemeType.$fEnumRoundedness_$cenumFromTo
                  PhonemeType.$fEnumRoundedness_$cenumFromThenTo -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness1 :: GHC.Prim.Int# -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <L,U>b -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness2 :: [PhonemeType.Roundedness]
  {- Unfolding: (PhonemeType.$fEnumRoundedness_go2 1) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness3 :: [PhonemeType.Roundedness]
  {- Unfolding: (PhonemeType.$fEnumRoundedness_go3 0) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness4 :: PhonemeType.Roundedness
  {- Strictness: b -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness5 :: PhonemeType.Roundedness
  {- Strictness: b -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_$cenumFrom ::
    PhonemeType.Roundedness -> [PhonemeType.Roundedness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED -> PhonemeType.$fEnumRoundedness3
                   PhonemeType.UNROUNDED -> PhonemeType.$fEnumRoundedness2 }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_$cenumFromThen ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> [PhonemeType.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Roundedness
                   b :: PhonemeType.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Roundedness]
                                    PhonemeType.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType.Roundedness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Roundedness]
                                    PhonemeType.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType.Roundedness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.ROUNDED -> $j1 0 PhonemeType.UNROUNDED -> $j1 1 }
                 } in
                 case a8 of wild {
                   PhonemeType.ROUNDED -> $j 0 PhonemeType.UNROUNDED -> $j 1 }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_$cenumFromThenTo ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness
    -> PhonemeType.Roundedness
    -> [PhonemeType.Roundedness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Roundedness
                   x2 :: PhonemeType.Roundedness
                   y :: PhonemeType.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.ROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Roundedness]
                                     PhonemeType.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType.Roundedness)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Roundedness]
                                     PhonemeType.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType.Roundedness)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.UNROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Roundedness]
                                     PhonemeType.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType.Roundedness)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Roundedness]
                                     PhonemeType.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType.Roundedness)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType.ROUNDED -> $j1 0 PhonemeType.UNROUNDED -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType.ROUNDED -> $j 0 PhonemeType.UNROUNDED -> $j 1 }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_$cenumFromTo ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> [PhonemeType.Roundedness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Roundedness
                   y :: PhonemeType.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.ROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumRoundedness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Roundedness }
                       PhonemeType.UNROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumRoundedness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Roundedness } }
                 } in
                 case x of wild {
                   PhonemeType.ROUNDED -> $j 0 PhonemeType.UNROUNDED -> $j 1 }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_$cfromEnum ::
    PhonemeType.Roundedness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED -> GHC.Types.I# 0
                   PhonemeType.UNROUNDED -> GHC.Types.I# 1 }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_$cpred ::
    PhonemeType.Roundedness -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED -> PhonemeType.$fEnumRoundedness4
                   PhonemeType.UNROUNDED -> PhonemeType.ROUNDED }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_$csucc ::
    PhonemeType.Roundedness -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED -> PhonemeType.UNROUNDED
                   PhonemeType.UNROUNDED -> PhonemeType.$fEnumRoundedness5 }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_$ctoEnum ::
    GHC.Types.Int -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum4 ww1 }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_c ::
    GHC.Types.Int
    -> [PhonemeType.Roundedness] -> [PhonemeType.Roundedness]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType.Roundedness
                   (PhonemeType.$fEnumRoundedness_$ctoEnum x)
                   ys) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_c1 ::
    GHC.Types.Int
    -> [PhonemeType.Roundedness] -> [PhonemeType.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType.Roundedness
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Roundedness a8 })
                   ys) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_go :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_go1 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_go2 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
731583abbaff278fb0f2c55475c6f2cd
  $fEnumRoundedness_go3 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice :: GHC.Enum.Enum PhonemeType.Voice
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Voice
                  PhonemeType.$fEnumVoice_$csucc
                  PhonemeType.$fEnumVoice_$cpred
                  PhonemeType.$fEnumVoice_$ctoEnum
                  PhonemeType.$fEnumVoice_$cfromEnum
                  PhonemeType.$fEnumVoice_$cenumFrom
                  PhonemeType.$fEnumVoice_$cenumFromThen
                  PhonemeType.$fEnumVoice_$cenumFromTo
                  PhonemeType.$fEnumVoice_$cenumFromThenTo -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice1 :: GHC.Prim.Int# -> PhonemeType.Voice
  {- Arity: 1, Strictness: <L,U>b -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice2 :: [PhonemeType.Voice]
  {- Unfolding: (PhonemeType.$fEnumVoice_go2 1) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice3 :: [PhonemeType.Voice]
  {- Unfolding: (PhonemeType.$fEnumVoice_go3 0) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice4 :: PhonemeType.Voice
  {- Strictness: b -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice5 :: PhonemeType.Voice
  {- Strictness: b -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_$cenumFrom :: PhonemeType.Voice -> [PhonemeType.Voice]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS -> PhonemeType.$fEnumVoice3
                   PhonemeType.VOICED -> PhonemeType.$fEnumVoice2 }) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_$cenumFromThen ::
    PhonemeType.Voice -> PhonemeType.Voice -> [PhonemeType.Voice]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Voice b :: PhonemeType.Voice ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Voice]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Voice]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Voice]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Voice]
                                    PhonemeType.$fEnumVoice_c1
                                    (GHC.Types.[] @ PhonemeType.Voice)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Voice]
                                    PhonemeType.$fEnumVoice_c1
                                    (GHC.Types.[] @ PhonemeType.Voice)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.VOICELESS -> $j1 0 PhonemeType.VOICED -> $j1 1 }
                 } in
                 case a8 of wild {
                   PhonemeType.VOICELESS -> $j 0 PhonemeType.VOICED -> $j 1 }) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_$cenumFromThenTo ::
    PhonemeType.Voice
    -> PhonemeType.Voice -> PhonemeType.Voice -> [PhonemeType.Voice]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Voice
                   x2 :: PhonemeType.Voice
                   y :: PhonemeType.Voice ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Voice]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Voice]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.VOICELESS
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Voice]
                                     PhonemeType.$fEnumVoice_c
                                     (GHC.Types.[] @ PhonemeType.Voice)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Voice]
                                     PhonemeType.$fEnumVoice_c
                                     (GHC.Types.[] @ PhonemeType.Voice)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.VOICED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Voice]
                                     PhonemeType.$fEnumVoice_c
                                     (GHC.Types.[] @ PhonemeType.Voice)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Voice]
                                     PhonemeType.$fEnumVoice_c
                                     (GHC.Types.[] @ PhonemeType.Voice)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType.VOICELESS -> $j1 0 PhonemeType.VOICED -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType.VOICELESS -> $j 0 PhonemeType.VOICED -> $j 1 }) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_$cenumFromTo ::
    PhonemeType.Voice -> PhonemeType.Voice -> [PhonemeType.Voice]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Voice y :: PhonemeType.Voice ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Voice]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.VOICELESS
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumVoice_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Voice }
                       PhonemeType.VOICED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumVoice_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Voice } }
                 } in
                 case x of wild {
                   PhonemeType.VOICELESS -> $j 0 PhonemeType.VOICED -> $j 1 }) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_$cfromEnum :: PhonemeType.Voice -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS -> GHC.Types.I# 0
                   PhonemeType.VOICED -> GHC.Types.I# 1 }) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_$cpred :: PhonemeType.Voice -> PhonemeType.Voice
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS -> PhonemeType.$fEnumVoice4
                   PhonemeType.VOICED -> PhonemeType.VOICELESS }) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_$csucc :: PhonemeType.Voice -> PhonemeType.Voice
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a8 :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS -> PhonemeType.VOICED
                   PhonemeType.VOICED -> PhonemeType.$fEnumVoice5 }) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_$ctoEnum :: GHC.Types.Int -> PhonemeType.Voice
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum5 ww1 }) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_c ::
    GHC.Types.Int -> [PhonemeType.Voice] -> [PhonemeType.Voice]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Voice] ->
                 GHC.Types.:
                   @ PhonemeType.Voice
                   (PhonemeType.$fEnumVoice_$ctoEnum x)
                   ys) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_c1 ::
    GHC.Types.Int -> [PhonemeType.Voice] -> [PhonemeType.Voice]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Voice] ->
                 GHC.Types.:
                   @ PhonemeType.Voice
                   (case x of wild { GHC.Types.I# a8 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Voice a8 })
                   ys) -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_go :: GHC.Prim.Int# -> [PhonemeType.Voice]
  {- Arity: 1, Strictness: <L,U> -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_go1 :: GHC.Prim.Int# -> [PhonemeType.Voice]
  {- Arity: 1, Strictness: <L,U> -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_go2 :: GHC.Prim.Int# -> [PhonemeType.Voice]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
555397b244896c50401e55d764c2ad9e
  $fEnumVoice_go3 :: GHC.Prim.Int# -> [PhonemeType.Voice]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEqBackness :: GHC.Classes.Eq PhonemeType.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fEqBackness_$c==
                  PhonemeType.$fEqBackness_$c/= -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEqBackness_$c/= ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.BACK -> GHC.Types.False }
                   PhonemeType.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.NEARBACK -> GHC.Types.False }
                   PhonemeType.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.CENTRAL -> GHC.Types.False }
                   PhonemeType.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.NEARFRONT -> GHC.Types.False }
                   PhonemeType.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.False } }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fEqBackness_$c== ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType.Backness
                   ds1 :: PhonemeType.Backness ->
                 case ds of wild {
                   PhonemeType.BACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.BACK -> GHC.Types.True }
                   PhonemeType.NEARBACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.NEARBACK -> GHC.Types.True }
                   PhonemeType.CENTRAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.CENTRAL -> GHC.Types.True }
                   PhonemeType.NEARFRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEARFRONT -> GHC.Types.True }
                   PhonemeType.FRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.True } }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEqHeight :: GHC.Classes.Eq PhonemeType.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fEqHeight_$c==
                  PhonemeType.$fEqHeight_$c/= -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEqHeight_$c/= ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Height b :: PhonemeType.Height ->
                 case a8 of wild {
                   PhonemeType.CLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.CLOSE -> GHC.Types.False }
                   PhonemeType.NEARCLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.NEARCLOSE -> GHC.Types.False }
                   PhonemeType.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.CLOSEMID -> GHC.Types.False }
                   PhonemeType.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.MID -> GHC.Types.False }
                   PhonemeType.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.OPENMID -> GHC.Types.False }
                   PhonemeType.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.NEAROPEN -> GHC.Types.False }
                   PhonemeType.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.OPEN -> GHC.Types.False } }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fEqHeight_$c== ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType.Height ds1 :: PhonemeType.Height ->
                 case ds of wild {
                   PhonemeType.CLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.CLOSE -> GHC.Types.True }
                   PhonemeType.NEARCLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEARCLOSE -> GHC.Types.True }
                   PhonemeType.CLOSEMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.CLOSEMID -> GHC.Types.True }
                   PhonemeType.MID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.MID -> GHC.Types.True }
                   PhonemeType.OPENMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.OPENMID -> GHC.Types.True }
                   PhonemeType.NEAROPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.NEAROPEN -> GHC.Types.True }
                   PhonemeType.OPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.OPEN -> GHC.Types.True } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEqManner :: GHC.Classes.Eq PhonemeType.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner
                  PhonemeType.$fEqManner_$c==
                  PhonemeType.$fEqManner_$c/= -}
ad2ca82feee9cd68bab57395bd7db297
  $fEqManner_$c/= ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeType.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType.Manner x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fEqManner_$c== ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x2)) } }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fEqMaybeConsonant :: GHC.Classes.Eq PhonemeType.MaybeConsonant
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.MaybeConsonant
                  PhonemeType.$fEqMaybeConsonant_$c==
                  PhonemeType.$fEqMaybeConsonant_$c/= -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fEqMaybeConsonant_$c/= ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.MaybeConsonant
                   b :: PhonemeType.MaybeConsonant ->
                 case PhonemeType.$fEqMaybeConsonant_$c== a8 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fEqMaybeConsonant_$c== ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType.MaybeConsonant
                   ds1 :: PhonemeType.MaybeConsonant ->
                 case ds of wild {
                   PhonemeType.Consonant a8 a9 a10 a11
                   -> case ds1 of wild1 {
                        PhonemeType.Consonant b1 b2 b3 b4
                        -> case a8 of x1 { DEFAULT ->
                           case b1 of x2 { DEFAULT ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==#
                                     (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                                     (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case a9 of x3 { DEFAULT ->
                                case b2 of x4 { DEFAULT ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==#
                                          (GHC.Prim.dataToTag# @ PhonemeType.Manner x3)
                                          (GHC.Prim.dataToTag# @ PhonemeType.Manner x4)) of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case a10 of wild4 {
                                       PhonemeType.VOICELESS
                                       -> case b3 of wild5 {
                                            PhonemeType.VOICELESS -> GHC.Base.eqString a11 b4
                                            PhonemeType.VOICED -> GHC.Types.False }
                                       PhonemeType.VOICED
                                       -> case b3 of wild5 {
                                            PhonemeType.VOICELESS -> GHC.Types.False
                                            PhonemeType.VOICED
                                            -> GHC.Base.eqString a11 b4 } } } } } } } }
                        PhonemeType.Blank -> GHC.Types.False }
                   PhonemeType.Blank
                   -> case ds1 of wild1 {
                        PhonemeType.Consonant ipv ipv1 ipv2 ipv3 -> GHC.Types.False
                        PhonemeType.Blank -> GHC.Types.True } }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fEqPhonemeInventory :: GHC.Classes.Eq PhonemeType.PhonemeInventory
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PhonemeInventory
                  PhonemeType.$fEqPhonemeInventory_$c==
                  PhonemeType.$fEqPhonemeInventory_$c/= -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fEqPhonemeInventory_$c/= ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.PhonemeInventory
                   b :: PhonemeType.PhonemeInventory ->
                 case PhonemeType.$fEqPhonemeInventory_$c== a8 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fEqPhonemeInventory_$c== ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.PhonemeInventory
                   w1 :: PhonemeType.PhonemeInventory ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.PhonemeInventory ww4 ww5 ->
                 PhonemeType.$w$c== ww1 ww2 ww4 ww5 } }) -}
75666487cf3af3760456cef495e6a332
  $fEqPlace :: GHC.Classes.Eq PhonemeType.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place
                  PhonemeType.$fEqPlace_$c==
                  PhonemeType.$fEqPlace_$c/= -}
75666487cf3af3760456cef495e6a332
  $fEqPlace_$c/= ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
75666487cf3af3760456cef495e6a332
  $fEqPlace_$c== ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEqRoundedness :: GHC.Classes.Eq PhonemeType.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fEqRoundedness_$c==
                  PhonemeType.$fEqRoundedness_$c/= -}
731583abbaff278fb0f2c55475c6f2cd
  $fEqRoundedness_$c/= ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Roundedness b :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED
                   -> case b of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.False
                        PhonemeType.UNROUNDED -> GHC.Types.True }
                   PhonemeType.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.True
                        PhonemeType.UNROUNDED -> GHC.Types.False } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fEqRoundedness_$c== ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Roundedness ds1 :: PhonemeType.Roundedness ->
                 case ds of wild {
                   PhonemeType.ROUNDED
                   -> case ds1 of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.True
                        PhonemeType.UNROUNDED -> GHC.Types.False }
                   PhonemeType.UNROUNDED
                   -> case ds1 of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.False
                        PhonemeType.UNROUNDED -> GHC.Types.True } }) -}
555397b244896c50401e55d764c2ad9e
  $fEqVoice :: GHC.Classes.Eq PhonemeType.Voice
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Voice
                  PhonemeType.$fEqVoice_$c==
                  PhonemeType.$fEqVoice_$c/= -}
555397b244896c50401e55d764c2ad9e
  $fEqVoice_$c/= ::
    PhonemeType.Voice -> PhonemeType.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Voice b :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS
                   -> case b of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.False
                        PhonemeType.VOICED -> GHC.Types.True }
                   PhonemeType.VOICED
                   -> case b of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.True
                        PhonemeType.VOICED -> GHC.Types.False } }) -}
555397b244896c50401e55d764c2ad9e
  $fEqVoice_$c== ::
    PhonemeType.Voice -> PhonemeType.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Voice ds1 :: PhonemeType.Voice ->
                 case ds of wild {
                   PhonemeType.VOICELESS
                   -> case ds1 of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.True
                        PhonemeType.VOICED -> GHC.Types.False }
                   PhonemeType.VOICED
                   -> case ds1 of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.False
                        PhonemeType.VOICED -> GHC.Types.True } }) -}
e51938fc3a28180cc0e71906aef6982c
  $fEqVowel :: GHC.Classes.Eq PhonemeType.Vowel
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Vowel
                  PhonemeType.$fEqVowel_$c==
                  PhonemeType.$fEqVowel_$c/= -}
e51938fc3a28180cc0e71906aef6982c
  $fEqVowel_$c/= ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Vowel b :: PhonemeType.Vowel ->
                 case PhonemeType.$fEqVowel_$c== a8 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e51938fc3a28180cc0e71906aef6982c
  $fEqVowel_$c== ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Vowel w1 :: PhonemeType.Vowel ->
                 case w of ww { PhonemeType.Vowel ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { PhonemeType.Vowel ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$c==1 ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fOrdBackness :: GHC.Classes.Ord PhonemeType.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fEqBackness
                  PhonemeType.$fOrdBackness_$ccompare
                  PhonemeType.$fOrdBackness_$c<
                  PhonemeType.$fOrdBackness_$c<=
                  PhonemeType.$fOrdBackness_$c>
                  PhonemeType.$fOrdBackness_$c>=
                  PhonemeType.$fOrdBackness_$cmax
                  PhonemeType.$fOrdBackness_$cmin -}
b87c0c3ee94d9a9392430cfc9b970753
  $fOrdBackness_$c< ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK
                   -> case b of wild1 {
                        PhonemeType.BACK -> GHC.Types.False
                        PhonemeType.NEARBACK -> GHC.Types.True
                        PhonemeType.CENTRAL -> GHC.Types.True
                        PhonemeType.NEARFRONT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.True }
                   PhonemeType.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.CENTRAL -> GHC.Types.True
                        PhonemeType.NEARFRONT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.True }
                   PhonemeType.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEARFRONT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.True }
                   PhonemeType.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.FRONT -> GHC.Types.True }
                   PhonemeType.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fOrdBackness_$c<= ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType.NEARBACK
                   -> case b of wild1 {
                        PhonemeType.BACK -> GHC.Types.False
                        PhonemeType.NEARBACK -> GHC.Types.True
                        PhonemeType.CENTRAL -> GHC.Types.True
                        PhonemeType.NEARFRONT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.True }
                   PhonemeType.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.CENTRAL -> GHC.Types.True
                        PhonemeType.NEARFRONT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.True }
                   PhonemeType.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEARFRONT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.True }
                   PhonemeType.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.True } }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fOrdBackness_$c> ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType.NEARBACK
                   -> case b of wild1 {
                        PhonemeType.BACK -> GHC.Types.True
                        PhonemeType.NEARBACK -> GHC.Types.False
                        PhonemeType.CENTRAL -> GHC.Types.False
                        PhonemeType.NEARFRONT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.False }
                   PhonemeType.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.CENTRAL -> GHC.Types.False
                        PhonemeType.NEARFRONT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.False }
                   PhonemeType.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.NEARFRONT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.False }
                   PhonemeType.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.False } }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fOrdBackness_$c>= ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK
                   -> case b of wild1 {
                        PhonemeType.BACK -> GHC.Types.True
                        PhonemeType.NEARBACK -> GHC.Types.False
                        PhonemeType.CENTRAL -> GHC.Types.False
                        PhonemeType.NEARFRONT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.False }
                   PhonemeType.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.CENTRAL -> GHC.Types.False
                        PhonemeType.NEARFRONT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.False }
                   PhonemeType.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.NEARFRONT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.False }
                   PhonemeType.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.FRONT -> GHC.Types.False }
                   PhonemeType.FRONT
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fOrdBackness_$ccompare ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 case a8 of wild {
                   PhonemeType.BACK
                   -> case b of wild1 {
                        PhonemeType.BACK -> GHC.Types.EQ
                        PhonemeType.NEARBACK -> GHC.Types.LT
                        PhonemeType.CENTRAL -> GHC.Types.LT
                        PhonemeType.NEARFRONT -> GHC.Types.LT
                        PhonemeType.FRONT -> GHC.Types.LT }
                   PhonemeType.NEARBACK
                   -> case b of wild1 {
                        PhonemeType.BACK -> GHC.Types.GT
                        PhonemeType.NEARBACK -> GHC.Types.EQ
                        PhonemeType.CENTRAL -> GHC.Types.LT
                        PhonemeType.NEARFRONT -> GHC.Types.LT
                        PhonemeType.FRONT -> GHC.Types.LT }
                   PhonemeType.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType.CENTRAL -> GHC.Types.EQ
                        PhonemeType.NEARFRONT -> GHC.Types.LT
                        PhonemeType.FRONT -> GHC.Types.LT }
                   PhonemeType.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType.NEARFRONT -> GHC.Types.EQ
                        PhonemeType.FRONT -> GHC.Types.LT }
                   PhonemeType.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeType.FRONT -> GHC.Types.EQ } }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fOrdBackness_$cmax ::
    PhonemeType.Backness
    -> PhonemeType.Backness -> PhonemeType.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Backness
                   y :: PhonemeType.Backness ->
                 case x of wild {
                   PhonemeType.BACK -> y
                   PhonemeType.NEARBACK
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType.NEARBACK
                        PhonemeType.CENTRAL -> PhonemeType.CENTRAL
                        PhonemeType.NEARFRONT -> PhonemeType.NEARFRONT
                        PhonemeType.FRONT -> PhonemeType.FRONT }
                   PhonemeType.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType.CENTRAL
                        PhonemeType.NEARFRONT -> PhonemeType.NEARFRONT
                        PhonemeType.FRONT -> PhonemeType.FRONT }
                   PhonemeType.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> PhonemeType.NEARFRONT
                        PhonemeType.FRONT -> PhonemeType.FRONT }
                   PhonemeType.FRONT
                   -> case y of wild1 { DEFAULT -> PhonemeType.FRONT } }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fOrdBackness_$cmin ::
    PhonemeType.Backness
    -> PhonemeType.Backness -> PhonemeType.Backness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Backness
                   y :: PhonemeType.Backness ->
                 case x of wild {
                   PhonemeType.BACK -> case y of wild1 { DEFAULT -> PhonemeType.BACK }
                   PhonemeType.NEARBACK
                   -> case y of wild1 {
                        PhonemeType.BACK -> PhonemeType.BACK
                        PhonemeType.NEARBACK -> PhonemeType.NEARBACK
                        PhonemeType.CENTRAL -> PhonemeType.NEARBACK
                        PhonemeType.NEARFRONT -> PhonemeType.NEARBACK
                        PhonemeType.FRONT -> PhonemeType.NEARBACK }
                   PhonemeType.CENTRAL
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        PhonemeType.CENTRAL -> PhonemeType.CENTRAL
                        PhonemeType.NEARFRONT -> PhonemeType.CENTRAL
                        PhonemeType.FRONT -> PhonemeType.CENTRAL }
                   PhonemeType.NEARFRONT
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        PhonemeType.NEARFRONT -> PhonemeType.NEARFRONT
                        PhonemeType.FRONT -> PhonemeType.NEARFRONT }
                   PhonemeType.FRONT -> y }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fOrdHeight :: GHC.Classes.Ord PhonemeType.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fEqHeight
                  PhonemeType.$fOrdHeight_$ccompare
                  PhonemeType.$fOrdHeight_$c<
                  PhonemeType.$fOrdHeight_$c<=
                  PhonemeType.$fOrdHeight_$c>
                  PhonemeType.$fOrdHeight_$c>=
                  PhonemeType.$fOrdHeight_$cmax
                  PhonemeType.$fOrdHeight_$cmin -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fOrdHeight_$c< ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Height b :: PhonemeType.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 0)
                       PhonemeType.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 1)
                       PhonemeType.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 2)
                       PhonemeType.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 3)
                       PhonemeType.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 4)
                       PhonemeType.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 5)
                       PhonemeType.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType.CLOSE -> $j 0
                   PhonemeType.NEARCLOSE -> $j 1
                   PhonemeType.CLOSEMID -> $j 2
                   PhonemeType.MID -> $j 3
                   PhonemeType.OPENMID -> $j 4
                   PhonemeType.NEAROPEN -> $j 5
                   PhonemeType.OPEN -> $j 6 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fOrdHeight_$c<= ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Height b :: PhonemeType.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 0)
                       PhonemeType.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 1)
                       PhonemeType.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 2)
                       PhonemeType.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 3)
                       PhonemeType.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 4)
                       PhonemeType.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 5)
                       PhonemeType.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType.CLOSE -> $j 0
                   PhonemeType.NEARCLOSE -> $j 1
                   PhonemeType.CLOSEMID -> $j 2
                   PhonemeType.MID -> $j 3
                   PhonemeType.OPENMID -> $j 4
                   PhonemeType.NEAROPEN -> $j 5
                   PhonemeType.OPEN -> $j 6 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fOrdHeight_$c> ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Height b :: PhonemeType.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 0)
                       PhonemeType.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 1)
                       PhonemeType.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 2)
                       PhonemeType.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 3)
                       PhonemeType.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 4)
                       PhonemeType.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 5)
                       PhonemeType.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType.CLOSE -> $j 0
                   PhonemeType.NEARCLOSE -> $j 1
                   PhonemeType.CLOSEMID -> $j 2
                   PhonemeType.MID -> $j 3
                   PhonemeType.OPENMID -> $j 4
                   PhonemeType.NEAROPEN -> $j 5
                   PhonemeType.OPEN -> $j 6 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fOrdHeight_$c>= ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Height b :: PhonemeType.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     case b of wild {
                       PhonemeType.CLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 0)
                       PhonemeType.NEARCLOSE
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 1)
                       PhonemeType.CLOSEMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 2)
                       PhonemeType.MID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 3)
                       PhonemeType.OPENMID
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 4)
                       PhonemeType.NEAROPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 5)
                       PhonemeType.OPEN
                       -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# a# 6) }
                 } in
                 case a8 of wild {
                   PhonemeType.CLOSE -> $j 0
                   PhonemeType.NEARCLOSE -> $j 1
                   PhonemeType.CLOSEMID -> $j 2
                   PhonemeType.MID -> $j 3
                   PhonemeType.OPENMID -> $j 4
                   PhonemeType.NEAROPEN -> $j 5
                   PhonemeType.OPEN -> $j 6 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fOrdHeight_$ccompare ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.Height b :: PhonemeType.Height ->
                 case a8 of wild {
                   PhonemeType.CLOSE
                   -> case b of wild1 {
                        PhonemeType.CLOSE -> GHC.Types.EQ
                        PhonemeType.NEARCLOSE -> GHC.Types.LT
                        PhonemeType.CLOSEMID -> GHC.Types.LT
                        PhonemeType.MID -> GHC.Types.LT
                        PhonemeType.OPENMID -> GHC.Types.LT
                        PhonemeType.NEAROPEN -> GHC.Types.LT
                        PhonemeType.OPEN -> GHC.Types.LT }
                   PhonemeType.NEARCLOSE
                   -> case b of wild1 {
                        PhonemeType.CLOSE -> GHC.Types.GT
                        PhonemeType.NEARCLOSE -> GHC.Types.EQ
                        PhonemeType.CLOSEMID -> GHC.Types.LT
                        PhonemeType.MID -> GHC.Types.LT
                        PhonemeType.OPENMID -> GHC.Types.LT
                        PhonemeType.NEAROPEN -> GHC.Types.LT
                        PhonemeType.OPEN -> GHC.Types.LT }
                   PhonemeType.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType.CLOSEMID -> GHC.Types.EQ
                        PhonemeType.MID -> GHC.Types.LT
                        PhonemeType.OPENMID -> GHC.Types.LT
                        PhonemeType.NEAROPEN -> GHC.Types.LT
                        PhonemeType.OPEN -> GHC.Types.LT }
                   PhonemeType.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType.MID -> GHC.Types.EQ
                        PhonemeType.OPENMID -> GHC.Types.LT
                        PhonemeType.NEAROPEN -> GHC.Types.LT
                        PhonemeType.OPEN -> GHC.Types.LT }
                   PhonemeType.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType.OPENMID -> GHC.Types.EQ
                        PhonemeType.NEAROPEN -> GHC.Types.LT
                        PhonemeType.OPEN -> GHC.Types.LT }
                   PhonemeType.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        PhonemeType.NEAROPEN -> GHC.Types.EQ
                        PhonemeType.OPEN -> GHC.Types.LT }
                   PhonemeType.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT PhonemeType.OPEN -> GHC.Types.EQ } }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fOrdHeight_$cmax ::
    PhonemeType.Height -> PhonemeType.Height -> PhonemeType.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Height y :: PhonemeType.Height ->
                 case PhonemeType.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fOrdHeight_$cmin ::
    PhonemeType.Height -> PhonemeType.Height -> PhonemeType.Height
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Height y :: PhonemeType.Height ->
                 case PhonemeType.$fOrdHeight_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fOrdManner :: GHC.Classes.Ord PhonemeType.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner
                  PhonemeType.$fEqManner
                  PhonemeType.$fOrdManner_$ccompare
                  PhonemeType.$fOrdManner_$c<
                  PhonemeType.$fOrdManner_$c<=
                  PhonemeType.$fOrdManner_$c>
                  PhonemeType.$fOrdManner_$c>=
                  PhonemeType.$fOrdManner_$cmax
                  PhonemeType.$fOrdManner_$cmin -}
ad2ca82feee9cd68bab57395bd7db297
  $fOrdManner_$c< ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x2)) } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fOrdManner_$c<= ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x2)) } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fOrdManner_$c> ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x2)) } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fOrdManner_$c>= ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Manner x2)) } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fOrdManner_$ccompare ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Manner x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fOrdManner_$cmax ::
    PhonemeType.Manner -> PhonemeType.Manner -> PhonemeType.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Manner y :: PhonemeType.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType.Manner x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $fOrdManner_$cmin ::
    PhonemeType.Manner -> PhonemeType.Manner -> PhonemeType.Manner
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Manner y :: PhonemeType.Manner ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType.Manner x1)
                           (GHC.Prim.dataToTag# @ PhonemeType.Manner x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fOrdMaybeConsonant :: GHC.Classes.Ord PhonemeType.MaybeConsonant
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.MaybeConsonant
                  PhonemeType.$fEqMaybeConsonant
                  PhonemeType.$fOrdMaybeConsonant_$ccompare
                  PhonemeType.$fOrdMaybeConsonant_$c<
                  PhonemeType.$fOrdMaybeConsonant_$c<=
                  PhonemeType.$fOrdMaybeConsonant_$c>
                  PhonemeType.$fOrdMaybeConsonant_$c>=
                  PhonemeType.$fOrdMaybeConsonant_$cmax
                  PhonemeType.$fOrdMaybeConsonant_$cmin -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fOrdMaybeConsonant_$c< ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.MaybeConsonant
                   b :: PhonemeType.MaybeConsonant ->
                 case a8 of wild {
                   PhonemeType.Consonant a9 a10 a11 a12
                   -> case b of wild1 {
                        PhonemeType.Consonant b1 b2 b3 b4
                        -> case a9 of x1 { DEFAULT ->
                           case b1 of x2 { DEFAULT ->
                           let {
                             a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                           } in
                           let {
                             b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x2
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# a# b#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# a# b#) of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case a10 of x3 { DEFAULT ->
                                     case b2 of x4 { DEFAULT ->
                                     let {
                                       a#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x3
                                     } in
                                     let {
                                       b#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x4
                                     } in
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# a#1 b#1) of wild4 {
                                       GHC.Types.False
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.==# a#1 b#1) of wild5 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case a11 of wild6 {
                                                 PhonemeType.VOICELESS
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS
                                                      -> GHC.Classes.$fOrd[]_$s$c<1 a12 b4
                                                      PhonemeType.VOICED -> GHC.Types.True }
                                                 PhonemeType.VOICED
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS -> GHC.Types.False
                                                      PhonemeType.VOICED
                                                      -> GHC.Classes.$fOrd[]_$s$c<1 a12 b4 } } }
                                       GHC.Types.True -> GHC.Types.True } } } }
                             GHC.Types.True -> GHC.Types.True } } }
                        PhonemeType.Blank -> GHC.Types.True }
                   PhonemeType.Blank
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fOrdMaybeConsonant_$c<= ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.MaybeConsonant
                   b :: PhonemeType.MaybeConsonant ->
                 case a8 of wild {
                   PhonemeType.Consonant a9 a10 a11 a12
                   -> case b of wild1 {
                        PhonemeType.Consonant b1 b2 b3 b4
                        -> case a9 of x1 { DEFAULT ->
                           case b1 of x2 { DEFAULT ->
                           let {
                             a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                           } in
                           let {
                             b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x2
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# a# b#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# a# b#) of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case a10 of x3 { DEFAULT ->
                                     case b2 of x4 { DEFAULT ->
                                     let {
                                       a#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x3
                                     } in
                                     let {
                                       b#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x4
                                     } in
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# a#1 b#1) of wild4 {
                                       GHC.Types.False
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.==# a#1 b#1) of wild5 {
                                            GHC.Types.False -> GHC.Types.False
                                            GHC.Types.True
                                            -> case a11 of wild6 {
                                                 PhonemeType.VOICELESS
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS
                                                      -> GHC.Classes.$fOrd[]_$s$c<=1 a12 b4
                                                      PhonemeType.VOICED -> GHC.Types.True }
                                                 PhonemeType.VOICED
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS -> GHC.Types.False
                                                      PhonemeType.VOICED
                                                      -> GHC.Classes.$fOrd[]_$s$c<=1 a12 b4 } } }
                                       GHC.Types.True -> GHC.Types.True } } } }
                             GHC.Types.True -> GHC.Types.True } } }
                        PhonemeType.Blank -> GHC.Types.True }
                   PhonemeType.Blank
                   -> case b of wild1 {
                        PhonemeType.Consonant ipv ipv1 ipv2 ipv3 -> GHC.Types.False
                        PhonemeType.Blank -> GHC.Types.True } }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fOrdMaybeConsonant_$c> ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.MaybeConsonant
                   b :: PhonemeType.MaybeConsonant ->
                 case a8 of wild {
                   PhonemeType.Consonant a9 a10 a11 a12
                   -> case b of wild1 {
                        PhonemeType.Consonant b1 b2 b3 b4
                        -> case a9 of x1 { DEFAULT ->
                           case b1 of x2 { DEFAULT ->
                           let {
                             a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                           } in
                           let {
                             b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x2
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# a# b#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# a# b#) of wild3 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True
                                  -> case a10 of x3 { DEFAULT ->
                                     case b2 of x4 { DEFAULT ->
                                     let {
                                       a#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x3
                                     } in
                                     let {
                                       b#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x4
                                     } in
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# a#1 b#1) of wild4 {
                                       GHC.Types.False
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.==# a#1 b#1) of wild5 {
                                            GHC.Types.False -> GHC.Types.True
                                            GHC.Types.True
                                            -> case a11 of wild6 {
                                                 PhonemeType.VOICELESS
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS
                                                      -> GHC.Classes.$fOrd[]_$s$c>1 a12 b4
                                                      PhonemeType.VOICED -> GHC.Types.False }
                                                 PhonemeType.VOICED
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS -> GHC.Types.True
                                                      PhonemeType.VOICED
                                                      -> GHC.Classes.$fOrd[]_$s$c>1 a12 b4 } } }
                                       GHC.Types.True -> GHC.Types.False } } } }
                             GHC.Types.True -> GHC.Types.False } } }
                        PhonemeType.Blank -> GHC.Types.False }
                   PhonemeType.Blank
                   -> case b of wild1 {
                        PhonemeType.Consonant ipv ipv1 ipv2 ipv3 -> GHC.Types.True
                        PhonemeType.Blank -> GHC.Types.False } }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fOrdMaybeConsonant_$c>= ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.MaybeConsonant
                   b :: PhonemeType.MaybeConsonant ->
                 case a8 of wild {
                   PhonemeType.Consonant a9 a10 a11 a12
                   -> case b of wild1 {
                        PhonemeType.Consonant b1 b2 b3 b4
                        -> case a9 of x1 { DEFAULT ->
                           case b1 of x2 { DEFAULT ->
                           let {
                             a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                           } in
                           let {
                             b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x2
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# a# b#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# a# b#) of wild3 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True
                                  -> case a10 of x3 { DEFAULT ->
                                     case b2 of x4 { DEFAULT ->
                                     let {
                                       a#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x3
                                     } in
                                     let {
                                       b#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x4
                                     } in
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# a#1 b#1) of wild4 {
                                       GHC.Types.False
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.==# a#1 b#1) of wild5 {
                                            GHC.Types.False -> GHC.Types.True
                                            GHC.Types.True
                                            -> case a11 of wild6 {
                                                 PhonemeType.VOICELESS
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS
                                                      -> GHC.Classes.$fOrd[]_$s$c>=1 a12 b4
                                                      PhonemeType.VOICED -> GHC.Types.False }
                                                 PhonemeType.VOICED
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS -> GHC.Types.True
                                                      PhonemeType.VOICED
                                                      -> GHC.Classes.$fOrd[]_$s$c>=1 a12 b4 } } }
                                       GHC.Types.True -> GHC.Types.False } } } }
                             GHC.Types.True -> GHC.Types.False } } }
                        PhonemeType.Blank -> GHC.Types.False }
                   PhonemeType.Blank
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fOrdMaybeConsonant_$ccompare ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a8 :: PhonemeType.MaybeConsonant
                   b :: PhonemeType.MaybeConsonant ->
                 case a8 of wild {
                   PhonemeType.Consonant a9 a10 a11 a12
                   -> case b of wild1 {
                        PhonemeType.Consonant b1 b2 b3 b4
                        -> case a9 of x1 { DEFAULT ->
                           case b1 of x2 { DEFAULT ->
                           let {
                             a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                           } in
                           let {
                             b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x2
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# a# b#) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# a# b#) of wild3 {
                                  GHC.Types.False -> GHC.Types.GT
                                  GHC.Types.True
                                  -> case a10 of x3 { DEFAULT ->
                                     case b2 of x4 { DEFAULT ->
                                     let {
                                       a#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x3
                                     } in
                                     let {
                                       b#1 :: GHC.Prim.Int#
                                       = GHC.Prim.dataToTag# @ PhonemeType.Manner x4
                                     } in
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# a#1 b#1) of wild4 {
                                       GHC.Types.False
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.==# a#1 b#1) of wild5 {
                                            GHC.Types.False -> GHC.Types.GT
                                            GHC.Types.True
                                            -> case a11 of wild6 {
                                                 PhonemeType.VOICELESS
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS
                                                      -> GHC.Classes.$fOrd[]_$s$ccompare1 a12 b4
                                                      PhonemeType.VOICED -> GHC.Types.LT }
                                                 PhonemeType.VOICED
                                                 -> case b3 of wild7 {
                                                      PhonemeType.VOICELESS -> GHC.Types.GT
                                                      PhonemeType.VOICED
                                                      -> GHC.Classes.$fOrd[]_$s$ccompare1
                                                           a12
                                                           b4 } } }
                                       GHC.Types.True -> GHC.Types.LT } } } }
                             GHC.Types.True -> GHC.Types.LT } } }
                        PhonemeType.Blank -> GHC.Types.LT }
                   PhonemeType.Blank
                   -> case b of wild1 {
                        PhonemeType.Consonant ipv ipv1 ipv2 ipv3 -> GHC.Types.GT
                        PhonemeType.Blank -> GHC.Types.EQ } }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fOrdMaybeConsonant_$cmax ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> PhonemeType.MaybeConsonant
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.MaybeConsonant
                   y :: PhonemeType.MaybeConsonant ->
                 case PhonemeType.$fOrdMaybeConsonant_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fOrdMaybeConsonant_$cmin ::
    PhonemeType.MaybeConsonant
    -> PhonemeType.MaybeConsonant -> PhonemeType.MaybeConsonant
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.MaybeConsonant
                   y :: PhonemeType.MaybeConsonant ->
                 case PhonemeType.$fOrdMaybeConsonant_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fOrdPhonemeInventory ::
    GHC.Classes.Ord PhonemeType.PhonemeInventory
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PhonemeInventory
                  PhonemeType.$fEqPhonemeInventory
                  PhonemeType.$fOrdPhonemeInventory_$ccompare
                  PhonemeType.$fOrdPhonemeInventory_$c<
                  PhonemeType.$fOrdPhonemeInventory_$c<=
                  PhonemeType.$fOrdPhonemeInventory_$c>
                  PhonemeType.$fOrdPhonemeInventory_$c>=
                  PhonemeType.$fOrdPhonemeInventory_$cmax
                  PhonemeType.$fOrdPhonemeInventory_$cmin -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fOrdPhonemeInventory_$c< ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.PhonemeInventory
                   w1 :: PhonemeType.PhonemeInventory ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.PhonemeInventory ww4 ww5 ->
                 PhonemeType.$w$c<1 ww1 ww2 ww4 ww5 } }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fOrdPhonemeInventory_$c<= ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.PhonemeInventory
                   w1 :: PhonemeType.PhonemeInventory ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.PhonemeInventory ww4 ww5 ->
                 PhonemeType.$w$c<=1 ww1 ww2 ww4 ww5 } }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fOrdPhonemeInventory_$c> ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.PhonemeInventory
                   w1 :: PhonemeType.PhonemeInventory ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.PhonemeInventory ww4 ww5 ->
                 PhonemeType.$w$c>1 ww1 ww2 ww4 ww5 } }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fOrdPhonemeInventory_$c>= ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.PhonemeInventory
                   w1 :: PhonemeType.PhonemeInventory ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.PhonemeInventory ww4 ww5 ->
                 PhonemeType.$w$c>=1 ww1 ww2 ww4 ww5 } }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fOrdPhonemeInventory_$ccompare ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.PhonemeInventory
                   w1 :: PhonemeType.PhonemeInventory ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.PhonemeInventory ww4 ww5 ->
                 PhonemeType.$w$ccompare1 ww1 ww2 ww4 ww5 } }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fOrdPhonemeInventory_$cmax ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> PhonemeType.PhonemeInventory
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(U,U)><S(SL),1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.PhonemeInventory
                   w1 :: PhonemeType.PhonemeInventory ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.PhonemeInventory ww4 ww5 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType.MaybeConsonant
                        PhonemeType.$fOrdMaybeConsonant
                        ww1
                        ww4 of wild {
                   GHC.Types.LT -> PhonemeType.PhonemeInventory ww4 ww5
                   GHC.Types.EQ
                   -> case GHC.Classes.$w$ccompare14
                             @ PhonemeType.Vowel
                             PhonemeType.$fOrdVowel
                             ww2
                             ww5 of wild1 {
                        DEFAULT -> PhonemeType.PhonemeInventory ww4 ww5
                        GHC.Types.GT -> PhonemeType.PhonemeInventory ww1 ww2 }
                   GHC.Types.GT -> PhonemeType.PhonemeInventory ww1 ww2 } } }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fOrdPhonemeInventory_$cmin ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> PhonemeType.PhonemeInventory
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(U,U)><S(SL),1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.PhonemeInventory
                   w1 :: PhonemeType.PhonemeInventory ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.PhonemeInventory ww4 ww5 ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType.MaybeConsonant
                        PhonemeType.$fOrdMaybeConsonant
                        ww1
                        ww4 of wild {
                   GHC.Types.LT -> PhonemeType.PhonemeInventory ww1 ww2
                   GHC.Types.EQ
                   -> case GHC.Classes.$w$ccompare14
                             @ PhonemeType.Vowel
                             PhonemeType.$fOrdVowel
                             ww2
                             ww5 of wild1 {
                        DEFAULT -> PhonemeType.PhonemeInventory ww1 ww2
                        GHC.Types.GT -> PhonemeType.PhonemeInventory ww4 ww5 }
                   GHC.Types.GT -> PhonemeType.PhonemeInventory ww4 ww5 } } }) -}
75666487cf3af3760456cef495e6a332
  $fOrdPlace :: GHC.Classes.Ord PhonemeType.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place
                  PhonemeType.$fEqPlace
                  PhonemeType.$fOrdPlace_$ccompare
                  PhonemeType.$fOrdPlace_$c<
                  PhonemeType.$fOrdPlace_$c<=
                  PhonemeType.$fOrdPlace_$c>
                  PhonemeType.$fOrdPlace_$c>=
                  PhonemeType.$fOrdPlace_$cmax
                  PhonemeType.$fOrdPlace_$cmin -}
75666487cf3af3760456cef495e6a332
  $fOrdPlace_$c< ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<#
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) } }) -}
75666487cf3af3760456cef495e6a332
  $fOrdPlace_$c<= ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.<=#
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) } }) -}
75666487cf3af3760456cef495e6a332
  $fOrdPlace_$c> ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>#
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) } }) -}
75666487cf3af3760456cef495e6a332
  $fOrdPlace_$c>= ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>=#
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) } }) -}
75666487cf3af3760456cef495e6a332
  $fOrdPlace_$ccompare ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case a8 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   b# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x2
                 } in
                 let {
                   a# :: GHC.Prim.Int# = GHC.Prim.dataToTag# @ PhonemeType.Place x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# a# b#) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# a# b#) of wild1 {
                        GHC.Types.False -> GHC.Types.GT GHC.Types.True -> GHC.Types.EQ }
                   GHC.Types.True -> GHC.Types.LT } } }) -}
75666487cf3af3760456cef495e6a332
  $fOrdPlace_$cmax ::
    PhonemeType.Place -> PhonemeType.Place -> PhonemeType.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Place y :: PhonemeType.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) of wild {
                   GHC.Types.False -> x1 GHC.Types.True -> x2 } } }) -}
75666487cf3af3760456cef495e6a332
  $fOrdPlace_$cmin ::
    PhonemeType.Place -> PhonemeType.Place -> PhonemeType.Place
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Place y :: PhonemeType.Place ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=#
                           (GHC.Prim.dataToTag# @ PhonemeType.Place x1)
                           (GHC.Prim.dataToTag# @ PhonemeType.Place x2)) of wild {
                   GHC.Types.False -> x2 GHC.Types.True -> x1 } } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fOrdRoundedness :: GHC.Classes.Ord PhonemeType.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fEqRoundedness
                  PhonemeType.$fOrdRoundedness_$ccompare
                  PhonemeType.$fOrdRoundedness_$c<
                  PhonemeType.$fOrdRoundedness_$c<=
                  PhonemeType.$fOrdRoundedness_$c>
                  PhonemeType.$fOrdRoundedness_$c>=
                  PhonemeType.$fOrdRoundedness_$cmax
                  PhonemeType.$fOrdRoundedness_$cmin -}
731583abbaff278fb0f2c55475c6f2cd
  $fOrdRoundedness_$c< ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Roundedness b :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED
                   -> case b of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.False
                        PhonemeType.UNROUNDED -> GHC.Types.True }
                   PhonemeType.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fOrdRoundedness_$c<= ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Roundedness b :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.False
                        PhonemeType.UNROUNDED -> GHC.Types.True } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fOrdRoundedness_$c> ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Roundedness b :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.True
                        PhonemeType.UNROUNDED -> GHC.Types.False } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fOrdRoundedness_$c>= ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Roundedness b :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED
                   -> case b of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.True
                        PhonemeType.UNROUNDED -> GHC.Types.False }
                   PhonemeType.UNROUNDED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fOrdRoundedness_$ccompare ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Roundedness b :: PhonemeType.Roundedness ->
                 case a8 of wild {
                   PhonemeType.ROUNDED
                   -> case b of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.EQ
                        PhonemeType.UNROUNDED -> GHC.Types.LT }
                   PhonemeType.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType.ROUNDED -> GHC.Types.GT
                        PhonemeType.UNROUNDED -> GHC.Types.EQ } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fOrdRoundedness_$cmax ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> PhonemeType.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Roundedness y :: PhonemeType.Roundedness ->
                 case x of wild {
                   PhonemeType.ROUNDED -> y
                   PhonemeType.UNROUNDED
                   -> case y of wild1 { DEFAULT -> PhonemeType.UNROUNDED } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fOrdRoundedness_$cmin ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> PhonemeType.Roundedness
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Roundedness y :: PhonemeType.Roundedness ->
                 case x of wild {
                   PhonemeType.ROUNDED
                   -> case y of wild1 { DEFAULT -> PhonemeType.ROUNDED }
                   PhonemeType.UNROUNDED -> y }) -}
555397b244896c50401e55d764c2ad9e
  $fOrdVoice :: GHC.Classes.Ord PhonemeType.Voice
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Voice
                  PhonemeType.$fEqVoice
                  PhonemeType.$fOrdVoice_$ccompare
                  PhonemeType.$fOrdVoice_$c<
                  PhonemeType.$fOrdVoice_$c<=
                  PhonemeType.$fOrdVoice_$c>
                  PhonemeType.$fOrdVoice_$c>=
                  PhonemeType.$fOrdVoice_$cmax
                  PhonemeType.$fOrdVoice_$cmin -}
555397b244896c50401e55d764c2ad9e
  $fOrdVoice_$c< ::
    PhonemeType.Voice -> PhonemeType.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Voice b :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS
                   -> case b of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.False
                        PhonemeType.VOICED -> GHC.Types.True }
                   PhonemeType.VOICED
                   -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
555397b244896c50401e55d764c2ad9e
  $fOrdVoice_$c<= ::
    PhonemeType.Voice -> PhonemeType.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Voice b :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS
                   -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   PhonemeType.VOICED
                   -> case b of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.False
                        PhonemeType.VOICED -> GHC.Types.True } }) -}
555397b244896c50401e55d764c2ad9e
  $fOrdVoice_$c> ::
    PhonemeType.Voice -> PhonemeType.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Voice b :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS
                   -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   PhonemeType.VOICED
                   -> case b of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.True
                        PhonemeType.VOICED -> GHC.Types.False } }) -}
555397b244896c50401e55d764c2ad9e
  $fOrdVoice_$c>= ::
    PhonemeType.Voice -> PhonemeType.Voice -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Voice b :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS
                   -> case b of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.True
                        PhonemeType.VOICED -> GHC.Types.False }
                   PhonemeType.VOICED
                   -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
555397b244896c50401e55d764c2ad9e
  $fOrdVoice_$ccompare ::
    PhonemeType.Voice -> PhonemeType.Voice -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a8 :: PhonemeType.Voice b :: PhonemeType.Voice ->
                 case a8 of wild {
                   PhonemeType.VOICELESS
                   -> case b of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.EQ
                        PhonemeType.VOICED -> GHC.Types.LT }
                   PhonemeType.VOICED
                   -> case b of wild1 {
                        PhonemeType.VOICELESS -> GHC.Types.GT
                        PhonemeType.VOICED -> GHC.Types.EQ } }) -}
555397b244896c50401e55d764c2ad9e
  $fOrdVoice_$cmax ::
    PhonemeType.Voice -> PhonemeType.Voice -> PhonemeType.Voice
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Voice y :: PhonemeType.Voice ->
                 case x of wild {
                   PhonemeType.VOICELESS -> y
                   PhonemeType.VOICED
                   -> case y of wild1 { DEFAULT -> PhonemeType.VOICED } }) -}
555397b244896c50401e55d764c2ad9e
  $fOrdVoice_$cmin ::
    PhonemeType.Voice -> PhonemeType.Voice -> PhonemeType.Voice
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Voice y :: PhonemeType.Voice ->
                 case x of wild {
                   PhonemeType.VOICELESS
                   -> case y of wild1 { DEFAULT -> PhonemeType.VOICELESS }
                   PhonemeType.VOICED -> y }) -}
e51938fc3a28180cc0e71906aef6982c
  $fOrdVowel :: GHC.Classes.Ord PhonemeType.Vowel
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Vowel
                  PhonemeType.$fEqVowel
                  PhonemeType.$fOrdVowel_$ccompare
                  PhonemeType.$fOrdVowel_$c<
                  PhonemeType.$fOrdVowel_$c<=
                  PhonemeType.$fOrdVowel_$c>
                  PhonemeType.$fOrdVowel_$c>=
                  PhonemeType.$fOrdVowel_$cmax
                  PhonemeType.$fOrdVowel_$cmin -}
e51938fc3a28180cc0e71906aef6982c
  $fOrdVowel_$c< ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Vowel w1 :: PhonemeType.Vowel ->
                 case w of ww { PhonemeType.Vowel ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { PhonemeType.Vowel ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$c< ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
e51938fc3a28180cc0e71906aef6982c
  $fOrdVowel_$c<= ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Vowel w1 :: PhonemeType.Vowel ->
                 case w of ww { PhonemeType.Vowel ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { PhonemeType.Vowel ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$c<= ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
e51938fc3a28180cc0e71906aef6982c
  $fOrdVowel_$c> ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Vowel w1 :: PhonemeType.Vowel ->
                 case w of ww { PhonemeType.Vowel ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { PhonemeType.Vowel ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$c> ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
e51938fc3a28180cc0e71906aef6982c
  $fOrdVowel_$c>= ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Vowel w1 :: PhonemeType.Vowel ->
                 case w of ww { PhonemeType.Vowel ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { PhonemeType.Vowel ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$c>= ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
e51938fc3a28180cc0e71906aef6982c
  $fOrdVowel_$ccompare ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Vowel w1 :: PhonemeType.Vowel ->
                 case w of ww { PhonemeType.Vowel ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { PhonemeType.Vowel ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$ccompare ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
e51938fc3a28180cc0e71906aef6982c
  $fOrdVowel_$cmax ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> PhonemeType.Vowel
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),U(U,U,U,U)><S(SLLL),U(U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Vowel y :: PhonemeType.Vowel ->
                 case PhonemeType.$fOrdVowel_$c<= x y of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
e51938fc3a28180cc0e71906aef6982c
  $fOrdVowel_$cmin ::
    PhonemeType.Vowel -> PhonemeType.Vowel -> PhonemeType.Vowel
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),U(U,U,U,U)><S(SLLL),U(U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ x :: PhonemeType.Vowel y :: PhonemeType.Vowel ->
                 case PhonemeType.$fOrdVowel_$c<= x y of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness :: GHC.Read.Read PhonemeType.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fReadBackness_$s$dmreadsPrec
                  PhonemeType.$fReadBackness_$sreadListDefault
                  PhonemeType.$fReadBackness_$creadPrec
                  PhonemeType.$fReadBackness_$creadListPrec -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Backness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Backness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Backness
                   PhonemeType.$fReadBackness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Backness>_R))
                   @ b
                   eta1) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.FRONT) -}
1cadb6e29df62a6b51f05ba2ec6f4543
  $fReadBackness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRONT"#) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness14,
                  PhonemeType.$fReadBackness13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEARFRONT) -}
e34431f44d540eabdccebf4ae2b47057
  $fReadBackness14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARFRONT"#) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness17,
                  PhonemeType.$fReadBackness16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.CENTRAL) -}
604efea70df2a61a44e5928a0d053250
  $fReadBackness17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CENTRAL"#) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness20,
                  PhonemeType.$fReadBackness19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEARBACK) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Backness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Backness
                   PhonemeType.$fReadBackness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Backness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Backness>_R)))) -}
beeedcf89a7b5b45710881fee949e4e3
  $fReadBackness20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARBACK"#) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness23,
                  PhonemeType.$fReadBackness22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.BACK) -}
8ad857483afc11ec3cd5cb4c6338066f
  $fReadBackness23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACK"#) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Backness
                   PhonemeType.$fReadBackness4
                   eta
                   @ b
                   eta1) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness21
                   PhonemeType.$fReadBackness5) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness18
                   PhonemeType.$fReadBackness6) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness15
                   PhonemeType.$fReadBackness7) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness12
                   PhonemeType.$fReadBackness8) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness9
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness))) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness11,
                  PhonemeType.$fReadBackness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Backness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadBackness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Backness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Backness]>_R))) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadBackness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Backness>_R)) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Backness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Backness
                   PhonemeType.$fReadBackness_$creadPrec
                   eta) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fReadBackness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Backness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Backness]
                   ((PhonemeType.$fReadBackness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Backness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Backness]>_R)
                      @ [PhonemeType.Backness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Backness]))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight :: GHC.Read.Read PhonemeType.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fReadHeight_$s$dmreadsPrec
                  PhonemeType.$fReadHeight_$sreadListDefault
                  PhonemeType.$fReadHeight_$creadPrec
                  PhonemeType.$fReadHeight_$creadListPrec -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Height] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Height] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Height
                   PhonemeType.$fReadHeight2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Height>_R))
                   @ b
                   eta1) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight13,
                  PhonemeType.$fReadHeight12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.OPEN) -}
5851bc653447bd0bb0aa6b20160f86d3
  $fReadHeight13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPEN"#) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight16,
                  PhonemeType.$fReadHeight15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEAROPEN) -}
9f76e72d98acd7b791e7ddf4a8d0b1fb
  $fReadHeight16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEAROPEN"#) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight19,
                  PhonemeType.$fReadHeight18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.OPENMID) -}
65dbf6cf7ebf39dd6da982d981e3c341
  $fReadHeight19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPENMID"#) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Height
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Height
                   PhonemeType.$fReadHeight3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Height>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Height>_R)))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight22,
                  PhonemeType.$fReadHeight21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.MID) -}
867b1073da4609e2a2f18511c693d2ce
  $fReadHeight22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MID"#) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight25,
                  PhonemeType.$fReadHeight24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.CLOSEMID) -}
6c4a98224c1054fb4f76e9ff06938904
  $fReadHeight25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSEMID"#) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight28,
                  PhonemeType.$fReadHeight27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEARCLOSE) -}
5e37df91b214448524b841dc8b9ac979
  $fReadHeight28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARCLOSE"#) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight31,
                  PhonemeType.$fReadHeight30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Height
                   PhonemeType.$fReadHeight4
                   eta
                   @ b
                   eta1) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.CLOSE) -}
3cf3a06dc686e41a2a061c201f110f76
  $fReadHeight31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSE"#) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight29
                   PhonemeType.$fReadHeight5) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight26
                   PhonemeType.$fReadHeight6) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight23
                   PhonemeType.$fReadHeight7) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight20
                   PhonemeType.$fReadHeight8) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight17
                   PhonemeType.$fReadHeight9) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight14
                   PhonemeType.$fReadHeight10) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Height]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadHeight1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Height]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Height]>_R))) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadHeight2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Height>_R)) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Height
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Height
                   PhonemeType.$fReadHeight_$creadPrec
                   eta) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fReadHeight_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Height]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Height]
                   ((PhonemeType.$fReadHeight_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Height]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Height]>_R)
                      @ [PhonemeType.Height]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Height]))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner :: GHC.Read.Read PhonemeType.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner
                  PhonemeType.$fReadManner_$s$dmreadsPrec
                  PhonemeType.$fReadManner_$sreadListDefault
                  PhonemeType.$fReadManner_$creadPrec
                  PhonemeType.$fReadManner_$creadListPrec -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Manner] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Manner] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Manner
                   PhonemeType.$fReadManner2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Manner>_R))
                   @ b
                   eta1) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner27
                   PhonemeType.$fReadManner11) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner24
                   PhonemeType.$fReadManner12) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner21
                   PhonemeType.$fReadManner13) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner18
                   PhonemeType.$fReadManner14) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner15
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner17,
                  PhonemeType.$fReadManner16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LFLAP) -}
cfd4bc93338cc15a2326f9745e470739
  $fReadManner17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFLAP"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner20,
                  PhonemeType.$fReadManner19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LAPPROXIMANT) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Manner
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Manner
                   PhonemeType.$fReadManner3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Manner>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Manner>_R)))) -}
261337e2af9d08535e1eb9d08edc8f92
  $fReadManner20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAPPROXIMANT"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner23,
                  PhonemeType.$fReadManner22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LFRICATIVE) -}
f6303c43e34e3e9cec1f582bf86de293
  $fReadManner23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LFRICATIVE"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner24 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner26,
                  PhonemeType.$fReadManner25
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner25 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LAFFRICATE) -}
9c5e800cdc9cc11eb540f664d630219d
  $fReadManner26 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LAFFRICATE"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner27 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner29,
                  PhonemeType.$fReadManner28
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner28 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TRILL) -}
0f3a41e839e81d8473630fec1054f744
  $fReadManner29 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRILL"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Manner
                   PhonemeType.$fReadManner4
                   eta
                   @ b
                   eta1) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner30 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner32,
                  PhonemeType.$fReadManner31
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner31 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.FLAP) -}
5a4f55db79b399d95bf8b2a225b16955
  $fReadManner32 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FLAP"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner33 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner35,
                  PhonemeType.$fReadManner34
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner34 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.APPROXIMANT) -}
425088bd12c112834eb9ab0d5bed516c
  $fReadManner35 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "APPROXIMANT"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner36 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner38,
                  PhonemeType.$fReadManner37
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner37 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.FRICATIVE) -}
23847271f359e8e358342a5c8adc3749
  $fReadManner38 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRICATIVE"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner39 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner41,
                  PhonemeType.$fReadManner40
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner45
                   PhonemeType.$fReadManner5) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner40 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.AFFRICATE) -}
e779a195a8de816985199d398ce284e3
  $fReadManner41 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AFFRICATE"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner42 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner44,
                  PhonemeType.$fReadManner43
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner43 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.STOP) -}
0f579748e07c20acc7235760f94b0c9e
  $fReadManner44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STOP"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner45 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadManner47,
                  PhonemeType.$fReadManner46
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Manner>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Manner>_R))))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner46 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NASAL) -}
e50c532e38880f477ed27054a67803a1
  $fReadManner47 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NASAL"#) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner42
                   PhonemeType.$fReadManner6) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner39
                   PhonemeType.$fReadManner7) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner36
                   PhonemeType.$fReadManner8) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner33
                   PhonemeType.$fReadManner9) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner)
                   PhonemeType.$fReadManner30
                   PhonemeType.$fReadManner10) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Manner]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadManner1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Manner]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Manner]>_R))) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadManner2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Manner>_R)) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Manner
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Manner
                   PhonemeType.$fReadManner_$creadPrec
                   eta) -}
ad2ca82feee9cd68bab57395bd7db297
  $fReadManner_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Manner]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Manner]
                   ((PhonemeType.$fReadManner_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Manner]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Manner]>_R)
                      @ [PhonemeType.Manner]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Manner]))) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fReadMaybeConsonant :: GHC.Read.Read PhonemeType.MaybeConsonant
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.MaybeConsonant
                  PhonemeType.$fReadMaybeConsonant_$s$dmreadsPrec
                  PhonemeType.$fReadMaybeConsonant_$sreadListDefault
                  PhonemeType.$fReadMaybeConsonant_$creadPrec
                  PhonemeType.$fReadMaybeConsonant_$creadListPrec -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fReadMaybeConsonant1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.MaybeConsonant] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.MaybeConsonant]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.MaybeConsonant
                   PhonemeType.$fReadMaybeConsonant2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.MaybeConsonant>_R))
                   @ b
                   eta1) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fReadMaybeConsonant2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.MaybeConsonant
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.MaybeConsonant
                   PhonemeType.$fReadMaybeConsonant3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.MaybeConsonant>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.MaybeConsonant>_R)))) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fReadMaybeConsonant3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.MaybeConsonant -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)> -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fReadMaybeConsonant_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.MaybeConsonant]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeConsonant1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.MaybeConsonant]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.MaybeConsonant]>_R))) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fReadMaybeConsonant_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.MaybeConsonant
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeConsonant2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.MaybeConsonant>_R)) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fReadMaybeConsonant_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.MaybeConsonant
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.MaybeConsonant
                   PhonemeType.$fReadMaybeConsonant_$creadPrec
                   eta) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fReadMaybeConsonant_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.MaybeConsonant]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.MaybeConsonant]
                   ((PhonemeType.$fReadMaybeConsonant_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.MaybeConsonant]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.MaybeConsonant]>_R)
                      @ [PhonemeType.MaybeConsonant]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.MaybeConsonant]))) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fReadPhonemeInventory ::
    GHC.Read.Read PhonemeType.PhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PhonemeInventory
                  PhonemeType.$fReadPhonemeInventory_$creadsPrec
                  PhonemeType.$fReadPhonemeInventory_$sreadListDefault
                  PhonemeType.$fReadPhonemeInventory_$creadPrec
                  PhonemeType.$fReadPhonemeInventory_$creadListPrec -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fReadPhonemeInventory1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.PhonemeInventory]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.PhonemeInventory]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.PhonemeInventory
                   PhonemeType.$fReadPhonemeInventory2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.PhonemeInventory>_R))
                   @ b
                   eta1) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fReadPhonemeInventory2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.PhonemeInventory
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.PhonemeInventory
                   PhonemeType.$fReadPhonemeInventory3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.PhonemeInventory>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.PhonemeInventory>_R)))) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fReadPhonemeInventory3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PhonemeInventory -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.PhonemeInventory
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 -> PhonemeType.$wa ww1 @ b w1 }) -}
4a22cc8a916751a2c37ee0e88ea2b3fc
  $fReadPhonemeInventory4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PhonemeInventory"#) -}
e51938fc3a28180cc0e71906aef6982c
  $fReadPhonemeInventory5 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Vowel
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Vowel
                   PhonemeType.$fReadPhonemeInventory6
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Vowel>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Vowel>_R)))) -}
e51938fc3a28180cc0e71906aef6982c
  $fReadPhonemeInventory6 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Vowel -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.Vowel -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$wa1 ww1 @ b w1 }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fReadPhonemeInventory_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.PhonemeInventory]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPhonemeInventory1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.PhonemeInventory]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.PhonemeInventory]>_R))) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fReadPhonemeInventory_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType.PhonemeInventory
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPhonemeInventory2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.PhonemeInventory>_R)) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fReadPhonemeInventory_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.PhonemeInventory
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.PhonemeInventory
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.PhonemeInventory
                       PhonemeType.$fReadPhonemeInventory3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.PhonemeInventory>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.PhonemeInventory>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.PhonemeInventory>_R)
                      @ PhonemeType.PhonemeInventory
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.PhonemeInventory))) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fReadPhonemeInventory_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.PhonemeInventory]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.PhonemeInventory]
                   ((PhonemeType.$fReadPhonemeInventory_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.PhonemeInventory]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.PhonemeInventory]>_R)
                      @ [PhonemeType.PhonemeInventory]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.PhonemeInventory]))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace :: GHC.Read.Read PhonemeType.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place
                  PhonemeType.$fReadPlace_$s$dmreadsPrec
                  PhonemeType.$fReadPlace_$sreadListDefault
                  PhonemeType.$fReadPlace_$creadPrec
                  PhonemeType.$fReadPlace_$creadListPrec -}
75666487cf3af3760456cef495e6a332
  $fReadPlace1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Place] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Place] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Place
                   PhonemeType.$fReadPlace2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Place>_R))
                   @ b
                   eta1) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace31
                   PhonemeType.$fReadPlace11) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace11 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace28
                   PhonemeType.$fReadPlace12) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace12 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace25
                   PhonemeType.$fReadPlace13) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace13 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace22
                   PhonemeType.$fReadPlace14) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace14 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace19
                   PhonemeType.$fReadPlace15) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace16
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace16 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace18,
                  PhonemeType.$fReadPlace17
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace17 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.GLOTTAL) -}
08e66f58093fc679ecb1ec799257b0d3
  $fReadPlace18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTAL"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace19 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace21,
                  PhonemeType.$fReadPlace20
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Place
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Place
                   PhonemeType.$fReadPlace3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Place>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Place>_R)))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace20 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.PHARYNGEAL) -}
862c4f2d806c5c42cad65a414dd20849
  $fReadPlace21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PHARYNGEAL"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace22 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace24,
                  PhonemeType.$fReadPlace23
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace23 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.UVULAR) -}
b6ac9ec444faf13a4e8f7109b1d7e1d5
  $fReadPlace24 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVULAR"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace25 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace27,
                  PhonemeType.$fReadPlace26
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace26 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.VELAR) -}
5345fd15f441aaf0340862a0c9549b29
  $fReadPlace27 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VELAR"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace28 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace30,
                  PhonemeType.$fReadPlace29
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace29 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.PALATAL) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Place
                   PhonemeType.$fReadPlace4
                   eta
                   @ b
                   eta1) -}
8d17625a0c3cce7803c45a80fcb92587
  $fReadPlace30 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PALATAL"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace31 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace33,
                  PhonemeType.$fReadPlace32
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace32 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.ALVEOLOPALATAL) -}
22ade3382e23243cd38e7beee3b21c69
  $fReadPlace33 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLOPALATAL"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace34 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace36,
                  PhonemeType.$fReadPlace35
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace35 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.RETROFLEX) -}
7aba0ba4e346226707991c325205b92c
  $fReadPlace36 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RETROFLEX"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace37 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace39,
                  PhonemeType.$fReadPlace38
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace38 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.PALATOALVEOLAR) -}
12197a317c3ab2ea6caa21e576fda221
  $fReadPlace39 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PALATOALVEOLAR"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace49
                   PhonemeType.$fReadPlace5) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace40 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace42,
                  PhonemeType.$fReadPlace41
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace41 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.ALVEOLAR) -}
7389c41adde216dc939d16d38fdb1d77
  $fReadPlace42 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ALVEOLAR"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace43 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace45,
                  PhonemeType.$fReadPlace44
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace44 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.DENTAL) -}
409022929f893f49e390d7bdcb070e6d
  $fReadPlace45 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DENTAL"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace46 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace48,
                  PhonemeType.$fReadPlace47
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace47 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LABIODENTAL) -}
15a7db8037a6fbba6dcdcbf2995467de
  $fReadPlace48 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LABIODENTAL"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace49 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadPlace51,
                  PhonemeType.$fReadPlace50
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Place>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Place>_R))))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace46
                   PhonemeType.$fReadPlace6) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace50 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.BILABIAL) -}
1fa3d40fe74739cf20426677b97f4507
  $fReadPlace51 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BILABIAL"#) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace43
                   PhonemeType.$fReadPlace7) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace40
                   PhonemeType.$fReadPlace8) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace37
                   PhonemeType.$fReadPlace9) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place)
                   PhonemeType.$fReadPlace34
                   PhonemeType.$fReadPlace10) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Place]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPlace1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Place]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Place]>_R))) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPlace2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Place>_R)) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Place
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Place
                   PhonemeType.$fReadPlace_$creadPrec
                   eta) -}
75666487cf3af3760456cef495e6a332
  $fReadPlace_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Place]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Place]
                   ((PhonemeType.$fReadPlace_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Place]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Place]>_R)
                      @ [PhonemeType.Place]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Place]))) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness :: GHC.Read.Read PhonemeType.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fReadRoundedness_$s$dmreadsPrec
                  PhonemeType.$fReadRoundedness_$sreadListDefault
                  PhonemeType.$fReadRoundedness_$creadPrec
                  PhonemeType.$fReadRoundedness_$creadListPrec -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Roundedness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Roundedness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Roundedness
                   PhonemeType.$fReadRoundedness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Roundedness>_R))
                   @ b
                   eta1) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.ROUNDED) -}
32449c91c88b13be80e8933ea27f1e56
  $fReadRoundedness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ROUNDED"#) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Roundedness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Roundedness
                   PhonemeType.$fReadRoundedness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Roundedness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Roundedness>_R)))) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Roundedness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Roundedness
                   PhonemeType.$fReadRoundedness4
                   eta
                   @ b
                   eta1) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)
                   PhonemeType.$fReadRoundedness9
                   PhonemeType.$fReadRoundedness5) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)
                   PhonemeType.$fReadRoundedness6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.Roundedness))) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadRoundedness8,
                  PhonemeType.$fReadRoundedness7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Roundedness>_R))))) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.UNROUNDED) -}
46e8b575b46ee8350b43e9345ecd9b33
  $fReadRoundedness8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UNROUNDED"#) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadRoundedness11,
                  PhonemeType.$fReadRoundedness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Roundedness>_R))))) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Roundedness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadRoundedness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Roundedness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Roundedness]>_R))) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadRoundedness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Roundedness>_R)) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Roundedness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Roundedness
                   PhonemeType.$fReadRoundedness_$creadPrec
                   eta) -}
731583abbaff278fb0f2c55475c6f2cd
  $fReadRoundedness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Roundedness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Roundedness]
                   ((PhonemeType.$fReadRoundedness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Roundedness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Roundedness]>_R)
                      @ [PhonemeType.Roundedness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Roundedness]))) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice :: GHC.Read.Read PhonemeType.Voice
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Voice
                  PhonemeType.$fReadVoice_$s$dmreadsPrec
                  PhonemeType.$fReadVoice_$sreadListDefault
                  PhonemeType.$fReadVoice_$creadPrec
                  PhonemeType.$fReadVoice_$creadListPrec -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Voice] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Voice] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Voice
                   PhonemeType.$fReadVoice2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Voice>_R))
                   @ b
                   eta1) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Voice -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.VOICELESS) -}
a00482d9887f610d4d0f0c561ec90516
  $fReadVoice11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICELESS"#) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Voice
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Voice
                   PhonemeType.$fReadVoice3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Voice>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Voice>_R)))) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Voice -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Voice
                   PhonemeType.$fReadVoice4
                   eta
                   @ b
                   eta1) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Voice)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Voice)
                   PhonemeType.$fReadVoice9
                   PhonemeType.$fReadVoice5) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Voice)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Voice)
                   PhonemeType.$fReadVoice6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Voice))) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Voice)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadVoice8,
                  PhonemeType.$fReadVoice7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Voice>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Voice>_R))))) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Voice -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Voice -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.VOICED) -}
248bee827d8260b9c6ee5e5529016b82
  $fReadVoice8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICED"#) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Voice)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadVoice11,
                  PhonemeType.$fReadVoice10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Voice>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Voice>_R))))) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Voice]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVoice1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Voice]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Voice]>_R))) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Voice
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVoice2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Voice>_R)) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Voice
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Voice
                   PhonemeType.$fReadVoice_$creadPrec
                   eta) -}
555397b244896c50401e55d764c2ad9e
  $fReadVoice_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Voice]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Voice]
                   ((PhonemeType.$fReadVoice_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Voice]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Voice]>_R)
                      @ [PhonemeType.Voice]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Voice]))) -}
e51938fc3a28180cc0e71906aef6982c
  $fReadVowel :: GHC.Read.Read PhonemeType.Vowel
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Vowel
                  PhonemeType.$fReadVowel_$s$dmreadsPrec
                  PhonemeType.$fReadVowel_$sreadListDefault
                  PhonemeType.$fReadVowel_$creadPrec
                  PhonemeType.$fReadVowel_$creadListPrec -}
e51938fc3a28180cc0e71906aef6982c
  $fReadVowel1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Vowel] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Vowel] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Vowel
                   PhonemeType.$fReadPhonemeInventory5
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Vowel>_R))
                   @ b
                   eta1) -}
e51938fc3a28180cc0e71906aef6982c
  $fReadVowel_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Vowel]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVowel1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Vowel]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Vowel]>_R))) -}
e51938fc3a28180cc0e71906aef6982c
  $fReadVowel_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Vowel
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPhonemeInventory5
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Vowel>_R)) -}
e51938fc3a28180cc0e71906aef6982c
  $fReadVowel_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Vowel
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Vowel
                   PhonemeType.$fReadVowel_$creadPrec
                   eta) -}
e51938fc3a28180cc0e71906aef6982c
  $fReadVowel_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Vowel]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Vowel]
                   ((PhonemeType.$fReadVowel_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Vowel]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Vowel]>_R)
                      @ [PhonemeType.Vowel]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Vowel]))) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fShowBackness :: GHC.Show.Show PhonemeType.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fShowBackness_$cshowsPrec
                  PhonemeType.$fShowBackness_$cshow
                  PhonemeType.$fShowBackness_$cshowList -}
b87c0c3ee94d9a9392430cfc9b970753
  $fShowBackness_$cshow :: PhonemeType.Backness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Backness ->
                 PhonemeType.$fShowBackness_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fShowBackness_$cshowList ::
    [PhonemeType.Backness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Backness
                   PhonemeType.$w$cshowsPrec) -}
b87c0c3ee94d9a9392430cfc9b970753
  $fShowBackness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Backness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Backness
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec w1 w2) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fShowHeight :: GHC.Show.Show PhonemeType.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fShowHeight_$cshowsPrec
                  PhonemeType.$fShowHeight_$cshow
                  PhonemeType.$fShowHeight_$cshowList -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fShowHeight_$cshow :: PhonemeType.Height -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Height ->
                 PhonemeType.$fShowHeight_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fShowHeight_$cshowList :: [PhonemeType.Height] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Height
                   PhonemeType.$w$cshowsPrec1) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $fShowHeight_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Height -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Height
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec1 w1 w2) -}
ad2ca82feee9cd68bab57395bd7db297
  $fShowManner :: GHC.Show.Show PhonemeType.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner
                  PhonemeType.$fShowManner_$cshowsPrec
                  PhonemeType.$fShowManner_$cshow
                  PhonemeType.$fShowManner_$cshowList -}
ad2ca82feee9cd68bab57395bd7db297
  $fShowManner_$cshow :: PhonemeType.Manner -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Manner ->
                 PhonemeType.$fShowManner_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ad2ca82feee9cd68bab57395bd7db297
  $fShowManner_$cshowList :: [PhonemeType.Manner] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Manner
                   PhonemeType.$w$cshowsPrec2) -}
ad2ca82feee9cd68bab57395bd7db297
  $fShowManner_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Manner -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Manner
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec2 w1 w2) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fShowMaybeConsonant :: GHC.Show.Show PhonemeType.MaybeConsonant
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.MaybeConsonant
                  PhonemeType.$fShowMaybeConsonant_$cshowsPrec
                  PhonemeType.$fShowMaybeConsonant_$cshow
                  PhonemeType.$fShowMaybeConsonant_$cshowList -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fShowMaybeConsonant1 ::
    PhonemeType.MaybeConsonant -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (PhonemeType.$fShowMaybeConsonant_$cshowsPrec
                   PhonemeType.$fShowMaybeConsonant2) -}
ce20d766f7db823a1a116763987469e0
  $fShowMaybeConsonant10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "place = "#) -}
9bfdc6967977d4759524094b6c24d452
  $fShowMaybeConsonant2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
a10f3497ae1690112aa63d85a98e564a
  $fShowMaybeConsonant3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Blank"#) -}
91c7b647902288b41c038158415dd39c
  $fShowMaybeConsonant4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Consonant {"#) -}
c6fb8f00030cf707ca1aee4159e94745
  $fShowMaybeConsonant5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
3fef6bc31edd17641b6b5ddde239994e
  $fShowMaybeConsonant6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "csymbol = "#) -}
7870e3602239974c86a560aafdf13957
  $fShowMaybeConsonant7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "voice = "#) -}
fdf494c808ccdc9780575408f4a573d6
  $fShowMaybeConsonant8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "manner = "#) -}
5af1692e888acfc09467d7a572e7228d
  $fShowMaybeConsonant9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fShowMaybeConsonant_$cshow ::
    PhonemeType.MaybeConsonant -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.MaybeConsonant ->
                 PhonemeType.$fShowMaybeConsonant_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fShowMaybeConsonant_$cshowList ::
    [PhonemeType.MaybeConsonant] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.MaybeConsonant
                   PhonemeType.$fShowMaybeConsonant1) -}
8b1f1964c3eda75693ff3855f66d2ad1
  $fShowMaybeConsonant_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.MaybeConsonant -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a8 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeConsonant
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Consonant b1 b2 b3 b4
                   -> case a8 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType.$fShowMaybeConsonant10
                            (PhonemeType.$w$cshowsPrec3
                               b1
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  PhonemeType.$fShowMaybeConsonant9
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     PhonemeType.$fShowMaybeConsonant8
                                     (PhonemeType.$w$cshowsPrec2
                                        b2
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           PhonemeType.$fShowMaybeConsonant9
                                           (GHC.Base.++
                                              @ GHC.Types.Char
                                              PhonemeType.$fShowMaybeConsonant7
                                              (let {
                                                 eta1 :: GHC.Base.String
                                                 = GHC.Base.++
                                                     @ GHC.Types.Char
                                                     PhonemeType.$fShowMaybeConsonant9
                                                     (GHC.Base.++
                                                        @ GHC.Types.Char
                                                        PhonemeType.$fShowMaybeConsonant6
                                                        (GHC.Types.:
                                                           @ GHC.Types.Char
                                                           GHC.Show.shows6
                                                           (GHC.Show.showLitString
                                                              b4
                                                              (GHC.Types.:
                                                                 @ GHC.Types.Char
                                                                 GHC.Show.shows6
                                                                 (GHC.Base.++
                                                                    @ GHC.Types.Char
                                                                    PhonemeType.$fShowMaybeConsonant5
                                                                    x1)))))
                                               } in
                                               case b3 of wild2 {
                                                 PhonemeType.VOICELESS
                                                 -> GHC.Base.++
                                                      @ GHC.Types.Char
                                                      PhonemeType.$fReadVoice11
                                                      eta1
                                                 PhonemeType.VOICED
                                                 -> GHC.Base.++
                                                      @ GHC.Types.Char
                                                      PhonemeType.$fReadVoice8
                                                      eta1 })))))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowMaybeConsonant4
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowMaybeConsonant4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Blank
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowMaybeConsonant3
                        eta }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fShowPhonemeInventory ::
    GHC.Show.Show PhonemeType.PhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PhonemeInventory
                  PhonemeType.$fShowPhonemeInventory_$cshowsPrec
                  PhonemeType.$fShowPhonemeInventory_$cshow
                  PhonemeType.$fShowPhonemeInventory_$cshowList -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fShowPhonemeInventory1 ::
    PhonemeType.PhonemeInventory -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType.PhonemeInventory
                   w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ww2 ->
                 PhonemeType.$w$cshowsPrec4 0 ww1 ww2 w1 }) -}
ec9a998ad74c0654f38c23c34b8baea5
  $fShowPhonemeInventory2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PhonemeInventory "#) -}
e51938fc3a28180cc0e71906aef6982c
  $fShowPhonemeInventory3 :: PhonemeType.Vowel -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType.Vowel w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType.Vowel ww1 ww2 ww3 ww4 ->
                 PhonemeType.$w$cshowsPrec5 0 ww1 ww2 ww3 ww4 w1 }) -}
0f35635b99700ec3bf138a6df948a3f6
  $fShowPhonemeInventory4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Vowel {"#) -}
d57b2066b2b058c5ea37921073ad33e1
  $fShowPhonemeInventory5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "vsymbol = "#) -}
75e12cba601104de732da27f4f7111d0
  $fShowPhonemeInventory6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "roundedness = "#) -}
cf4af2fde0d7de7c68f0f23d60ec0bea
  $fShowPhonemeInventory7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "backness = "#) -}
5b6a694498980afb0c473e972d8f625d
  $fShowPhonemeInventory8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "height = "#) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fShowPhonemeInventory_$cshow ::
    PhonemeType.PhonemeInventory -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.PhonemeInventory ->
                 PhonemeType.$fShowPhonemeInventory_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fShowPhonemeInventory_$cshowList ::
    [PhonemeType.PhonemeInventory] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.PhonemeInventory
                   PhonemeType.$fShowPhonemeInventory1) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $fShowPhonemeInventory_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.PhonemeInventory -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.PhonemeInventory
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.PhonemeInventory ww3 ww4 ->
                 PhonemeType.$w$cshowsPrec4 ww1 ww3 ww4 w2 } }) -}
75666487cf3af3760456cef495e6a332
  $fShowPlace :: GHC.Show.Show PhonemeType.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place
                  PhonemeType.$fShowPlace_$cshowsPrec
                  PhonemeType.$fShowPlace_$cshow
                  PhonemeType.$fShowPlace_$cshowList -}
75666487cf3af3760456cef495e6a332
  $fShowPlace_$cshow :: PhonemeType.Place -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Place ->
                 PhonemeType.$fShowPlace_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
75666487cf3af3760456cef495e6a332
  $fShowPlace_$cshowList :: [PhonemeType.Place] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Place
                   PhonemeType.$w$cshowsPrec3) -}
75666487cf3af3760456cef495e6a332
  $fShowPlace_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Place -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Place
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec3 w1 w2) -}
731583abbaff278fb0f2c55475c6f2cd
  $fShowRoundedness :: GHC.Show.Show PhonemeType.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fShowRoundedness_$cshowsPrec
                  PhonemeType.$fShowRoundedness_$cshow
                  PhonemeType.$fShowRoundedness_$cshowList -}
731583abbaff278fb0f2c55475c6f2cd
  $fShowRoundedness1 :: PhonemeType.Roundedness -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Roundedness eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.ROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType.$fReadRoundedness11)
                        eta
                   PhonemeType.UNROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType.$fReadRoundedness8)
                        eta }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fShowRoundedness_$cshow ::
    PhonemeType.Roundedness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Roundedness ->
                 case x of wild {
                   PhonemeType.ROUNDED -> PhonemeType.$fReadRoundedness11
                   PhonemeType.UNROUNDED -> PhonemeType.$fReadRoundedness8 }) -}
731583abbaff278fb0f2c55475c6f2cd
  $fShowRoundedness_$cshowList ::
    [PhonemeType.Roundedness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Roundedness
                   PhonemeType.$fShowRoundedness1) -}
731583abbaff278fb0f2c55475c6f2cd
  $fShowRoundedness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Roundedness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType.Roundedness
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType.ROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType.$fReadRoundedness11)
                        eta
                   PhonemeType.UNROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c2
                           n
                           PhonemeType.$fReadRoundedness8)
                        eta }) -}
555397b244896c50401e55d764c2ad9e
  $fShowVoice :: GHC.Show.Show PhonemeType.Voice
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Voice
                  PhonemeType.$fShowVoice_$cshowsPrec
                  PhonemeType.$fShowVoice_$cshow
                  PhonemeType.$fShowVoice_$cshowList -}
555397b244896c50401e55d764c2ad9e
  $fShowVoice1 :: PhonemeType.Voice -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Voice eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.VOICELESS
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c2 n PhonemeType.$fReadVoice11)
                        eta
                   PhonemeType.VOICED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c2 n PhonemeType.$fReadVoice8)
                        eta }) -}
555397b244896c50401e55d764c2ad9e
  $fShowVoice_$cshow :: PhonemeType.Voice -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Voice ->
                 case x of wild {
                   PhonemeType.VOICELESS -> PhonemeType.$fReadVoice11
                   PhonemeType.VOICED -> PhonemeType.$fReadVoice8 }) -}
555397b244896c50401e55d764c2ad9e
  $fShowVoice_$cshowList :: [PhonemeType.Voice] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Voice
                   PhonemeType.$fShowVoice1) -}
555397b244896c50401e55d764c2ad9e
  $fShowVoice_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Voice -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType.Voice
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType.VOICELESS
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c2 n PhonemeType.$fReadVoice11)
                        eta
                   PhonemeType.VOICED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c2 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c2 n PhonemeType.$fReadVoice8)
                        eta }) -}
e51938fc3a28180cc0e71906aef6982c
  $fShowVowel :: GHC.Show.Show PhonemeType.Vowel
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Vowel
                  PhonemeType.$fShowVowel_$cshowsPrec
                  PhonemeType.$fShowVowel_$cshow
                  PhonemeType.$fShowVowel_$cshowList -}
e51938fc3a28180cc0e71906aef6982c
  $fShowVowel_$cshow :: PhonemeType.Vowel -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Vowel ->
                 PhonemeType.$fShowVowel_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e51938fc3a28180cc0e71906aef6982c
  $fShowVowel_$cshowList :: [PhonemeType.Vowel] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Vowel
                   PhonemeType.$fShowPhonemeInventory3) -}
e51938fc3a28180cc0e71906aef6982c
  $fShowVowel_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Vowel -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Vowel
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.Vowel ww3 ww4 ww5 ww6 ->
                 PhonemeType.$w$cshowsPrec5 ww1 ww3 ww4 ww5 ww6 w2 } }) -}
2eb452ed508175ffd00e0d461ded3bd8
  $w$c< ::
    PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
43ed3d6ea9088d6352adbe7c5a51734d
  $w$c<1 ::
    [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [PhonemeType.MaybeConsonant]
                   ww1 :: [PhonemeType.Vowel]
                   ww2 :: [PhonemeType.MaybeConsonant]
                   ww3 :: [PhonemeType.Vowel] ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType.MaybeConsonant
                        PhonemeType.$fOrdMaybeConsonant
                        ww
                        ww2 of wild {
                   GHC.Types.LT -> GHC.Types.True
                   GHC.Types.EQ
                   -> case GHC.Classes.$w$ccompare14
                             @ PhonemeType.Vowel
                             PhonemeType.$fOrdVowel
                             ww1
                             ww3 of wild1 {
                        DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }
                   GHC.Types.GT -> GHC.Types.False }) -}
4419b74b4c15ddad22bfc8f7c90d5a57
  $w$c<= ::
    PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
9c0a3c3ab47db522d79a25982284b945
  $w$c<=1 ::
    [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [PhonemeType.MaybeConsonant]
                   ww1 :: [PhonemeType.Vowel]
                   ww2 :: [PhonemeType.MaybeConsonant]
                   ww3 :: [PhonemeType.Vowel] ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType.MaybeConsonant
                        PhonemeType.$fOrdMaybeConsonant
                        ww
                        ww2 of wild {
                   GHC.Types.LT -> GHC.Types.True
                   GHC.Types.EQ
                   -> case GHC.Classes.$w$ccompare14
                             @ PhonemeType.Vowel
                             PhonemeType.$fOrdVowel
                             ww1
                             ww3 of wild1 {
                        DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }
                   GHC.Types.GT -> GHC.Types.False }) -}
53222a1407301f66f53e3c0b854960b0
  $w$c== ::
    [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [PhonemeType.MaybeConsonant]
                   ww1 :: [PhonemeType.Vowel]
                   ww2 :: [PhonemeType.MaybeConsonant]
                   ww3 :: [PhonemeType.Vowel] ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeType.MaybeConsonant
                        PhonemeType.$fEqMaybeConsonant
                        ww
                        ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ PhonemeType.Vowel
                        PhonemeType.$fEqVowel
                        ww1
                        ww3 }) -}
19fc45b3c8ab7d18d3af5e5b42054030
  $w$c==1 ::
    PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: PhonemeType.Height
                   ww1 :: PhonemeType.Backness
                   ww2 :: PhonemeType.Roundedness
                   ww3 :: GHC.Base.String
                   ww4 :: PhonemeType.Height
                   ww5 :: PhonemeType.Backness
                   ww6 :: PhonemeType.Roundedness
                   ww7 :: GHC.Base.String ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ w :: GHC.Prim.Void#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Void# -> GHC.Types.Bool
                         {- Arity: 1, Strictness: <L,A> -}
                       = \ w1 :: GHC.Prim.Void#[OneShot] ->
                         case ww2 of wild {
                           PhonemeType.ROUNDED
                           -> case ww6 of wild1 {
                                PhonemeType.ROUNDED -> GHC.Base.eqString ww3 ww7
                                PhonemeType.UNROUNDED -> GHC.Types.False }
                           PhonemeType.UNROUNDED
                           -> case ww6 of wild1 {
                                PhonemeType.ROUNDED -> GHC.Types.False
                                PhonemeType.UNROUNDED -> GHC.Base.eqString ww3 ww7 } }
                     } in
                     case ww1 of wild {
                       PhonemeType.BACK
                       -> case ww5 of wild1 {
                            DEFAULT -> GHC.Types.False PhonemeType.BACK -> $j1 GHC.Prim.void# }
                       PhonemeType.NEARBACK
                       -> case ww5 of wild1 {
                            DEFAULT -> GHC.Types.False
                            PhonemeType.NEARBACK -> $j1 GHC.Prim.void# }
                       PhonemeType.CENTRAL
                       -> case ww5 of wild1 {
                            DEFAULT -> GHC.Types.False
                            PhonemeType.CENTRAL -> $j1 GHC.Prim.void# }
                       PhonemeType.NEARFRONT
                       -> case ww5 of wild1 {
                            DEFAULT -> GHC.Types.False
                            PhonemeType.NEARFRONT -> $j1 GHC.Prim.void# }
                       PhonemeType.FRONT
                       -> case ww5 of wild1 {
                            DEFAULT -> GHC.Types.False
                            PhonemeType.FRONT -> $j1 GHC.Prim.void# } }
                 } in
                 case ww of wild {
                   PhonemeType.CLOSE
                   -> case ww4 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.CLOSE -> $j GHC.Prim.void# }
                   PhonemeType.NEARCLOSE
                   -> case ww4 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEARCLOSE -> $j GHC.Prim.void# }
                   PhonemeType.CLOSEMID
                   -> case ww4 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.CLOSEMID -> $j GHC.Prim.void# }
                   PhonemeType.MID
                   -> case ww4 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.MID -> $j GHC.Prim.void# }
                   PhonemeType.OPENMID
                   -> case ww4 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.OPENMID -> $j GHC.Prim.void# }
                   PhonemeType.NEAROPEN
                   -> case ww4 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEAROPEN -> $j GHC.Prim.void# }
                   PhonemeType.OPEN
                   -> case ww4 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.OPEN -> $j GHC.Prim.void# } }) -}
95343f568ca9482755f4a6590fae3903
  $w$c> ::
    PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
f44fb5b7b04fe24cbb5c4c2d93a65c4e
  $w$c>1 ::
    [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [PhonemeType.MaybeConsonant]
                   ww1 :: [PhonemeType.Vowel]
                   ww2 :: [PhonemeType.MaybeConsonant]
                   ww3 :: [PhonemeType.Vowel] ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType.MaybeConsonant
                        PhonemeType.$fOrdMaybeConsonant
                        ww
                        ww2 of wild {
                   GHC.Types.LT -> GHC.Types.False
                   GHC.Types.EQ
                   -> case GHC.Classes.$w$ccompare14
                             @ PhonemeType.Vowel
                             PhonemeType.$fOrdVowel
                             ww1
                             ww3 of wild1 {
                        DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }
                   GHC.Types.GT -> GHC.Types.True }) -}
7ada2804b4afde7eeb2087a5a8da6686
  $w$c>= ::
    PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
4d3339a0a60db3ff8c65475a007882e8
  $w$c>=1 ::
    [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [PhonemeType.MaybeConsonant]
                   ww1 :: [PhonemeType.Vowel]
                   ww2 :: [PhonemeType.MaybeConsonant]
                   ww3 :: [PhonemeType.Vowel] ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType.MaybeConsonant
                        PhonemeType.$fOrdMaybeConsonant
                        ww
                        ww2 of wild {
                   GHC.Types.LT -> GHC.Types.False
                   GHC.Types.EQ
                   -> case GHC.Classes.$w$ccompare14
                             @ PhonemeType.Vowel
                             PhonemeType.$fOrdVowel
                             ww1
                             ww3 of wild1 {
                        DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }
                   GHC.Types.GT -> GHC.Types.True }) -}
4262468b337d986cff0a737fcceca18d
  $w$ccompare ::
    PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> GHC.Types.Ordering
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
97dabce70ba2d8cec4f2be4744588816
  $w$ccompare1 ::
    [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [PhonemeType.MaybeConsonant]
                   ww1 :: [PhonemeType.Vowel]
                   ww2 :: [PhonemeType.MaybeConsonant]
                   ww3 :: [PhonemeType.Vowel] ->
                 case GHC.Classes.$w$ccompare14
                        @ PhonemeType.MaybeConsonant
                        PhonemeType.$fOrdMaybeConsonant
                        ww
                        ww2 of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ
                   -> GHC.Classes.$w$ccompare14
                        @ PhonemeType.Vowel
                        PhonemeType.$fOrdVowel
                        ww1
                        ww3
                   GHC.Types.GT -> GHC.Types.GT }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $w$cshowsPrec ::
    PhonemeType.Backness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Backness w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.BACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadBackness23 w1
                   PhonemeType.NEARBACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadBackness20 w1
                   PhonemeType.CENTRAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadBackness17 w1
                   PhonemeType.NEARFRONT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadBackness14 w1
                   PhonemeType.FRONT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadBackness11
                        w1 }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $w$cshowsPrec1 ::
    PhonemeType.Height -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Height w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.CLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight31 w1
                   PhonemeType.NEARCLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight28 w1
                   PhonemeType.CLOSEMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight25 w1
                   PhonemeType.MID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight22 w1
                   PhonemeType.OPENMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight19 w1
                   PhonemeType.NEAROPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight16 w1
                   PhonemeType.OPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight13 w1 }) -}
ad2ca82feee9cd68bab57395bd7db297
  $w$cshowsPrec2 ::
    PhonemeType.Manner -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Manner w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.NASAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner47 w1
                   PhonemeType.STOP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner44 w1
                   PhonemeType.AFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner41 w1
                   PhonemeType.FRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner38 w1
                   PhonemeType.APPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner35 w1
                   PhonemeType.FLAP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner32 w1
                   PhonemeType.TRILL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner29 w1
                   PhonemeType.LAFFRICATE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner26 w1
                   PhonemeType.LFRICATIVE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner23 w1
                   PhonemeType.LAPPROXIMANT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner20 w1
                   PhonemeType.LFLAP
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadManner17 w1 }) -}
75666487cf3af3760456cef495e6a332
  $w$cshowsPrec3 ::
    PhonemeType.Place -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Place w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.BILABIAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace51 w1
                   PhonemeType.LABIODENTAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace48 w1
                   PhonemeType.DENTAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace45 w1
                   PhonemeType.ALVEOLAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace42 w1
                   PhonemeType.PALATOALVEOLAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace39 w1
                   PhonemeType.RETROFLEX
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace36 w1
                   PhonemeType.ALVEOLOPALATAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace33 w1
                   PhonemeType.PALATAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace30 w1
                   PhonemeType.VELAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace27 w1
                   PhonemeType.UVULAR
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace24 w1
                   PhonemeType.PHARYNGEAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace21 w1
                   PhonemeType.GLOTTAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadPlace18 w1 }) -}
87fcf26af45dc012df53a4da2bfbbb88
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> [PhonemeType.MaybeConsonant]
    -> [PhonemeType.Vowel]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeType.MaybeConsonant]
                   ww2 :: [PhonemeType.Vowel]
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Show.showList__
                       @ PhonemeType.MaybeConsonant
                       PhonemeType.$fShowMaybeConsonant1
                       ww1
                       (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.showSpace1
                          (GHC.Show.showList__
                             @ PhonemeType.Vowel
                             PhonemeType.$fShowPhonemeInventory3
                             ww2
                             x))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowPhonemeInventory2
                        (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType.$fShowPhonemeInventory2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
25b87582a8929dde194c49d82e5d38e2
  $w$cshowsPrec5 ::
    GHC.Prim.Int#
    -> PhonemeType.Height
    -> PhonemeType.Backness
    -> PhonemeType.Roundedness
    -> GHC.Base.String
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 6, Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType.Height
                   ww2 :: PhonemeType.Backness
                   ww3 :: PhonemeType.Roundedness
                   ww4 :: GHC.Base.String
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType.$fShowPhonemeInventory8
                       (PhonemeType.$w$cshowsPrec1
                          ww1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowMaybeConsonant9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowPhonemeInventory7
                                (PhonemeType.$w$cshowsPrec
                                   ww2
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      PhonemeType.$fShowMaybeConsonant9
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         PhonemeType.$fShowPhonemeInventory6
                                         (let {
                                            eta :: GHC.Base.String
                                            = GHC.Base.++
                                                @ GHC.Types.Char
                                                PhonemeType.$fShowMaybeConsonant9
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   PhonemeType.$fShowPhonemeInventory5
                                                   (GHC.Types.:
                                                      @ GHC.Types.Char
                                                      GHC.Show.shows6
                                                      (GHC.Show.showLitString
                                                         ww4
                                                         (GHC.Types.:
                                                            @ GHC.Types.Char
                                                            GHC.Show.shows6
                                                            (GHC.Base.++
                                                               @ GHC.Types.Char
                                                               PhonemeType.$fShowMaybeConsonant5
                                                               x)))))
                                          } in
                                          case ww3 of wild {
                                            PhonemeType.ROUNDED
                                            -> GHC.Base.++
                                                 @ GHC.Types.Char
                                                 PhonemeType.$fReadRoundedness11
                                                 eta
                                            PhonemeType.UNROUNDED
                                            -> GHC.Base.++
                                                 @ GHC.Types.Char
                                                 PhonemeType.$fReadRoundedness8
                                                 eta })))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowPhonemeInventory4
                        (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType.$fShowPhonemeInventory4
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
b87c0c3ee94d9a9392430cfc9b970753
  $w$ctoEnum :: GHC.Prim.Int# -> PhonemeType.Backness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumBackness6 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 4) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumBackness6 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Backness ww } }) -}
d2d6ccc9167c24cb6a2e2ffa3696e323
  $w$ctoEnum1 :: GHC.Prim.Int# -> PhonemeType.Height
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumHeight8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumHeight8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Height ww } }) -}
ad2ca82feee9cd68bab57395bd7db297
  $w$ctoEnum2 :: GHC.Prim.Int# -> PhonemeType.Manner
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumManner1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 10) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumManner1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Manner ww } }) -}
75666487cf3af3760456cef495e6a332
  $w$ctoEnum3 :: GHC.Prim.Int# -> PhonemeType.Place
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumPlace1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 11) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumPlace1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Place ww } }) -}
731583abbaff278fb0f2c55475c6f2cd
  $w$ctoEnum4 :: GHC.Prim.Int# -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumRoundedness1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumRoundedness1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Roundedness ww } }) -}
555397b244896c50401e55d764c2ad9e
  $w$ctoEnum5 :: GHC.Prim.Int# -> PhonemeType.Voice
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumVoice1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumVoice1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Voice ww } }) -}
804ff93701ffdbf6b2cf2fbcf45f6032
  $wa ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.PhonemeInventory -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType.PhonemeInventory
                        -> Text.ParserCombinators.ReadP.P b ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                   GHC.Types.True
                   -> let {
                        lvl78 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl79 :: Text.ParserCombinators.ReadP.P b
                            = GHC.Read.$wa
                                @ PhonemeType.MaybeConsonant
                                PhonemeType.$fReadMaybeConsonant2
                                  `cast`
                                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                          <PhonemeType.MaybeConsonant>_R))
                                @ b
                                (\ a8 :: [PhonemeType.MaybeConsonant] ->
                                 GHC.Read.$wa
                                   @ PhonemeType.Vowel
                                   PhonemeType.$fReadPhonemeInventory5
                                     `cast`
                                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                             <PhonemeType.Vowel>_R))
                                   @ b
                                   (\ a9 :: [PhonemeType.Vowel] ->
                                    w (PhonemeType.PhonemeInventory a8 a9)))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a8
                               -> case GHC.Base.eqString
                                         a8
                                         PhonemeType.$fReadPhonemeInventory4 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl79 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl78) -}
                        = \ w2 :: () -> lvl78
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ a98 :: GHC.Base.String ->
                         (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                           `cast`
                         (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                           @ b
                           k) }) -}
e51938fc3a28180cc0e71906aef6982c
  $wa1 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.Vowel -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
b87c0c3ee94d9a9392430cfc9b970753
  data Backness = BACK | NEARBACK | CENTRAL | NEARFRONT | FRONT
    Promotable
d2d6ccc9167c24cb6a2e2ffa3696e323
  data Height
    = CLOSE | NEARCLOSE | CLOSEMID | MID | OPENMID | NEAROPEN | OPEN
    Promotable
ad2ca82feee9cd68bab57395bd7db297
  data Manner
    = NASAL
    | STOP
    | AFFRICATE
    | FRICATIVE
    | APPROXIMANT
    | FLAP
    | TRILL
    | LAFFRICATE
    | LFRICATIVE
    | LAPPROXIMANT
    | LFLAP
    Promotable
8b1f1964c3eda75693ff3855f66d2ad1
  data MaybeConsonant
    = Consonant {place :: PhonemeType.Place,
                 manner :: PhonemeType.Manner,
                 voice :: PhonemeType.Voice,
                 csymbol :: GHC.Base.String}
    | Blank
804ff93701ffdbf6b2cf2fbcf45f6032
  data PhonemeInventory
    = PhonemeInventory [PhonemeType.MaybeConsonant] [PhonemeType.Vowel]
75666487cf3af3760456cef495e6a332
  data Place
    = BILABIAL
    | LABIODENTAL
    | DENTAL
    | ALVEOLAR
    | PALATOALVEOLAR
    | RETROFLEX
    | ALVEOLOPALATAL
    | PALATAL
    | VELAR
    | UVULAR
    | PHARYNGEAL
    | GLOTTAL
    Promotable
731583abbaff278fb0f2c55475c6f2cd
  data Roundedness = ROUNDED | UNROUNDED
    Promotable
555397b244896c50401e55d764c2ad9e
  data Voice = VOICELESS | VOICED
    Promotable
e51938fc3a28180cc0e71906aef6982c
  data Vowel
    = Vowel {height :: PhonemeType.Height,
             backness :: PhonemeType.Backness,
             roundedness :: PhonemeType.Roundedness,
             vsymbol :: GHC.Base.String}
bf368135c8e69bd10949ba57e1a89035
  backness :: PhonemeType.Vowel -> PhonemeType.Backness
  RecSel PhonemeType.Vowel
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Vowel ->
                 case ds of wild { PhonemeType.Vowel ds1 ds2 ds3 ds4 -> ds2 }) -}
b6e3542c49e902fb66a84156d3e9bf2f
  csymbol :: PhonemeType.MaybeConsonant -> GHC.Base.String
  RecSel PhonemeType.MaybeConsonant
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.MaybeConsonant ->
                 case ds of wild {
                   PhonemeType.Consonant ds1 ds2 ds3 ds4 -> ds4
                   PhonemeType.Blank -> PhonemeType.csymbol1 }) -}
9f701c2e931fb1674651bd56f0a259ff
  csymbol1 :: GHC.Base.String
  {- Strictness: b -}
ae4b6cd1160e46070ff972991b7d042c
  height :: PhonemeType.Vowel -> PhonemeType.Height
  RecSel PhonemeType.Vowel
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Vowel ->
                 case ds of wild { PhonemeType.Vowel ds1 ds2 ds3 ds4 -> ds1 }) -}
0b67e7736f76d2a36423a4fac280bcdb
  manner :: PhonemeType.MaybeConsonant -> PhonemeType.Manner
  RecSel PhonemeType.MaybeConsonant
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.MaybeConsonant ->
                 case ds of wild {
                   PhonemeType.Consonant ds1 ds2 ds3 ds4 -> ds2
                   PhonemeType.Blank -> PhonemeType.manner1 }) -}
9a6f43d158ab2fd73112b2144376ddab
  manner1 :: PhonemeType.Manner
  {- Strictness: b -}
7c8b702e51168c8fab25421a7dbc3883
  place :: PhonemeType.MaybeConsonant -> PhonemeType.Place
  RecSel PhonemeType.MaybeConsonant
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.MaybeConsonant ->
                 case ds of wild {
                   PhonemeType.Consonant ds1 ds2 ds3 ds4 -> ds1
                   PhonemeType.Blank -> PhonemeType.place1 }) -}
a3038bfde5ac0a82531e41f546e7a6bc
  place1 :: PhonemeType.Place
  {- Strictness: b -}
4e11e34a9ab6f908626e10296f5d2a7c
  roundedness :: PhonemeType.Vowel -> PhonemeType.Roundedness
  RecSel PhonemeType.Vowel
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Vowel ->
                 case ds of wild { PhonemeType.Vowel ds1 ds2 ds3 ds4 -> ds3 }) -}
33b01813a3d452b380572c6dd037f688
  voice :: PhonemeType.MaybeConsonant -> PhonemeType.Voice
  RecSel PhonemeType.MaybeConsonant
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.MaybeConsonant ->
                 case ds of wild {
                   PhonemeType.Consonant ds1 ds2 ds3 ds4 -> ds3
                   PhonemeType.Blank -> PhonemeType.voice1 }) -}
6d7378c05b55f266e56a8fc467efd170
  voice1 :: PhonemeType.Voice
  {- Strictness: b -}
164ca582ed0d0268bd70459273e59e52
  vsymbol :: PhonemeType.Vowel -> GHC.Base.String
  RecSel PhonemeType.Vowel
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Vowel ->
                 case ds of wild { PhonemeType.Vowel ds1 ds2 ds3 ds4 -> ds4 }) -}
instance GHC.Enum.Bounded [PhonemeType.Backness]
  = PhonemeType.$fBoundedBackness
instance GHC.Enum.Bounded [PhonemeType.Height]
  = PhonemeType.$fBoundedHeight
instance GHC.Enum.Bounded [PhonemeType.Manner]
  = PhonemeType.$fBoundedManner
instance GHC.Enum.Bounded [PhonemeType.Place]
  = PhonemeType.$fBoundedPlace
instance GHC.Enum.Bounded [PhonemeType.Roundedness]
  = PhonemeType.$fBoundedRoundedness
instance GHC.Enum.Bounded [PhonemeType.Voice]
  = PhonemeType.$fBoundedVoice
instance GHC.Enum.Enum [PhonemeType.Backness]
  = PhonemeType.$fEnumBackness
instance GHC.Enum.Enum [PhonemeType.Height]
  = PhonemeType.$fEnumHeight
instance GHC.Enum.Enum [PhonemeType.Manner]
  = PhonemeType.$fEnumManner
instance GHC.Enum.Enum [PhonemeType.Place]
  = PhonemeType.$fEnumPlace
instance GHC.Enum.Enum [PhonemeType.Roundedness]
  = PhonemeType.$fEnumRoundedness
instance GHC.Enum.Enum [PhonemeType.Voice]
  = PhonemeType.$fEnumVoice
instance GHC.Classes.Eq [PhonemeType.Backness]
  = PhonemeType.$fEqBackness
instance GHC.Classes.Eq [PhonemeType.Height]
  = PhonemeType.$fEqHeight
instance GHC.Classes.Eq [PhonemeType.Manner]
  = PhonemeType.$fEqManner
instance GHC.Classes.Eq [PhonemeType.MaybeConsonant]
  = PhonemeType.$fEqMaybeConsonant
instance GHC.Classes.Eq [PhonemeType.PhonemeInventory]
  = PhonemeType.$fEqPhonemeInventory
instance GHC.Classes.Eq [PhonemeType.Place] = PhonemeType.$fEqPlace
instance GHC.Classes.Eq [PhonemeType.Roundedness]
  = PhonemeType.$fEqRoundedness
instance GHC.Classes.Eq [PhonemeType.Voice] = PhonemeType.$fEqVoice
instance GHC.Classes.Eq [PhonemeType.Vowel] = PhonemeType.$fEqVowel
instance GHC.Classes.Ord [PhonemeType.Backness]
  = PhonemeType.$fOrdBackness
instance GHC.Classes.Ord [PhonemeType.Height]
  = PhonemeType.$fOrdHeight
instance GHC.Classes.Ord [PhonemeType.Manner]
  = PhonemeType.$fOrdManner
instance GHC.Classes.Ord [PhonemeType.MaybeConsonant]
  = PhonemeType.$fOrdMaybeConsonant
instance GHC.Classes.Ord [PhonemeType.PhonemeInventory]
  = PhonemeType.$fOrdPhonemeInventory
instance GHC.Classes.Ord [PhonemeType.Place]
  = PhonemeType.$fOrdPlace
instance GHC.Classes.Ord [PhonemeType.Roundedness]
  = PhonemeType.$fOrdRoundedness
instance GHC.Classes.Ord [PhonemeType.Voice]
  = PhonemeType.$fOrdVoice
instance GHC.Classes.Ord [PhonemeType.Vowel]
  = PhonemeType.$fOrdVowel
instance GHC.Read.Read [PhonemeType.Backness]
  = PhonemeType.$fReadBackness
instance GHC.Read.Read [PhonemeType.Height]
  = PhonemeType.$fReadHeight
instance GHC.Read.Read [PhonemeType.Manner]
  = PhonemeType.$fReadManner
instance GHC.Read.Read [PhonemeType.MaybeConsonant]
  = PhonemeType.$fReadMaybeConsonant
instance GHC.Read.Read [PhonemeType.PhonemeInventory]
  = PhonemeType.$fReadPhonemeInventory
instance GHC.Read.Read [PhonemeType.Place]
  = PhonemeType.$fReadPlace
instance GHC.Read.Read [PhonemeType.Roundedness]
  = PhonemeType.$fReadRoundedness
instance GHC.Read.Read [PhonemeType.Voice]
  = PhonemeType.$fReadVoice
instance GHC.Read.Read [PhonemeType.Vowel]
  = PhonemeType.$fReadVowel
instance GHC.Show.Show [PhonemeType.Backness]
  = PhonemeType.$fShowBackness
instance GHC.Show.Show [PhonemeType.Height]
  = PhonemeType.$fShowHeight
instance GHC.Show.Show [PhonemeType.Manner]
  = PhonemeType.$fShowManner
instance GHC.Show.Show [PhonemeType.MaybeConsonant]
  = PhonemeType.$fShowMaybeConsonant
instance GHC.Show.Show [PhonemeType.PhonemeInventory]
  = PhonemeType.$fShowPhonemeInventory
instance GHC.Show.Show [PhonemeType.Place]
  = PhonemeType.$fShowPlace
instance GHC.Show.Show [PhonemeType.Roundedness]
  = PhonemeType.$fShowRoundedness
instance GHC.Show.Show [PhonemeType.Voice]
  = PhonemeType.$fShowVoice
instance GHC.Show.Show [PhonemeType.Vowel]
  = PhonemeType.$fShowVowel
"SPEC/PhonemeType $dmreadsPrec @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeType.Backness
  GHC.Read.$dmreadsPrec @ PhonemeType.Backness $dRead
  = PhonemeType.$fReadBackness_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeType.Height
  GHC.Read.$dmreadsPrec @ PhonemeType.Height $dRead
  = PhonemeType.$fReadHeight_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                     PhonemeType.Manner
  GHC.Read.$dmreadsPrec @ PhonemeType.Manner $dRead
  = PhonemeType.$fReadManner_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ MaybeConsonant" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                             PhonemeType.MaybeConsonant
  GHC.Read.$dmreadsPrec @ PhonemeType.MaybeConsonant $dRead
  = PhonemeType.$fReadMaybeConsonant_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                    PhonemeType.Place
  GHC.Read.$dmreadsPrec @ PhonemeType.Place $dRead
  = PhonemeType.$fReadPlace_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          PhonemeType.Roundedness
  GHC.Read.$dmreadsPrec @ PhonemeType.Roundedness $dRead
  = PhonemeType.$fReadRoundedness_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Voice" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                    PhonemeType.Voice
  GHC.Read.$dmreadsPrec @ PhonemeType.Voice $dRead
  = PhonemeType.$fReadVoice_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Vowel" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                    PhonemeType.Vowel
  GHC.Read.$dmreadsPrec @ PhonemeType.Vowel $dRead
  = PhonemeType.$fReadVowel_$s$dmreadsPrec
"SPEC/PhonemeType readListDefault @ Backness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          PhonemeType.Backness
  GHC.Read.readListDefault @ PhonemeType.Backness $dRead
  = PhonemeType.$fReadBackness_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Height" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType.Height
  GHC.Read.readListDefault @ PhonemeType.Height $dRead
  = PhonemeType.$fReadHeight_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Manner" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                        PhonemeType.Manner
  GHC.Read.readListDefault @ PhonemeType.Manner $dRead
  = PhonemeType.$fReadManner_$sreadListDefault
"SPEC/PhonemeType readListDefault @ MaybeConsonant" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                PhonemeType.MaybeConsonant
  GHC.Read.readListDefault @ PhonemeType.MaybeConsonant $dRead
  = PhonemeType.$fReadMaybeConsonant_$sreadListDefault
"SPEC/PhonemeType readListDefault @ PhonemeInventory" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                                  PhonemeType.PhonemeInventory
  GHC.Read.readListDefault @ PhonemeType.PhonemeInventory $dRead
  = PhonemeType.$fReadPhonemeInventory_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Place" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeType.Place
  GHC.Read.readListDefault @ PhonemeType.Place $dRead
  = PhonemeType.$fReadPlace_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Roundedness" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                             PhonemeType.Roundedness
  GHC.Read.readListDefault @ PhonemeType.Roundedness $dRead
  = PhonemeType.$fReadRoundedness_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Voice" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeType.Voice
  GHC.Read.readListDefault @ PhonemeType.Voice $dRead
  = PhonemeType.$fReadVoice_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Vowel" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       PhonemeType.Vowel
  GHC.Read.readListDefault @ PhonemeType.Vowel $dRead
  = PhonemeType.$fReadVowel_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

