
==================== FINAL INTERFACE ====================
2016-09-05 02:25:17.570567 UTC

interface conla_4HxSYcynNloL3TkunNPLrN:PhonemeType 7103
  interface hash: a3445d32c777ed111550b186b7137880
  ABI hash: 64ec2953210c96a06877ebe69cbc6bdb
  export-list hash: 004e39dea0afa7a2c08b26e1f45e6f41
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  PhonemeType.ActiveArticulator{PhonemeType.LARYNX PhonemeType.LOWERLIP PhonemeType.TONGUEBLADE PhonemeType.TONGUEBODY PhonemeType.TONGUEROOT PhonemeType.TONGUETIP PhonemeType.TONGUEUNDER}
  PhonemeType.AirEscape{PhonemeType.NASALIZED PhonemeType.ORAL}
  PhonemeType.Airstream{PhonemeType.Airstream PhonemeType.direction PhonemeType.initiator}
  PhonemeType.Backness{PhonemeType.BACK PhonemeType.CENTRAL PhonemeType.FRONT PhonemeType.NEARBACK PhonemeType.NEARFRONT}
  PhonemeType.ConsonantFeatures{PhonemeType.ConsonantFeatures PhonemeType.airstream PhonemeType.manner PhonemeType.phonation PhonemeType.place}
  PhonemeType.ConsonantFeaturesContour{PhonemeType.ConsonantFeaturesContour PhonemeType.firstCContour PhonemeType.secondCContour}
  PhonemeType.Direction{PhonemeType.EGRESSIVE PhonemeType.INGRESSIVE}
  PhonemeType.Height{PhonemeType.CLOSE PhonemeType.CLOSEMID PhonemeType.MID PhonemeType.NEARCLOSE PhonemeType.NEAROPEN PhonemeType.OPEN PhonemeType.OPENMID}
  PhonemeType.Initiator{PhonemeType.GLOTTIC PhonemeType.LINGUAL PhonemeType.PULMONIC}
  PhonemeType.Laterality{PhonemeType.LATERAL PhonemeType.NONLATERAL}
  PhonemeType.Length{PhonemeType.LONG PhonemeType.NORMAL PhonemeType.SHORT}
  PhonemeType.Manner{PhonemeType.Manner PhonemeType.airescape PhonemeType.laterality PhonemeType.mannerLength PhonemeType.silibance PhonemeType.stricture PhonemeType.trill PhonemeType.vot}
  PhonemeType.MaybeBlank{PhonemeType.Blank PhonemeType.Filled}
  PhonemeType.MaybeImpossible{PhonemeType.Impossible PhonemeType.Possible}
  PhonemeType.MaybeUnspecified{PhonemeType.Specified PhonemeType.Unspecified}
  PhonemeType.PassiveArticulator{PhonemeType.BACKRIDGE PhonemeType.EPIGLOTTIS PhonemeType.GLOTTIS PhonemeType.HARDPALATE PhonemeType.PHARYNX PhonemeType.RIDGE PhonemeType.SOFTPALATE PhonemeType.TEETHRIDGE PhonemeType.UPPERLIP PhonemeType.UPPERTEETH PhonemeType.UVULA}
  PhonemeType.Phonation{PhonemeType.BREATHY PhonemeType.CLOSURE PhonemeType.CREAKY PhonemeType.MODAL PhonemeType.SLACK PhonemeType.STIFF PhonemeType.VOICELESS}
  PhonemeType.PhonemeInventory{PhonemeType.PhonemeInventory}
  PhonemeType.Place{PhonemeType.Place PhonemeType.active PhonemeType.passive}
  PhonemeType.Roundedness{PhonemeType.ROUNDED PhonemeType.UNROUNDED}
  PhonemeType.Silibance{PhonemeType.NONSILIBANT PhonemeType.SILIBANT}
  PhonemeType.Stricture{PhonemeType.OCCLUSION PhonemeType.SLIGHTTURBULENT PhonemeType.TURBULENT}
  PhonemeType.Trill{PhonemeType.NOTTRILLED PhonemeType.TRILLED}
  PhonemeType.VOT{PhonemeType.NEGATIVE PhonemeType.POSITIVE PhonemeType.ZERO}
  PhonemeType.VowelFeatures{PhonemeType.VowelFeatures PhonemeType.airescape2 PhonemeType.airstream2 PhonemeType.backness PhonemeType.height PhonemeType.length2 PhonemeType.phonation2 PhonemeType.roundedness}
  PhonemeType.VowelFeaturesContour{PhonemeType.VowelFeaturesContour PhonemeType.firstVContour PhonemeType.secondVContour}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Read b423b4506a014855edbd329b567629f3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.ParserCombinators.ReadPrec 2590e0e0a57a86ac7c62727f4d868dd2
import  -/  base-4.8.2.0:Text.Read.Lex 724ca44ddd38ddc5f47a501d62736c26
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
fd40a704b56f8a83c2b0aea2398f0cd7
  $fBoundedActiveArticulator ::
    GHC.Enum.Bounded PhonemeType.ActiveArticulator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ActiveArticulator
                  PhonemeType.LOWERLIP
                  PhonemeType.LARYNX -}
483edd05f8d1cf327b30114f3225d3b2
  $fBoundedAirEscape :: GHC.Enum.Bounded PhonemeType.AirEscape
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.AirEscape PhonemeType.NASALIZED PhonemeType.ORAL -}
4600283dc79ec1a04339fecb849d3137
  $fBoundedBackness :: GHC.Enum.Bounded PhonemeType.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness PhonemeType.BACK PhonemeType.FRONT -}
40a9c5f987e37783909145cb5997138e
  $fBoundedDirection :: GHC.Enum.Bounded PhonemeType.Direction
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Direction
                  PhonemeType.INGRESSIVE
                  PhonemeType.EGRESSIVE -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fBoundedHeight :: GHC.Enum.Bounded PhonemeType.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height PhonemeType.CLOSE PhonemeType.OPEN -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fBoundedInitiator :: GHC.Enum.Bounded PhonemeType.Initiator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Initiator PhonemeType.LINGUAL PhonemeType.PULMONIC -}
563547f95f31ce703bd3964698c86217
  $fBoundedLaterality :: GHC.Enum.Bounded PhonemeType.Laterality
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Laterality
                  PhonemeType.LATERAL
                  PhonemeType.NONLATERAL -}
355f724f9de26105f3758df52d82fae4
  $fBoundedLength :: GHC.Enum.Bounded PhonemeType.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Length PhonemeType.SHORT PhonemeType.LONG -}
dcbf3455324a78016700898324489067
  $fBoundedPassiveArticulator ::
    GHC.Enum.Bounded PhonemeType.PassiveArticulator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PassiveArticulator
                  PhonemeType.UPPERLIP
                  PhonemeType.GLOTTIS -}
1876b99e8b904b79707be731945482ec
  $fBoundedPhonation :: GHC.Enum.Bounded PhonemeType.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Phonation
                  PhonemeType.VOICELESS
                  PhonemeType.CLOSURE -}
9c915b50edb2977ec86c27bd6c240a83
  $fBoundedRoundedness :: GHC.Enum.Bounded PhonemeType.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.UNROUNDED
                  PhonemeType.ROUNDED -}
1940ee84f46a7a0f1801689311b6be65
  $fBoundedSilibance :: GHC.Enum.Bounded PhonemeType.Silibance
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Silibance
                  PhonemeType.SILIBANT
                  PhonemeType.NONSILIBANT -}
f45b7454df7117690624094b2e33986b
  $fBoundedStricture :: GHC.Enum.Bounded PhonemeType.Stricture
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Stricture
                  PhonemeType.OCCLUSION
                  PhonemeType.SLIGHTTURBULENT -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fBoundedTrill :: GHC.Enum.Bounded PhonemeType.Trill
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Trill PhonemeType.TRILLED PhonemeType.NOTTRILLED -}
16d61d06081f347fd36865d448a9e38e
  $fBoundedVOT :: GHC.Enum.Bounded PhonemeType.VOT
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VOT PhonemeType.POSITIVE PhonemeType.NEGATIVE -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator ::
    GHC.Enum.Enum PhonemeType.ActiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ActiveArticulator
                  PhonemeType.$fEnumActiveArticulator_$csucc
                  PhonemeType.$fEnumActiveArticulator_$cpred
                  PhonemeType.$fEnumActiveArticulator_$ctoEnum
                  PhonemeType.$fEnumActiveArticulator_$cfromEnum
                  PhonemeType.$fEnumActiveArticulator_$cenumFrom
                  PhonemeType.$fEnumActiveArticulator_$cenumFromThen
                  PhonemeType.$fEnumActiveArticulator_$cenumFromTo
                  PhonemeType.$fEnumActiveArticulator_$cenumFromThenTo -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator1 :: [PhonemeType.ActiveArticulator]
  {- Unfolding: (PhonemeType.$fEnumActiveArticulator_go7 6) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator10 :: PhonemeType.ActiveArticulator
  {- Strictness: b -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator2 :: [PhonemeType.ActiveArticulator]
  {- Unfolding: (PhonemeType.$fEnumActiveArticulator_go8 5) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator3 :: [PhonemeType.ActiveArticulator]
  {- Unfolding: (PhonemeType.$fEnumActiveArticulator_go9 4) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator4 :: [PhonemeType.ActiveArticulator]
  {- Unfolding: (PhonemeType.$fEnumActiveArticulator_go10 3) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator5 :: [PhonemeType.ActiveArticulator]
  {- Unfolding: (PhonemeType.$fEnumActiveArticulator_go11 2) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator6 :: [PhonemeType.ActiveArticulator]
  {- Unfolding: (PhonemeType.$fEnumActiveArticulator_go12 1) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator7 :: [PhonemeType.ActiveArticulator]
  {- Unfolding: (PhonemeType.$fEnumActiveArticulator_go13 0) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator8 ::
    GHC.Prim.Int# -> PhonemeType.ActiveArticulator
  {- Arity: 1, Strictness: <L,U>b -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator9 :: PhonemeType.ActiveArticulator
  {- Strictness: b -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_$cenumFrom ::
    PhonemeType.ActiveArticulator -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.ActiveArticulator ->
                 case a23 of wild {
                   PhonemeType.LOWERLIP -> PhonemeType.$fEnumActiveArticulator7
                   PhonemeType.TONGUEBLADE -> PhonemeType.$fEnumActiveArticulator6
                   PhonemeType.TONGUETIP -> PhonemeType.$fEnumActiveArticulator5
                   PhonemeType.TONGUEUNDER -> PhonemeType.$fEnumActiveArticulator4
                   PhonemeType.TONGUEBODY -> PhonemeType.$fEnumActiveArticulator3
                   PhonemeType.TONGUEROOT -> PhonemeType.$fEnumActiveArticulator2
                   PhonemeType.LARYNX -> PhonemeType.$fEnumActiveArticulator1 }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_$cenumFromThen ::
    PhonemeType.ActiveArticulator
    -> PhonemeType.ActiveArticulator -> [PhonemeType.ActiveArticulator]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.ActiveArticulator
                   b :: PhonemeType.ActiveArticulator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.ActiveArticulator]
                                    PhonemeType.$fEnumActiveArticulator_c
                                    (GHC.Types.[] @ PhonemeType.ActiveArticulator)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.ActiveArticulator]
                                    PhonemeType.$fEnumActiveArticulator_c
                                    (GHC.Types.[] @ PhonemeType.ActiveArticulator)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.LOWERLIP -> $j1 0
                       PhonemeType.TONGUEBLADE -> $j1 1
                       PhonemeType.TONGUETIP -> $j1 2
                       PhonemeType.TONGUEUNDER -> $j1 3
                       PhonemeType.TONGUEBODY -> $j1 4
                       PhonemeType.TONGUEROOT -> $j1 5
                       PhonemeType.LARYNX -> $j1 6 }
                 } in
                 case a23 of wild {
                   PhonemeType.LOWERLIP -> $j 0
                   PhonemeType.TONGUEBLADE -> $j 1
                   PhonemeType.TONGUETIP -> $j 2
                   PhonemeType.TONGUEUNDER -> $j 3
                   PhonemeType.TONGUEBODY -> $j 4
                   PhonemeType.TONGUEROOT -> $j 5
                   PhonemeType.LARYNX -> $j 6 }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_$cenumFromThenTo ::
    PhonemeType.ActiveArticulator
    -> PhonemeType.ActiveArticulator
    -> PhonemeType.ActiveArticulator
    -> [PhonemeType.ActiveArticulator]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_$cenumFromTo ::
    PhonemeType.ActiveArticulator
    -> PhonemeType.ActiveArticulator -> [PhonemeType.ActiveArticulator]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.ActiveArticulator
                   y :: PhonemeType.ActiveArticulator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.LOWERLIP
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumActiveArticulator_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.ActiveArticulator }
                       PhonemeType.TONGUEBLADE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumActiveArticulator_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.ActiveArticulator }
                       PhonemeType.TONGUETIP
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumActiveArticulator_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.ActiveArticulator }
                       PhonemeType.TONGUEUNDER
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumActiveArticulator_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.ActiveArticulator }
                       PhonemeType.TONGUEBODY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumActiveArticulator_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.ActiveArticulator }
                       PhonemeType.TONGUEROOT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumActiveArticulator_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.ActiveArticulator }
                       PhonemeType.LARYNX
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumActiveArticulator_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.ActiveArticulator } }
                 } in
                 case x of wild {
                   PhonemeType.LOWERLIP -> $j 0
                   PhonemeType.TONGUEBLADE -> $j 1
                   PhonemeType.TONGUETIP -> $j 2
                   PhonemeType.TONGUEUNDER -> $j 3
                   PhonemeType.TONGUEBODY -> $j 4
                   PhonemeType.TONGUEROOT -> $j 5
                   PhonemeType.LARYNX -> $j 6 }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_$cfromEnum ::
    PhonemeType.ActiveArticulator -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType.ActiveArticulator ->
                 case w of wild {
                   PhonemeType.LOWERLIP -> GHC.Types.I# 0
                   PhonemeType.TONGUEBLADE -> GHC.Types.I# 1
                   PhonemeType.TONGUETIP -> GHC.Types.I# 2
                   PhonemeType.TONGUEUNDER -> GHC.Types.I# 3
                   PhonemeType.TONGUEBODY -> GHC.Types.I# 4
                   PhonemeType.TONGUEROOT -> GHC.Types.I# 5
                   PhonemeType.LARYNX -> GHC.Types.I# 6 }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_$cpred ::
    PhonemeType.ActiveArticulator -> PhonemeType.ActiveArticulator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.ActiveArticulator ->
                 case a23 of wild {
                   PhonemeType.LOWERLIP -> PhonemeType.$fEnumActiveArticulator9
                   PhonemeType.TONGUEBLADE -> PhonemeType.LOWERLIP
                   PhonemeType.TONGUETIP -> PhonemeType.TONGUEBLADE
                   PhonemeType.TONGUEUNDER -> PhonemeType.TONGUETIP
                   PhonemeType.TONGUEBODY -> PhonemeType.TONGUEUNDER
                   PhonemeType.TONGUEROOT -> PhonemeType.TONGUEBODY
                   PhonemeType.LARYNX -> PhonemeType.TONGUEROOT }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_$csucc ::
    PhonemeType.ActiveArticulator -> PhonemeType.ActiveArticulator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.ActiveArticulator ->
                 case a23 of wild {
                   PhonemeType.LOWERLIP -> PhonemeType.TONGUEBLADE
                   PhonemeType.TONGUEBLADE -> PhonemeType.TONGUETIP
                   PhonemeType.TONGUETIP -> PhonemeType.TONGUEUNDER
                   PhonemeType.TONGUEUNDER -> PhonemeType.TONGUEBODY
                   PhonemeType.TONGUEBODY -> PhonemeType.TONGUEROOT
                   PhonemeType.TONGUEROOT -> PhonemeType.LARYNX
                   PhonemeType.LARYNX -> PhonemeType.$fEnumActiveArticulator10 }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_$ctoEnum ::
    GHC.Types.Int -> PhonemeType.ActiveArticulator
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 -> PhonemeType.$w$ctoEnum ww1 }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_c ::
    GHC.Types.Int
    -> [PhonemeType.ActiveArticulator]
    -> [PhonemeType.ActiveArticulator]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.ActiveArticulator] ->
                 GHC.Types.:
                   @ PhonemeType.ActiveArticulator
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.ActiveArticulator a23 })
                   ys) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go1 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go10 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go11 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go12 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go13 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go2 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go3 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go4 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go5 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go6 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go7 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go8 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEnumActiveArticulator_go9 ::
    GHC.Prim.Int# -> [PhonemeType.ActiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape :: GHC.Enum.Enum PhonemeType.AirEscape
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.AirEscape
                  PhonemeType.$fEnumAirEscape_$csucc
                  PhonemeType.$fEnumAirEscape_$cpred
                  PhonemeType.$fEnumAirEscape_$ctoEnum
                  PhonemeType.$fEnumAirEscape_$cfromEnum
                  PhonemeType.$fEnumAirEscape_$cenumFrom
                  PhonemeType.$fEnumAirEscape_$cenumFromThen
                  PhonemeType.$fEnumAirEscape_$cenumFromTo
                  PhonemeType.$fEnumAirEscape_$cenumFromThenTo -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape1 :: GHC.Prim.Int# -> PhonemeType.AirEscape
  {- Arity: 1, Strictness: <L,U>b -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape2 :: [PhonemeType.AirEscape]
  {- Unfolding: (PhonemeType.$fEnumAirEscape_go2 1) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape3 :: [PhonemeType.AirEscape]
  {- Unfolding: (PhonemeType.$fEnumAirEscape_go3 0) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape4 :: PhonemeType.AirEscape
  {- Strictness: b -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape5 :: PhonemeType.AirEscape
  {- Strictness: b -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_$cenumFrom ::
    PhonemeType.AirEscape -> [PhonemeType.AirEscape]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.AirEscape ->
                 case a23 of wild {
                   PhonemeType.NASALIZED -> PhonemeType.$fEnumAirEscape3
                   PhonemeType.ORAL -> PhonemeType.$fEnumAirEscape2 }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_$cenumFromThen ::
    PhonemeType.AirEscape
    -> PhonemeType.AirEscape -> [PhonemeType.AirEscape]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.AirEscape
                   b :: PhonemeType.AirEscape ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.AirEscape]
                                    PhonemeType.$fEnumAirEscape_c1
                                    (GHC.Types.[] @ PhonemeType.AirEscape)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.AirEscape]
                                    PhonemeType.$fEnumAirEscape_c1
                                    (GHC.Types.[] @ PhonemeType.AirEscape)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.NASALIZED -> $j1 0 PhonemeType.ORAL -> $j1 1 }
                 } in
                 case a23 of wild {
                   PhonemeType.NASALIZED -> $j 0 PhonemeType.ORAL -> $j 1 }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_$cenumFromThenTo ::
    PhonemeType.AirEscape
    -> PhonemeType.AirEscape
    -> PhonemeType.AirEscape
    -> [PhonemeType.AirEscape]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.AirEscape
                   x2 :: PhonemeType.AirEscape
                   y :: PhonemeType.AirEscape ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.NASALIZED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.AirEscape]
                                     PhonemeType.$fEnumAirEscape_c
                                     (GHC.Types.[] @ PhonemeType.AirEscape)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.AirEscape]
                                     PhonemeType.$fEnumAirEscape_c
                                     (GHC.Types.[] @ PhonemeType.AirEscape)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.ORAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.AirEscape]
                                     PhonemeType.$fEnumAirEscape_c
                                     (GHC.Types.[] @ PhonemeType.AirEscape)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.AirEscape]
                                     PhonemeType.$fEnumAirEscape_c
                                     (GHC.Types.[] @ PhonemeType.AirEscape)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType.NASALIZED -> $j1 0 PhonemeType.ORAL -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType.NASALIZED -> $j 0 PhonemeType.ORAL -> $j 1 }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_$cenumFromTo ::
    PhonemeType.AirEscape
    -> PhonemeType.AirEscape -> [PhonemeType.AirEscape]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.AirEscape
                   y :: PhonemeType.AirEscape ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.NASALIZED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumAirEscape_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.AirEscape }
                       PhonemeType.ORAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumAirEscape_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.AirEscape } }
                 } in
                 case x of wild {
                   PhonemeType.NASALIZED -> $j 0 PhonemeType.ORAL -> $j 1 }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_$cfromEnum ::
    PhonemeType.AirEscape -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.AirEscape ->
                 case a23 of wild {
                   PhonemeType.NASALIZED -> GHC.Types.I# 0
                   PhonemeType.ORAL -> GHC.Types.I# 1 }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_$cpred ::
    PhonemeType.AirEscape -> PhonemeType.AirEscape
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.AirEscape ->
                 case a23 of wild {
                   PhonemeType.NASALIZED -> PhonemeType.$fEnumAirEscape4
                   PhonemeType.ORAL -> PhonemeType.NASALIZED }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_$csucc ::
    PhonemeType.AirEscape -> PhonemeType.AirEscape
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.AirEscape ->
                 case a23 of wild {
                   PhonemeType.NASALIZED -> PhonemeType.ORAL
                   PhonemeType.ORAL -> PhonemeType.$fEnumAirEscape5 }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_$ctoEnum :: GHC.Types.Int -> PhonemeType.AirEscape
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum1 ww1 }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_c ::
    GHC.Types.Int -> [PhonemeType.AirEscape] -> [PhonemeType.AirEscape]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.AirEscape] ->
                 GHC.Types.:
                   @ PhonemeType.AirEscape
                   (PhonemeType.$fEnumAirEscape_$ctoEnum x)
                   ys) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_c1 ::
    GHC.Types.Int -> [PhonemeType.AirEscape] -> [PhonemeType.AirEscape]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.AirEscape] ->
                 GHC.Types.:
                   @ PhonemeType.AirEscape
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.AirEscape a23 })
                   ys) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_go :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
  {- Arity: 1, Strictness: <L,U> -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_go1 :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
  {- Arity: 1, Strictness: <L,U> -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_go2 :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
483edd05f8d1cf327b30114f3225d3b2
  $fEnumAirEscape_go3 :: GHC.Prim.Int# -> [PhonemeType.AirEscape]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness :: GHC.Enum.Enum PhonemeType.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fEnumBackness_$csucc
                  PhonemeType.$fEnumBackness_$cpred
                  PhonemeType.$fEnumBackness_$ctoEnum
                  PhonemeType.$fEnumBackness_$cfromEnum
                  PhonemeType.$fEnumBackness_$cenumFrom
                  PhonemeType.$fEnumBackness_$cenumFromThen
                  PhonemeType.$fEnumBackness_$cenumFromTo
                  PhonemeType.$fEnumBackness_$cenumFromThenTo -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness1 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go5 4) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness2 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go6 3) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness3 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go7 2) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness4 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go8 1) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness5 :: [PhonemeType.Backness]
  {- Unfolding: (PhonemeType.$fEnumBackness_go9 0) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness6 :: GHC.Prim.Int# -> PhonemeType.Backness
  {- Arity: 1, Strictness: <L,U>b -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness7 :: PhonemeType.Backness
  {- Strictness: b -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness8 :: PhonemeType.Backness
  {- Strictness: b -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_$cenumFrom ::
    PhonemeType.Backness -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Backness ->
                 case a23 of wild {
                   PhonemeType.BACK -> PhonemeType.$fEnumBackness5
                   PhonemeType.NEARBACK -> PhonemeType.$fEnumBackness4
                   PhonemeType.CENTRAL -> PhonemeType.$fEnumBackness3
                   PhonemeType.NEARFRONT -> PhonemeType.$fEnumBackness2
                   PhonemeType.FRONT -> PhonemeType.$fEnumBackness1 }) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_$cenumFromThen ::
    PhonemeType.Backness
    -> PhonemeType.Backness -> [PhonemeType.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Backness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Backness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Backness]
                                    PhonemeType.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType.Backness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Backness]
                                    PhonemeType.$fEnumBackness_c
                                    (GHC.Types.[] @ PhonemeType.Backness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 4 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.BACK -> $j1 0
                       PhonemeType.NEARBACK -> $j1 1
                       PhonemeType.CENTRAL -> $j1 2
                       PhonemeType.NEARFRONT -> $j1 3
                       PhonemeType.FRONT -> $j1 4 }
                 } in
                 case a23 of wild {
                   PhonemeType.BACK -> $j 0
                   PhonemeType.NEARBACK -> $j 1
                   PhonemeType.CENTRAL -> $j 2
                   PhonemeType.NEARFRONT -> $j 3
                   PhonemeType.FRONT -> $j 4 }) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_$cenumFromThenTo ::
    PhonemeType.Backness
    -> PhonemeType.Backness
    -> PhonemeType.Backness
    -> [PhonemeType.Backness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_$cenumFromTo ::
    PhonemeType.Backness
    -> PhonemeType.Backness -> [PhonemeType.Backness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Backness
                   y :: PhonemeType.Backness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Backness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.BACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness }
                       PhonemeType.NEARBACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness }
                       PhonemeType.CENTRAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness }
                       PhonemeType.NEARFRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness }
                       PhonemeType.FRONT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumBackness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Backness } }
                 } in
                 case x of wild {
                   PhonemeType.BACK -> $j 0
                   PhonemeType.NEARBACK -> $j 1
                   PhonemeType.CENTRAL -> $j 2
                   PhonemeType.NEARFRONT -> $j 3
                   PhonemeType.FRONT -> $j 4 }) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_$cfromEnum :: PhonemeType.Backness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType.Backness ->
                 case w of wild {
                   PhonemeType.BACK -> GHC.Types.I# 0
                   PhonemeType.NEARBACK -> GHC.Types.I# 1
                   PhonemeType.CENTRAL -> GHC.Types.I# 2
                   PhonemeType.NEARFRONT -> GHC.Types.I# 3
                   PhonemeType.FRONT -> GHC.Types.I# 4 }) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_$cpred ::
    PhonemeType.Backness -> PhonemeType.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Backness ->
                 case a23 of wild {
                   PhonemeType.BACK -> PhonemeType.$fEnumBackness7
                   PhonemeType.NEARBACK -> PhonemeType.BACK
                   PhonemeType.CENTRAL -> PhonemeType.NEARBACK
                   PhonemeType.NEARFRONT -> PhonemeType.CENTRAL
                   PhonemeType.FRONT -> PhonemeType.NEARFRONT }) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_$csucc ::
    PhonemeType.Backness -> PhonemeType.Backness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Backness ->
                 case a23 of wild {
                   PhonemeType.BACK -> PhonemeType.NEARBACK
                   PhonemeType.NEARBACK -> PhonemeType.CENTRAL
                   PhonemeType.CENTRAL -> PhonemeType.NEARFRONT
                   PhonemeType.NEARFRONT -> PhonemeType.FRONT
                   PhonemeType.FRONT -> PhonemeType.$fEnumBackness8 }) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_$ctoEnum :: GHC.Types.Int -> PhonemeType.Backness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum2 ww1 }) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_c ::
    GHC.Types.Int -> [PhonemeType.Backness] -> [PhonemeType.Backness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Backness] ->
                 GHC.Types.:
                   @ PhonemeType.Backness
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Backness a23 })
                   ys) -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go1 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go2 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go3 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go4 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go5 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go6 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go7 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go8 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
4600283dc79ec1a04339fecb849d3137
  $fEnumBackness_go9 :: GHC.Prim.Int# -> [PhonemeType.Backness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection :: GHC.Enum.Enum PhonemeType.Direction
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Direction
                  PhonemeType.$fEnumDirection_$csucc
                  PhonemeType.$fEnumDirection_$cpred
                  PhonemeType.$fEnumDirection_$ctoEnum
                  PhonemeType.$fEnumDirection_$cfromEnum
                  PhonemeType.$fEnumDirection_$cenumFrom
                  PhonemeType.$fEnumDirection_$cenumFromThen
                  PhonemeType.$fEnumDirection_$cenumFromTo
                  PhonemeType.$fEnumDirection_$cenumFromThenTo -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection1 :: GHC.Prim.Int# -> PhonemeType.Direction
  {- Arity: 1, Strictness: <L,U>b -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection2 :: [PhonemeType.Direction]
  {- Unfolding: (PhonemeType.$fEnumDirection_go2 1) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection3 :: [PhonemeType.Direction]
  {- Unfolding: (PhonemeType.$fEnumDirection_go3 0) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection4 :: PhonemeType.Direction
  {- Strictness: b -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection5 :: PhonemeType.Direction
  {- Strictness: b -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_$cenumFrom ::
    PhonemeType.Direction -> [PhonemeType.Direction]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Direction ->
                 case a23 of wild {
                   PhonemeType.INGRESSIVE -> PhonemeType.$fEnumDirection3
                   PhonemeType.EGRESSIVE -> PhonemeType.$fEnumDirection2 }) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_$cenumFromThen ::
    PhonemeType.Direction
    -> PhonemeType.Direction -> [PhonemeType.Direction]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Direction
                   b :: PhonemeType.Direction ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Direction]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Direction]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Direction]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Direction]
                                    PhonemeType.$fEnumDirection_c1
                                    (GHC.Types.[] @ PhonemeType.Direction)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Direction]
                                    PhonemeType.$fEnumDirection_c1
                                    (GHC.Types.[] @ PhonemeType.Direction)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.INGRESSIVE -> $j1 0 PhonemeType.EGRESSIVE -> $j1 1 }
                 } in
                 case a23 of wild {
                   PhonemeType.INGRESSIVE -> $j 0 PhonemeType.EGRESSIVE -> $j 1 }) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_$cenumFromThenTo ::
    PhonemeType.Direction
    -> PhonemeType.Direction
    -> PhonemeType.Direction
    -> [PhonemeType.Direction]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Direction
                   x2 :: PhonemeType.Direction
                   y :: PhonemeType.Direction ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Direction]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Direction]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.INGRESSIVE
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Direction]
                                     PhonemeType.$fEnumDirection_c
                                     (GHC.Types.[] @ PhonemeType.Direction)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Direction]
                                     PhonemeType.$fEnumDirection_c
                                     (GHC.Types.[] @ PhonemeType.Direction)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.EGRESSIVE
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Direction]
                                     PhonemeType.$fEnumDirection_c
                                     (GHC.Types.[] @ PhonemeType.Direction)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Direction]
                                     PhonemeType.$fEnumDirection_c
                                     (GHC.Types.[] @ PhonemeType.Direction)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType.INGRESSIVE -> $j1 0 PhonemeType.EGRESSIVE -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType.INGRESSIVE -> $j 0 PhonemeType.EGRESSIVE -> $j 1 }) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_$cenumFromTo ::
    PhonemeType.Direction
    -> PhonemeType.Direction -> [PhonemeType.Direction]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Direction
                   y :: PhonemeType.Direction ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Direction]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.INGRESSIVE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumDirection_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Direction }
                       PhonemeType.EGRESSIVE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumDirection_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Direction } }
                 } in
                 case x of wild {
                   PhonemeType.INGRESSIVE -> $j 0 PhonemeType.EGRESSIVE -> $j 1 }) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_$cfromEnum ::
    PhonemeType.Direction -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Direction ->
                 case a23 of wild {
                   PhonemeType.INGRESSIVE -> GHC.Types.I# 0
                   PhonemeType.EGRESSIVE -> GHC.Types.I# 1 }) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_$cpred ::
    PhonemeType.Direction -> PhonemeType.Direction
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Direction ->
                 case a23 of wild {
                   PhonemeType.INGRESSIVE -> PhonemeType.$fEnumDirection4
                   PhonemeType.EGRESSIVE -> PhonemeType.INGRESSIVE }) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_$csucc ::
    PhonemeType.Direction -> PhonemeType.Direction
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Direction ->
                 case a23 of wild {
                   PhonemeType.INGRESSIVE -> PhonemeType.EGRESSIVE
                   PhonemeType.EGRESSIVE -> PhonemeType.$fEnumDirection5 }) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_$ctoEnum :: GHC.Types.Int -> PhonemeType.Direction
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum3 ww1 }) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_c ::
    GHC.Types.Int -> [PhonemeType.Direction] -> [PhonemeType.Direction]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Direction] ->
                 GHC.Types.:
                   @ PhonemeType.Direction
                   (PhonemeType.$fEnumDirection_$ctoEnum x)
                   ys) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_c1 ::
    GHC.Types.Int -> [PhonemeType.Direction] -> [PhonemeType.Direction]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Direction] ->
                 GHC.Types.:
                   @ PhonemeType.Direction
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Direction a23 })
                   ys) -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_go :: GHC.Prim.Int# -> [PhonemeType.Direction]
  {- Arity: 1, Strictness: <L,U> -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_go1 :: GHC.Prim.Int# -> [PhonemeType.Direction]
  {- Arity: 1, Strictness: <L,U> -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_go2 :: GHC.Prim.Int# -> [PhonemeType.Direction]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
40a9c5f987e37783909145cb5997138e
  $fEnumDirection_go3 :: GHC.Prim.Int# -> [PhonemeType.Direction]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight :: GHC.Enum.Enum PhonemeType.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fEnumHeight_$csucc
                  PhonemeType.$fEnumHeight_$cpred
                  PhonemeType.$fEnumHeight_$ctoEnum
                  PhonemeType.$fEnumHeight_$cfromEnum
                  PhonemeType.$fEnumHeight_$cenumFrom
                  PhonemeType.$fEnumHeight_$cenumFromThen
                  PhonemeType.$fEnumHeight_$cenumFromTo
                  PhonemeType.$fEnumHeight_$cenumFromThenTo -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight1 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go7 6) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight10 :: PhonemeType.Height
  {- Strictness: b -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight2 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go8 5) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight3 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go9 4) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight4 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go10 3) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight5 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go11 2) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight6 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go12 1) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight7 :: [PhonemeType.Height]
  {- Unfolding: (PhonemeType.$fEnumHeight_go13 0) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight8 :: GHC.Prim.Int# -> PhonemeType.Height
  {- Arity: 1, Strictness: <L,U>b -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight9 :: PhonemeType.Height
  {- Strictness: b -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_$cenumFrom ::
    PhonemeType.Height -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Height ->
                 case a23 of wild {
                   PhonemeType.CLOSE -> PhonemeType.$fEnumHeight7
                   PhonemeType.NEARCLOSE -> PhonemeType.$fEnumHeight6
                   PhonemeType.CLOSEMID -> PhonemeType.$fEnumHeight5
                   PhonemeType.MID -> PhonemeType.$fEnumHeight4
                   PhonemeType.OPENMID -> PhonemeType.$fEnumHeight3
                   PhonemeType.NEAROPEN -> PhonemeType.$fEnumHeight2
                   PhonemeType.OPEN -> PhonemeType.$fEnumHeight1 }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_$cenumFromThen ::
    PhonemeType.Height -> PhonemeType.Height -> [PhonemeType.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Height b :: PhonemeType.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Height]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Height]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Height]
                                    PhonemeType.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType.Height)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Height]
                                    PhonemeType.$fEnumHeight_c
                                    (GHC.Types.[] @ PhonemeType.Height)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.CLOSE -> $j1 0
                       PhonemeType.NEARCLOSE -> $j1 1
                       PhonemeType.CLOSEMID -> $j1 2
                       PhonemeType.MID -> $j1 3
                       PhonemeType.OPENMID -> $j1 4
                       PhonemeType.NEAROPEN -> $j1 5
                       PhonemeType.OPEN -> $j1 6 }
                 } in
                 case a23 of wild {
                   PhonemeType.CLOSE -> $j 0
                   PhonemeType.NEARCLOSE -> $j 1
                   PhonemeType.CLOSEMID -> $j 2
                   PhonemeType.MID -> $j 3
                   PhonemeType.OPENMID -> $j 4
                   PhonemeType.NEAROPEN -> $j 5
                   PhonemeType.OPEN -> $j 6 }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_$cenumFromThenTo ::
    PhonemeType.Height
    -> PhonemeType.Height -> PhonemeType.Height -> [PhonemeType.Height]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_$cenumFromTo ::
    PhonemeType.Height -> PhonemeType.Height -> [PhonemeType.Height]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Height y :: PhonemeType.Height ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Height]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.CLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.NEARCLOSE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.CLOSEMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.MID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.OPENMID
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.NEAROPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height }
                       PhonemeType.OPEN
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumHeight_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Height } }
                 } in
                 case x of wild {
                   PhonemeType.CLOSE -> $j 0
                   PhonemeType.NEARCLOSE -> $j 1
                   PhonemeType.CLOSEMID -> $j 2
                   PhonemeType.MID -> $j 3
                   PhonemeType.OPENMID -> $j 4
                   PhonemeType.NEAROPEN -> $j 5
                   PhonemeType.OPEN -> $j 6 }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_$cfromEnum :: PhonemeType.Height -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType.Height ->
                 case w of wild {
                   PhonemeType.CLOSE -> GHC.Types.I# 0
                   PhonemeType.NEARCLOSE -> GHC.Types.I# 1
                   PhonemeType.CLOSEMID -> GHC.Types.I# 2
                   PhonemeType.MID -> GHC.Types.I# 3
                   PhonemeType.OPENMID -> GHC.Types.I# 4
                   PhonemeType.NEAROPEN -> GHC.Types.I# 5
                   PhonemeType.OPEN -> GHC.Types.I# 6 }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_$cpred :: PhonemeType.Height -> PhonemeType.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Height ->
                 case a23 of wild {
                   PhonemeType.CLOSE -> PhonemeType.$fEnumHeight9
                   PhonemeType.NEARCLOSE -> PhonemeType.CLOSE
                   PhonemeType.CLOSEMID -> PhonemeType.NEARCLOSE
                   PhonemeType.MID -> PhonemeType.CLOSEMID
                   PhonemeType.OPENMID -> PhonemeType.MID
                   PhonemeType.NEAROPEN -> PhonemeType.OPENMID
                   PhonemeType.OPEN -> PhonemeType.NEAROPEN }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_$csucc :: PhonemeType.Height -> PhonemeType.Height
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Height ->
                 case a23 of wild {
                   PhonemeType.CLOSE -> PhonemeType.NEARCLOSE
                   PhonemeType.NEARCLOSE -> PhonemeType.CLOSEMID
                   PhonemeType.CLOSEMID -> PhonemeType.MID
                   PhonemeType.MID -> PhonemeType.OPENMID
                   PhonemeType.OPENMID -> PhonemeType.NEAROPEN
                   PhonemeType.NEAROPEN -> PhonemeType.OPEN
                   PhonemeType.OPEN -> PhonemeType.$fEnumHeight10 }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_$ctoEnum :: GHC.Types.Int -> PhonemeType.Height
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum4 ww1 }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_c ::
    GHC.Types.Int -> [PhonemeType.Height] -> [PhonemeType.Height]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Height] ->
                 GHC.Types.:
                   @ PhonemeType.Height
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Height a23 })
                   ys) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go1 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go10 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go11 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go12 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go13 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go2 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go3 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go4 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go5 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go6 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go7 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go8 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEnumHeight_go9 :: GHC.Prim.Int# -> [PhonemeType.Height]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator :: GHC.Enum.Enum PhonemeType.Initiator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Initiator
                  PhonemeType.$fEnumInitiator_$csucc
                  PhonemeType.$fEnumInitiator_$cpred
                  PhonemeType.$fEnumInitiator_$ctoEnum
                  PhonemeType.$fEnumInitiator_$cfromEnum
                  PhonemeType.$fEnumInitiator_$cenumFrom
                  PhonemeType.$fEnumInitiator_$cenumFromThen
                  PhonemeType.$fEnumInitiator_$cenumFromTo
                  PhonemeType.$fEnumInitiator_$cenumFromThenTo -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator1 :: GHC.Prim.Int# -> PhonemeType.Initiator
  {- Arity: 1, Strictness: <L,U>b -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator2 :: [PhonemeType.Initiator]
  {- Unfolding: (PhonemeType.$fEnumInitiator_go3 2) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator3 :: [PhonemeType.Initiator]
  {- Unfolding: (PhonemeType.$fEnumInitiator_go4 1) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator4 :: [PhonemeType.Initiator]
  {- Unfolding: (PhonemeType.$fEnumInitiator_go5 0) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator5 :: PhonemeType.Initiator
  {- Strictness: b -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator6 :: PhonemeType.Initiator
  {- Strictness: b -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_$cenumFrom ::
    PhonemeType.Initiator -> [PhonemeType.Initiator]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Initiator ->
                 case a23 of wild {
                   PhonemeType.LINGUAL -> PhonemeType.$fEnumInitiator4
                   PhonemeType.GLOTTIC -> PhonemeType.$fEnumInitiator3
                   PhonemeType.PULMONIC -> PhonemeType.$fEnumInitiator2 }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_$cenumFromThen ::
    PhonemeType.Initiator
    -> PhonemeType.Initiator -> [PhonemeType.Initiator]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Initiator
                   b :: PhonemeType.Initiator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Initiator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Initiator]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Initiator]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Initiator]
                                    PhonemeType.$fEnumInitiator_c1
                                    (GHC.Types.[] @ PhonemeType.Initiator)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Initiator]
                                    PhonemeType.$fEnumInitiator_c1
                                    (GHC.Types.[] @ PhonemeType.Initiator)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.LINGUAL -> $j1 0
                       PhonemeType.GLOTTIC -> $j1 1
                       PhonemeType.PULMONIC -> $j1 2 }
                 } in
                 case a23 of wild {
                   PhonemeType.LINGUAL -> $j 0
                   PhonemeType.GLOTTIC -> $j 1
                   PhonemeType.PULMONIC -> $j 2 }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_$cenumFromThenTo ::
    PhonemeType.Initiator
    -> PhonemeType.Initiator
    -> PhonemeType.Initiator
    -> [PhonemeType.Initiator]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Initiator
                   x2 :: PhonemeType.Initiator
                   y :: PhonemeType.Initiator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Initiator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Initiator]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.LINGUAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Initiator]
                                     PhonemeType.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType.Initiator)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Initiator]
                                     PhonemeType.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType.Initiator)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.GLOTTIC
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Initiator]
                                     PhonemeType.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType.Initiator)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Initiator]
                                     PhonemeType.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType.Initiator)
                                     x4
                                     x5
                                     1 }
                           PhonemeType.PULMONIC
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Initiator]
                                     PhonemeType.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType.Initiator)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Initiator]
                                     PhonemeType.$fEnumInitiator_c
                                     (GHC.Types.[] @ PhonemeType.Initiator)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType.LINGUAL -> $j1 0
                       PhonemeType.GLOTTIC -> $j1 1
                       PhonemeType.PULMONIC -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType.LINGUAL -> $j 0
                   PhonemeType.GLOTTIC -> $j 1
                   PhonemeType.PULMONIC -> $j 2 }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_$cenumFromTo ::
    PhonemeType.Initiator
    -> PhonemeType.Initiator -> [PhonemeType.Initiator]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Initiator
                   y :: PhonemeType.Initiator ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Initiator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.LINGUAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumInitiator_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Initiator }
                       PhonemeType.GLOTTIC
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumInitiator_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Initiator }
                       PhonemeType.PULMONIC
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumInitiator_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Initiator } }
                 } in
                 case x of wild {
                   PhonemeType.LINGUAL -> $j 0
                   PhonemeType.GLOTTIC -> $j 1
                   PhonemeType.PULMONIC -> $j 2 }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_$cfromEnum ::
    PhonemeType.Initiator -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Initiator ->
                 case a23 of wild {
                   PhonemeType.LINGUAL -> GHC.Types.I# 0
                   PhonemeType.GLOTTIC -> GHC.Types.I# 1
                   PhonemeType.PULMONIC -> GHC.Types.I# 2 }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_$cpred ::
    PhonemeType.Initiator -> PhonemeType.Initiator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Initiator ->
                 case a23 of wild {
                   PhonemeType.LINGUAL -> PhonemeType.$fEnumInitiator5
                   PhonemeType.GLOTTIC -> PhonemeType.LINGUAL
                   PhonemeType.PULMONIC -> PhonemeType.GLOTTIC }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_$csucc ::
    PhonemeType.Initiator -> PhonemeType.Initiator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Initiator ->
                 case a23 of wild {
                   PhonemeType.LINGUAL -> PhonemeType.GLOTTIC
                   PhonemeType.GLOTTIC -> PhonemeType.PULMONIC
                   PhonemeType.PULMONIC -> PhonemeType.$fEnumInitiator6 }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_$ctoEnum :: GHC.Types.Int -> PhonemeType.Initiator
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum5 ww1 }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_c ::
    GHC.Types.Int -> [PhonemeType.Initiator] -> [PhonemeType.Initiator]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Initiator] ->
                 GHC.Types.:
                   @ PhonemeType.Initiator
                   (PhonemeType.$fEnumInitiator_$ctoEnum x)
                   ys) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_c1 ::
    GHC.Types.Int -> [PhonemeType.Initiator] -> [PhonemeType.Initiator]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Initiator] ->
                 GHC.Types.:
                   @ PhonemeType.Initiator
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Initiator a23 })
                   ys) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_go :: GHC.Prim.Int# -> [PhonemeType.Initiator]
  {- Arity: 1, Strictness: <L,U> -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_go1 :: GHC.Prim.Int# -> [PhonemeType.Initiator]
  {- Arity: 1, Strictness: <L,U> -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_go2 :: GHC.Prim.Int# -> [PhonemeType.Initiator]
  {- Arity: 1, Strictness: <L,U> -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_go3 :: GHC.Prim.Int# -> [PhonemeType.Initiator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_go4 :: GHC.Prim.Int# -> [PhonemeType.Initiator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEnumInitiator_go5 :: GHC.Prim.Int# -> [PhonemeType.Initiator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality :: GHC.Enum.Enum PhonemeType.Laterality
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Laterality
                  PhonemeType.$fEnumLaterality_$csucc
                  PhonemeType.$fEnumLaterality_$cpred
                  PhonemeType.$fEnumLaterality_$ctoEnum
                  PhonemeType.$fEnumLaterality_$cfromEnum
                  PhonemeType.$fEnumLaterality_$cenumFrom
                  PhonemeType.$fEnumLaterality_$cenumFromThen
                  PhonemeType.$fEnumLaterality_$cenumFromTo
                  PhonemeType.$fEnumLaterality_$cenumFromThenTo -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality1 :: GHC.Prim.Int# -> PhonemeType.Laterality
  {- Arity: 1, Strictness: <L,U>b -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality2 :: [PhonemeType.Laterality]
  {- Unfolding: (PhonemeType.$fEnumLaterality_go2 1) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality3 :: [PhonemeType.Laterality]
  {- Unfolding: (PhonemeType.$fEnumLaterality_go3 0) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality4 :: PhonemeType.Laterality
  {- Strictness: b -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality5 :: PhonemeType.Laterality
  {- Strictness: b -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_$cenumFrom ::
    PhonemeType.Laterality -> [PhonemeType.Laterality]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Laterality ->
                 case a23 of wild {
                   PhonemeType.LATERAL -> PhonemeType.$fEnumLaterality3
                   PhonemeType.NONLATERAL -> PhonemeType.$fEnumLaterality2 }) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_$cenumFromThen ::
    PhonemeType.Laterality
    -> PhonemeType.Laterality -> [PhonemeType.Laterality]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Laterality
                   b :: PhonemeType.Laterality ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Laterality]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Laterality]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Laterality]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Laterality]
                                    PhonemeType.$fEnumLaterality_c1
                                    (GHC.Types.[] @ PhonemeType.Laterality)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Laterality]
                                    PhonemeType.$fEnumLaterality_c1
                                    (GHC.Types.[] @ PhonemeType.Laterality)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.LATERAL -> $j1 0 PhonemeType.NONLATERAL -> $j1 1 }
                 } in
                 case a23 of wild {
                   PhonemeType.LATERAL -> $j 0 PhonemeType.NONLATERAL -> $j 1 }) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_$cenumFromThenTo ::
    PhonemeType.Laterality
    -> PhonemeType.Laterality
    -> PhonemeType.Laterality
    -> [PhonemeType.Laterality]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Laterality
                   x2 :: PhonemeType.Laterality
                   y :: PhonemeType.Laterality ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Laterality]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Laterality]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.LATERAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Laterality]
                                     PhonemeType.$fEnumLaterality_c
                                     (GHC.Types.[] @ PhonemeType.Laterality)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Laterality]
                                     PhonemeType.$fEnumLaterality_c
                                     (GHC.Types.[] @ PhonemeType.Laterality)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.NONLATERAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Laterality]
                                     PhonemeType.$fEnumLaterality_c
                                     (GHC.Types.[] @ PhonemeType.Laterality)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Laterality]
                                     PhonemeType.$fEnumLaterality_c
                                     (GHC.Types.[] @ PhonemeType.Laterality)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType.LATERAL -> $j1 0 PhonemeType.NONLATERAL -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType.LATERAL -> $j 0 PhonemeType.NONLATERAL -> $j 1 }) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_$cenumFromTo ::
    PhonemeType.Laterality
    -> PhonemeType.Laterality -> [PhonemeType.Laterality]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Laterality
                   y :: PhonemeType.Laterality ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Laterality]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.LATERAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumLaterality_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Laterality }
                       PhonemeType.NONLATERAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumLaterality_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Laterality } }
                 } in
                 case x of wild {
                   PhonemeType.LATERAL -> $j 0 PhonemeType.NONLATERAL -> $j 1 }) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_$cfromEnum ::
    PhonemeType.Laterality -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Laterality ->
                 case a23 of wild {
                   PhonemeType.LATERAL -> GHC.Types.I# 0
                   PhonemeType.NONLATERAL -> GHC.Types.I# 1 }) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_$cpred ::
    PhonemeType.Laterality -> PhonemeType.Laterality
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Laterality ->
                 case a23 of wild {
                   PhonemeType.LATERAL -> PhonemeType.$fEnumLaterality4
                   PhonemeType.NONLATERAL -> PhonemeType.LATERAL }) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_$csucc ::
    PhonemeType.Laterality -> PhonemeType.Laterality
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Laterality ->
                 case a23 of wild {
                   PhonemeType.LATERAL -> PhonemeType.NONLATERAL
                   PhonemeType.NONLATERAL -> PhonemeType.$fEnumLaterality5 }) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_$ctoEnum ::
    GHC.Types.Int -> PhonemeType.Laterality
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum6 ww1 }) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_c ::
    GHC.Types.Int
    -> [PhonemeType.Laterality] -> [PhonemeType.Laterality]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Laterality] ->
                 GHC.Types.:
                   @ PhonemeType.Laterality
                   (PhonemeType.$fEnumLaterality_$ctoEnum x)
                   ys) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_c1 ::
    GHC.Types.Int
    -> [PhonemeType.Laterality] -> [PhonemeType.Laterality]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Laterality] ->
                 GHC.Types.:
                   @ PhonemeType.Laterality
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Laterality a23 })
                   ys) -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_go :: GHC.Prim.Int# -> [PhonemeType.Laterality]
  {- Arity: 1, Strictness: <L,U> -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_go1 :: GHC.Prim.Int# -> [PhonemeType.Laterality]
  {- Arity: 1, Strictness: <L,U> -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_go2 :: GHC.Prim.Int# -> [PhonemeType.Laterality]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
563547f95f31ce703bd3964698c86217
  $fEnumLaterality_go3 :: GHC.Prim.Int# -> [PhonemeType.Laterality]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength :: GHC.Enum.Enum PhonemeType.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Length
                  PhonemeType.$fEnumLength_$csucc
                  PhonemeType.$fEnumLength_$cpred
                  PhonemeType.$fEnumLength_$ctoEnum
                  PhonemeType.$fEnumLength_$cfromEnum
                  PhonemeType.$fEnumLength_$cenumFrom
                  PhonemeType.$fEnumLength_$cenumFromThen
                  PhonemeType.$fEnumLength_$cenumFromTo
                  PhonemeType.$fEnumLength_$cenumFromThenTo -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength1 :: GHC.Prim.Int# -> PhonemeType.Length
  {- Arity: 1, Strictness: <L,U>b -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength2 :: [PhonemeType.Length]
  {- Unfolding: (PhonemeType.$fEnumLength_go3 2) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength3 :: [PhonemeType.Length]
  {- Unfolding: (PhonemeType.$fEnumLength_go4 1) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength4 :: [PhonemeType.Length]
  {- Unfolding: (PhonemeType.$fEnumLength_go5 0) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength5 :: PhonemeType.Length
  {- Strictness: b -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength6 :: PhonemeType.Length
  {- Strictness: b -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_$cenumFrom ::
    PhonemeType.Length -> [PhonemeType.Length]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Length ->
                 case a23 of wild {
                   PhonemeType.SHORT -> PhonemeType.$fEnumLength4
                   PhonemeType.NORMAL -> PhonemeType.$fEnumLength3
                   PhonemeType.LONG -> PhonemeType.$fEnumLength2 }) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_$cenumFromThen ::
    PhonemeType.Length -> PhonemeType.Length -> [PhonemeType.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Length b :: PhonemeType.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Length]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Length]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Length]
                                    PhonemeType.$fEnumLength_c1
                                    (GHC.Types.[] @ PhonemeType.Length)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Length]
                                    PhonemeType.$fEnumLength_c1
                                    (GHC.Types.[] @ PhonemeType.Length)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.SHORT -> $j1 0
                       PhonemeType.NORMAL -> $j1 1
                       PhonemeType.LONG -> $j1 2 }
                 } in
                 case a23 of wild {
                   PhonemeType.SHORT -> $j 0
                   PhonemeType.NORMAL -> $j 1
                   PhonemeType.LONG -> $j 2 }) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_$cenumFromThenTo ::
    PhonemeType.Length
    -> PhonemeType.Length -> PhonemeType.Length -> [PhonemeType.Length]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Length
                   x2 :: PhonemeType.Length
                   y :: PhonemeType.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Length]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.SHORT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Length]
                                     PhonemeType.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType.Length)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Length]
                                     PhonemeType.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType.Length)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.NORMAL
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Length]
                                     PhonemeType.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType.Length)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Length]
                                     PhonemeType.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType.Length)
                                     x4
                                     x5
                                     1 }
                           PhonemeType.LONG
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Length]
                                     PhonemeType.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType.Length)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Length]
                                     PhonemeType.$fEnumLength_c
                                     (GHC.Types.[] @ PhonemeType.Length)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType.SHORT -> $j1 0
                       PhonemeType.NORMAL -> $j1 1
                       PhonemeType.LONG -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType.SHORT -> $j 0
                   PhonemeType.NORMAL -> $j 1
                   PhonemeType.LONG -> $j 2 }) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_$cenumFromTo ::
    PhonemeType.Length -> PhonemeType.Length -> [PhonemeType.Length]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Length y :: PhonemeType.Length ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Length]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.SHORT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumLength_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Length }
                       PhonemeType.NORMAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumLength_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Length }
                       PhonemeType.LONG
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumLength_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Length } }
                 } in
                 case x of wild {
                   PhonemeType.SHORT -> $j 0
                   PhonemeType.NORMAL -> $j 1
                   PhonemeType.LONG -> $j 2 }) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_$cfromEnum :: PhonemeType.Length -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Length ->
                 case a23 of wild {
                   PhonemeType.SHORT -> GHC.Types.I# 0
                   PhonemeType.NORMAL -> GHC.Types.I# 1
                   PhonemeType.LONG -> GHC.Types.I# 2 }) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_$cpred :: PhonemeType.Length -> PhonemeType.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Length ->
                 case a23 of wild {
                   PhonemeType.SHORT -> PhonemeType.$fEnumLength5
                   PhonemeType.NORMAL -> PhonemeType.SHORT
                   PhonemeType.LONG -> PhonemeType.NORMAL }) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_$csucc :: PhonemeType.Length -> PhonemeType.Length
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Length ->
                 case a23 of wild {
                   PhonemeType.SHORT -> PhonemeType.NORMAL
                   PhonemeType.NORMAL -> PhonemeType.LONG
                   PhonemeType.LONG -> PhonemeType.$fEnumLength6 }) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_$ctoEnum :: GHC.Types.Int -> PhonemeType.Length
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum7 ww1 }) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_c ::
    GHC.Types.Int -> [PhonemeType.Length] -> [PhonemeType.Length]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Length] ->
                 GHC.Types.:
                   @ PhonemeType.Length
                   (PhonemeType.$fEnumLength_$ctoEnum x)
                   ys) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_c1 ::
    GHC.Types.Int -> [PhonemeType.Length] -> [PhonemeType.Length]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Length] ->
                 GHC.Types.:
                   @ PhonemeType.Length
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Length a23 })
                   ys) -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_go :: GHC.Prim.Int# -> [PhonemeType.Length]
  {- Arity: 1, Strictness: <L,U> -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_go1 :: GHC.Prim.Int# -> [PhonemeType.Length]
  {- Arity: 1, Strictness: <L,U> -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_go2 :: GHC.Prim.Int# -> [PhonemeType.Length]
  {- Arity: 1, Strictness: <L,U> -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_go3 :: GHC.Prim.Int# -> [PhonemeType.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_go4 :: GHC.Prim.Int# -> [PhonemeType.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
355f724f9de26105f3758df52d82fae4
  $fEnumLength_go5 :: GHC.Prim.Int# -> [PhonemeType.Length]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator ::
    GHC.Enum.Enum PhonemeType.PassiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PassiveArticulator
                  PhonemeType.$fEnumPassiveArticulator_$csucc
                  PhonemeType.$fEnumPassiveArticulator_$cpred
                  PhonemeType.$fEnumPassiveArticulator_$ctoEnum
                  PhonemeType.$fEnumPassiveArticulator_$cfromEnum
                  PhonemeType.$fEnumPassiveArticulator_$cenumFrom
                  PhonemeType.$fEnumPassiveArticulator_$cenumFromThen
                  PhonemeType.$fEnumPassiveArticulator_$cenumFromTo
                  PhonemeType.$fEnumPassiveArticulator_$cenumFromThenTo -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator1 ::
    GHC.Prim.Int# -> PhonemeType.PassiveArticulator
  {- Arity: 1, Strictness: <L,U>b -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator2 :: PhonemeType.PassiveArticulator
  {- Strictness: b -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator3 :: PhonemeType.PassiveArticulator
  {- Strictness: b -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_$cenumFrom ::
    PhonemeType.PassiveArticulator -> [PhonemeType.PassiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.PassiveArticulator ->
                 case a23 of x1 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 10) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumPassiveArticulator_go x0
                   GHC.Types.True
                   -> GHC.Types.[] @ PhonemeType.PassiveArticulator } }) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_$cenumFromThen ::
    PhonemeType.PassiveArticulator
    -> PhonemeType.PassiveArticulator
    -> [PhonemeType.PassiveArticulator]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.PassiveArticulator
                   b :: PhonemeType.PassiveArticulator ->
                 case a23 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 let {
                   a# :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x1
                 } in
                 let {
                   b# :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x2
                 } in
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.PassiveArticulator]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ y :: GHC.Prim.Int#[OneShot] ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# b# a#) of wild {
                       GHC.Types.False
                       -> GHC.Enum.efdtIntDnFB
                            @ [PhonemeType.PassiveArticulator]
                            PhonemeType.$fEnumPassiveArticulator_c1
                            (GHC.Types.[] @ PhonemeType.PassiveArticulator)
                            a#
                            b#
                            y
                       GHC.Types.True
                       -> GHC.Enum.efdtIntUpFB
                            @ [PhonemeType.PassiveArticulator]
                            PhonemeType.$fEnumPassiveArticulator_c1
                            (GHC.Types.[] @ PhonemeType.PassiveArticulator)
                            a#
                            b#
                            y }
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># a# b#) of wild {
                   GHC.Types.False -> $j 10 GHC.Types.True -> $j 0 } } }) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_$cenumFromThenTo ::
    PhonemeType.PassiveArticulator
    -> PhonemeType.PassiveArticulator
    -> PhonemeType.PassiveArticulator
    -> [PhonemeType.PassiveArticulator]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.PassiveArticulator
                   x2 :: PhonemeType.PassiveArticulator
                   y :: PhonemeType.PassiveArticulator ->
                 case x1 of x4 { DEFAULT ->
                 case x2 of x5 { DEFAULT ->
                 case y of x6 { DEFAULT ->
                 let {
                   x7 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x4
                 } in
                 let {
                   x8 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x5
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# x8 x7) of wild {
                   GHC.Types.False
                   -> GHC.Enum.efdtIntDnFB
                        @ [PhonemeType.PassiveArticulator]
                        PhonemeType.$fEnumPassiveArticulator_c
                        (GHC.Types.[] @ PhonemeType.PassiveArticulator)
                        x7
                        x8
                        (GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x6)
                   GHC.Types.True
                   -> GHC.Enum.efdtIntUpFB
                        @ [PhonemeType.PassiveArticulator]
                        PhonemeType.$fEnumPassiveArticulator_c
                        (GHC.Types.[] @ PhonemeType.PassiveArticulator)
                        x7
                        x8
                        (GHC.Prim.dataToTag#
                           @ PhonemeType.PassiveArticulator
                           x6) } } } }) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_$cenumFromTo ::
    PhonemeType.PassiveArticulator
    -> PhonemeType.PassiveArticulator
    -> [PhonemeType.PassiveArticulator]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.PassiveArticulator
                   y :: PhonemeType.PassiveArticulator ->
                 case x of x1 { DEFAULT ->
                 case y of x2 { DEFAULT ->
                 let {
                   x0 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x1
                 } in
                 let {
                   y1 :: GHC.Prim.Int#
                   = GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># x0 y1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go50 :: GHC.Prim.Int# -> [PhonemeType.PassiveArticulator]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x3 :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ PhonemeType.PassiveArticulator
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x3 0) of wild1 {
                               GHC.Types.False -> PhonemeType.$fEnumPassiveArticulator1 x3
                               GHC.Types.True
                               -> case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# x3 10) of wild2 {
                                    GHC.Types.False -> PhonemeType.$fEnumPassiveArticulator1 x3
                                    GHC.Types.True
                                    -> GHC.Prim.tagToEnum# @ PhonemeType.PassiveArticulator x3 } })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x3 y1) of wild1 {
                               GHC.Types.False -> go50 (GHC.Prim.+# x3 1)
                               GHC.Types.True -> GHC.Types.[] @ PhonemeType.PassiveArticulator })
                      } in
                      go50 x0
                   GHC.Types.True
                   -> GHC.Types.[] @ PhonemeType.PassiveArticulator } } }) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_$cfromEnum ::
    PhonemeType.PassiveArticulator -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.PassiveArticulator ->
                 case a23 of x1 { DEFAULT ->
                 GHC.Types.I#
                   (GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x1) }) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_$cpred ::
    PhonemeType.PassiveArticulator -> PhonemeType.PassiveArticulator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.PassiveArticulator ->
                 case a23 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag#
                        @ PhonemeType.PassiveArticulator
                        x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum#
                        @ PhonemeType.PassiveArticulator
                        (GHC.Prim.+# wild (-1))
                   0 -> PhonemeType.$fEnumPassiveArticulator2 } }) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_$csucc ::
    PhonemeType.PassiveArticulator -> PhonemeType.PassiveArticulator
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.PassiveArticulator ->
                 case a23 of x1 { DEFAULT ->
                 case GHC.Prim.dataToTag#
                        @ PhonemeType.PassiveArticulator
                        x1 of wild {
                   DEFAULT
                   -> GHC.Prim.tagToEnum#
                        @ PhonemeType.PassiveArticulator
                        (GHC.Prim.+# wild 1)
                   10 -> PhonemeType.$fEnumPassiveArticulator3 } }) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_$ctoEnum ::
    GHC.Types.Int -> PhonemeType.PassiveArticulator
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum8 ww1 }) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_c ::
    GHC.Types.Int
    -> [PhonemeType.PassiveArticulator]
    -> [PhonemeType.PassiveArticulator]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.PassiveArticulator] ->
                 GHC.Types.:
                   @ PhonemeType.PassiveArticulator
                   (PhonemeType.$fEnumPassiveArticulator_$ctoEnum x)
                   ys) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_c1 ::
    GHC.Types.Int
    -> [PhonemeType.PassiveArticulator]
    -> [PhonemeType.PassiveArticulator]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.PassiveArticulator] ->
                 GHC.Types.:
                   @ PhonemeType.PassiveArticulator
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.PassiveArticulator a23 })
                   ys) -}
dcbf3455324a78016700898324489067
  $fEnumPassiveArticulator_go ::
    GHC.Prim.Int# -> [PhonemeType.PassiveArticulator]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation :: GHC.Enum.Enum PhonemeType.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Phonation
                  PhonemeType.$fEnumPhonation_$csucc
                  PhonemeType.$fEnumPhonation_$cpred
                  PhonemeType.$fEnumPhonation_$ctoEnum
                  PhonemeType.$fEnumPhonation_$cfromEnum
                  PhonemeType.$fEnumPhonation_$cenumFrom
                  PhonemeType.$fEnumPhonation_$cenumFromThen
                  PhonemeType.$fEnumPhonation_$cenumFromTo
                  PhonemeType.$fEnumPhonation_$cenumFromThenTo -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation1 :: [PhonemeType.Phonation]
  {- Unfolding: (PhonemeType.$fEnumPhonation_go7 6) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation10 :: PhonemeType.Phonation
  {- Strictness: b -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation2 :: [PhonemeType.Phonation]
  {- Unfolding: (PhonemeType.$fEnumPhonation_go8 5) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation3 :: [PhonemeType.Phonation]
  {- Unfolding: (PhonemeType.$fEnumPhonation_go9 4) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation4 :: [PhonemeType.Phonation]
  {- Unfolding: (PhonemeType.$fEnumPhonation_go10 3) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation5 :: [PhonemeType.Phonation]
  {- Unfolding: (PhonemeType.$fEnumPhonation_go11 2) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation6 :: [PhonemeType.Phonation]
  {- Unfolding: (PhonemeType.$fEnumPhonation_go12 1) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation7 :: [PhonemeType.Phonation]
  {- Unfolding: (PhonemeType.$fEnumPhonation_go13 0) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation8 :: GHC.Prim.Int# -> PhonemeType.Phonation
  {- Arity: 1, Strictness: <L,U>b -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation9 :: PhonemeType.Phonation
  {- Strictness: b -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_$cenumFrom ::
    PhonemeType.Phonation -> [PhonemeType.Phonation]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Phonation ->
                 case a23 of wild {
                   PhonemeType.VOICELESS -> PhonemeType.$fEnumPhonation7
                   PhonemeType.BREATHY -> PhonemeType.$fEnumPhonation6
                   PhonemeType.SLACK -> PhonemeType.$fEnumPhonation5
                   PhonemeType.MODAL -> PhonemeType.$fEnumPhonation4
                   PhonemeType.STIFF -> PhonemeType.$fEnumPhonation3
                   PhonemeType.CREAKY -> PhonemeType.$fEnumPhonation2
                   PhonemeType.CLOSURE -> PhonemeType.$fEnumPhonation1 }) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_$cenumFromThen ::
    PhonemeType.Phonation
    -> PhonemeType.Phonation -> [PhonemeType.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Phonation
                   b :: PhonemeType.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Phonation]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Phonation]
                                    PhonemeType.$fEnumPhonation_c
                                    (GHC.Types.[] @ PhonemeType.Phonation)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Phonation]
                                    PhonemeType.$fEnumPhonation_c
                                    (GHC.Types.[] @ PhonemeType.Phonation)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 6 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.VOICELESS -> $j1 0
                       PhonemeType.BREATHY -> $j1 1
                       PhonemeType.SLACK -> $j1 2
                       PhonemeType.MODAL -> $j1 3
                       PhonemeType.STIFF -> $j1 4
                       PhonemeType.CREAKY -> $j1 5
                       PhonemeType.CLOSURE -> $j1 6 }
                 } in
                 case a23 of wild {
                   PhonemeType.VOICELESS -> $j 0
                   PhonemeType.BREATHY -> $j 1
                   PhonemeType.SLACK -> $j 2
                   PhonemeType.MODAL -> $j 3
                   PhonemeType.STIFF -> $j 4
                   PhonemeType.CREAKY -> $j 5
                   PhonemeType.CLOSURE -> $j 6 }) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_$cenumFromThenTo ::
    PhonemeType.Phonation
    -> PhonemeType.Phonation
    -> PhonemeType.Phonation
    -> [PhonemeType.Phonation]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_$cenumFromTo ::
    PhonemeType.Phonation
    -> PhonemeType.Phonation -> [PhonemeType.Phonation]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Phonation
                   y :: PhonemeType.Phonation ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Phonation]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.VOICELESS
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumPhonation_go6 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Phonation }
                       PhonemeType.BREATHY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumPhonation_go5 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Phonation }
                       PhonemeType.SLACK
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumPhonation_go4 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Phonation }
                       PhonemeType.MODAL
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 3) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumPhonation_go3 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Phonation }
                       PhonemeType.STIFF
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 4) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumPhonation_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Phonation }
                       PhonemeType.CREAKY
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 5) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumPhonation_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Phonation }
                       PhonemeType.CLOSURE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 6) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumPhonation_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Phonation } }
                 } in
                 case x of wild {
                   PhonemeType.VOICELESS -> $j 0
                   PhonemeType.BREATHY -> $j 1
                   PhonemeType.SLACK -> $j 2
                   PhonemeType.MODAL -> $j 3
                   PhonemeType.STIFF -> $j 4
                   PhonemeType.CREAKY -> $j 5
                   PhonemeType.CLOSURE -> $j 6 }) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_$cfromEnum ::
    PhonemeType.Phonation -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PhonemeType.Phonation ->
                 case w of wild {
                   PhonemeType.VOICELESS -> GHC.Types.I# 0
                   PhonemeType.BREATHY -> GHC.Types.I# 1
                   PhonemeType.SLACK -> GHC.Types.I# 2
                   PhonemeType.MODAL -> GHC.Types.I# 3
                   PhonemeType.STIFF -> GHC.Types.I# 4
                   PhonemeType.CREAKY -> GHC.Types.I# 5
                   PhonemeType.CLOSURE -> GHC.Types.I# 6 }) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_$cpred ::
    PhonemeType.Phonation -> PhonemeType.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Phonation ->
                 case a23 of wild {
                   PhonemeType.VOICELESS -> PhonemeType.$fEnumPhonation9
                   PhonemeType.BREATHY -> PhonemeType.VOICELESS
                   PhonemeType.SLACK -> PhonemeType.BREATHY
                   PhonemeType.MODAL -> PhonemeType.SLACK
                   PhonemeType.STIFF -> PhonemeType.MODAL
                   PhonemeType.CREAKY -> PhonemeType.STIFF
                   PhonemeType.CLOSURE -> PhonemeType.CREAKY }) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_$csucc ::
    PhonemeType.Phonation -> PhonemeType.Phonation
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Phonation ->
                 case a23 of wild {
                   PhonemeType.VOICELESS -> PhonemeType.BREATHY
                   PhonemeType.BREATHY -> PhonemeType.SLACK
                   PhonemeType.SLACK -> PhonemeType.MODAL
                   PhonemeType.MODAL -> PhonemeType.STIFF
                   PhonemeType.STIFF -> PhonemeType.CREAKY
                   PhonemeType.CREAKY -> PhonemeType.CLOSURE
                   PhonemeType.CLOSURE -> PhonemeType.$fEnumPhonation10 }) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_$ctoEnum :: GHC.Types.Int -> PhonemeType.Phonation
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum9 ww1 }) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_c ::
    GHC.Types.Int -> [PhonemeType.Phonation] -> [PhonemeType.Phonation]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Phonation] ->
                 GHC.Types.:
                   @ PhonemeType.Phonation
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Phonation a23 })
                   ys) -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go1 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go10 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go11 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go12 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go13 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go2 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go3 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go4 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go5 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go6 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go7 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go8 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1876b99e8b904b79707be731945482ec
  $fEnumPhonation_go9 :: GHC.Prim.Int# -> [PhonemeType.Phonation]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness :: GHC.Enum.Enum PhonemeType.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fEnumRoundedness_$csucc
                  PhonemeType.$fEnumRoundedness_$cpred
                  PhonemeType.$fEnumRoundedness_$ctoEnum
                  PhonemeType.$fEnumRoundedness_$cfromEnum
                  PhonemeType.$fEnumRoundedness_$cenumFrom
                  PhonemeType.$fEnumRoundedness_$cenumFromThen
                  PhonemeType.$fEnumRoundedness_$cenumFromTo
                  PhonemeType.$fEnumRoundedness_$cenumFromThenTo -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness1 :: GHC.Prim.Int# -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <L,U>b -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness2 :: [PhonemeType.Roundedness]
  {- Unfolding: (PhonemeType.$fEnumRoundedness_go2 1) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness3 :: [PhonemeType.Roundedness]
  {- Unfolding: (PhonemeType.$fEnumRoundedness_go3 0) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness4 :: PhonemeType.Roundedness
  {- Strictness: b -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness5 :: PhonemeType.Roundedness
  {- Strictness: b -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_$cenumFrom ::
    PhonemeType.Roundedness -> [PhonemeType.Roundedness]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Roundedness ->
                 case a23 of wild {
                   PhonemeType.UNROUNDED -> PhonemeType.$fEnumRoundedness3
                   PhonemeType.ROUNDED -> PhonemeType.$fEnumRoundedness2 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_$cenumFromThen ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> [PhonemeType.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Roundedness
                   b :: PhonemeType.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Roundedness]
                                    PhonemeType.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType.Roundedness)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Roundedness]
                                    PhonemeType.$fEnumRoundedness_c1
                                    (GHC.Types.[] @ PhonemeType.Roundedness)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.UNROUNDED -> $j1 0 PhonemeType.ROUNDED -> $j1 1 }
                 } in
                 case a23 of wild {
                   PhonemeType.UNROUNDED -> $j 0 PhonemeType.ROUNDED -> $j 1 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_$cenumFromThenTo ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness
    -> PhonemeType.Roundedness
    -> [PhonemeType.Roundedness]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Roundedness
                   x2 :: PhonemeType.Roundedness
                   y :: PhonemeType.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.UNROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Roundedness]
                                     PhonemeType.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType.Roundedness)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Roundedness]
                                     PhonemeType.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType.Roundedness)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.ROUNDED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Roundedness]
                                     PhonemeType.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType.Roundedness)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Roundedness]
                                     PhonemeType.$fEnumRoundedness_c
                                     (GHC.Types.[] @ PhonemeType.Roundedness)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType.UNROUNDED -> $j1 0 PhonemeType.ROUNDED -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType.UNROUNDED -> $j 0 PhonemeType.ROUNDED -> $j 1 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_$cenumFromTo ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> [PhonemeType.Roundedness]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Roundedness
                   y :: PhonemeType.Roundedness ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.UNROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumRoundedness_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Roundedness }
                       PhonemeType.ROUNDED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumRoundedness_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Roundedness } }
                 } in
                 case x of wild {
                   PhonemeType.UNROUNDED -> $j 0 PhonemeType.ROUNDED -> $j 1 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_$cfromEnum ::
    PhonemeType.Roundedness -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Roundedness ->
                 case a23 of wild {
                   PhonemeType.UNROUNDED -> GHC.Types.I# 0
                   PhonemeType.ROUNDED -> GHC.Types.I# 1 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_$cpred ::
    PhonemeType.Roundedness -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Roundedness ->
                 case a23 of wild {
                   PhonemeType.UNROUNDED -> PhonemeType.$fEnumRoundedness4
                   PhonemeType.ROUNDED -> PhonemeType.UNROUNDED }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_$csucc ::
    PhonemeType.Roundedness -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Roundedness ->
                 case a23 of wild {
                   PhonemeType.UNROUNDED -> PhonemeType.ROUNDED
                   PhonemeType.ROUNDED -> PhonemeType.$fEnumRoundedness5 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_$ctoEnum ::
    GHC.Types.Int -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum10 ww1 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_c ::
    GHC.Types.Int
    -> [PhonemeType.Roundedness] -> [PhonemeType.Roundedness]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType.Roundedness
                   (PhonemeType.$fEnumRoundedness_$ctoEnum x)
                   ys) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_c1 ::
    GHC.Types.Int
    -> [PhonemeType.Roundedness] -> [PhonemeType.Roundedness]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Roundedness] ->
                 GHC.Types.:
                   @ PhonemeType.Roundedness
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Roundedness a23 })
                   ys) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_go :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_go1 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
  {- Arity: 1, Strictness: <L,U> -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_go2 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
9c915b50edb2977ec86c27bd6c240a83
  $fEnumRoundedness_go3 :: GHC.Prim.Int# -> [PhonemeType.Roundedness]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance :: GHC.Enum.Enum PhonemeType.Silibance
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Silibance
                  PhonemeType.$fEnumSilibance_$csucc
                  PhonemeType.$fEnumSilibance_$cpred
                  PhonemeType.$fEnumSilibance_$ctoEnum
                  PhonemeType.$fEnumSilibance_$cfromEnum
                  PhonemeType.$fEnumSilibance_$cenumFrom
                  PhonemeType.$fEnumSilibance_$cenumFromThen
                  PhonemeType.$fEnumSilibance_$cenumFromTo
                  PhonemeType.$fEnumSilibance_$cenumFromThenTo -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance1 :: GHC.Prim.Int# -> PhonemeType.Silibance
  {- Arity: 1, Strictness: <L,U>b -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance2 :: [PhonemeType.Silibance]
  {- Unfolding: (PhonemeType.$fEnumSilibance_go2 1) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance3 :: [PhonemeType.Silibance]
  {- Unfolding: (PhonemeType.$fEnumSilibance_go3 0) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance4 :: PhonemeType.Silibance
  {- Strictness: b -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance5 :: PhonemeType.Silibance
  {- Strictness: b -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_$cenumFrom ::
    PhonemeType.Silibance -> [PhonemeType.Silibance]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Silibance ->
                 case a23 of wild {
                   PhonemeType.SILIBANT -> PhonemeType.$fEnumSilibance3
                   PhonemeType.NONSILIBANT -> PhonemeType.$fEnumSilibance2 }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_$cenumFromThen ::
    PhonemeType.Silibance
    -> PhonemeType.Silibance -> [PhonemeType.Silibance]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Silibance
                   b :: PhonemeType.Silibance ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Silibance]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Silibance]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Silibance]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Silibance]
                                    PhonemeType.$fEnumSilibance_c1
                                    (GHC.Types.[] @ PhonemeType.Silibance)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Silibance]
                                    PhonemeType.$fEnumSilibance_c1
                                    (GHC.Types.[] @ PhonemeType.Silibance)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.SILIBANT -> $j1 0 PhonemeType.NONSILIBANT -> $j1 1 }
                 } in
                 case a23 of wild {
                   PhonemeType.SILIBANT -> $j 0 PhonemeType.NONSILIBANT -> $j 1 }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_$cenumFromThenTo ::
    PhonemeType.Silibance
    -> PhonemeType.Silibance
    -> PhonemeType.Silibance
    -> [PhonemeType.Silibance]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Silibance
                   x2 :: PhonemeType.Silibance
                   y :: PhonemeType.Silibance ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Silibance]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Silibance]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.SILIBANT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Silibance]
                                     PhonemeType.$fEnumSilibance_c
                                     (GHC.Types.[] @ PhonemeType.Silibance)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Silibance]
                                     PhonemeType.$fEnumSilibance_c
                                     (GHC.Types.[] @ PhonemeType.Silibance)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.NONSILIBANT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Silibance]
                                     PhonemeType.$fEnumSilibance_c
                                     (GHC.Types.[] @ PhonemeType.Silibance)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Silibance]
                                     PhonemeType.$fEnumSilibance_c
                                     (GHC.Types.[] @ PhonemeType.Silibance)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType.SILIBANT -> $j1 0 PhonemeType.NONSILIBANT -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType.SILIBANT -> $j 0 PhonemeType.NONSILIBANT -> $j 1 }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_$cenumFromTo ::
    PhonemeType.Silibance
    -> PhonemeType.Silibance -> [PhonemeType.Silibance]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Silibance
                   y :: PhonemeType.Silibance ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Silibance]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.SILIBANT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumSilibance_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Silibance }
                       PhonemeType.NONSILIBANT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumSilibance_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Silibance } }
                 } in
                 case x of wild {
                   PhonemeType.SILIBANT -> $j 0 PhonemeType.NONSILIBANT -> $j 1 }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_$cfromEnum ::
    PhonemeType.Silibance -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Silibance ->
                 case a23 of wild {
                   PhonemeType.SILIBANT -> GHC.Types.I# 0
                   PhonemeType.NONSILIBANT -> GHC.Types.I# 1 }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_$cpred ::
    PhonemeType.Silibance -> PhonemeType.Silibance
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Silibance ->
                 case a23 of wild {
                   PhonemeType.SILIBANT -> PhonemeType.$fEnumSilibance4
                   PhonemeType.NONSILIBANT -> PhonemeType.SILIBANT }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_$csucc ::
    PhonemeType.Silibance -> PhonemeType.Silibance
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Silibance ->
                 case a23 of wild {
                   PhonemeType.SILIBANT -> PhonemeType.NONSILIBANT
                   PhonemeType.NONSILIBANT -> PhonemeType.$fEnumSilibance5 }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_$ctoEnum :: GHC.Types.Int -> PhonemeType.Silibance
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum11 ww1 }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_c ::
    GHC.Types.Int -> [PhonemeType.Silibance] -> [PhonemeType.Silibance]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Silibance] ->
                 GHC.Types.:
                   @ PhonemeType.Silibance
                   (PhonemeType.$fEnumSilibance_$ctoEnum x)
                   ys) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_c1 ::
    GHC.Types.Int -> [PhonemeType.Silibance] -> [PhonemeType.Silibance]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Silibance] ->
                 GHC.Types.:
                   @ PhonemeType.Silibance
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Silibance a23 })
                   ys) -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_go :: GHC.Prim.Int# -> [PhonemeType.Silibance]
  {- Arity: 1, Strictness: <L,U> -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_go1 :: GHC.Prim.Int# -> [PhonemeType.Silibance]
  {- Arity: 1, Strictness: <L,U> -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_go2 :: GHC.Prim.Int# -> [PhonemeType.Silibance]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
1940ee84f46a7a0f1801689311b6be65
  $fEnumSilibance_go3 :: GHC.Prim.Int# -> [PhonemeType.Silibance]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture :: GHC.Enum.Enum PhonemeType.Stricture
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Stricture
                  PhonemeType.$fEnumStricture_$csucc
                  PhonemeType.$fEnumStricture_$cpred
                  PhonemeType.$fEnumStricture_$ctoEnum
                  PhonemeType.$fEnumStricture_$cfromEnum
                  PhonemeType.$fEnumStricture_$cenumFrom
                  PhonemeType.$fEnumStricture_$cenumFromThen
                  PhonemeType.$fEnumStricture_$cenumFromTo
                  PhonemeType.$fEnumStricture_$cenumFromThenTo -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture1 :: GHC.Prim.Int# -> PhonemeType.Stricture
  {- Arity: 1, Strictness: <L,U>b -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture2 :: [PhonemeType.Stricture]
  {- Unfolding: (PhonemeType.$fEnumStricture_go3 2) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture3 :: [PhonemeType.Stricture]
  {- Unfolding: (PhonemeType.$fEnumStricture_go4 1) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture4 :: [PhonemeType.Stricture]
  {- Unfolding: (PhonemeType.$fEnumStricture_go5 0) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture5 :: PhonemeType.Stricture
  {- Strictness: b -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture6 :: PhonemeType.Stricture
  {- Strictness: b -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_$cenumFrom ::
    PhonemeType.Stricture -> [PhonemeType.Stricture]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Stricture ->
                 case a23 of wild {
                   PhonemeType.OCCLUSION -> PhonemeType.$fEnumStricture4
                   PhonemeType.TURBULENT -> PhonemeType.$fEnumStricture3
                   PhonemeType.SLIGHTTURBULENT -> PhonemeType.$fEnumStricture2 }) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_$cenumFromThen ::
    PhonemeType.Stricture
    -> PhonemeType.Stricture -> [PhonemeType.Stricture]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Stricture
                   b :: PhonemeType.Stricture ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Stricture]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Stricture]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Stricture]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Stricture]
                                    PhonemeType.$fEnumStricture_c1
                                    (GHC.Types.[] @ PhonemeType.Stricture)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Stricture]
                                    PhonemeType.$fEnumStricture_c1
                                    (GHC.Types.[] @ PhonemeType.Stricture)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.OCCLUSION -> $j1 0
                       PhonemeType.TURBULENT -> $j1 1
                       PhonemeType.SLIGHTTURBULENT -> $j1 2 }
                 } in
                 case a23 of wild {
                   PhonemeType.OCCLUSION -> $j 0
                   PhonemeType.TURBULENT -> $j 1
                   PhonemeType.SLIGHTTURBULENT -> $j 2 }) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_$cenumFromThenTo ::
    PhonemeType.Stricture
    -> PhonemeType.Stricture
    -> PhonemeType.Stricture
    -> [PhonemeType.Stricture]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Stricture
                   x2 :: PhonemeType.Stricture
                   y :: PhonemeType.Stricture ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Stricture]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Stricture]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.OCCLUSION
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Stricture]
                                     PhonemeType.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType.Stricture)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Stricture]
                                     PhonemeType.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType.Stricture)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.TURBULENT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Stricture]
                                     PhonemeType.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType.Stricture)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Stricture]
                                     PhonemeType.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType.Stricture)
                                     x4
                                     x5
                                     1 }
                           PhonemeType.SLIGHTTURBULENT
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Stricture]
                                     PhonemeType.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType.Stricture)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Stricture]
                                     PhonemeType.$fEnumStricture_c
                                     (GHC.Types.[] @ PhonemeType.Stricture)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType.OCCLUSION -> $j1 0
                       PhonemeType.TURBULENT -> $j1 1
                       PhonemeType.SLIGHTTURBULENT -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType.OCCLUSION -> $j 0
                   PhonemeType.TURBULENT -> $j 1
                   PhonemeType.SLIGHTTURBULENT -> $j 2 }) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_$cenumFromTo ::
    PhonemeType.Stricture
    -> PhonemeType.Stricture -> [PhonemeType.Stricture]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Stricture
                   y :: PhonemeType.Stricture ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Stricture]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.OCCLUSION
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumStricture_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Stricture }
                       PhonemeType.TURBULENT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumStricture_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Stricture }
                       PhonemeType.SLIGHTTURBULENT
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumStricture_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Stricture } }
                 } in
                 case x of wild {
                   PhonemeType.OCCLUSION -> $j 0
                   PhonemeType.TURBULENT -> $j 1
                   PhonemeType.SLIGHTTURBULENT -> $j 2 }) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_$cfromEnum ::
    PhonemeType.Stricture -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Stricture ->
                 case a23 of wild {
                   PhonemeType.OCCLUSION -> GHC.Types.I# 0
                   PhonemeType.TURBULENT -> GHC.Types.I# 1
                   PhonemeType.SLIGHTTURBULENT -> GHC.Types.I# 2 }) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_$cpred ::
    PhonemeType.Stricture -> PhonemeType.Stricture
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Stricture ->
                 case a23 of wild {
                   PhonemeType.OCCLUSION -> PhonemeType.$fEnumStricture5
                   PhonemeType.TURBULENT -> PhonemeType.OCCLUSION
                   PhonemeType.SLIGHTTURBULENT -> PhonemeType.TURBULENT }) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_$csucc ::
    PhonemeType.Stricture -> PhonemeType.Stricture
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Stricture ->
                 case a23 of wild {
                   PhonemeType.OCCLUSION -> PhonemeType.TURBULENT
                   PhonemeType.TURBULENT -> PhonemeType.SLIGHTTURBULENT
                   PhonemeType.SLIGHTTURBULENT -> PhonemeType.$fEnumStricture6 }) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_$ctoEnum :: GHC.Types.Int -> PhonemeType.Stricture
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum12 ww1 }) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_c ::
    GHC.Types.Int -> [PhonemeType.Stricture] -> [PhonemeType.Stricture]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Stricture] ->
                 GHC.Types.:
                   @ PhonemeType.Stricture
                   (PhonemeType.$fEnumStricture_$ctoEnum x)
                   ys) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_c1 ::
    GHC.Types.Int -> [PhonemeType.Stricture] -> [PhonemeType.Stricture]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Stricture] ->
                 GHC.Types.:
                   @ PhonemeType.Stricture
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Stricture a23 })
                   ys) -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_go :: GHC.Prim.Int# -> [PhonemeType.Stricture]
  {- Arity: 1, Strictness: <L,U> -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_go1 :: GHC.Prim.Int# -> [PhonemeType.Stricture]
  {- Arity: 1, Strictness: <L,U> -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_go2 :: GHC.Prim.Int# -> [PhonemeType.Stricture]
  {- Arity: 1, Strictness: <L,U> -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_go3 :: GHC.Prim.Int# -> [PhonemeType.Stricture]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_go4 :: GHC.Prim.Int# -> [PhonemeType.Stricture]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
f45b7454df7117690624094b2e33986b
  $fEnumStricture_go5 :: GHC.Prim.Int# -> [PhonemeType.Stricture]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill :: GHC.Enum.Enum PhonemeType.Trill
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Trill
                  PhonemeType.$fEnumTrill_$csucc
                  PhonemeType.$fEnumTrill_$cpred
                  PhonemeType.$fEnumTrill_$ctoEnum
                  PhonemeType.$fEnumTrill_$cfromEnum
                  PhonemeType.$fEnumTrill_$cenumFrom
                  PhonemeType.$fEnumTrill_$cenumFromThen
                  PhonemeType.$fEnumTrill_$cenumFromTo
                  PhonemeType.$fEnumTrill_$cenumFromThenTo -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill1 :: GHC.Prim.Int# -> PhonemeType.Trill
  {- Arity: 1, Strictness: <L,U>b -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill2 :: [PhonemeType.Trill]
  {- Unfolding: (PhonemeType.$fEnumTrill_go2 1) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill3 :: [PhonemeType.Trill]
  {- Unfolding: (PhonemeType.$fEnumTrill_go3 0) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill4 :: PhonemeType.Trill
  {- Strictness: b -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill5 :: PhonemeType.Trill
  {- Strictness: b -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_$cenumFrom :: PhonemeType.Trill -> [PhonemeType.Trill]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Trill ->
                 case a23 of wild {
                   PhonemeType.TRILLED -> PhonemeType.$fEnumTrill3
                   PhonemeType.NOTTRILLED -> PhonemeType.$fEnumTrill2 }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_$cenumFromThen ::
    PhonemeType.Trill -> PhonemeType.Trill -> [PhonemeType.Trill]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Trill b :: PhonemeType.Trill ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Trill]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Trill]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.Trill]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.Trill]
                                    PhonemeType.$fEnumTrill_c1
                                    (GHC.Types.[] @ PhonemeType.Trill)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.Trill]
                                    PhonemeType.$fEnumTrill_c1
                                    (GHC.Types.[] @ PhonemeType.Trill)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 1 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.TRILLED -> $j1 0 PhonemeType.NOTTRILLED -> $j1 1 }
                 } in
                 case a23 of wild {
                   PhonemeType.TRILLED -> $j 0 PhonemeType.NOTTRILLED -> $j 1 }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_$cenumFromThenTo ::
    PhonemeType.Trill
    -> PhonemeType.Trill -> PhonemeType.Trill -> [PhonemeType.Trill]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.Trill
                   x2 :: PhonemeType.Trill
                   y :: PhonemeType.Trill ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Trill]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.Trill]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.TRILLED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Trill]
                                     PhonemeType.$fEnumTrill_c
                                     (GHC.Types.[] @ PhonemeType.Trill)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Trill]
                                     PhonemeType.$fEnumTrill_c
                                     (GHC.Types.[] @ PhonemeType.Trill)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.NOTTRILLED
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.Trill]
                                     PhonemeType.$fEnumTrill_c
                                     (GHC.Types.[] @ PhonemeType.Trill)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.Trill]
                                     PhonemeType.$fEnumTrill_c
                                     (GHC.Types.[] @ PhonemeType.Trill)
                                     x4
                                     x5
                                     1 } }
                     } in
                     case x2 of wild {
                       PhonemeType.TRILLED -> $j1 0 PhonemeType.NOTTRILLED -> $j1 1 }
                 } in
                 case x1 of wild {
                   PhonemeType.TRILLED -> $j 0 PhonemeType.NOTTRILLED -> $j 1 }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_$cenumFromTo ::
    PhonemeType.Trill -> PhonemeType.Trill -> [PhonemeType.Trill]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.Trill y :: PhonemeType.Trill ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.Trill]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.TRILLED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumTrill_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Trill }
                       PhonemeType.NOTTRILLED
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumTrill_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.Trill } }
                 } in
                 case x of wild {
                   PhonemeType.TRILLED -> $j 0 PhonemeType.NOTTRILLED -> $j 1 }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_$cfromEnum :: PhonemeType.Trill -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Trill ->
                 case a23 of wild {
                   PhonemeType.TRILLED -> GHC.Types.I# 0
                   PhonemeType.NOTTRILLED -> GHC.Types.I# 1 }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_$cpred :: PhonemeType.Trill -> PhonemeType.Trill
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Trill ->
                 case a23 of wild {
                   PhonemeType.TRILLED -> PhonemeType.$fEnumTrill4
                   PhonemeType.NOTTRILLED -> PhonemeType.TRILLED }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_$csucc :: PhonemeType.Trill -> PhonemeType.Trill
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.Trill ->
                 case a23 of wild {
                   PhonemeType.TRILLED -> PhonemeType.NOTTRILLED
                   PhonemeType.NOTTRILLED -> PhonemeType.$fEnumTrill5 }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_$ctoEnum :: GHC.Types.Int -> PhonemeType.Trill
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum13 ww1 }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_c ::
    GHC.Types.Int -> [PhonemeType.Trill] -> [PhonemeType.Trill]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Trill] ->
                 GHC.Types.:
                   @ PhonemeType.Trill
                   (PhonemeType.$fEnumTrill_$ctoEnum x)
                   ys) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_c1 ::
    GHC.Types.Int -> [PhonemeType.Trill] -> [PhonemeType.Trill]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.Trill] ->
                 GHC.Types.:
                   @ PhonemeType.Trill
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.Trill a23 })
                   ys) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_go :: GHC.Prim.Int# -> [PhonemeType.Trill]
  {- Arity: 1, Strictness: <L,U> -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_go1 :: GHC.Prim.Int# -> [PhonemeType.Trill]
  {- Arity: 1, Strictness: <L,U> -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_go2 :: GHC.Prim.Int# -> [PhonemeType.Trill]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEnumTrill_go3 :: GHC.Prim.Int# -> [PhonemeType.Trill]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT :: GHC.Enum.Enum PhonemeType.VOT
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VOT
                  PhonemeType.$fEnumVOT_$csucc
                  PhonemeType.$fEnumVOT_$cpred
                  PhonemeType.$fEnumVOT_$ctoEnum
                  PhonemeType.$fEnumVOT_$cfromEnum
                  PhonemeType.$fEnumVOT_$cenumFrom
                  PhonemeType.$fEnumVOT_$cenumFromThen
                  PhonemeType.$fEnumVOT_$cenumFromTo
                  PhonemeType.$fEnumVOT_$cenumFromThenTo -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT1 :: GHC.Prim.Int# -> PhonemeType.VOT
  {- Arity: 1, Strictness: <L,U>b -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT2 :: [PhonemeType.VOT]
  {- Unfolding: (PhonemeType.$fEnumVOT_go3 2) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT3 :: [PhonemeType.VOT]
  {- Unfolding: (PhonemeType.$fEnumVOT_go4 1) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT4 :: [PhonemeType.VOT]
  {- Unfolding: (PhonemeType.$fEnumVOT_go5 0) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT5 :: PhonemeType.VOT
  {- Strictness: b -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT6 :: PhonemeType.VOT
  {- Strictness: b -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_$cenumFrom :: PhonemeType.VOT -> [PhonemeType.VOT]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.VOT ->
                 case a23 of wild {
                   PhonemeType.POSITIVE -> PhonemeType.$fEnumVOT4
                   PhonemeType.ZERO -> PhonemeType.$fEnumVOT3
                   PhonemeType.NEGATIVE -> PhonemeType.$fEnumVOT2 }) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_$cenumFromThen ::
    PhonemeType.VOT -> PhonemeType.VOT -> [PhonemeType.VOT]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.VOT b :: PhonemeType.VOT ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.VOT]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ a# :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.VOT]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ b# :: GHC.Prim.Int#[OneShot] ->
                         let {
                           $j2 :: GHC.Prim.Int# -> [PhonemeType.VOT]
                             {- Arity: 1, Strictness: <L,U> -}
                           = \ y :: GHC.Prim.Int#[OneShot] ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# b# a#) of wild {
                               GHC.Types.False
                               -> GHC.Enum.efdtIntDnFB
                                    @ [PhonemeType.VOT]
                                    PhonemeType.$fEnumVOT_c1
                                    (GHC.Types.[] @ PhonemeType.VOT)
                                    a#
                                    b#
                                    y
                               GHC.Types.True
                               -> GHC.Enum.efdtIntUpFB
                                    @ [PhonemeType.VOT]
                                    PhonemeType.$fEnumVOT_c1
                                    (GHC.Types.[] @ PhonemeType.VOT)
                                    a#
                                    b#
                                    y }
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># a# b#) of wild {
                           GHC.Types.False -> $j2 2 GHC.Types.True -> $j2 0 }
                     } in
                     case b of wild {
                       PhonemeType.POSITIVE -> $j1 0
                       PhonemeType.ZERO -> $j1 1
                       PhonemeType.NEGATIVE -> $j1 2 }
                 } in
                 case a23 of wild {
                   PhonemeType.POSITIVE -> $j 0
                   PhonemeType.ZERO -> $j 1
                   PhonemeType.NEGATIVE -> $j 2 }) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_$cenumFromThenTo ::
    PhonemeType.VOT
    -> PhonemeType.VOT -> PhonemeType.VOT -> [PhonemeType.VOT]
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ x1 :: PhonemeType.VOT
                   x2 :: PhonemeType.VOT
                   y :: PhonemeType.VOT ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.VOT]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x4 :: GHC.Prim.Int#[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [PhonemeType.VOT]
                         {- Arity: 1, Strictness: <L,U> -}
                       = \ x5 :: GHC.Prim.Int#[OneShot] ->
                         case y of wild {
                           PhonemeType.POSITIVE
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.VOT]
                                     PhonemeType.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType.VOT)
                                     x4
                                     x5
                                     0
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.VOT]
                                     PhonemeType.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType.VOT)
                                     x4
                                     x5
                                     0 }
                           PhonemeType.ZERO
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.VOT]
                                     PhonemeType.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType.VOT)
                                     x4
                                     x5
                                     1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.VOT]
                                     PhonemeType.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType.VOT)
                                     x4
                                     x5
                                     1 }
                           PhonemeType.NEGATIVE
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [PhonemeType.VOT]
                                     PhonemeType.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType.VOT)
                                     x4
                                     x5
                                     2
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [PhonemeType.VOT]
                                     PhonemeType.$fEnumVOT_c
                                     (GHC.Types.[] @ PhonemeType.VOT)
                                     x4
                                     x5
                                     2 } }
                     } in
                     case x2 of wild {
                       PhonemeType.POSITIVE -> $j1 0
                       PhonemeType.ZERO -> $j1 1
                       PhonemeType.NEGATIVE -> $j1 2 }
                 } in
                 case x1 of wild {
                   PhonemeType.POSITIVE -> $j 0
                   PhonemeType.ZERO -> $j 1
                   PhonemeType.NEGATIVE -> $j 2 }) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_$cenumFromTo ::
    PhonemeType.VOT -> PhonemeType.VOT -> [PhonemeType.VOT]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: PhonemeType.VOT y :: PhonemeType.VOT ->
                 let {
                   $j :: GHC.Prim.Int# -> [PhonemeType.VOT]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ x1 :: GHC.Prim.Int#[OneShot] ->
                     case y of wild {
                       PhonemeType.POSITIVE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumVOT_go2 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.VOT }
                       PhonemeType.ZERO
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 1) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumVOT_go1 x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.VOT }
                       PhonemeType.NEGATIVE
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 2) of wild1 {
                            GHC.Types.False -> PhonemeType.$fEnumVOT_go x1
                            GHC.Types.True -> GHC.Types.[] @ PhonemeType.VOT } }
                 } in
                 case x of wild {
                   PhonemeType.POSITIVE -> $j 0
                   PhonemeType.ZERO -> $j 1
                   PhonemeType.NEGATIVE -> $j 2 }) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_$cfromEnum :: PhonemeType.VOT -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.VOT ->
                 case a23 of wild {
                   PhonemeType.POSITIVE -> GHC.Types.I# 0
                   PhonemeType.ZERO -> GHC.Types.I# 1
                   PhonemeType.NEGATIVE -> GHC.Types.I# 2 }) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_$cpred :: PhonemeType.VOT -> PhonemeType.VOT
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.VOT ->
                 case a23 of wild {
                   PhonemeType.POSITIVE -> PhonemeType.$fEnumVOT5
                   PhonemeType.ZERO -> PhonemeType.POSITIVE
                   PhonemeType.NEGATIVE -> PhonemeType.ZERO }) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_$csucc :: PhonemeType.VOT -> PhonemeType.VOT
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ a23 :: PhonemeType.VOT ->
                 case a23 of wild {
                   PhonemeType.POSITIVE -> PhonemeType.ZERO
                   PhonemeType.ZERO -> PhonemeType.NEGATIVE
                   PhonemeType.NEGATIVE -> PhonemeType.$fEnumVOT6 }) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_$ctoEnum :: GHC.Types.Int -> PhonemeType.VOT
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$w$ctoEnum14 ww1 }) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_c ::
    GHC.Types.Int -> [PhonemeType.VOT] -> [PhonemeType.VOT]
  {- Arity: 2, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.VOT] ->
                 GHC.Types.:
                   @ PhonemeType.VOT
                   (PhonemeType.$fEnumVOT_$ctoEnum x)
                   ys) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_c1 ::
    GHC.Types.Int -> [PhonemeType.VOT] -> [PhonemeType.VOT]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ x :: GHC.Types.Int ys :: [PhonemeType.VOT] ->
                 GHC.Types.:
                   @ PhonemeType.VOT
                   (case x of wild { GHC.Types.I# a23 ->
                    GHC.Prim.tagToEnum# @ PhonemeType.VOT a23 })
                   ys) -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_go :: GHC.Prim.Int# -> [PhonemeType.VOT]
  {- Arity: 1, Strictness: <L,U> -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_go1 :: GHC.Prim.Int# -> [PhonemeType.VOT]
  {- Arity: 1, Strictness: <L,U> -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_go2 :: GHC.Prim.Int# -> [PhonemeType.VOT]
  {- Arity: 1, Strictness: <L,U> -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_go3 :: GHC.Prim.Int# -> [PhonemeType.VOT]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_go4 :: GHC.Prim.Int# -> [PhonemeType.VOT]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
16d61d06081f347fd36865d448a9e38e
  $fEnumVOT_go5 :: GHC.Prim.Int# -> [PhonemeType.VOT]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEqActiveArticulator ::
    GHC.Classes.Eq PhonemeType.ActiveArticulator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ActiveArticulator
                  PhonemeType.$fEqActiveArticulator_$c==
                  PhonemeType.$fEqActiveArticulator_$c/= -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEqActiveArticulator_$c/= ::
    PhonemeType.ActiveArticulator
    -> PhonemeType.ActiveArticulator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.ActiveArticulator
                   b :: PhonemeType.ActiveArticulator ->
                 case a23 of wild {
                   PhonemeType.LOWERLIP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.LOWERLIP -> GHC.Types.False }
                   PhonemeType.TONGUEBLADE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.TONGUEBLADE -> GHC.Types.False }
                   PhonemeType.TONGUETIP
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.TONGUETIP -> GHC.Types.False }
                   PhonemeType.TONGUEUNDER
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.TONGUEUNDER -> GHC.Types.False }
                   PhonemeType.TONGUEBODY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.TONGUEBODY -> GHC.Types.False }
                   PhonemeType.TONGUEROOT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.TONGUEROOT -> GHC.Types.False }
                   PhonemeType.LARYNX
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.LARYNX -> GHC.Types.False } }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fEqActiveArticulator_$c== ::
    PhonemeType.ActiveArticulator
    -> PhonemeType.ActiveArticulator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType.ActiveArticulator
                   ds1 :: PhonemeType.ActiveArticulator ->
                 case ds of wild {
                   PhonemeType.LOWERLIP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.LOWERLIP -> GHC.Types.True }
                   PhonemeType.TONGUEBLADE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.TONGUEBLADE -> GHC.Types.True }
                   PhonemeType.TONGUETIP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.TONGUETIP -> GHC.Types.True }
                   PhonemeType.TONGUEUNDER
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.TONGUEUNDER -> GHC.Types.True }
                   PhonemeType.TONGUEBODY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.TONGUEBODY -> GHC.Types.True }
                   PhonemeType.TONGUEROOT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.TONGUEROOT -> GHC.Types.True }
                   PhonemeType.LARYNX
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.LARYNX -> GHC.Types.True } }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEqAirEscape :: GHC.Classes.Eq PhonemeType.AirEscape
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.AirEscape
                  PhonemeType.$fEqAirEscape_$c==
                  PhonemeType.$fEqAirEscape_$c/= -}
483edd05f8d1cf327b30114f3225d3b2
  $fEqAirEscape_$c/= ::
    PhonemeType.AirEscape -> PhonemeType.AirEscape -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.AirEscape b :: PhonemeType.AirEscape ->
                 case a23 of wild {
                   PhonemeType.NASALIZED
                   -> case b of wild1 {
                        PhonemeType.NASALIZED -> GHC.Types.False
                        PhonemeType.ORAL -> GHC.Types.True }
                   PhonemeType.ORAL
                   -> case b of wild1 {
                        PhonemeType.NASALIZED -> GHC.Types.True
                        PhonemeType.ORAL -> GHC.Types.False } }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fEqAirEscape_$c== ::
    PhonemeType.AirEscape -> PhonemeType.AirEscape -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.AirEscape ds1 :: PhonemeType.AirEscape ->
                 case ds of wild {
                   PhonemeType.NASALIZED
                   -> case ds1 of wild1 {
                        PhonemeType.NASALIZED -> GHC.Types.True
                        PhonemeType.ORAL -> GHC.Types.False }
                   PhonemeType.ORAL
                   -> case ds1 of wild1 {
                        PhonemeType.NASALIZED -> GHC.Types.False
                        PhonemeType.ORAL -> GHC.Types.True } }) -}
355bf06edf14b009f06abed2ef70f036
  $fEqAirstream :: GHC.Classes.Eq PhonemeType.Airstream
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Airstream
                  PhonemeType.$fEqAirstream_$c==
                  PhonemeType.$fEqAirstream_$c/= -}
355bf06edf14b009f06abed2ef70f036
  $fEqAirstream_$c/= ::
    PhonemeType.Airstream -> PhonemeType.Airstream -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Airstream b :: PhonemeType.Airstream ->
                 case PhonemeType.$fEqAirstream_$c== a23 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
355bf06edf14b009f06abed2ef70f036
  $fEqAirstream_$c== ::
    PhonemeType.Airstream -> PhonemeType.Airstream -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Airstream w1 :: PhonemeType.Airstream ->
                 case w of ww { PhonemeType.Airstream ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.Airstream ww4 ww5 ->
                 PhonemeType.$w$c== ww1 ww2 ww4 ww5 } }) -}
40a9c5f987e37783909145cb5997138e
  $fEqAirstream_$c==1 ::
    PhonemeType.Direction -> PhonemeType.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Direction ds1 :: PhonemeType.Direction ->
                 case ds of wild {
                   PhonemeType.INGRESSIVE
                   -> case ds1 of wild1 {
                        PhonemeType.INGRESSIVE -> GHC.Types.True
                        PhonemeType.EGRESSIVE -> GHC.Types.False }
                   PhonemeType.EGRESSIVE
                   -> case ds1 of wild1 {
                        PhonemeType.INGRESSIVE -> GHC.Types.False
                        PhonemeType.EGRESSIVE -> GHC.Types.True } }) -}
4600283dc79ec1a04339fecb849d3137
  $fEqBackness :: GHC.Classes.Eq PhonemeType.Backness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fEqBackness_$c==
                  PhonemeType.$fEqBackness_$c/= -}
4600283dc79ec1a04339fecb849d3137
  $fEqBackness_$c/= ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Backness
                   b :: PhonemeType.Backness ->
                 case a23 of wild {
                   PhonemeType.BACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.BACK -> GHC.Types.False }
                   PhonemeType.NEARBACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.NEARBACK -> GHC.Types.False }
                   PhonemeType.CENTRAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.CENTRAL -> GHC.Types.False }
                   PhonemeType.NEARFRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.NEARFRONT -> GHC.Types.False }
                   PhonemeType.FRONT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.FRONT -> GHC.Types.False } }) -}
4600283dc79ec1a04339fecb849d3137
  $fEqBackness_$c== ::
    PhonemeType.Backness -> PhonemeType.Backness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType.Backness
                   ds1 :: PhonemeType.Backness ->
                 case ds of wild {
                   PhonemeType.BACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.BACK -> GHC.Types.True }
                   PhonemeType.NEARBACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.NEARBACK -> GHC.Types.True }
                   PhonemeType.CENTRAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.CENTRAL -> GHC.Types.True }
                   PhonemeType.NEARFRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEARFRONT -> GHC.Types.True }
                   PhonemeType.FRONT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.FRONT -> GHC.Types.True } }) -}
62312b673b3cb46a867844b1181e8c1b
  $fEqConsonantFeatures ::
    GHC.Classes.Eq PhonemeType.ConsonantFeatures
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ConsonantFeatures
                  PhonemeType.$fEqConsonantFeatures_$c==
                  PhonemeType.$fEqConsonantFeatures_$c/= -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fEqConsonantFeaturesContour ::
    GHC.Classes.Eq PhonemeType.ConsonantFeaturesContour
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ConsonantFeaturesContour
                  PhonemeType.$fEqConsonantFeaturesContour_$c==
                  PhonemeType.$fEqConsonantFeaturesContour_$c/= -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fEqConsonantFeaturesContour_$c/= ::
    PhonemeType.ConsonantFeaturesContour
    -> PhonemeType.ConsonantFeaturesContour -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLLL)L),1*U(1*U(1*U,1*U,1*U,1*U),1*U)><S(S(SLLL)L),1*U(1*U(1*U,1*U,1*U,1*U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.ConsonantFeaturesContour
                   b :: PhonemeType.ConsonantFeaturesContour ->
                 case PhonemeType.$fEqConsonantFeaturesContour_$c== a23 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fEqConsonantFeaturesContour_$c== ::
    PhonemeType.ConsonantFeaturesContour
    -> PhonemeType.ConsonantFeaturesContour -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLLL)L),1*U(1*U(1*U,1*U,1*U,1*U),1*U)><S(S(SLLL)L),1*U(1*U(1*U,1*U,1*U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.ConsonantFeaturesContour
                   w1 :: PhonemeType.ConsonantFeaturesContour ->
                 case w of ww { PhonemeType.ConsonantFeaturesContour ww1 ww2 ->
                 case ww1 of ww3 { PhonemeType.ConsonantFeatures ww4 ww5 ww6 ww7 ->
                 case w1 of ww8 { PhonemeType.ConsonantFeaturesContour ww9 ww10 ->
                 case ww9 of ww11 { PhonemeType.ConsonantFeatures ww12 ww13 ww14 ww15 ->
                 PhonemeType.$w$c==2
                   ww4
                   ww5
                   ww6
                   ww7
                   ww2
                   ww12
                   ww13
                   ww14
                   ww15
                   ww10 } } } }) -}
62312b673b3cb46a867844b1181e8c1b
  $fEqConsonantFeatures_$c/= ::
    PhonemeType.ConsonantFeatures
    -> PhonemeType.ConsonantFeatures -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.ConsonantFeatures
                   b :: PhonemeType.ConsonantFeatures ->
                 case PhonemeType.$fEqConsonantFeatures_$c== a23 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
62312b673b3cb46a867844b1181e8c1b
  $fEqConsonantFeatures_$c== ::
    PhonemeType.ConsonantFeatures
    -> PhonemeType.ConsonantFeatures -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)><S(SLLL),1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.ConsonantFeatures
                   w1 :: PhonemeType.ConsonantFeatures ->
                 case w of ww { PhonemeType.ConsonantFeatures ww1 ww2 ww3 ww4 ->
                 case w1 of ww5 { PhonemeType.ConsonantFeatures ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$c==1 ww1 ww2 ww3 ww4 ww6 ww7 ww8 ww9 } }) -}
40a9c5f987e37783909145cb5997138e
  $fEqDirection :: GHC.Classes.Eq PhonemeType.Direction
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Direction
                  PhonemeType.$fEqAirstream_$c==1
                  PhonemeType.$fEqDirection_$c/= -}
40a9c5f987e37783909145cb5997138e
  $fEqDirection_$c/= ::
    PhonemeType.Direction -> PhonemeType.Direction -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Direction b :: PhonemeType.Direction ->
                 case a23 of wild {
                   PhonemeType.INGRESSIVE
                   -> case b of wild1 {
                        PhonemeType.INGRESSIVE -> GHC.Types.False
                        PhonemeType.EGRESSIVE -> GHC.Types.True }
                   PhonemeType.EGRESSIVE
                   -> case b of wild1 {
                        PhonemeType.INGRESSIVE -> GHC.Types.True
                        PhonemeType.EGRESSIVE -> GHC.Types.False } }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEqHeight :: GHC.Classes.Eq PhonemeType.Height
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fEqHeight_$c==
                  PhonemeType.$fEqHeight_$c/= -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEqHeight_$c/= ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Height b :: PhonemeType.Height ->
                 case a23 of wild {
                   PhonemeType.CLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.CLOSE -> GHC.Types.False }
                   PhonemeType.NEARCLOSE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.NEARCLOSE -> GHC.Types.False }
                   PhonemeType.CLOSEMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.CLOSEMID -> GHC.Types.False }
                   PhonemeType.MID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.MID -> GHC.Types.False }
                   PhonemeType.OPENMID
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.OPENMID -> GHC.Types.False }
                   PhonemeType.NEAROPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.NEAROPEN -> GHC.Types.False }
                   PhonemeType.OPEN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.OPEN -> GHC.Types.False } }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fEqHeight_$c== ::
    PhonemeType.Height -> PhonemeType.Height -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType.Height ds1 :: PhonemeType.Height ->
                 case ds of wild {
                   PhonemeType.CLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.CLOSE -> GHC.Types.True }
                   PhonemeType.NEARCLOSE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEARCLOSE -> GHC.Types.True }
                   PhonemeType.CLOSEMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.CLOSEMID -> GHC.Types.True }
                   PhonemeType.MID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.MID -> GHC.Types.True }
                   PhonemeType.OPENMID
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.OPENMID -> GHC.Types.True }
                   PhonemeType.NEAROPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.NEAROPEN -> GHC.Types.True }
                   PhonemeType.OPEN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.OPEN -> GHC.Types.True } }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEqInitiator :: GHC.Classes.Eq PhonemeType.Initiator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Initiator
                  PhonemeType.$fEqInitiator_$c==
                  PhonemeType.$fEqInitiator_$c/= -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEqInitiator_$c/= ::
    PhonemeType.Initiator -> PhonemeType.Initiator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Initiator b :: PhonemeType.Initiator ->
                 case a23 of wild {
                   PhonemeType.LINGUAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.LINGUAL -> GHC.Types.False }
                   PhonemeType.GLOTTIC
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.GLOTTIC -> GHC.Types.False }
                   PhonemeType.PULMONIC
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.PULMONIC -> GHC.Types.False } }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fEqInitiator_$c== ::
    PhonemeType.Initiator -> PhonemeType.Initiator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Initiator ds1 :: PhonemeType.Initiator ->
                 case ds of wild {
                   PhonemeType.LINGUAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.LINGUAL -> GHC.Types.True }
                   PhonemeType.GLOTTIC
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.GLOTTIC -> GHC.Types.True }
                   PhonemeType.PULMONIC
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.PULMONIC -> GHC.Types.True } }) -}
563547f95f31ce703bd3964698c86217
  $fEqLaterality :: GHC.Classes.Eq PhonemeType.Laterality
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Laterality
                  PhonemeType.$fEqLaterality_$c==
                  PhonemeType.$fEqLaterality_$c/= -}
563547f95f31ce703bd3964698c86217
  $fEqLaterality_$c/= ::
    PhonemeType.Laterality -> PhonemeType.Laterality -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Laterality b :: PhonemeType.Laterality ->
                 case a23 of wild {
                   PhonemeType.LATERAL
                   -> case b of wild1 {
                        PhonemeType.LATERAL -> GHC.Types.False
                        PhonemeType.NONLATERAL -> GHC.Types.True }
                   PhonemeType.NONLATERAL
                   -> case b of wild1 {
                        PhonemeType.LATERAL -> GHC.Types.True
                        PhonemeType.NONLATERAL -> GHC.Types.False } }) -}
563547f95f31ce703bd3964698c86217
  $fEqLaterality_$c== ::
    PhonemeType.Laterality -> PhonemeType.Laterality -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Laterality ds1 :: PhonemeType.Laterality ->
                 case ds of wild {
                   PhonemeType.LATERAL
                   -> case ds1 of wild1 {
                        PhonemeType.LATERAL -> GHC.Types.True
                        PhonemeType.NONLATERAL -> GHC.Types.False }
                   PhonemeType.NONLATERAL
                   -> case ds1 of wild1 {
                        PhonemeType.LATERAL -> GHC.Types.False
                        PhonemeType.NONLATERAL -> GHC.Types.True } }) -}
355f724f9de26105f3758df52d82fae4
  $fEqLength :: GHC.Classes.Eq PhonemeType.Length
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Length
                  PhonemeType.$fEqLength_$c==
                  PhonemeType.$fEqLength_$c/= -}
355f724f9de26105f3758df52d82fae4
  $fEqLength_$c/= ::
    PhonemeType.Length -> PhonemeType.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Length b :: PhonemeType.Length ->
                 case a23 of wild {
                   PhonemeType.SHORT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.SHORT -> GHC.Types.False }
                   PhonemeType.NORMAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.NORMAL -> GHC.Types.False }
                   PhonemeType.LONG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.LONG -> GHC.Types.False } }) -}
355f724f9de26105f3758df52d82fae4
  $fEqLength_$c== ::
    PhonemeType.Length -> PhonemeType.Length -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Length ds1 :: PhonemeType.Length ->
                 case ds of wild {
                   PhonemeType.SHORT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.SHORT -> GHC.Types.True }
                   PhonemeType.NORMAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.NORMAL -> GHC.Types.True }
                   PhonemeType.LONG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.LONG -> GHC.Types.True } }) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fEqManner :: GHC.Classes.Eq PhonemeType.Manner
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner
                  PhonemeType.$fEqManner_$c==
                  PhonemeType.$fEqManner_$c/= -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fEqManner_$c/= ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Manner b :: PhonemeType.Manner ->
                 case PhonemeType.$fEqManner_$c== a23 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fEqManner_$c== ::
    PhonemeType.Manner -> PhonemeType.Manner -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Manner w1 :: PhonemeType.Manner ->
                 case w of ww { PhonemeType.Manner ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w1 of ww8 { PhonemeType.Manner ww9 ww10 ww11 ww12 ww13 ww14 ww15 ->
                 PhonemeType.$w$c==3
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15 } }) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fEqMaybeBlank ::
    GHC.Classes.Eq a => GHC.Classes.Eq (PhonemeType.MaybeBlank a)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dEq :: GHC.Classes.Eq a23.
                  @ (PhonemeType.MaybeBlank a23)
                  (PhonemeType.$fEqMaybeBlank_$c== @ a23 $dEq)
                  (PhonemeType.$fEqMaybeBlank_$c/= @ a23 $dEq) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fEqMaybeBlank_$c/= ::
    GHC.Classes.Eq a =>
    PhonemeType.MaybeBlank a
    -> PhonemeType.MaybeBlank a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a23
                   $dEq :: GHC.Classes.Eq a23
                   a24 :: PhonemeType.MaybeBlank a23
                   b :: PhonemeType.MaybeBlank a23 ->
                 case a24 of wild {
                   PhonemeType.Filled a25
                   -> case b of wild1 {
                        PhonemeType.Filled b1
                        -> case GHC.Classes.== @ a23 $dEq a25 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        PhonemeType.Blank -> GHC.Types.True }
                   PhonemeType.Blank
                   -> case b of wild1 {
                        PhonemeType.Filled ipv -> GHC.Types.True
                        PhonemeType.Blank -> GHC.Types.False } }) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fEqMaybeBlank_$c== ::
    GHC.Classes.Eq a =>
    PhonemeType.MaybeBlank a
    -> PhonemeType.MaybeBlank a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dEq :: GHC.Classes.Eq a23
                   ds :: PhonemeType.MaybeBlank a23
                   ds1 :: PhonemeType.MaybeBlank a23 ->
                 case ds of wild {
                   PhonemeType.Filled a24
                   -> case ds1 of wild1 {
                        PhonemeType.Filled b1 -> GHC.Classes.== @ a23 $dEq a24 b1
                        PhonemeType.Blank -> GHC.Types.False }
                   PhonemeType.Blank
                   -> case ds1 of wild1 {
                        PhonemeType.Filled ipv -> GHC.Types.False
                        PhonemeType.Blank -> GHC.Types.True } }) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fEqMaybeBlank_$c==1 ::
    PhonemeType.VowelFeatures
    -> PhonemeType.VowelFeatures -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.VowelFeatures
                   w1 :: PhonemeType.VowelFeatures ->
                 case w of ww { PhonemeType.VowelFeatures ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w1 of ww8 { PhonemeType.VowelFeatures ww9 ww10 ww11 ww12 ww13 ww14 ww15 ->
                 PhonemeType.$w$c==4
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww9
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14
                   ww15 } }) -}
60779ee60a7b7b6d291add8ce22569fb
  $fEqMaybeImpossible ::
    GHC.Classes.Eq a => GHC.Classes.Eq (PhonemeType.MaybeImpossible a)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dEq :: GHC.Classes.Eq a23.
                  @ (PhonemeType.MaybeImpossible a23)
                  (PhonemeType.$fEqMaybeImpossible_$c== @ a23 $dEq)
                  (PhonemeType.$fEqMaybeImpossible_$c/= @ a23 $dEq) -}
60779ee60a7b7b6d291add8ce22569fb
  $fEqMaybeImpossible_$c/= ::
    GHC.Classes.Eq a =>
    PhonemeType.MaybeImpossible a
    -> PhonemeType.MaybeImpossible a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a23
                   $dEq :: GHC.Classes.Eq a23
                   a24 :: PhonemeType.MaybeImpossible a23
                   b :: PhonemeType.MaybeImpossible a23 ->
                 case a24 of wild {
                   PhonemeType.Possible a25
                   -> case b of wild1 {
                        PhonemeType.Possible b1
                        -> case GHC.Classes.== @ a23 $dEq a25 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        PhonemeType.Impossible -> GHC.Types.True }
                   PhonemeType.Impossible
                   -> case b of wild1 {
                        PhonemeType.Possible ipv -> GHC.Types.True
                        PhonemeType.Impossible -> GHC.Types.False } }) -}
60779ee60a7b7b6d291add8ce22569fb
  $fEqMaybeImpossible_$c== ::
    GHC.Classes.Eq a =>
    PhonemeType.MaybeImpossible a
    -> PhonemeType.MaybeImpossible a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dEq :: GHC.Classes.Eq a23
                   ds :: PhonemeType.MaybeImpossible a23
                   ds1 :: PhonemeType.MaybeImpossible a23 ->
                 case ds of wild {
                   PhonemeType.Possible a24
                   -> case ds1 of wild1 {
                        PhonemeType.Possible b1 -> GHC.Classes.== @ a23 $dEq a24 b1
                        PhonemeType.Impossible -> GHC.Types.False }
                   PhonemeType.Impossible
                   -> case ds1 of wild1 {
                        PhonemeType.Possible ipv -> GHC.Types.False
                        PhonemeType.Impossible -> GHC.Types.True } }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEqMaybeImpossible_$c==1 ::
    PhonemeType.Trill -> PhonemeType.Trill -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Trill ds1 :: PhonemeType.Trill ->
                 case ds of wild {
                   PhonemeType.TRILLED
                   -> case ds1 of wild1 {
                        PhonemeType.TRILLED -> GHC.Types.True
                        PhonemeType.NOTTRILLED -> GHC.Types.False }
                   PhonemeType.NOTTRILLED
                   -> case ds1 of wild1 {
                        PhonemeType.TRILLED -> GHC.Types.False
                        PhonemeType.NOTTRILLED -> GHC.Types.True } }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEqMaybeImpossible_$c==2 ::
    PhonemeType.Silibance -> PhonemeType.Silibance -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Silibance ds1 :: PhonemeType.Silibance ->
                 case ds of wild {
                   PhonemeType.SILIBANT
                   -> case ds1 of wild1 {
                        PhonemeType.SILIBANT -> GHC.Types.True
                        PhonemeType.NONSILIBANT -> GHC.Types.False }
                   PhonemeType.NONSILIBANT
                   -> case ds1 of wild1 {
                        PhonemeType.SILIBANT -> GHC.Types.False
                        PhonemeType.NONSILIBANT -> GHC.Types.True } }) -}
16d61d06081f347fd36865d448a9e38e
  $fEqMaybeImpossible_$c==3 ::
    PhonemeType.VOT -> PhonemeType.VOT -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.VOT ds1 :: PhonemeType.VOT ->
                 case ds of wild {
                   PhonemeType.POSITIVE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.POSITIVE -> GHC.Types.True }
                   PhonemeType.ZERO
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.ZERO -> GHC.Types.True }
                   PhonemeType.NEGATIVE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.NEGATIVE -> GHC.Types.True } }) -}
f75d2e440f9f9789e9aa1c7b0fc1b40d
  $fEqMaybeImpossible_$s$c==7 ::
    PhonemeType.MaybeUnspecified PhonemeType.VOT
    -> PhonemeType.MaybeUnspecified PhonemeType.VOT -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.MaybeUnspecified PhonemeType.VOT
                   ds1 :: PhonemeType.MaybeUnspecified PhonemeType.VOT ->
                 case ds of wild {
                   PhonemeType.Specified a23
                   -> case ds1 of wild1 {
                        PhonemeType.Specified b1
                        -> PhonemeType.$fEqMaybeImpossible_$c==3 a23 b1
                        PhonemeType.Unspecified -> GHC.Types.False }
                   PhonemeType.Unspecified
                   -> case ds1 of wild1 {
                        PhonemeType.Specified ipv -> GHC.Types.False
                        PhonemeType.Unspecified -> GHC.Types.True } }) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fEqMaybeUnspecified ::
    GHC.Classes.Eq a => GHC.Classes.Eq (PhonemeType.MaybeUnspecified a)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dEq :: GHC.Classes.Eq a23.
                  @ (PhonemeType.MaybeUnspecified a23)
                  (PhonemeType.$fEqMaybeUnspecified_$c== @ a23 $dEq)
                  (PhonemeType.$fEqMaybeUnspecified_$c/= @ a23 $dEq) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fEqMaybeUnspecified_$c/= ::
    GHC.Classes.Eq a =>
    PhonemeType.MaybeUnspecified a
    -> PhonemeType.MaybeUnspecified a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a23
                   $dEq :: GHC.Classes.Eq a23
                   a24 :: PhonemeType.MaybeUnspecified a23
                   b :: PhonemeType.MaybeUnspecified a23 ->
                 case a24 of wild {
                   PhonemeType.Specified a25
                   -> case b of wild1 {
                        PhonemeType.Specified b1
                        -> case GHC.Classes.== @ a23 $dEq a25 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        PhonemeType.Unspecified -> GHC.Types.True }
                   PhonemeType.Unspecified
                   -> case b of wild1 {
                        PhonemeType.Specified ipv -> GHC.Types.True
                        PhonemeType.Unspecified -> GHC.Types.False } }) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fEqMaybeUnspecified_$c== ::
    GHC.Classes.Eq a =>
    PhonemeType.MaybeUnspecified a
    -> PhonemeType.MaybeUnspecified a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dEq :: GHC.Classes.Eq a23
                   ds :: PhonemeType.MaybeUnspecified a23
                   ds1 :: PhonemeType.MaybeUnspecified a23 ->
                 case ds of wild {
                   PhonemeType.Specified a24
                   -> case ds1 of wild1 {
                        PhonemeType.Specified b1 -> GHC.Classes.== @ a23 $dEq a24 b1
                        PhonemeType.Unspecified -> GHC.Types.False }
                   PhonemeType.Unspecified
                   -> case ds1 of wild1 {
                        PhonemeType.Specified ipv -> GHC.Types.False
                        PhonemeType.Unspecified -> GHC.Types.True } }) -}
95417ac7dbeb758b510442ae50c858cb
  $fEqMaybeUnspecified_$c==1 ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.Place w1 :: PhonemeType.Place ->
                 case w of ww { PhonemeType.Place ww1 ww2 ->
                 case w1 of ww3 { PhonemeType.Place ww4 ww5 ->
                 PhonemeType.$w$c==5 ww1 ww2 ww4 ww5 } }) -}
f45b7454df7117690624094b2e33986b
  $fEqMaybeUnspecified_$c==2 ::
    PhonemeType.Stricture -> PhonemeType.Stricture -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Stricture ds1 :: PhonemeType.Stricture ->
                 case ds of wild {
                   PhonemeType.OCCLUSION
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.OCCLUSION -> GHC.Types.True }
                   PhonemeType.TURBULENT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.TURBULENT -> GHC.Types.True }
                   PhonemeType.SLIGHTTURBULENT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.SLIGHTTURBULENT -> GHC.Types.True } }) -}
1876b99e8b904b79707be731945482ec
  $fEqMaybeUnspecified_$c==3 ::
    PhonemeType.Phonation -> PhonemeType.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: PhonemeType.Phonation
                   ds1 :: PhonemeType.Phonation ->
                 case ds of wild {
                   PhonemeType.VOICELESS
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.VOICELESS -> GHC.Types.True }
                   PhonemeType.BREATHY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.BREATHY -> GHC.Types.True }
                   PhonemeType.SLACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.SLACK -> GHC.Types.True }
                   PhonemeType.MODAL
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.MODAL -> GHC.Types.True }
                   PhonemeType.STIFF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.STIFF -> GHC.Types.True }
                   PhonemeType.CREAKY
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False PhonemeType.CREAKY -> GHC.Types.True }
                   PhonemeType.CLOSURE
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        PhonemeType.CLOSURE -> GHC.Types.True } }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEqMaybeUnspecified_$c==4 ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Roundedness ds1 :: PhonemeType.Roundedness ->
                 case ds of wild {
                   PhonemeType.UNROUNDED
                   -> case ds1 of wild1 {
                        PhonemeType.UNROUNDED -> GHC.Types.True
                        PhonemeType.ROUNDED -> GHC.Types.False }
                   PhonemeType.ROUNDED
                   -> case ds1 of wild1 {
                        PhonemeType.UNROUNDED -> GHC.Types.False
                        PhonemeType.ROUNDED -> GHC.Types.True } }) -}
dcbf3455324a78016700898324489067
  $fEqPassiveArticulator ::
    GHC.Classes.Eq PhonemeType.PassiveArticulator
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PassiveArticulator
                  PhonemeType.$fEqPassiveArticulator_$c==
                  PhonemeType.$fEqPassiveArticulator_$c/= -}
dcbf3455324a78016700898324489067
  $fEqPassiveArticulator_$c/= ::
    PhonemeType.PassiveArticulator
    -> PhonemeType.PassiveArticulator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.PassiveArticulator
                   b :: PhonemeType.PassiveArticulator ->
                 case a23 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x1)
                           (GHC.Prim.dataToTag#
                              @ PhonemeType.PassiveArticulator
                              x2)) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
dcbf3455324a78016700898324489067
  $fEqPassiveArticulator_$c== ::
    PhonemeType.PassiveArticulator
    -> PhonemeType.PassiveArticulator -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.PassiveArticulator
                   b :: PhonemeType.PassiveArticulator ->
                 case a23 of x1 { DEFAULT ->
                 case b of x2 { DEFAULT ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      (GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x1)
                      (GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x2)) } }) -}
1876b99e8b904b79707be731945482ec
  $fEqPhonation :: GHC.Classes.Eq PhonemeType.Phonation
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Phonation
                  PhonemeType.$fEqMaybeUnspecified_$c==3
                  PhonemeType.$fEqPhonation_$c/= -}
1876b99e8b904b79707be731945482ec
  $fEqPhonation_$c/= ::
    PhonemeType.Phonation -> PhonemeType.Phonation -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a23 :: PhonemeType.Phonation
                   b :: PhonemeType.Phonation ->
                 case a23 of wild {
                   PhonemeType.VOICELESS
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.VOICELESS -> GHC.Types.False }
                   PhonemeType.BREATHY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.BREATHY -> GHC.Types.False }
                   PhonemeType.SLACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.SLACK -> GHC.Types.False }
                   PhonemeType.MODAL
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.MODAL -> GHC.Types.False }
                   PhonemeType.STIFF
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.STIFF -> GHC.Types.False }
                   PhonemeType.CREAKY
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.CREAKY -> GHC.Types.False }
                   PhonemeType.CLOSURE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.CLOSURE -> GHC.Types.False } }) -}
d63366b958aa268c953fb9cc54988074
  $fEqPhonemeInventory :: GHC.Classes.Eq PhonemeType.PhonemeInventory
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PhonemeInventory
                  PhonemeType.$fEqPhonemeInventory_$c==
                  PhonemeType.$fEqPhonemeInventory_$c/= -}
d63366b958aa268c953fb9cc54988074
  $fEqPhonemeInventory_$c/= ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.PhonemeInventory
                   b :: PhonemeType.PhonemeInventory ->
                 case a23 of wild { PhonemeType.PhonemeInventory a24 ->
                 case b of wild1 { PhonemeType.PhonemeInventory b1 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PhonemeType.ConsonantFeaturesContour
                        PhonemeType.$fEqConsonantFeaturesContour
                        a24
                        b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } }) -}
d63366b958aa268c953fb9cc54988074
  $fEqPhonemeInventory_$c== ::
    PhonemeType.PhonemeInventory
    -> PhonemeType.PhonemeInventory -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><S(S),1*U(1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.PhonemeInventory
                   ds1 :: PhonemeType.PhonemeInventory ->
                 case ds of wild { PhonemeType.PhonemeInventory a23 ->
                 case ds1 of wild1 { PhonemeType.PhonemeInventory b1 ->
                 GHC.Classes.$fEq[]_$c==
                   @ PhonemeType.ConsonantFeaturesContour
                   PhonemeType.$fEqConsonantFeaturesContour
                   a23
                   b1 } }) -}
95417ac7dbeb758b510442ae50c858cb
  $fEqPlace :: GHC.Classes.Eq PhonemeType.Place
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place
                  PhonemeType.$fEqMaybeUnspecified_$c==1
                  PhonemeType.$fEqPlace_$c/= -}
95417ac7dbeb758b510442ae50c858cb
  $fEqPlace_$c/= ::
    PhonemeType.Place -> PhonemeType.Place -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Place b :: PhonemeType.Place ->
                 case PhonemeType.$fEqMaybeUnspecified_$c==1 a23 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fEqRoundedness :: GHC.Classes.Eq PhonemeType.Roundedness
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fEqMaybeUnspecified_$c==4
                  PhonemeType.$fEqRoundedness_$c/= -}
9c915b50edb2977ec86c27bd6c240a83
  $fEqRoundedness_$c/= ::
    PhonemeType.Roundedness
    -> PhonemeType.Roundedness -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Roundedness b :: PhonemeType.Roundedness ->
                 case a23 of wild {
                   PhonemeType.UNROUNDED
                   -> case b of wild1 {
                        PhonemeType.UNROUNDED -> GHC.Types.False
                        PhonemeType.ROUNDED -> GHC.Types.True }
                   PhonemeType.ROUNDED
                   -> case b of wild1 {
                        PhonemeType.UNROUNDED -> GHC.Types.True
                        PhonemeType.ROUNDED -> GHC.Types.False } }) -}
1940ee84f46a7a0f1801689311b6be65
  $fEqSilibance :: GHC.Classes.Eq PhonemeType.Silibance
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Silibance
                  PhonemeType.$fEqMaybeImpossible_$c==2
                  PhonemeType.$fEqSilibance_$c/= -}
1940ee84f46a7a0f1801689311b6be65
  $fEqSilibance_$c/= ::
    PhonemeType.Silibance -> PhonemeType.Silibance -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Silibance b :: PhonemeType.Silibance ->
                 case a23 of wild {
                   PhonemeType.SILIBANT
                   -> case b of wild1 {
                        PhonemeType.SILIBANT -> GHC.Types.False
                        PhonemeType.NONSILIBANT -> GHC.Types.True }
                   PhonemeType.NONSILIBANT
                   -> case b of wild1 {
                        PhonemeType.SILIBANT -> GHC.Types.True
                        PhonemeType.NONSILIBANT -> GHC.Types.False } }) -}
f45b7454df7117690624094b2e33986b
  $fEqStricture :: GHC.Classes.Eq PhonemeType.Stricture
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Stricture
                  PhonemeType.$fEqMaybeUnspecified_$c==2
                  PhonemeType.$fEqStricture_$c/= -}
f45b7454df7117690624094b2e33986b
  $fEqStricture_$c/= ::
    PhonemeType.Stricture -> PhonemeType.Stricture -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Stricture b :: PhonemeType.Stricture ->
                 case a23 of wild {
                   PhonemeType.OCCLUSION
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.OCCLUSION -> GHC.Types.False }
                   PhonemeType.TURBULENT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.TURBULENT -> GHC.Types.False }
                   PhonemeType.SLIGHTTURBULENT
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.SLIGHTTURBULENT -> GHC.Types.False } }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEqTrill :: GHC.Classes.Eq PhonemeType.Trill
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Trill
                  PhonemeType.$fEqMaybeImpossible_$c==1
                  PhonemeType.$fEqTrill_$c/= -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fEqTrill_$c/= ::
    PhonemeType.Trill -> PhonemeType.Trill -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.Trill b :: PhonemeType.Trill ->
                 case a23 of wild {
                   PhonemeType.TRILLED
                   -> case b of wild1 {
                        PhonemeType.TRILLED -> GHC.Types.False
                        PhonemeType.NOTTRILLED -> GHC.Types.True }
                   PhonemeType.NOTTRILLED
                   -> case b of wild1 {
                        PhonemeType.TRILLED -> GHC.Types.True
                        PhonemeType.NOTTRILLED -> GHC.Types.False } }) -}
16d61d06081f347fd36865d448a9e38e
  $fEqVOT :: GHC.Classes.Eq PhonemeType.VOT
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VOT
                  PhonemeType.$fEqMaybeImpossible_$c==3
                  PhonemeType.$fEqVOT_$c/= -}
16d61d06081f347fd36865d448a9e38e
  $fEqVOT_$c/= ::
    PhonemeType.VOT -> PhonemeType.VOT -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.VOT b :: PhonemeType.VOT ->
                 case a23 of wild {
                   PhonemeType.POSITIVE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.POSITIVE -> GHC.Types.False }
                   PhonemeType.ZERO
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True PhonemeType.ZERO -> GHC.Types.False }
                   PhonemeType.NEGATIVE
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        PhonemeType.NEGATIVE -> GHC.Types.False } }) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fEqVowelFeatures :: GHC.Classes.Eq PhonemeType.VowelFeatures
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VowelFeatures
                  PhonemeType.$fEqMaybeBlank_$c==1
                  PhonemeType.$fEqVowelFeatures_$c/= -}
de5feaa368b0763e13d665742a85ee00
  $fEqVowelFeaturesContour ::
    GHC.Classes.Eq PhonemeType.VowelFeaturesContour
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VowelFeaturesContour
                  PhonemeType.$fEqVowelFeaturesContour_$c==
                  PhonemeType.$fEqVowelFeaturesContour_$c/= -}
de5feaa368b0763e13d665742a85ee00
  $fEqVowelFeaturesContour_$c/= ::
    PhonemeType.VowelFeaturesContour
    -> PhonemeType.VowelFeaturesContour -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLLLLLL)L),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)><S(S(SLLLLLL)L),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.VowelFeaturesContour
                   b :: PhonemeType.VowelFeaturesContour ->
                 case PhonemeType.$fEqVowelFeaturesContour_$c== a23 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
de5feaa368b0763e13d665742a85ee00
  $fEqVowelFeaturesContour_$c== ::
    PhonemeType.VowelFeaturesContour
    -> PhonemeType.VowelFeaturesContour -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLLLLLL)L),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)><S(S(SLLLLLL)L),1*U(1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: PhonemeType.VowelFeaturesContour
                   w1 :: PhonemeType.VowelFeaturesContour ->
                 case w of ww { PhonemeType.VowelFeaturesContour ww1 ww2 ->
                 case ww1 of ww3 { PhonemeType.VowelFeatures ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 case w1 of ww11 { PhonemeType.VowelFeaturesContour ww12 ww13 ->
                 case ww12 of ww14 { PhonemeType.VowelFeatures ww15 ww16 ww17 ww18 ww19 ww20 ww21 ->
                 PhonemeType.$w$c==6
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww2
                   ww15
                   ww16
                   ww17
                   ww18
                   ww19
                   ww20
                   ww21
                   ww13 } } } }) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fEqVowelFeatures_$c/= ::
    PhonemeType.VowelFeatures
    -> PhonemeType.VowelFeatures -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><S(SLLLLLL),1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a23 :: PhonemeType.VowelFeatures
                   b :: PhonemeType.VowelFeatures ->
                 case PhonemeType.$fEqMaybeBlank_$c==1 a23 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator ::
    GHC.Read.Read PhonemeType.ActiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ActiveArticulator
                  PhonemeType.$fReadActiveArticulator_$s$dmreadsPrec
                  PhonemeType.$fReadActiveArticulator_$sreadListDefault
                  PhonemeType.$fReadActiveArticulator_$creadPrec
                  PhonemeType.$fReadActiveArticulator_$creadListPrec -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.ActiveArticulator]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.ActiveArticulator]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.ActiveArticulator
                   PhonemeType.$fReadActiveArticulator2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.ActiveArticulator>_R))
                   @ b
                   eta1) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.ActiveArticulator)
                   PhonemeType.$fReadActiveArticulator11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.ActiveArticulator))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadActiveArticulator13,
                  PhonemeType.$fReadActiveArticulator12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.ActiveArticulator>_R))))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ActiveArticulator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LARYNX) -}
e4cf0ccee80b80b503096c71917f86e4
  $fReadActiveArticulator13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LARYNX"#) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadActiveArticulator16,
                  PhonemeType.$fReadActiveArticulator15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.ActiveArticulator>_R))))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ActiveArticulator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TONGUEROOT) -}
962ebd64d954d6c5e392341372e5d1c9
  $fReadActiveArticulator16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUEROOT"#) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadActiveArticulator19,
                  PhonemeType.$fReadActiveArticulator18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.ActiveArticulator>_R))))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ActiveArticulator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TONGUEBODY) -}
df845eac2a5e38eb28a21eabdfcac8bc
  $fReadActiveArticulator19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUEBODY"#) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.ActiveArticulator
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.ActiveArticulator
                   PhonemeType.$fReadActiveArticulator3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.ActiveArticulator>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.ActiveArticulator>_R)))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadActiveArticulator22,
                  PhonemeType.$fReadActiveArticulator21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.ActiveArticulator>_R))))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ActiveArticulator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TONGUEUNDER) -}
840f8b1b1364fed04e989aee4b71d92d
  $fReadActiveArticulator22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUEUNDER"#) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadActiveArticulator25,
                  PhonemeType.$fReadActiveArticulator24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.ActiveArticulator>_R))))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ActiveArticulator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TONGUETIP) -}
3fe970cc3375bbb7f311771b85b4ca6f
  $fReadActiveArticulator25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUETIP"#) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadActiveArticulator28,
                  PhonemeType.$fReadActiveArticulator27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.ActiveArticulator>_R))))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ActiveArticulator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TONGUEBLADE) -}
c4099fa9825026e8000a3efb39cfcb11
  $fReadActiveArticulator28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TONGUEBLADE"#) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.ActiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadActiveArticulator31,
                  PhonemeType.$fReadActiveArticulator30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.ActiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.ActiveArticulator>_R))))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ActiveArticulator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.ActiveArticulator
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.ActiveArticulator
                   PhonemeType.$fReadActiveArticulator4
                   eta
                   @ b
                   eta1) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ActiveArticulator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.ActiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LOWERLIP) -}
1c3bbb1f7d6280cbbdf41a7795df07f5
  $fReadActiveArticulator31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LOWERLIP"#) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.ActiveArticulator)
                   PhonemeType.$fReadActiveArticulator29
                   PhonemeType.$fReadActiveArticulator5) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.ActiveArticulator)
                   PhonemeType.$fReadActiveArticulator26
                   PhonemeType.$fReadActiveArticulator6) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.ActiveArticulator)
                   PhonemeType.$fReadActiveArticulator23
                   PhonemeType.$fReadActiveArticulator7) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.ActiveArticulator)
                   PhonemeType.$fReadActiveArticulator20
                   PhonemeType.$fReadActiveArticulator8) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.ActiveArticulator)
                   PhonemeType.$fReadActiveArticulator17
                   PhonemeType.$fReadActiveArticulator9) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.ActiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.ActiveArticulator)
                   PhonemeType.$fReadActiveArticulator14
                   PhonemeType.$fReadActiveArticulator10) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.ActiveArticulator]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadActiveArticulator1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.ActiveArticulator]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.ActiveArticulator]>_R))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType.ActiveArticulator
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadActiveArticulator2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.ActiveArticulator>_R)) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.ActiveArticulator
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.ActiveArticulator
                   PhonemeType.$fReadActiveArticulator_$creadPrec
                   eta) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fReadActiveArticulator_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.ActiveArticulator]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.ActiveArticulator]
                   ((PhonemeType.$fReadActiveArticulator_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.ActiveArticulator]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.ActiveArticulator]>_R)
                      @ [PhonemeType.ActiveArticulator]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.ActiveArticulator]))) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape :: GHC.Read.Read PhonemeType.AirEscape
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.AirEscape
                  PhonemeType.$fReadAirEscape_$s$dmreadsPrec
                  PhonemeType.$fReadAirEscape_$sreadListDefault
                  PhonemeType.$fReadAirEscape_$creadPrec
                  PhonemeType.$fReadAirEscape_$creadListPrec -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.AirEscape] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.AirEscape]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.AirEscape
                   PhonemeType.$fReadAirEscape2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.AirEscape>_R))
                   @ b
                   eta1) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.AirEscape -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.AirEscape -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NASALIZED) -}
43da6104ff402b4137cfd4f263e53a6a
  $fReadAirEscape11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NASALIZED"#) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.AirEscape
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.AirEscape
                   PhonemeType.$fReadAirEscape3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.AirEscape>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.AirEscape>_R)))) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.AirEscape -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.AirEscape
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.AirEscape
                   PhonemeType.$fReadAirEscape4
                   eta
                   @ b
                   eta1) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.AirEscape)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.AirEscape)
                   PhonemeType.$fReadAirEscape9
                   PhonemeType.$fReadAirEscape5) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.AirEscape)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.AirEscape)
                   PhonemeType.$fReadAirEscape6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.AirEscape))) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.AirEscape)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadAirEscape8,
                  PhonemeType.$fReadAirEscape7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.AirEscape>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.AirEscape>_R))))) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.AirEscape -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.AirEscape -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.ORAL) -}
69f6ef83f96acdd106771f475fd7d8f4
  $fReadAirEscape8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ORAL"#) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.AirEscape)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadAirEscape11,
                  PhonemeType.$fReadAirEscape10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.AirEscape>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.AirEscape>_R))))) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.AirEscape]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadAirEscape1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.AirEscape]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.AirEscape]>_R))) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.AirEscape
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadAirEscape2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.AirEscape>_R)) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.AirEscape
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.AirEscape
                   PhonemeType.$fReadAirEscape_$creadPrec
                   eta) -}
483edd05f8d1cf327b30114f3225d3b2
  $fReadAirEscape_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.AirEscape]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.AirEscape]
                   ((PhonemeType.$fReadAirEscape_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.AirEscape]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.AirEscape]>_R)
                      @ [PhonemeType.AirEscape]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.AirEscape]))) -}
355bf06edf14b009f06abed2ef70f036
  $fReadAirstream :: GHC.Read.Read PhonemeType.Airstream
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Airstream
                  PhonemeType.$fReadAirstream_$creadsPrec
                  PhonemeType.$fReadAirstream_$sreadListDefault
                  PhonemeType.$fReadAirstream_$creadPrec
                  PhonemeType.$fReadAirstream_$creadListPrec -}
355bf06edf14b009f06abed2ef70f036
  $fReadAirstream1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Airstream] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Airstream]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Airstream
                   PhonemeType.$fReadAirstream2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Airstream>_R))
                   @ b
                   eta1) -}
355bf06edf14b009f06abed2ef70f036
  $fReadAirstream2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Airstream
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Airstream
                   PhonemeType.$fReadAirstream3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Airstream>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Airstream>_R)))) -}
355bf06edf14b009f06abed2ef70f036
  $fReadAirstream3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Airstream -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.Airstream -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 -> PhonemeType.$wa ww1 @ b w1 }) -}
355bf06edf14b009f06abed2ef70f036
  $fReadAirstream_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Airstream]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadAirstream1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Airstream]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Airstream]>_R))) -}
355bf06edf14b009f06abed2ef70f036
  $fReadAirstream_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Airstream
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadAirstream2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Airstream>_R)) -}
355bf06edf14b009f06abed2ef70f036
  $fReadAirstream_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Airstream
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.Airstream
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.Airstream
                       PhonemeType.$fReadAirstream3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.Airstream>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.Airstream>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.Airstream>_R)
                      @ PhonemeType.Airstream
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.Airstream))) -}
355bf06edf14b009f06abed2ef70f036
  $fReadAirstream_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Airstream]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Airstream]
                   ((PhonemeType.$fReadAirstream_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Airstream]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Airstream]>_R)
                      @ [PhonemeType.Airstream]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Airstream]))) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness :: GHC.Read.Read PhonemeType.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fReadBackness_$s$dmreadsPrec
                  PhonemeType.$fReadBackness_$sreadListDefault
                  PhonemeType.$fReadBackness_$creadPrec
                  PhonemeType.$fReadBackness_$creadListPrec -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Backness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Backness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Backness
                   PhonemeType.$fReadBackness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Backness>_R))
                   @ b
                   eta1) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.FRONT) -}
cbb92117ea01670e855a38cdd2c16dc4
  $fReadBackness11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FRONT"#) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness12 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness14,
                  PhonemeType.$fReadBackness13
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness13 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEARFRONT) -}
6f7b7020589dcda776565ba96fb3d4a2
  $fReadBackness14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARFRONT"#) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness15 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness17,
                  PhonemeType.$fReadBackness16
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness16 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.CENTRAL) -}
9bf975caba1c1b020ee1f927c335c3d0
  $fReadBackness17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CENTRAL"#) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness18 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness20,
                  PhonemeType.$fReadBackness19
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEARBACK) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Backness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Backness
                   PhonemeType.$fReadBackness3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Backness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Backness>_R)))) -}
f9300b8fb3623eaeeac94153168f0531
  $fReadBackness20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARBACK"#) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness21 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness23,
                  PhonemeType.$fReadBackness22
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.BACK) -}
a5809bebe5586a85036c16370741a88c
  $fReadBackness23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACK"#) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Backness -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Backness
                   PhonemeType.$fReadBackness4
                   eta
                   @ b
                   eta1) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness21
                   PhonemeType.$fReadBackness5) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness18
                   PhonemeType.$fReadBackness6) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness15
                   PhonemeType.$fReadBackness7) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness12
                   PhonemeType.$fReadBackness8) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
                   PhonemeType.$fReadBackness9
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness))) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadBackness11,
                  PhonemeType.$fReadBackness10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Backness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Backness>_R))))) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Backness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadBackness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Backness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Backness]>_R))) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Backness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadBackness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Backness>_R)) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Backness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Backness
                   PhonemeType.$fReadBackness_$creadPrec
                   eta) -}
4600283dc79ec1a04339fecb849d3137
  $fReadBackness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Backness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Backness]
                   ((PhonemeType.$fReadBackness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Backness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Backness]>_R)
                      @ [PhonemeType.Backness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Backness]))) -}
62312b673b3cb46a867844b1181e8c1b
  $fReadConsonantFeatures ::
    GHC.Read.Read PhonemeType.ConsonantFeatures
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ConsonantFeatures
                  PhonemeType.$fReadConsonantFeatures_$creadsPrec
                  PhonemeType.$fReadConsonantFeatures_$sreadListDefault
                  PhonemeType.$fReadConsonantFeatures_$creadPrec
                  PhonemeType.$fReadConsonantFeatures_$creadListPrec -}
62312b673b3cb46a867844b1181e8c1b
  $fReadConsonantFeatures1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.ConsonantFeatures]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.ConsonantFeatures]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.ConsonantFeatures
                   PhonemeType.$fReadConsonantFeatures2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.ConsonantFeatures>_R))
                   @ b
                   eta1) -}
62312b673b3cb46a867844b1181e8c1b
  $fReadConsonantFeatures2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.ConsonantFeatures
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.ConsonantFeatures
                   PhonemeType.$fReadConsonantFeatures3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.ConsonantFeatures>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.ConsonantFeatures>_R)))) -}
62312b673b3cb46a867844b1181e8c1b
  $fReadConsonantFeatures3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ConsonantFeatures -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.ConsonantFeatures
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$wa1 ww1 @ b w1 }) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fReadConsonantFeaturesContour ::
    GHC.Read.Read PhonemeType.ConsonantFeaturesContour
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ConsonantFeaturesContour
                  PhonemeType.$fReadConsonantFeaturesContour_$creadsPrec
                  PhonemeType.$fReadConsonantFeaturesContour_$sreadListDefault
                  PhonemeType.$fReadConsonantFeaturesContour_$creadPrec
                  PhonemeType.$fReadConsonantFeaturesContour_$creadListPrec -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fReadConsonantFeaturesContour1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.ConsonantFeaturesContour]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.ConsonantFeaturesContour]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.ConsonantFeaturesContour
                   PhonemeType.$fReadConsonantFeaturesContour2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.ConsonantFeaturesContour>_R))
                   @ b
                   eta1) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fReadConsonantFeaturesContour2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         PhonemeType.ConsonantFeaturesContour
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.ConsonantFeaturesContour
                   PhonemeType.$fReadConsonantFeaturesContour3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.ConsonantFeaturesContour>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.ConsonantFeaturesContour>_R)))) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fReadConsonantFeaturesContour3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.ConsonantFeaturesContour
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.ConsonantFeaturesContour
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$wa2 ww1 @ b w1 }) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fReadConsonantFeaturesContour_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.ConsonantFeaturesContour]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadConsonantFeaturesContour1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.ConsonantFeaturesContour]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.ConsonantFeaturesContour]>_R))) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fReadConsonantFeaturesContour_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType.ConsonantFeaturesContour
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadConsonantFeaturesContour2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.ConsonantFeaturesContour>_R)) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fReadConsonantFeaturesContour_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         PhonemeType.ConsonantFeaturesContour
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.ConsonantFeaturesContour
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.ConsonantFeaturesContour
                       PhonemeType.$fReadConsonantFeaturesContour3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.ConsonantFeaturesContour>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.ConsonantFeaturesContour>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.ConsonantFeaturesContour>_R)
                      @ PhonemeType.ConsonantFeaturesContour
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.ConsonantFeaturesContour))) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fReadConsonantFeaturesContour_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType.ConsonantFeaturesContour]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.ConsonantFeaturesContour]
                   ((PhonemeType.$fReadConsonantFeaturesContour_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.ConsonantFeaturesContour]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.ConsonantFeaturesContour]>_R)
                      @ [PhonemeType.ConsonantFeaturesContour]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.ConsonantFeaturesContour]))) -}
62312b673b3cb46a867844b1181e8c1b
  $fReadConsonantFeatures_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.ConsonantFeatures]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadConsonantFeatures1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.ConsonantFeatures]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.ConsonantFeatures]>_R))) -}
62312b673b3cb46a867844b1181e8c1b
  $fReadConsonantFeatures_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType.ConsonantFeatures
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadConsonantFeatures2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.ConsonantFeatures>_R)) -}
62312b673b3cb46a867844b1181e8c1b
  $fReadConsonantFeatures_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.ConsonantFeatures
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.ConsonantFeatures
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.ConsonantFeatures
                       PhonemeType.$fReadConsonantFeatures3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.ConsonantFeatures>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.ConsonantFeatures>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.ConsonantFeatures>_R)
                      @ PhonemeType.ConsonantFeatures
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.ConsonantFeatures))) -}
62312b673b3cb46a867844b1181e8c1b
  $fReadConsonantFeatures_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.ConsonantFeatures]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.ConsonantFeatures]
                   ((PhonemeType.$fReadConsonantFeatures_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.ConsonantFeatures]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.ConsonantFeatures]>_R)
                      @ [PhonemeType.ConsonantFeatures]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.ConsonantFeatures]))) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection :: GHC.Read.Read PhonemeType.Direction
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Direction
                  PhonemeType.$fReadDirection_$s$dmreadsPrec
                  PhonemeType.$fReadDirection_$sreadListDefault
                  PhonemeType.$fReadDirection_$creadPrec
                  PhonemeType.$fReadDirection_$creadListPrec -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Direction] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Direction]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Direction
                   PhonemeType.$fReadDirection2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Direction>_R))
                   @ b
                   eta1) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Direction -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Direction -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.INGRESSIVE) -}
4afc127ae9f11e5042b05fedafc06d84
  $fReadDirection11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "INGRESSIVE"#) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Direction
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Direction
                   PhonemeType.$fReadDirection3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Direction>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Direction>_R)))) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Direction -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Direction
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Direction
                   PhonemeType.$fReadDirection4
                   eta
                   @ b
                   eta1) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Direction)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Direction)
                   PhonemeType.$fReadDirection9
                   PhonemeType.$fReadDirection5) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Direction)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Direction)
                   PhonemeType.$fReadDirection6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.Direction))) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Direction)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadDirection8,
                  PhonemeType.$fReadDirection7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Direction>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Direction>_R))))) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Direction -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Direction -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.EGRESSIVE) -}
8ecf85f53076a6d0986c091aa167fd50
  $fReadDirection8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EGRESSIVE"#) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Direction)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadDirection11,
                  PhonemeType.$fReadDirection10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Direction>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Direction>_R))))) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Direction]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadDirection1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Direction]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Direction]>_R))) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Direction
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadDirection2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Direction>_R)) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Direction
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Direction
                   PhonemeType.$fReadDirection_$creadPrec
                   eta) -}
40a9c5f987e37783909145cb5997138e
  $fReadDirection_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Direction]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Direction]
                   ((PhonemeType.$fReadDirection_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Direction]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Direction]>_R)
                      @ [PhonemeType.Direction]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Direction]))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight :: GHC.Read.Read PhonemeType.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fReadHeight_$s$dmreadsPrec
                  PhonemeType.$fReadHeight_$sreadListDefault
                  PhonemeType.$fReadHeight_$creadPrec
                  PhonemeType.$fReadHeight_$creadListPrec -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Height] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Height] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Height
                   PhonemeType.$fReadHeight2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Height>_R))
                   @ b
                   eta1) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight13,
                  PhonemeType.$fReadHeight12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.OPEN) -}
89e144289b565d24d3a998e82414eaf8
  $fReadHeight13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPEN"#) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight16,
                  PhonemeType.$fReadHeight15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEAROPEN) -}
bf14e80bc4e7050d3b672513ceeb447f
  $fReadHeight16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEAROPEN"#) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight19,
                  PhonemeType.$fReadHeight18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.OPENMID) -}
54d5244143cdbc38ff6721a509725900
  $fReadHeight19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OPENMID"#) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Height
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Height
                   PhonemeType.$fReadHeight3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Height>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Height>_R)))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight22,
                  PhonemeType.$fReadHeight21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.MID) -}
367273a2ca7a72ba5518e845bf938416
  $fReadHeight22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MID"#) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight23 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight25,
                  PhonemeType.$fReadHeight24
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight24 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.CLOSEMID) -}
c314a2aace0467331d1ae3a97cb7d30e
  $fReadHeight25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSEMID"#) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight28,
                  PhonemeType.$fReadHeight27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEARCLOSE) -}
b543847d2f41f4b9d9cc414b0a747cf4
  $fReadHeight28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEARCLOSE"#) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadHeight31,
                  PhonemeType.$fReadHeight30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Height>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Height>_R))))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Height
                   PhonemeType.$fReadHeight4
                   eta
                   @ b
                   eta1) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Height -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Height -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.CLOSE) -}
90c15978f2d25a5cbfc7ef87078b4b87
  $fReadHeight31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSE"#) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight29
                   PhonemeType.$fReadHeight5) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight26
                   PhonemeType.$fReadHeight6) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight23
                   PhonemeType.$fReadHeight7) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight7 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight20
                   PhonemeType.$fReadHeight8) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight8 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight17
                   PhonemeType.$fReadHeight9) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height)
                   PhonemeType.$fReadHeight14
                   PhonemeType.$fReadHeight10) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Height]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadHeight1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Height]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Height]>_R))) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Height
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadHeight2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Height>_R)) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Height
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Height
                   PhonemeType.$fReadHeight_$creadPrec
                   eta) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fReadHeight_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Height]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Height]
                   ((PhonemeType.$fReadHeight_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Height]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Height]>_R)
                      @ [PhonemeType.Height]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Height]))) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator :: GHC.Read.Read PhonemeType.Initiator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Initiator
                  PhonemeType.$fReadInitiator_$s$dmreadsPrec
                  PhonemeType.$fReadInitiator_$sreadListDefault
                  PhonemeType.$fReadInitiator_$creadPrec
                  PhonemeType.$fReadInitiator_$creadListPrec -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Initiator] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Initiator]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Initiator
                   PhonemeType.$fReadInitiator2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Initiator>_R))
                   @ b
                   eta1) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadInitiator12,
                  PhonemeType.$fReadInitiator11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Initiator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Initiator>_R))))) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Initiator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Initiator -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.GLOTTIC) -}
e456eee7295dd2e630e40921677b9243
  $fReadInitiator12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTIC"#) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadInitiator15,
                  PhonemeType.$fReadInitiator14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Initiator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Initiator>_R))))) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Initiator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Initiator -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LINGUAL) -}
a8c4a1992dde7ee3765ad5c36fa1b374
  $fReadInitiator15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LINGUAL"#) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Initiator
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Initiator
                   PhonemeType.$fReadInitiator3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Initiator>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Initiator>_R)))) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Initiator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Initiator
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Initiator
                   PhonemeType.$fReadInitiator4
                   eta
                   @ b
                   eta1) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)
                   PhonemeType.$fReadInitiator13
                   PhonemeType.$fReadInitiator5) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)
                   PhonemeType.$fReadInitiator10
                   PhonemeType.$fReadInitiator6) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)
                   PhonemeType.$fReadInitiator7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.Initiator))) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadInitiator9,
                  PhonemeType.$fReadInitiator8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Initiator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Initiator>_R))))) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Initiator -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Initiator -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.PULMONIC) -}
ccd35244213d843099c3bab334fdd6c4
  $fReadInitiator9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PULMONIC"#) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Initiator]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadInitiator1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Initiator]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Initiator]>_R))) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Initiator
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadInitiator2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Initiator>_R)) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Initiator
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Initiator
                   PhonemeType.$fReadInitiator_$creadPrec
                   eta) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fReadInitiator_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Initiator]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Initiator]
                   ((PhonemeType.$fReadInitiator_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Initiator]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Initiator]>_R)
                      @ [PhonemeType.Initiator]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Initiator]))) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality :: GHC.Read.Read PhonemeType.Laterality
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Laterality
                  PhonemeType.$fReadLaterality_$s$dmreadsPrec
                  PhonemeType.$fReadLaterality_$sreadListDefault
                  PhonemeType.$fReadLaterality_$creadPrec
                  PhonemeType.$fReadLaterality_$creadListPrec -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Laterality] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Laterality]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Laterality
                   PhonemeType.$fReadLaterality2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Laterality>_R))
                   @ b
                   eta1) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality10 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Laterality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Laterality
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LATERAL) -}
cfb2b657527f09ed203a9d23df050a95
  $fReadLaterality11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LATERAL"#) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Laterality
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Laterality
                   PhonemeType.$fReadLaterality3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Laterality>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Laterality>_R)))) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Laterality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Laterality
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Laterality
                   PhonemeType.$fReadLaterality4
                   eta
                   @ b
                   eta1) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Laterality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Laterality)
                   PhonemeType.$fReadLaterality9
                   PhonemeType.$fReadLaterality5) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Laterality)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Laterality)
                   PhonemeType.$fReadLaterality6
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.Laterality))) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality6 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Laterality)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadLaterality8,
                  PhonemeType.$fReadLaterality7
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Laterality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Laterality>_R))))) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Laterality -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Laterality
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NONLATERAL) -}
10f8cadc785ea735e52a12db9013629f
  $fReadLaterality8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NONLATERAL"#) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality9 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Laterality)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadLaterality11,
                  PhonemeType.$fReadLaterality10
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Laterality>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Laterality>_R))))) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Laterality]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadLaterality1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Laterality]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Laterality]>_R))) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Laterality
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadLaterality2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Laterality>_R)) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Laterality
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Laterality
                   PhonemeType.$fReadLaterality_$creadPrec
                   eta) -}
563547f95f31ce703bd3964698c86217
  $fReadLaterality_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Laterality]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Laterality]
                   ((PhonemeType.$fReadLaterality_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Laterality]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Laterality]>_R)
                      @ [PhonemeType.Laterality]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Laterality]))) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength :: GHC.Read.Read PhonemeType.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Length
                  PhonemeType.$fReadLength_$s$dmreadsPrec
                  PhonemeType.$fReadLength_$sreadListDefault
                  PhonemeType.$fReadLength_$creadPrec
                  PhonemeType.$fReadLength_$creadListPrec -}
355f724f9de26105f3758df52d82fae4
  $fReadLength1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Length] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Length] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Length
                   PhonemeType.$fReadLength2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Length>_R))
                   @ b
                   eta1) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength10 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadLength12,
                  PhonemeType.$fReadLength11
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Length>_R))))) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength11 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NORMAL) -}
f2f52f8461bff95b27299cd57a3bb339
  $fReadLength12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NORMAL"#) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength13 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadLength15,
                  PhonemeType.$fReadLength14
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Length>_R))))) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength14 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.SHORT) -}
015a0e3716310d3278cb6980ca384dfe
  $fReadLength15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SHORT"#) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Length
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Length
                   PhonemeType.$fReadLength3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Length>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Length>_R)))) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Length -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Length
                   PhonemeType.$fReadLength4
                   eta
                   @ b
                   eta1) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength4 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)
                   PhonemeType.$fReadLength13
                   PhonemeType.$fReadLength5) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength5 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)
                   PhonemeType.$fReadLength10
                   PhonemeType.$fReadLength6) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength6 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)
                   PhonemeType.$fReadLength7
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length))) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength7 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadLength9,
                  PhonemeType.$fReadLength8
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Length>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Length>_R))))) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Length -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Length -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.LONG) -}
865511754302a7d4d9691f62f98eef9a
  $fReadLength9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LONG"#) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Length]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadLength1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Length]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Length]>_R))) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Length
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadLength2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Length>_R)) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Length
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Length
                   PhonemeType.$fReadLength_$creadPrec
                   eta) -}
355f724f9de26105f3758df52d82fae4
  $fReadLength_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Length]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Length]
                   ((PhonemeType.$fReadLength_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Length]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Length]>_R)
                      @ [PhonemeType.Length]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Length]))) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fReadManner :: GHC.Read.Read PhonemeType.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner
                  PhonemeType.$fReadManner_$creadsPrec
                  PhonemeType.$fReadManner_$sreadListDefault
                  PhonemeType.$fReadManner_$creadPrec
                  PhonemeType.$fReadManner_$creadListPrec -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fReadManner1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Manner] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Manner] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Manner
                   PhonemeType.$fReadManner2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Manner>_R))
                   @ b
                   eta1) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fReadManner2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Manner
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Manner
                   PhonemeType.$fReadManner3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Manner>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Manner>_R)))) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fReadManner3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$wa3 ww1 @ b w1 }) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fReadManner_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Manner]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadManner1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Manner]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Manner]>_R))) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fReadManner_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Manner
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadManner2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Manner>_R)) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fReadManner_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Manner
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.Manner
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.Manner
                       PhonemeType.$fReadManner3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.Manner>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.Manner>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <PhonemeType.Manner>_R)
                      @ PhonemeType.Manner
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.Manner))) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fReadManner_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Manner]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Manner]
                   ((PhonemeType.$fReadManner_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Manner]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Manner]>_R)
                      @ [PhonemeType.Manner]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Manner]))) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fReadMaybeBlank ::
    GHC.Read.Read a => GHC.Read.Read (PhonemeType.MaybeBlank a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dRead2 :: GHC.Read.Read a23.
                  @ (PhonemeType.MaybeBlank a23)
                  (PhonemeType.$fReadMaybeBlank_$creadsPrec @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeBlank_$creadList @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeBlank_$creadPrec @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeBlank_$creadListPrec @ a23 $dRead2) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fReadMaybeBlank1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.MaybeBlank a] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dRead2 :: GHC.Read.Read a23
                   eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.MaybeBlank a23]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (PhonemeType.MaybeBlank a23)
                   (PhonemeType.$fReadMaybeBlank2 @ a23 $dRead2)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.MaybeBlank a23>_R))
                   @ b
                   eta1) -}
64bccfa95c34e6a1a9b110095397a132
  $fReadMaybeBlank10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Unspecified"#) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fReadMaybeBlank2 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP (PhonemeType.MaybeBlank a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: (\ @ a23
                   $dRead2 :: GHC.Read.Read a23
                   eta :: Text.ParserCombinators.ReadPrec.Prec ->
                 GHC.Read.$fReadDouble10
                   @ (PhonemeType.MaybeBlank a23)
                   (let {
                      ds :: Text.ParserCombinators.ReadPrec.ReadPrec a23
                      = GHC.Read.readPrec @ a23 $dRead2
                    } in
                    (\ n :: Text.ParserCombinators.ReadPrec.Prec
                       @ b
                       eta1 :: PhonemeType.MaybeBlank a23
                               -> Text.ParserCombinators.ReadP.P b ->
                     let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = let {
                           lvl131 :: Text.ParserCombinators.ReadP.P b
                           = eta1 (PhonemeType.Blank @ a23)
                         } in
                         Text.Read.Lex.expect2
                           @ b
                           (\ a98 :: Text.Read.Lex.Lexeme ->
                            case a98 of wild {
                              DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                              Text.Read.Lex.Ident a24
                              -> case GHC.Base.eqString
                                        a24
                                        PhonemeType.$fReadMaybeBlank5 of wild1 {
                                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                   GHC.Types.True -> lvl131 } })
                     } in
                     let {
                       k :: () -> Text.ParserCombinators.ReadP.P b
                         {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                            Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl130) -}
                       = \ w2 :: () -> lvl130
                     } in
                     Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                       @ b
                       (Text.ParserCombinators.ReadP.Look
                          @ b
                          (\ a98 :: GHC.Base.String ->
                           (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                             `cast`
                           (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                             @ b
                             k))
                       (case n of wild { GHC.Types.I# x ->
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<=# x 10) of wild2 {
                          GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                          GHC.Types.True
                          -> let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = let {
                                   lvl132 :: Text.ParserCombinators.ReadP.P b
                                   = (ds
                                        `cast`
                                      (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0] <a23>_R)
                                        PhonemeType.$fReadMaybeBlank4)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <a23>_R)
                                       @ b
                                       (\ a24 :: a23 -> eta1 (PhonemeType.Filled @ a23 a24))
                                 } in
                                 Text.Read.Lex.expect2
                                   @ b
                                   (\ a98 :: Text.Read.Lex.Lexeme ->
                                    case a98 of wild1 {
                                      DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                      Text.Read.Lex.Ident a24
                                      -> case GHC.Base.eqString
                                                a24
                                                PhonemeType.$fReadMaybeBlank3 of wild3 {
                                           GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                           GHC.Types.True -> lvl132 } })
                             } in
                             let {
                               k1 :: () -> Text.ParserCombinators.ReadP.P b
                                 {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                    Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl131) -}
                               = \ w2 :: () -> lvl131
                             } in
                             Text.ParserCombinators.ReadP.Look
                               @ b
                               (\ a98 :: GHC.Base.String ->
                                (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                                  `cast`
                                (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                                  @ b
                                  k1) } }))
                      `cast`
                    (Trans
                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                        <PhonemeType.MaybeBlank a23>_R))
                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                   <PhonemeType.MaybeBlank a23>_R))))
                   eta) -}
33f246c517c62962dce97ce3b5bada6e
  $fReadMaybeBlank3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Filled"#) -}
ca910d9377f08c1f14fe06395ced7b73
  $fReadMaybeBlank4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11) -}
df21ec766c8f8d13a761e5fe489a8efe
  $fReadMaybeBlank5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Blank"#) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fReadMaybeBlank8 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (PhonemeType.MaybeUnspecified a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: (\ @ a23
                   $dRead2 :: GHC.Read.Read a23
                   eta :: Text.ParserCombinators.ReadPrec.Prec ->
                 GHC.Read.$fReadDouble10
                   @ (PhonemeType.MaybeUnspecified a23)
                   (let {
                      ds :: Text.ParserCombinators.ReadPrec.ReadPrec a23
                      = GHC.Read.readPrec @ a23 $dRead2
                    } in
                    (\ n :: Text.ParserCombinators.ReadPrec.Prec
                       @ b
                       eta1 :: PhonemeType.MaybeUnspecified a23
                               -> Text.ParserCombinators.ReadP.P b ->
                     let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = let {
                           lvl131 :: Text.ParserCombinators.ReadP.P b
                           = eta1 (PhonemeType.Unspecified @ a23)
                         } in
                         Text.Read.Lex.expect2
                           @ b
                           (\ a98 :: Text.Read.Lex.Lexeme ->
                            case a98 of wild {
                              DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                              Text.Read.Lex.Ident a24
                              -> case GHC.Base.eqString
                                        a24
                                        PhonemeType.$fReadMaybeBlank10 of wild1 {
                                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                   GHC.Types.True -> lvl131 } })
                     } in
                     let {
                       k :: () -> Text.ParserCombinators.ReadP.P b
                         {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                            Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl130) -}
                       = \ w2 :: () -> lvl130
                     } in
                     Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                       @ b
                       (Text.ParserCombinators.ReadP.Look
                          @ b
                          (\ a98 :: GHC.Base.String ->
                           (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                             `cast`
                           (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                             @ b
                             k))
                       (case n of wild { GHC.Types.I# x ->
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<=# x 10) of wild2 {
                          GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                          GHC.Types.True
                          -> let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = let {
                                   lvl132 :: Text.ParserCombinators.ReadP.P b
                                   = (ds
                                        `cast`
                                      (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0] <a23>_R)
                                        PhonemeType.$fReadMaybeBlank4)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <a23>_R)
                                       @ b
                                       (\ a24 :: a23 -> eta1 (PhonemeType.Specified @ a23 a24))
                                 } in
                                 Text.Read.Lex.expect2
                                   @ b
                                   (\ a98 :: Text.Read.Lex.Lexeme ->
                                    case a98 of wild1 {
                                      DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                      Text.Read.Lex.Ident a24
                                      -> case GHC.Base.eqString
                                                a24
                                                PhonemeType.$fReadMaybeBlank9 of wild3 {
                                           GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                           GHC.Types.True -> lvl132 } })
                             } in
                             let {
                               k1 :: () -> Text.ParserCombinators.ReadP.P b
                                 {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                    Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl131) -}
                               = \ w2 :: () -> lvl131
                             } in
                             Text.ParserCombinators.ReadP.Look
                               @ b
                               (\ a98 :: GHC.Base.String ->
                                (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                                  `cast`
                                (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                                  @ b
                                  k1) } }))
                      `cast`
                    (Trans
                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                        <PhonemeType.MaybeUnspecified a23>_R))
                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                   <PhonemeType.MaybeUnspecified a23>_R))))
                   eta) -}
6e8c80c80a999f5b62d43a022f61889a
  $fReadMaybeBlank9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Specified"#) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fReadMaybeBlank_$creadList ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.MaybeBlank a]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a23 $dRead2 :: GHC.Read.Read a23 ->
                 Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.MaybeBlank a23]
                   (GHC.Read.$wa
                      @ (PhonemeType.MaybeBlank a23)
                      (PhonemeType.$fReadMaybeBlank2 @ a23 $dRead2)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                <PhonemeType.MaybeBlank a23>_R))
                      @ [PhonemeType.MaybeBlank a23]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.MaybeBlank a23]))) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fReadMaybeBlank_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.MaybeBlank a]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeBlank1
                  `cast`
                (forall a23.
                 <GHC.Read.Read a23>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                         <[PhonemeType.MaybeBlank a23]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                    <[PhonemeType.MaybeBlank a23]>_R))) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fReadMaybeBlank_$creadPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec (PhonemeType.MaybeBlank a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeBlank2
                  `cast`
                (forall a23.
                 <GHC.Read.Read a23>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <PhonemeType.MaybeBlank a23>_R)) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fReadMaybeBlank_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS (PhonemeType.MaybeBlank a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a23 $dRead2 :: GHC.Read.Read a23 eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType.MaybeBlank a23)
                   ((PhonemeType.$fReadMaybeBlank2 @ a23 $dRead2 eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.MaybeBlank a23>_R)
                      @ (PhonemeType.MaybeBlank a23)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType.MaybeBlank a23)))) -}
60779ee60a7b7b6d291add8ce22569fb
  $fReadMaybeImpossible ::
    GHC.Read.Read a => GHC.Read.Read (PhonemeType.MaybeImpossible a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dRead2 :: GHC.Read.Read a23.
                  @ (PhonemeType.MaybeImpossible a23)
                  (PhonemeType.$fReadMaybeImpossible_$creadsPrec @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeImpossible_$creadList @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeImpossible_$creadPrec @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeImpossible_$creadListPrec @ a23 $dRead2) -}
60779ee60a7b7b6d291add8ce22569fb
  $fReadMaybeImpossible1 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.MaybeImpossible a]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dRead2 :: GHC.Read.Read a23
                   eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.MaybeImpossible a23]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (PhonemeType.MaybeImpossible a23)
                   (PhonemeType.$fReadMaybeImpossible2 @ a23 $dRead2)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.MaybeImpossible a23>_R))
                   @ b
                   eta1) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadMaybeImpossible10 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Trill)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Trill)
                   PhonemeType.$fReadMaybeImpossible11
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Trill))) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadMaybeImpossible11 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Trill)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeImpossible13,
                  PhonemeType.$fReadMaybeImpossible12
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Trill>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Trill>_R))))) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadMaybeImpossible12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Trill -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Trill -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NOTTRILLED) -}
fb1483f5f8bb0bb5f77ccd8dad0c4a07
  $fReadMaybeImpossible13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NOTTRILLED"#) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadMaybeImpossible14 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Trill)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeImpossible16,
                  PhonemeType.$fReadMaybeImpossible15
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Trill>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Trill>_R))))) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadMaybeImpossible15 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Trill -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Trill -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TRILLED) -}
00ee05272c426a6a3dc45a9a4d58230b
  $fReadMaybeImpossible16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TRILLED"#) -}
2a877e1d2b3ff370aff49b6cdaf01d9b
  $fReadMaybeImpossible19 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.MaybeUnspecified PhonemeType.Laterality
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ n :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.MaybeUnspecified PhonemeType.Laterality
                          -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   lvl130 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl131 :: Text.ParserCombinators.ReadP.P b
                       = eta (PhonemeType.Unspecified @ PhonemeType.Laterality)
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ a98 :: Text.Read.Lex.Lexeme ->
                        case a98 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a23
                          -> case GHC.Base.eqString
                                    a23
                                    PhonemeType.$fReadMaybeBlank10 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl131 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl130) -}
                   = \ w2 :: () -> lvl130
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ a98 :: GHC.Base.String ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                         `cast`
                       (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl131 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl132 :: Text.ParserCombinators.ReadP.P b
                               = (GHC.Read.$fReadDouble10
                                    @ PhonemeType.Laterality
                                    PhonemeType.$fReadLaterality3
                                      `cast`
                                    (Trans
                                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                        <PhonemeType.Laterality>_R))
                                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                   <PhonemeType.Laterality>_R)))
                                    PhonemeType.$fReadMaybeBlank4)
                                   `cast`
                                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Laterality>_R)
                                   @ b
                                   (\ a23 :: PhonemeType.Laterality ->
                                    eta (PhonemeType.Specified @ PhonemeType.Laterality a23))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ a98 :: Text.Read.Lex.Lexeme ->
                                case a98 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a23
                                  -> case GHC.Base.eqString
                                            a23
                                            PhonemeType.$fReadMaybeBlank9 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl132 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl131) -}
                           = \ w2 :: () -> lvl131
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
60779ee60a7b7b6d291add8ce22569fb
  $fReadMaybeImpossible2 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (PhonemeType.MaybeImpossible a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: (\ @ a23
                   $dRead2 :: GHC.Read.Read a23
                   eta :: Text.ParserCombinators.ReadPrec.Prec ->
                 GHC.Read.$fReadDouble10
                   @ (PhonemeType.MaybeImpossible a23)
                   (let {
                      ds :: Text.ParserCombinators.ReadPrec.ReadPrec a23
                      = GHC.Read.readPrec @ a23 $dRead2
                    } in
                    (\ n :: Text.ParserCombinators.ReadPrec.Prec
                       @ b
                       eta1 :: PhonemeType.MaybeImpossible a23
                               -> Text.ParserCombinators.ReadP.P b ->
                     let {
                       lvl130 :: Text.ParserCombinators.ReadP.P b
                       = let {
                           lvl131 :: Text.ParserCombinators.ReadP.P b
                           = eta1 (PhonemeType.Impossible @ a23)
                         } in
                         Text.Read.Lex.expect2
                           @ b
                           (\ a98 :: Text.Read.Lex.Lexeme ->
                            case a98 of wild {
                              DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                              Text.Read.Lex.Ident a24
                              -> case GHC.Base.eqString
                                        a24
                                        PhonemeType.$fReadMaybeImpossible4 of wild1 {
                                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                   GHC.Types.True -> lvl131 } })
                     } in
                     let {
                       k :: () -> Text.ParserCombinators.ReadP.P b
                         {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                            Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl130) -}
                       = \ w2 :: () -> lvl130
                     } in
                     Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                       @ b
                       (Text.ParserCombinators.ReadP.Look
                          @ b
                          (\ a98 :: GHC.Base.String ->
                           (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                             `cast`
                           (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                             @ b
                             k))
                       (case n of wild { GHC.Types.I# x ->
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<=# x 10) of wild2 {
                          GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                          GHC.Types.True
                          -> let {
                               lvl131 :: Text.ParserCombinators.ReadP.P b
                               = let {
                                   lvl132 :: Text.ParserCombinators.ReadP.P b
                                   = (ds
                                        `cast`
                                      (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0] <a23>_R)
                                        PhonemeType.$fReadMaybeBlank4)
                                       `cast`
                                     (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <a23>_R)
                                       @ b
                                       (\ a24 :: a23 -> eta1 (PhonemeType.Possible @ a23 a24))
                                 } in
                                 Text.Read.Lex.expect2
                                   @ b
                                   (\ a98 :: Text.Read.Lex.Lexeme ->
                                    case a98 of wild1 {
                                      DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                      Text.Read.Lex.Ident a24
                                      -> case GHC.Base.eqString
                                                a24
                                                PhonemeType.$fReadMaybeImpossible3 of wild3 {
                                           GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                           GHC.Types.True -> lvl132 } })
                             } in
                             let {
                               k1 :: () -> Text.ParserCombinators.ReadP.P b
                                 {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                    Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl131) -}
                               = \ w2 :: () -> lvl131
                             } in
                             Text.ParserCombinators.ReadP.Look
                               @ b
                               (\ a98 :: GHC.Base.String ->
                                (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                                  `cast`
                                (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                                  @ b
                                  k1) } }))
                      `cast`
                    (Trans
                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                        <PhonemeType.MaybeImpossible a23>_R))
                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                   <PhonemeType.MaybeImpossible a23>_R))))
                   eta) -}
81eda8bb836691fd2358a7d452d2266d
  $fReadMaybeImpossible22 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.MaybeUnspecified PhonemeType.Silibance
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ n :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.MaybeUnspecified PhonemeType.Silibance
                          -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   lvl130 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl131 :: Text.ParserCombinators.ReadP.P b
                       = eta (PhonemeType.Unspecified @ PhonemeType.Silibance)
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ a98 :: Text.Read.Lex.Lexeme ->
                        case a98 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a23
                          -> case GHC.Base.eqString
                                    a23
                                    PhonemeType.$fReadMaybeBlank10 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl131 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl130) -}
                   = \ w2 :: () -> lvl130
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ a98 :: GHC.Base.String ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                         `cast`
                       (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl131 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl132 :: Text.ParserCombinators.ReadP.P b
                               = (GHC.Read.$fReadDouble10
                                    @ PhonemeType.Silibance
                                    PhonemeType.$fReadMaybeImpossible23
                                      `cast`
                                    (Trans
                                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                        <PhonemeType.Silibance>_R))
                                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                   <PhonemeType.Silibance>_R)))
                                    PhonemeType.$fReadMaybeBlank4)
                                   `cast`
                                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Silibance>_R)
                                   @ b
                                   (\ a23 :: PhonemeType.Silibance ->
                                    eta (PhonemeType.Specified @ PhonemeType.Silibance a23))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ a98 :: Text.Read.Lex.Lexeme ->
                                case a98 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a23
                                  -> case GHC.Base.eqString
                                            a23
                                            PhonemeType.$fReadMaybeBlank9 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl132 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl131) -}
                           = \ w2 :: () -> lvl131
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadMaybeImpossible23 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Silibance -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Silibance
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Silibance
                   PhonemeType.$fReadMaybeImpossible24
                   eta
                   @ b
                   eta1) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadMaybeImpossible24 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Silibance)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Silibance)
                   PhonemeType.$fReadMaybeImpossible29
                   PhonemeType.$fReadMaybeImpossible25) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadMaybeImpossible25 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Silibance)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Silibance)
                   PhonemeType.$fReadMaybeImpossible26
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.Silibance))) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadMaybeImpossible26 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Silibance)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeImpossible28,
                  PhonemeType.$fReadMaybeImpossible27
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Silibance>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Silibance>_R))))) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadMaybeImpossible27 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Silibance -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Silibance -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NONSILIBANT) -}
6ad568ea9cc1b807260d57fb2d0ab7f6
  $fReadMaybeImpossible28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NONSILIBANT"#) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadMaybeImpossible29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Silibance)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeImpossible31,
                  PhonemeType.$fReadMaybeImpossible30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Silibance>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Silibance>_R))))) -}
b78b70fb92bcab52954b3557682dba0c
  $fReadMaybeImpossible3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Possible"#) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadMaybeImpossible30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Silibance -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Silibance -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.SILIBANT) -}
4453cf58d45f9912ca9ab2826472ecfd
  $fReadMaybeImpossible31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SILIBANT"#) -}
b4ac1048a5df7e15b4750f647ca25d2a
  $fReadMaybeImpossible34 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.MaybeUnspecified PhonemeType.VOT
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ n :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.MaybeUnspecified PhonemeType.VOT
                          -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   lvl130 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl131 :: Text.ParserCombinators.ReadP.P b
                       = eta (PhonemeType.Unspecified @ PhonemeType.VOT)
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ a98 :: Text.Read.Lex.Lexeme ->
                        case a98 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a23
                          -> case GHC.Base.eqString
                                    a23
                                    PhonemeType.$fReadMaybeBlank10 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl131 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl130) -}
                   = \ w2 :: () -> lvl130
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ a98 :: GHC.Base.String ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                         `cast`
                       (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl131 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl132 :: Text.ParserCombinators.ReadP.P b
                               = (GHC.Read.$fReadDouble10
                                    @ PhonemeType.VOT
                                    PhonemeType.$fReadMaybeImpossible35
                                      `cast`
                                    (Trans
                                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                        <PhonemeType.VOT>_R))
                                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                   <PhonemeType.VOT>_R)))
                                    PhonemeType.$fReadMaybeBlank4)
                                   `cast`
                                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <PhonemeType.VOT>_R)
                                   @ b
                                   (\ a23 :: PhonemeType.VOT ->
                                    eta (PhonemeType.Specified @ PhonemeType.VOT a23))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ a98 :: Text.Read.Lex.Lexeme ->
                                case a98 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a23
                                  -> case GHC.Base.eqString
                                            a23
                                            PhonemeType.$fReadMaybeBlank9 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl132 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl131) -}
                           = \ w2 :: () -> lvl131
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible35 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.VOT -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.VOT -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.VOT
                   PhonemeType.$fReadMaybeImpossible36
                   eta
                   @ b
                   eta1) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible36 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)
                   PhonemeType.$fReadMaybeImpossible45
                   PhonemeType.$fReadMaybeImpossible37) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible37 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)
                   PhonemeType.$fReadMaybeImpossible42
                   PhonemeType.$fReadMaybeImpossible38) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible38 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)
                   PhonemeType.$fReadMaybeImpossible39
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT))) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible39 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeImpossible41,
                  PhonemeType.$fReadMaybeImpossible40
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.VOT>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.VOT>_R))))) -}
a306e1a50ca38092fde1b5fadeb1c10b
  $fReadMaybeImpossible4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Impossible"#) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible40 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.VOT -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.VOT -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.NEGATIVE) -}
c2bbdab0e09b9f067dcbc284ac9b65ed
  $fReadMaybeImpossible41 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NEGATIVE"#) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible42 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeImpossible44,
                  PhonemeType.$fReadMaybeImpossible43
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.VOT>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.VOT>_R))))) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible43 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.VOT -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.VOT -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.ZERO) -}
71f1aaf383bccbc4bad1094ba333bfdf
  $fReadMaybeImpossible44 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ZERO"#) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible45 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeImpossible47,
                  PhonemeType.$fReadMaybeImpossible46
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.VOT>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.VOT>_R))))) -}
16d61d06081f347fd36865d448a9e38e
  $fReadMaybeImpossible46 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.VOT -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.VOT -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.POSITIVE) -}
34e564b98c0c5cd72f585744d12528bd
  $fReadMaybeImpossible47 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "POSITIVE"#) -}
3978cd3edf78460ae9904b5e2532d862
  $fReadMaybeImpossible7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.MaybeUnspecified PhonemeType.Trill
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,1*U(U)><L,C(U)>,
     Unfolding: (\ n :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.MaybeUnspecified PhonemeType.Trill
                          -> Text.ParserCombinators.ReadP.P b ->
                 let {
                   lvl130 :: Text.ParserCombinators.ReadP.P b
                   = let {
                       lvl131 :: Text.ParserCombinators.ReadP.P b
                       = eta (PhonemeType.Unspecified @ PhonemeType.Trill)
                     } in
                     Text.Read.Lex.expect2
                       @ b
                       (\ a98 :: Text.Read.Lex.Lexeme ->
                        case a98 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                          Text.Read.Lex.Ident a23
                          -> case GHC.Base.eqString
                                    a23
                                    PhonemeType.$fReadMaybeBlank10 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                               GHC.Types.True -> lvl131 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl130) -}
                   = \ w2 :: () -> lvl130
                 } in
                 Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                   @ b
                   (Text.ParserCombinators.ReadP.Look
                      @ b
                      (\ a98 :: GHC.Base.String ->
                       (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                         `cast`
                       (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                         @ b
                         k))
                   (case n of wild { GHC.Types.I# x ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<=# x 10) of wild2 {
                      GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                      GHC.Types.True
                      -> let {
                           lvl131 :: Text.ParserCombinators.ReadP.P b
                           = let {
                               lvl132 :: Text.ParserCombinators.ReadP.P b
                               = (GHC.Read.$fReadDouble10
                                    @ PhonemeType.Trill
                                    PhonemeType.$fReadMaybeImpossible8
                                      `cast`
                                    (Trans
                                         (<Text.ParserCombinators.ReadPrec.Prec>_R
                                          ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                                        <PhonemeType.Trill>_R))
                                         (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                                   <PhonemeType.Trill>_R)))
                                    PhonemeType.$fReadMaybeBlank4)
                                   `cast`
                                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <PhonemeType.Trill>_R)
                                   @ b
                                   (\ a23 :: PhonemeType.Trill ->
                                    eta (PhonemeType.Specified @ PhonemeType.Trill a23))
                             } in
                             Text.Read.Lex.expect2
                               @ b
                               (\ a98 :: Text.Read.Lex.Lexeme ->
                                case a98 of wild1 {
                                  DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                                  Text.Read.Lex.Ident a23
                                  -> case GHC.Base.eqString
                                            a23
                                            PhonemeType.$fReadMaybeBlank9 of wild3 {
                                       GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                       GHC.Types.True -> lvl132 } })
                         } in
                         let {
                           k1 :: () -> Text.ParserCombinators.ReadP.P b
                             {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                                Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl131) -}
                           = \ w2 :: () -> lvl131
                         } in
                         Text.ParserCombinators.ReadP.Look
                           @ b
                           (\ a98 :: GHC.Base.String ->
                            (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                              `cast`
                            (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                              @ b
                              k1) } })) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadMaybeImpossible8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Trill -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Trill -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Trill
                   PhonemeType.$fReadMaybeImpossible9
                   eta
                   @ b
                   eta1) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadMaybeImpossible9 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Trill)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Trill)
                   PhonemeType.$fReadMaybeImpossible14
                   PhonemeType.$fReadMaybeImpossible10) -}
60779ee60a7b7b6d291add8ce22569fb
  $fReadMaybeImpossible_$creadList ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.MaybeImpossible a]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a23 $dRead2 :: GHC.Read.Read a23 ->
                 Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.MaybeImpossible a23]
                   (GHC.Read.$wa
                      @ (PhonemeType.MaybeImpossible a23)
                      (PhonemeType.$fReadMaybeImpossible2 @ a23 $dRead2)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                <PhonemeType.MaybeImpossible a23>_R))
                      @ [PhonemeType.MaybeImpossible a23]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.MaybeImpossible a23]))) -}
60779ee60a7b7b6d291add8ce22569fb
  $fReadMaybeImpossible_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.MaybeImpossible a]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeImpossible1
                  `cast`
                (forall a23.
                 <GHC.Read.Read a23>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                         <[PhonemeType.MaybeImpossible a23]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                    <[PhonemeType.MaybeImpossible a23]>_R))) -}
60779ee60a7b7b6d291add8ce22569fb
  $fReadMaybeImpossible_$creadPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      (PhonemeType.MaybeImpossible a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeImpossible2
                  `cast`
                (forall a23.
                 <GHC.Read.Read a23>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <PhonemeType.MaybeImpossible a23>_R)) -}
60779ee60a7b7b6d291add8ce22569fb
  $fReadMaybeImpossible_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (PhonemeType.MaybeImpossible a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a23 $dRead2 :: GHC.Read.Read a23 eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType.MaybeImpossible a23)
                   ((PhonemeType.$fReadMaybeImpossible2 @ a23 $dRead2 eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.MaybeImpossible a23>_R)
                      @ (PhonemeType.MaybeImpossible a23)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType.MaybeImpossible a23)))) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fReadMaybeUnspecified ::
    GHC.Read.Read a => GHC.Read.Read (PhonemeType.MaybeUnspecified a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dRead2 :: GHC.Read.Read a23.
                  @ (PhonemeType.MaybeUnspecified a23)
                  (PhonemeType.$fReadMaybeUnspecified_$creadsPrec @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeUnspecified_$creadList @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeUnspecified_$creadPrec @ a23 $dRead2)
                  (PhonemeType.$fReadMaybeUnspecified_$creadListPrec
                     @ a23
                     $dRead2) -}
0ced447c01ef0430c5f237287cb74cc0
  $fReadMaybeUnspecified1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.MaybeUnspecified PhonemeType.Trill]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.MaybeUnspecified PhonemeType.Trill]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Trill)
                   PhonemeType.$fReadMaybeUnspecified2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.MaybeUnspecified PhonemeType.Trill>_R))
                   @ b
                   eta1) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified100 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.CLOSURE) -}
36afc3e0a037bfee84bf740b95069617
  $fReadMaybeUnspecified101 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CLOSURE"#) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified102 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified104,
                  PhonemeType.$fReadMaybeUnspecified103
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Phonation>_R))))) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified103 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.CREAKY) -}
bebf04ddc8e6d58d9a7844d25932ca05
  $fReadMaybeUnspecified104 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CREAKY"#) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified105 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified107,
                  PhonemeType.$fReadMaybeUnspecified106
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Phonation>_R))))) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified106 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.STIFF) -}
6257a3ba3f32dc01e325331e88163de8
  $fReadMaybeUnspecified107 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STIFF"#) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified108 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified110,
                  PhonemeType.$fReadMaybeUnspecified109
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Phonation>_R))))) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified109 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.MODAL) -}
5d17f20c1c7712176d4cf19f17e2496b
  $fReadMaybeUnspecified110 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "MODAL"#) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified111 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified113,
                  PhonemeType.$fReadMaybeUnspecified112
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Phonation>_R))))) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified112 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.SLACK) -}
709b58866f694d96dc6e3f39574c7a96
  $fReadMaybeUnspecified113 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SLACK"#) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified114 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified116,
                  PhonemeType.$fReadMaybeUnspecified115
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Phonation>_R))))) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified115 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.BREATHY) -}
c0864df540eed9b417dadc448aea337c
  $fReadMaybeUnspecified116 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BREATHY"#) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified117 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified119,
                  PhonemeType.$fReadMaybeUnspecified118
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Phonation>_R))))) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified118 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.VOICELESS) -}
bd3fb2dc3bca8ef64cd1021e8e020fab
  $fReadMaybeUnspecified119 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "VOICELESS"#) -}
95417ac7dbeb758b510442ae50c858cb
  $fReadMaybeUnspecified12 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.Place -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$wa5 ww1 @ b w1 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadMaybeUnspecified126 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Roundedness
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Roundedness
                   PhonemeType.$fReadMaybeUnspecified127
                   eta
                   @ b
                   eta1) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadMaybeUnspecified127 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)
                   PhonemeType.$fReadMaybeUnspecified132
                   PhonemeType.$fReadMaybeUnspecified128) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadMaybeUnspecified128 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)
                   PhonemeType.$fReadMaybeUnspecified129
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.Roundedness))) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadMaybeUnspecified129 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified131,
                  PhonemeType.$fReadMaybeUnspecified130
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Roundedness>_R))))) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadMaybeUnspecified130 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.ROUNDED) -}
9a6b1ff50cb204f897c7633e6d07b820
  $fReadMaybeUnspecified131 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ROUNDED"#) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadMaybeUnspecified132 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified134,
                  PhonemeType.$fReadMaybeUnspecified133
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Roundedness>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Roundedness>_R))))) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadMaybeUnspecified133 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Roundedness -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Roundedness
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.UNROUNDED) -}
0beeb936a229a23cdd0b3053b9490fb0
  $fReadMaybeUnspecified134 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UNROUNDED"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified17 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.PassiveArticulator
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.PassiveArticulator
                   PhonemeType.$fReadMaybeUnspecified18
                   eta
                   @ b
                   eta1) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified18 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified59
                   PhonemeType.$fReadMaybeUnspecified19) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified19 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified56
                   PhonemeType.$fReadMaybeUnspecified20) -}
10ffbd8280d288a453a6fcc6444bcb1b
  $fReadMaybeUnspecified2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (PhonemeType.MaybeUnspecified PhonemeType.Trill)
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Trill)
                   PhonemeType.$fReadMaybeImpossible7
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.MaybeUnspecified PhonemeType.Trill>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.MaybeUnspecified PhonemeType.Trill>_R)))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified20 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified53
                   PhonemeType.$fReadMaybeUnspecified21) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified21 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified50
                   PhonemeType.$fReadMaybeUnspecified22) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified22 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified47
                   PhonemeType.$fReadMaybeUnspecified23) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified23 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified44
                   PhonemeType.$fReadMaybeUnspecified24) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified24 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified41
                   PhonemeType.$fReadMaybeUnspecified25) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified25 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified38
                   PhonemeType.$fReadMaybeUnspecified26) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified26 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified35
                   PhonemeType.$fReadMaybeUnspecified27) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified27 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified32
                   PhonemeType.$fReadMaybeUnspecified28) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified28 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec
        PhonemeType.PassiveArticulator)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec
                        PhonemeType.PassiveArticulator)
                   PhonemeType.$fReadMaybeUnspecified29
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.PassiveArticulator))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified29 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified31,
                  PhonemeType.$fReadMaybeUnspecified30
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
b22cd4f5ae523915afd5bafcb0d76d85
  $fReadMaybeUnspecified3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.MaybeUnspecified PhonemeType.Laterality]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.MaybeUnspecified PhonemeType.Laterality]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
                   PhonemeType.$fReadMaybeUnspecified4
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.MaybeUnspecified PhonemeType.Laterality>_R))
                   @ b
                   eta1) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified30 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.GLOTTIS) -}
9bda29e56ef1f42d4ae437764463c66e
  $fReadMaybeUnspecified31 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GLOTTIS"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified32 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified34,
                  PhonemeType.$fReadMaybeUnspecified33
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified33 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.EPIGLOTTIS) -}
5da7a241657fa642190a77b50b4d36db
  $fReadMaybeUnspecified34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EPIGLOTTIS"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified35 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified37,
                  PhonemeType.$fReadMaybeUnspecified36
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified36 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.PHARYNX) -}
b664e96c727065f26f47754fb08d9dfa
  $fReadMaybeUnspecified37 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PHARYNX"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified38 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified40,
                  PhonemeType.$fReadMaybeUnspecified39
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified39 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.UVULA) -}
8bf1ce91dbba72dc360379d4b2b0d5f7
  $fReadMaybeUnspecified4 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
                   PhonemeType.$fReadMaybeImpossible19
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.MaybeUnspecified PhonemeType.Laterality>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.MaybeUnspecified PhonemeType.Laterality>_R)))) -}
9e6845543ff2a2817f7bee5942a227fd
  $fReadMaybeUnspecified40 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UVULA"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified41 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified43,
                  PhonemeType.$fReadMaybeUnspecified42
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified42 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.SOFTPALATE) -}
8f7f813552bcead0bff5fc25f75a7ed7
  $fReadMaybeUnspecified43 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SOFTPALATE"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified44 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified46,
                  PhonemeType.$fReadMaybeUnspecified45
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified45 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.HARDPALATE) -}
076b3c6a32c9bb134f301435d25978d3
  $fReadMaybeUnspecified46 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "HARDPALATE"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified47 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified49,
                  PhonemeType.$fReadMaybeUnspecified48
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified48 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.BACKRIDGE) -}
eb56b0f6060ea8bf5a62a8d681e97e94
  $fReadMaybeUnspecified49 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "BACKRIDGE"#) -}
726f341493d474c2baaadffb4dc9ad7e
  $fReadMaybeUnspecified5 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.MaybeUnspecified PhonemeType.Silibance]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.MaybeUnspecified PhonemeType.Silibance]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
                   PhonemeType.$fReadMaybeUnspecified6
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.MaybeUnspecified PhonemeType.Silibance>_R))
                   @ b
                   eta1) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified50 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified52,
                  PhonemeType.$fReadMaybeUnspecified51
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified51 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.RIDGE) -}
d6238f7fcb15cedeab85f56b0b0bcd94
  $fReadMaybeUnspecified52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RIDGE"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified53 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified55,
                  PhonemeType.$fReadMaybeUnspecified54
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified54 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TEETHRIDGE) -}
8f5844a6f59c0c2edeb2e2fb6433a37a
  $fReadMaybeUnspecified55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TEETHRIDGE"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified56 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified58,
                  PhonemeType.$fReadMaybeUnspecified57
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified57 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.UPPERTEETH) -}
056d34a242d54f39882c244d8f1d9409
  $fReadMaybeUnspecified58 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UPPERTEETH"#) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified59 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec
       PhonemeType.PassiveArticulator)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified61,
                  PhonemeType.$fReadMaybeUnspecified60
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.PassiveArticulator>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.PassiveArticulator>_R))))) -}
22e930c9d2c23095cb32c68a93aa402e
  $fReadMaybeUnspecified6 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
                   PhonemeType.$fReadMaybeImpossible22
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.MaybeUnspecified PhonemeType.Silibance>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.MaybeUnspecified PhonemeType.Silibance>_R)))) -}
dcbf3455324a78016700898324489067
  $fReadMaybeUnspecified60 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PassiveArticulator
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.PassiveArticulator
                          -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.UPPERLIP) -}
4c67f66ffc0b0395f96d980bd8bd8a20
  $fReadMaybeUnspecified61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "UPPERLIP"#) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified66 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Stricture -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Stricture
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Stricture
                   PhonemeType.$fReadMaybeUnspecified67
                   eta
                   @ b
                   eta1) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified67 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)
                   PhonemeType.$fReadMaybeUnspecified76
                   PhonemeType.$fReadMaybeUnspecified68) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified68 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)
                   PhonemeType.$fReadMaybeUnspecified73
                   PhonemeType.$fReadMaybeUnspecified69) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified69 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)
                   PhonemeType.$fReadMaybeUnspecified70
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.Stricture))) -}
dbe7ad99cce7260f58e8863247343187
  $fReadMaybeUnspecified7 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.MaybeUnspecified PhonemeType.VOT]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.MaybeUnspecified PhonemeType.VOT]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (PhonemeType.MaybeUnspecified PhonemeType.VOT)
                   PhonemeType.$fReadMaybeUnspecified8
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.MaybeUnspecified PhonemeType.VOT>_R))
                   @ b
                   eta1) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified70 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified72,
                  PhonemeType.$fReadMaybeUnspecified71
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Stricture>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Stricture>_R))))) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified71 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Stricture -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Stricture -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.SLIGHTTURBULENT) -}
3b40fbecb87c05cc454872f101b39709
  $fReadMaybeUnspecified72 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SLIGHTTURBULENT"#) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified73 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified75,
                  PhonemeType.$fReadMaybeUnspecified74
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Stricture>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Stricture>_R))))) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified74 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Stricture -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Stricture -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.TURBULENT) -}
63b90a4db59a61118dcac3c9e2eb2436
  $fReadMaybeUnspecified75 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TURBULENT"#) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified76 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified78,
                  PhonemeType.$fReadMaybeUnspecified77
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Stricture>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Stricture>_R))))) -}
f45b7454df7117690624094b2e33986b
  $fReadMaybeUnspecified77 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Stricture -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ ds :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta :: PhonemeType.Stricture -> Text.ParserCombinators.ReadP.P b ->
                 eta PhonemeType.OCCLUSION) -}
a5b2b59f9ca8037a6804b7988a32dc24
  $fReadMaybeUnspecified78 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OCCLUSION"#) -}
139e337c48d0537c45c64722028eed73
  $fReadMaybeUnspecified8 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (PhonemeType.MaybeUnspecified PhonemeType.VOT)
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ (PhonemeType.MaybeUnspecified PhonemeType.VOT)
                   PhonemeType.$fReadMaybeImpossible34
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.MaybeUnspecified PhonemeType.VOT>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.MaybeUnspecified PhonemeType.VOT>_R)))) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fReadMaybeUnspecified9 ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.MaybeUnspecified a]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dRead2 :: GHC.Read.Read a23
                   eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.MaybeUnspecified a23]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (PhonemeType.MaybeUnspecified a23)
                   (PhonemeType.$fReadMaybeBlank8 @ a23 $dRead2)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.MaybeUnspecified a23>_R))
                   @ b
                   eta1) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified91 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.Phonation -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: PhonemeType.Phonation
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.choose2
                   @ PhonemeType.Phonation
                   PhonemeType.$fReadMaybeUnspecified92
                   eta
                   @ b
                   eta1) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified92 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
                   PhonemeType.$fReadMaybeUnspecified117
                   PhonemeType.$fReadMaybeUnspecified93) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified93 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
                   PhonemeType.$fReadMaybeUnspecified114
                   PhonemeType.$fReadMaybeUnspecified94) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified94 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
                   PhonemeType.$fReadMaybeUnspecified111
                   PhonemeType.$fReadMaybeUnspecified95) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified95 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
                   PhonemeType.$fReadMaybeUnspecified108
                   PhonemeType.$fReadMaybeUnspecified96) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified96 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
                   PhonemeType.$fReadMaybeUnspecified105
                   PhonemeType.$fReadMaybeUnspecified97) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified97 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
                   PhonemeType.$fReadMaybeUnspecified102
                   PhonemeType.$fReadMaybeUnspecified98) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified98 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
                   PhonemeType.$fReadMaybeUnspecified99
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec
                           PhonemeType.Phonation))) -}
1876b99e8b904b79707be731945482ec
  $fReadMaybeUnspecified99 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation)
  {- Strictness: m,
     Unfolding: ((PhonemeType.$fReadMaybeUnspecified101,
                  PhonemeType.$fReadMaybeUnspecified100
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                      <PhonemeType.Phonation>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                 <PhonemeType.Phonation>_R))))) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fReadMaybeUnspecified_$creadList ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.MaybeUnspecified a]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a23 $dRead2 :: GHC.Read.Read a23 ->
                 Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.MaybeUnspecified a23]
                   (GHC.Read.$wa
                      @ (PhonemeType.MaybeUnspecified a23)
                      (PhonemeType.$fReadMaybeBlank8 @ a23 $dRead2)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                <PhonemeType.MaybeUnspecified a23>_R))
                      @ [PhonemeType.MaybeUnspecified a23]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.MaybeUnspecified a23]))) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fReadMaybeUnspecified_$creadListPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.MaybeUnspecified a]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified9
                  `cast`
                (forall a23.
                 <GHC.Read.Read a23>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                         <[PhonemeType.MaybeUnspecified a23]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                    <[PhonemeType.MaybeUnspecified a23]>_R))) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fReadMaybeUnspecified_$creadPrec ::
    GHC.Read.Read a =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      (PhonemeType.MaybeUnspecified a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeBlank8
                  `cast`
                (forall a23.
                 <GHC.Read.Read a23>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <PhonemeType.MaybeUnspecified a23>_R)) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fReadMaybeUnspecified_$creadsPrec ::
    GHC.Read.Read a =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (PhonemeType.MaybeUnspecified a)
  {- Arity: 2, Strictness: <L,1*U(A,A,1*U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a23 $dRead2 :: GHC.Read.Read a23 eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType.MaybeUnspecified a23)
                   ((PhonemeType.$fReadMaybeBlank8 @ a23 $dRead2 eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.MaybeUnspecified a23>_R)
                      @ (PhonemeType.MaybeUnspecified a23)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType.MaybeUnspecified a23)))) -}
f9a414acd7b6c61d85df0f875c51f069
  $fReadMaybeUnspecified_$s$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.MaybeUnspecified PhonemeType.Trill]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.MaybeUnspecified PhonemeType.Trill]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.MaybeUnspecified PhonemeType.Trill]>_R))) -}
28208b58a485cccb77edc3916d2b3ba8
  $fReadMaybeUnspecified_$s$creadListPrec1 ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.MaybeUnspecified PhonemeType.Laterality]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified3
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.MaybeUnspecified PhonemeType.Laterality]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.MaybeUnspecified PhonemeType.Laterality]>_R))) -}
97a065716cfc0d0961f04936b6f33b48
  $fReadMaybeUnspecified_$s$creadListPrec2 ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.MaybeUnspecified PhonemeType.Silibance]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified5
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.MaybeUnspecified PhonemeType.Silibance]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.MaybeUnspecified PhonemeType.Silibance]>_R))) -}
309ecd3a66f620c94d432cea6b38a348
  $fReadMaybeUnspecified_$s$creadListPrec3 ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.MaybeUnspecified PhonemeType.VOT]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified7
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.MaybeUnspecified PhonemeType.VOT]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.MaybeUnspecified PhonemeType.VOT]>_R))) -}
07b00bdd48b861c5a156412b889c467b
  $fReadMaybeUnspecified_$s$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      (PhonemeType.MaybeUnspecified PhonemeType.Trill)
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.MaybeUnspecified PhonemeType.Trill>_R)) -}
499a340b4703e81c0b0e1806d3e4fdf9
  $fReadMaybeUnspecified_$s$creadPrec1 ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified4
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.MaybeUnspecified PhonemeType.Laterality>_R)) -}
c0d405110111075999a7147e7b7252db
  $fReadMaybeUnspecified_$s$creadPrec2 ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified6
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.MaybeUnspecified PhonemeType.Silibance>_R)) -}
3fe17c8fe7652fbe69d49f06edc75618
  $fReadMaybeUnspecified_$s$creadPrec3 ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      (PhonemeType.MaybeUnspecified PhonemeType.VOT)
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadMaybeUnspecified8
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.MaybeUnspecified PhonemeType.VOT>_R)) -}
07341950cf7d866f396d6438c1c1f918
  $fReadMaybeUnspecified_$s$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (PhonemeType.MaybeUnspecified PhonemeType.Trill)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Trill)
                   ((GHC.Read.$fReadDouble10
                       @ (PhonemeType.MaybeUnspecified PhonemeType.Trill)
                       PhonemeType.$fReadMaybeImpossible7
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.MaybeUnspecified PhonemeType.Trill>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.MaybeUnspecified PhonemeType.Trill>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.MaybeUnspecified PhonemeType.Trill>_R)
                      @ (PhonemeType.MaybeUnspecified PhonemeType.Trill)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType.MaybeUnspecified PhonemeType.Trill)))) -}
47c25836913297c71d5fdf000e242b99
  $fReadMaybeUnspecified_$s$creadsPrec1 ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
                   ((GHC.Read.$fReadDouble10
                       @ (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
                       PhonemeType.$fReadMaybeImpossible19
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.MaybeUnspecified PhonemeType.Laterality>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.MaybeUnspecified PhonemeType.Laterality>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.MaybeUnspecified PhonemeType.Laterality>_R)
                      @ (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType.MaybeUnspecified PhonemeType.Laterality)))) -}
905c0607227b3bc01794842ef4c7bbdb
  $fReadMaybeUnspecified_$s$creadsPrec2 ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
                   ((GHC.Read.$fReadDouble10
                       @ (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
                       PhonemeType.$fReadMaybeImpossible22
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.MaybeUnspecified PhonemeType.Silibance>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.MaybeUnspecified PhonemeType.Silibance>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.MaybeUnspecified PhonemeType.Silibance>_R)
                      @ (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType.MaybeUnspecified PhonemeType.Silibance)))) -}
036dbdf2ec5092f3512a0fa65fa0a4b4
  $fReadMaybeUnspecified_$s$creadsPrec3 ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (PhonemeType.MaybeUnspecified PhonemeType.VOT)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (PhonemeType.MaybeUnspecified PhonemeType.VOT)
                   ((GHC.Read.$fReadDouble10
                       @ (PhonemeType.MaybeUnspecified PhonemeType.VOT)
                       PhonemeType.$fReadMaybeImpossible34
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.MaybeUnspecified PhonemeType.VOT>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.MaybeUnspecified PhonemeType.VOT>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.MaybeUnspecified PhonemeType.VOT>_R)
                      @ (PhonemeType.MaybeUnspecified PhonemeType.VOT)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (PhonemeType.MaybeUnspecified PhonemeType.VOT)))) -}
a3045299196892954e83d80aa14b17a0
  $fReadMaybeUnspecified_$s$fReadMaybeUnspecified ::
    GHC.Read.Read (PhonemeType.MaybeUnspecified PhonemeType.Trill)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (PhonemeType.MaybeUnspecified PhonemeType.Trill)
                  PhonemeType.$fReadMaybeUnspecified_$s$creadsPrec
                  PhonemeType.$fReadMaybeUnspecified_$sreadListDefault
                  PhonemeType.$fReadMaybeUnspecified_$s$creadPrec
                  PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec -}
555a6574aef0b67a437befab5d08d109
  $fReadMaybeUnspecified_$s$fReadMaybeUnspecified1 ::
    GHC.Read.Read (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
                  PhonemeType.$fReadMaybeUnspecified_$s$creadsPrec1
                  PhonemeType.$fReadMaybeUnspecified_$sreadListDefault1
                  PhonemeType.$fReadMaybeUnspecified_$s$creadPrec1
                  PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec1 -}
5cd378cca65d0b039da290dc346076ee
  $fReadMaybeUnspecified_$s$fReadMaybeUnspecified2 ::
    GHC.Read.Read (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
                  PhonemeType.$fReadMaybeUnspecified_$s$creadsPrec2
                  PhonemeType.$fReadMaybeUnspecified_$sreadListDefault2
                  PhonemeType.$fReadMaybeUnspecified_$s$creadPrec2
                  PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec2 -}
b19c0252a3913c4c9c213f465e09cd94
  $fReadMaybeUnspecified_$s$fReadMaybeUnspecified3 ::
    GHC.Read.Read (PhonemeType.MaybeUnspecified PhonemeType.VOT)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (PhonemeType.MaybeUnspecified PhonemeType.VOT)
                  PhonemeType.$fReadMaybeUnspecified_$s$creadsPrec3
                  PhonemeType.$fReadMaybeUnspecified_$sreadListDefault3
                  PhonemeType.$fReadMaybeUnspecified_$s$creadPrec3
                  PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec3 -}
373a64a5207113c15b2bd03d61bce066
  $fReadMaybeUnspecified_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType.MaybeUnspecified PhonemeType.Trill]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.MaybeUnspecified PhonemeType.Trill]
                   ((PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.MaybeUnspecified PhonemeType.Trill]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.MaybeUnspecified PhonemeType.Trill]>_R)
                      @ [PhonemeType.MaybeUnspecified PhonemeType.Trill]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.MaybeUnspecified PhonemeType.Trill]))) -}
cd40a3487460fb2cc41ac3b8a0d6539b
  $fReadMaybeUnspecified_$sreadListDefault1 ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType.MaybeUnspecified PhonemeType.Laterality]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.MaybeUnspecified PhonemeType.Laterality]
                   ((PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec1
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.MaybeUnspecified PhonemeType.Laterality]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.MaybeUnspecified PhonemeType.Laterality]>_R)
                      @ [PhonemeType.MaybeUnspecified PhonemeType.Laterality]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.MaybeUnspecified PhonemeType.Laterality]))) -}
0a3fb37706a58680360a3b60df791dec
  $fReadMaybeUnspecified_$sreadListDefault2 ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType.MaybeUnspecified PhonemeType.Silibance]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.MaybeUnspecified PhonemeType.Silibance]
                   ((PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec2
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.MaybeUnspecified PhonemeType.Silibance]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.MaybeUnspecified PhonemeType.Silibance]>_R)
                      @ [PhonemeType.MaybeUnspecified PhonemeType.Silibance]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.MaybeUnspecified PhonemeType.Silibance]))) -}
af28d141574110c5a2a791569e92bcee
  $fReadMaybeUnspecified_$sreadListDefault3 ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType.MaybeUnspecified PhonemeType.VOT]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.MaybeUnspecified PhonemeType.VOT]
                   ((PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec3
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.MaybeUnspecified PhonemeType.VOT]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.MaybeUnspecified PhonemeType.VOT]>_R)
                      @ [PhonemeType.MaybeUnspecified PhonemeType.VOT]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.MaybeUnspecified PhonemeType.VOT]))) -}
dcbf3455324a78016700898324489067
  $fReadPassiveArticulator ::
    GHC.Read.Read PhonemeType.PassiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PassiveArticulator
                  PhonemeType.$fReadPassiveArticulator_$s$dmreadsPrec
                  PhonemeType.$fReadPassiveArticulator_$sreadListDefault
                  PhonemeType.$fReadPassiveArticulator_$creadPrec
                  PhonemeType.$fReadPassiveArticulator_$creadListPrec -}
dcbf3455324a78016700898324489067
  $fReadPassiveArticulator1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.PassiveArticulator]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.PassiveArticulator]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.PassiveArticulator
                   PhonemeType.$fReadPassiveArticulator2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.PassiveArticulator>_R))
                   @ b
                   eta1) -}
dcbf3455324a78016700898324489067
  $fReadPassiveArticulator2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         PhonemeType.PassiveArticulator
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.PassiveArticulator
                   PhonemeType.$fReadMaybeUnspecified17
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.PassiveArticulator>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.PassiveArticulator>_R)))) -}
dcbf3455324a78016700898324489067
  $fReadPassiveArticulator_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.PassiveArticulator]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPassiveArticulator1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.PassiveArticulator]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.PassiveArticulator]>_R))) -}
dcbf3455324a78016700898324489067
  $fReadPassiveArticulator_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType.PassiveArticulator
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPassiveArticulator2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.PassiveArticulator>_R)) -}
dcbf3455324a78016700898324489067
  $fReadPassiveArticulator_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         PhonemeType.PassiveArticulator
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.PassiveArticulator
                   PhonemeType.$fReadPassiveArticulator_$creadPrec
                   eta) -}
dcbf3455324a78016700898324489067
  $fReadPassiveArticulator_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.PassiveArticulator]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.PassiveArticulator]
                   ((PhonemeType.$fReadPassiveArticulator_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.PassiveArticulator]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.PassiveArticulator]>_R)
                      @ [PhonemeType.PassiveArticulator]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.PassiveArticulator]))) -}
1876b99e8b904b79707be731945482ec
  $fReadPhonation :: GHC.Read.Read PhonemeType.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Phonation
                  PhonemeType.$fReadPhonation_$s$dmreadsPrec
                  PhonemeType.$fReadPhonation_$sreadListDefault
                  PhonemeType.$fReadPhonation_$creadPrec
                  PhonemeType.$fReadPhonation_$creadListPrec -}
1876b99e8b904b79707be731945482ec
  $fReadPhonation1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Phonation] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Phonation]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Phonation
                   PhonemeType.$fReadPhonation2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Phonation>_R))
                   @ b
                   eta1) -}
1876b99e8b904b79707be731945482ec
  $fReadPhonation2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Phonation
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Phonation
                   PhonemeType.$fReadMaybeUnspecified91
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Phonation>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Phonation>_R)))) -}
1876b99e8b904b79707be731945482ec
  $fReadPhonation_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Phonation]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPhonation1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Phonation]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Phonation]>_R))) -}
1876b99e8b904b79707be731945482ec
  $fReadPhonation_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Phonation
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPhonation2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Phonation>_R)) -}
1876b99e8b904b79707be731945482ec
  $fReadPhonation_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Phonation
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Phonation
                   PhonemeType.$fReadPhonation_$creadPrec
                   eta) -}
1876b99e8b904b79707be731945482ec
  $fReadPhonation_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Phonation]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Phonation]
                   ((PhonemeType.$fReadPhonation_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Phonation]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Phonation]>_R)
                      @ [PhonemeType.Phonation]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Phonation]))) -}
d63366b958aa268c953fb9cc54988074
  $fReadPhonemeInventory ::
    GHC.Read.Read PhonemeType.PhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PhonemeInventory
                  PhonemeType.$fReadPhonemeInventory_$creadsPrec
                  PhonemeType.$fReadPhonemeInventory_$sreadListDefault
                  PhonemeType.$fReadPhonemeInventory_$creadPrec
                  PhonemeType.$fReadPhonemeInventory_$creadListPrec -}
d63366b958aa268c953fb9cc54988074
  $fReadPhonemeInventory1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.PhonemeInventory]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.PhonemeInventory]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.PhonemeInventory
                   PhonemeType.$fReadPhonemeInventory2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.PhonemeInventory>_R))
                   @ b
                   eta1) -}
d63366b958aa268c953fb9cc54988074
  $fReadPhonemeInventory2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.PhonemeInventory
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.PhonemeInventory
                   PhonemeType.$fReadPhonemeInventory3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.PhonemeInventory>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.PhonemeInventory>_R)))) -}
d63366b958aa268c953fb9cc54988074
  $fReadPhonemeInventory3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.PhonemeInventory -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.PhonemeInventory
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$wa6 ww1 @ b w1 }) -}
1aaa376d5e5038894b03585c6a7e1fdb
  $fReadPhonemeInventory4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PhonemeInventory"#) -}
d63366b958aa268c953fb9cc54988074
  $fReadPhonemeInventory_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.PhonemeInventory]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPhonemeInventory1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.PhonemeInventory]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.PhonemeInventory]>_R))) -}
d63366b958aa268c953fb9cc54988074
  $fReadPhonemeInventory_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType.PhonemeInventory
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPhonemeInventory2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.PhonemeInventory>_R)) -}
d63366b958aa268c953fb9cc54988074
  $fReadPhonemeInventory_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.PhonemeInventory
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.PhonemeInventory
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.PhonemeInventory
                       PhonemeType.$fReadPhonemeInventory3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.PhonemeInventory>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.PhonemeInventory>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.PhonemeInventory>_R)
                      @ PhonemeType.PhonemeInventory
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.PhonemeInventory))) -}
d63366b958aa268c953fb9cc54988074
  $fReadPhonemeInventory_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.PhonemeInventory]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.PhonemeInventory]
                   ((PhonemeType.$fReadPhonemeInventory_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.PhonemeInventory]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.PhonemeInventory]>_R)
                      @ [PhonemeType.PhonemeInventory]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.PhonemeInventory]))) -}
95417ac7dbeb758b510442ae50c858cb
  $fReadPlace :: GHC.Read.Read PhonemeType.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place
                  PhonemeType.$fReadPlace_$creadsPrec
                  PhonemeType.$fReadPlace_$sreadListDefault
                  PhonemeType.$fReadPlace_$creadPrec
                  PhonemeType.$fReadPlace_$creadListPrec -}
95417ac7dbeb758b510442ae50c858cb
  $fReadPlace1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Place] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Place] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Place
                   PhonemeType.$fReadPlace2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Place>_R))
                   @ b
                   eta1) -}
95417ac7dbeb758b510442ae50c858cb
  $fReadPlace2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Place
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Place
                   PhonemeType.$fReadMaybeUnspecified12
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Place>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Place>_R)))) -}
95417ac7dbeb758b510442ae50c858cb
  $fReadPlace_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Place]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPlace1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Place]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Place]>_R))) -}
95417ac7dbeb758b510442ae50c858cb
  $fReadPlace_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Place
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadPlace2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Place>_R)) -}
95417ac7dbeb758b510442ae50c858cb
  $fReadPlace_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Place
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.Place
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.Place
                       PhonemeType.$fReadMaybeUnspecified12
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.Place>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.Place>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <PhonemeType.Place>_R)
                      @ PhonemeType.Place
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.Place))) -}
95417ac7dbeb758b510442ae50c858cb
  $fReadPlace_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Place]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Place]
                   ((PhonemeType.$fReadPlace_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Place]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Place]>_R)
                      @ [PhonemeType.Place]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Place]))) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadRoundedness :: GHC.Read.Read PhonemeType.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fReadRoundedness_$s$dmreadsPrec
                  PhonemeType.$fReadRoundedness_$sreadListDefault
                  PhonemeType.$fReadRoundedness_$creadPrec
                  PhonemeType.$fReadRoundedness_$creadListPrec -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadRoundedness1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Roundedness] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Roundedness]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Roundedness
                   PhonemeType.$fReadRoundedness2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Roundedness>_R))
                   @ b
                   eta1) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadRoundedness2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Roundedness
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Roundedness
                   PhonemeType.$fReadMaybeUnspecified126
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Roundedness>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Roundedness>_R)))) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadRoundedness_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Roundedness]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadRoundedness1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Roundedness]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Roundedness]>_R))) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadRoundedness_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Roundedness
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadRoundedness2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Roundedness>_R)) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadRoundedness_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Roundedness
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Roundedness
                   PhonemeType.$fReadRoundedness_$creadPrec
                   eta) -}
9c915b50edb2977ec86c27bd6c240a83
  $fReadRoundedness_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Roundedness]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Roundedness]
                   ((PhonemeType.$fReadRoundedness_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Roundedness]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Roundedness]>_R)
                      @ [PhonemeType.Roundedness]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Roundedness]))) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadSilibance :: GHC.Read.Read PhonemeType.Silibance
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Silibance
                  PhonemeType.$fReadSilibance_$s$dmreadsPrec
                  PhonemeType.$fReadSilibance_$sreadListDefault
                  PhonemeType.$fReadSilibance_$creadPrec
                  PhonemeType.$fReadSilibance_$creadListPrec -}
1940ee84f46a7a0f1801689311b6be65
  $fReadSilibance1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Silibance] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Silibance]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Silibance
                   PhonemeType.$fReadSilibance2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Silibance>_R))
                   @ b
                   eta1) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadSilibance2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Silibance
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Silibance
                   PhonemeType.$fReadMaybeImpossible23
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Silibance>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Silibance>_R)))) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadSilibance_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Silibance]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadSilibance1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Silibance]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Silibance]>_R))) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadSilibance_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Silibance
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadSilibance2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Silibance>_R)) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadSilibance_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Silibance
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Silibance
                   PhonemeType.$fReadSilibance_$creadPrec
                   eta) -}
1940ee84f46a7a0f1801689311b6be65
  $fReadSilibance_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Silibance]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Silibance]
                   ((PhonemeType.$fReadSilibance_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Silibance]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Silibance]>_R)
                      @ [PhonemeType.Silibance]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Silibance]))) -}
f45b7454df7117690624094b2e33986b
  $fReadStricture :: GHC.Read.Read PhonemeType.Stricture
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Stricture
                  PhonemeType.$fReadStricture_$s$dmreadsPrec
                  PhonemeType.$fReadStricture_$sreadListDefault
                  PhonemeType.$fReadStricture_$creadPrec
                  PhonemeType.$fReadStricture_$creadListPrec -}
f45b7454df7117690624094b2e33986b
  $fReadStricture1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Stricture] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Stricture]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Stricture
                   PhonemeType.$fReadStricture2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Stricture>_R))
                   @ b
                   eta1) -}
f45b7454df7117690624094b2e33986b
  $fReadStricture2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Stricture
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Stricture
                   PhonemeType.$fReadMaybeUnspecified66
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Stricture>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Stricture>_R)))) -}
f45b7454df7117690624094b2e33986b
  $fReadStricture_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Stricture]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadStricture1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Stricture]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Stricture]>_R))) -}
f45b7454df7117690624094b2e33986b
  $fReadStricture_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Stricture
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadStricture2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Stricture>_R)) -}
f45b7454df7117690624094b2e33986b
  $fReadStricture_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Stricture
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Stricture
                   PhonemeType.$fReadStricture_$creadPrec
                   eta) -}
f45b7454df7117690624094b2e33986b
  $fReadStricture_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Stricture]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Stricture]
                   ((PhonemeType.$fReadStricture_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Stricture]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Stricture]>_R)
                      @ [PhonemeType.Stricture]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Stricture]))) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadTrill :: GHC.Read.Read PhonemeType.Trill
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Trill
                  PhonemeType.$fReadTrill_$s$dmreadsPrec
                  PhonemeType.$fReadTrill_$sreadListDefault
                  PhonemeType.$fReadTrill_$creadPrec
                  PhonemeType.$fReadTrill_$creadListPrec -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadTrill1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.Trill] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.Trill] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.Trill
                   PhonemeType.$fReadTrill2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.Trill>_R))
                   @ b
                   eta1) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadTrill2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.Trill
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.Trill
                   PhonemeType.$fReadMaybeImpossible8
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.Trill>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.Trill>_R)))) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadTrill_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.Trill]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadTrill1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.Trill]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.Trill]>_R))) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadTrill_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.Trill
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadTrill2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.Trill>_R)) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadTrill_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.Trill
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.Trill
                   PhonemeType.$fReadTrill_$creadPrec
                   eta) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fReadTrill_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.Trill]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.Trill]
                   ((PhonemeType.$fReadTrill_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.Trill]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.Trill]>_R)
                      @ [PhonemeType.Trill]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.Trill]))) -}
16d61d06081f347fd36865d448a9e38e
  $fReadVOT :: GHC.Read.Read PhonemeType.VOT
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VOT
                  PhonemeType.$fReadVOT_$s$dmreadsPrec
                  PhonemeType.$fReadVOT_$sreadListDefault
                  PhonemeType.$fReadVOT_$creadPrec
                  PhonemeType.$fReadVOT_$creadListPrec -}
16d61d06081f347fd36865d448a9e38e
  $fReadVOT1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.VOT] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.VOT] -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.VOT
                   PhonemeType.$fReadVOT2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.VOT>_R))
                   @ b
                   eta1) -}
16d61d06081f347fd36865d448a9e38e
  $fReadVOT2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.VOT
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.VOT
                   PhonemeType.$fReadMaybeImpossible35
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.VOT>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.VOT>_R)))) -}
16d61d06081f347fd36865d448a9e38e
  $fReadVOT_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PhonemeType.VOT]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVOT1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.VOT]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.VOT]>_R))) -}
16d61d06081f347fd36865d448a9e38e
  $fReadVOT_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VOT
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVOT2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.VOT>_R)) -}
16d61d06081f347fd36865d448a9e38e
  $fReadVOT_$s$dmreadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS PhonemeType.VOT
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ PhonemeType.VOT
                   PhonemeType.$fReadVOT_$creadPrec
                   eta) -}
16d61d06081f347fd36865d448a9e38e
  $fReadVOT_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.VOT]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.VOT]
                   ((PhonemeType.$fReadVOT_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.VOT]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <[PhonemeType.VOT]>_R)
                      @ [PhonemeType.VOT]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.VOT]))) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fReadVowelFeatures :: GHC.Read.Read PhonemeType.VowelFeatures
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VowelFeatures
                  PhonemeType.$fReadVowelFeatures_$creadsPrec
                  PhonemeType.$fReadVowelFeatures_$sreadListDefault
                  PhonemeType.$fReadVowelFeatures_$creadPrec
                  PhonemeType.$fReadVowelFeatures_$creadListPrec -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fReadVowelFeatures1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.VowelFeatures] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.VowelFeatures]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.VowelFeatures
                   PhonemeType.$fReadVowelFeatures2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.VowelFeatures>_R))
                   @ b
                   eta1) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fReadVowelFeatures2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP PhonemeType.VowelFeatures
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.VowelFeatures
                   PhonemeType.$fReadVowelFeatures3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.VowelFeatures>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.VowelFeatures>_R)))) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fReadVowelFeatures3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.VowelFeatures -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.VowelFeatures
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$wa4 ww1 @ b w1 }) -}
de5feaa368b0763e13d665742a85ee00
  $fReadVowelFeaturesContour ::
    GHC.Read.Read PhonemeType.VowelFeaturesContour
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VowelFeaturesContour
                  PhonemeType.$fReadVowelFeaturesContour_$creadsPrec
                  PhonemeType.$fReadVowelFeaturesContour_$sreadListDefault
                  PhonemeType.$fReadVowelFeaturesContour_$creadPrec
                  PhonemeType.$fReadVowelFeaturesContour_$creadListPrec -}
de5feaa368b0763e13d665742a85ee00
  $fReadVowelFeaturesContour1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PhonemeType.VowelFeaturesContour]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [PhonemeType.VowelFeaturesContour]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ PhonemeType.VowelFeaturesContour
                   PhonemeType.$fReadVowelFeaturesContour2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <PhonemeType.VowelFeaturesContour>_R))
                   @ b
                   eta1) -}
de5feaa368b0763e13d665742a85ee00
  $fReadVowelFeaturesContour2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         PhonemeType.VowelFeaturesContour
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ PhonemeType.VowelFeaturesContour
                   PhonemeType.$fReadVowelFeaturesContour3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <PhonemeType.VowelFeaturesContour>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <PhonemeType.VowelFeaturesContour>_R)))) -}
de5feaa368b0763e13d665742a85ee00
  $fReadVowelFeaturesContour3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PhonemeType.VowelFeaturesContour
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: PhonemeType.VowelFeaturesContour
                         -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 PhonemeType.$wa7 ww1 @ b w1 }) -}
de5feaa368b0763e13d665742a85ee00
  $fReadVowelFeaturesContour_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.VowelFeaturesContour]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVowelFeaturesContour1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.VowelFeaturesContour]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.VowelFeaturesContour]>_R))) -}
de5feaa368b0763e13d665742a85ee00
  $fReadVowelFeaturesContour_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      PhonemeType.VowelFeaturesContour
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVowelFeaturesContour2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.VowelFeaturesContour>_R)) -}
de5feaa368b0763e13d665742a85ee00
  $fReadVowelFeaturesContour_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         PhonemeType.VowelFeaturesContour
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.VowelFeaturesContour
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.VowelFeaturesContour
                       PhonemeType.$fReadVowelFeaturesContour3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.VowelFeaturesContour>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.VowelFeaturesContour>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.VowelFeaturesContour>_R)
                      @ PhonemeType.VowelFeaturesContour
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.VowelFeaturesContour))) -}
de5feaa368b0763e13d665742a85ee00
  $fReadVowelFeaturesContour_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS
      [PhonemeType.VowelFeaturesContour]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.VowelFeaturesContour]
                   ((PhonemeType.$fReadVowelFeaturesContour_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.VowelFeaturesContour]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.VowelFeaturesContour]>_R)
                      @ [PhonemeType.VowelFeaturesContour]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.VowelFeaturesContour]))) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fReadVowelFeatures_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec
      [PhonemeType.VowelFeatures]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVowelFeatures1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[PhonemeType.VowelFeatures]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[PhonemeType.VowelFeatures]>_R))) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fReadVowelFeatures_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PhonemeType.VowelFeatures
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                PhonemeType.$fReadVowelFeatures2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <PhonemeType.VowelFeatures>_R)) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fReadVowelFeatures_$creadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS PhonemeType.VowelFeatures
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ PhonemeType.VowelFeatures
                   ((GHC.Read.$fReadDouble10
                       @ PhonemeType.VowelFeatures
                       PhonemeType.$fReadVowelFeatures3
                         `cast`
                       (Trans
                            (<Text.ParserCombinators.ReadPrec.Prec>_R
                             ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                           <PhonemeType.VowelFeatures>_R))
                            (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                      <PhonemeType.VowelFeatures>_R)))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <PhonemeType.VowelFeatures>_R)
                      @ PhonemeType.VowelFeatures
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ PhonemeType.VowelFeatures))) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fReadVowelFeatures_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [PhonemeType.VowelFeatures]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [PhonemeType.VowelFeatures]
                   ((PhonemeType.$fReadVowelFeatures_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[PhonemeType.VowelFeatures]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[PhonemeType.VowelFeatures]>_R)
                      @ [PhonemeType.VowelFeatures]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [PhonemeType.VowelFeatures]))) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fShowActiveArticulator ::
    GHC.Show.Show PhonemeType.ActiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ActiveArticulator
                  PhonemeType.$fShowActiveArticulator_$cshowsPrec
                  PhonemeType.$fShowActiveArticulator_$cshow
                  PhonemeType.$fShowActiveArticulator_$cshowList -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fShowActiveArticulator_$cshow ::
    PhonemeType.ActiveArticulator -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.ActiveArticulator ->
                 PhonemeType.$fShowActiveArticulator_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fShowActiveArticulator_$cshowList ::
    [PhonemeType.ActiveArticulator] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.ActiveArticulator
                   PhonemeType.$w$cshowsPrec) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $fShowActiveArticulator_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.ActiveArticulator -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.ActiveArticulator
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec w1 w2) -}
483edd05f8d1cf327b30114f3225d3b2
  $fShowAirEscape :: GHC.Show.Show PhonemeType.AirEscape
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.AirEscape
                  PhonemeType.$fShowAirEscape_$cshowsPrec
                  PhonemeType.$fShowAirEscape_$cshow
                  PhonemeType.$fShowAirEscape_$cshowList -}
483edd05f8d1cf327b30114f3225d3b2
  $fShowAirEscape1 :: PhonemeType.AirEscape -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.AirEscape eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.NASALIZED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadAirEscape11)
                        eta
                   PhonemeType.ORAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadAirEscape8)
                        eta }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fShowAirEscape_$cshow :: PhonemeType.AirEscape -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.AirEscape ->
                 case x of wild {
                   PhonemeType.NASALIZED -> PhonemeType.$fReadAirEscape11
                   PhonemeType.ORAL -> PhonemeType.$fReadAirEscape8 }) -}
483edd05f8d1cf327b30114f3225d3b2
  $fShowAirEscape_$cshowList ::
    [PhonemeType.AirEscape] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.AirEscape
                   PhonemeType.$fShowAirEscape1) -}
483edd05f8d1cf327b30114f3225d3b2
  $fShowAirEscape_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.AirEscape -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType.AirEscape
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType.NASALIZED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadAirEscape11)
                        eta
                   PhonemeType.ORAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadAirEscape8)
                        eta }) -}
355bf06edf14b009f06abed2ef70f036
  $fShowAirstream :: GHC.Show.Show PhonemeType.Airstream
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Airstream
                  PhonemeType.$fShowAirstream_$cshowsPrec
                  PhonemeType.$fShowAirstream_$cshow
                  PhonemeType.$fShowAirstream_$cshowList -}
355bf06edf14b009f06abed2ef70f036
  $fShowAirstream1 :: PhonemeType.Airstream -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType.Airstream w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType.Airstream ww1 ww2 ->
                 PhonemeType.$w$cshowsPrec1 0 ww1 ww2 w1 }) -}
477c8e0fc8dc78c8a048d09270d7be21
  $fShowAirstream2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Airstream {"#) -}
e3484c2743fd494f0bed88fa6064ad9b
  $fShowAirstream3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
e982cc20557d976a7ae5dfcf8cd49b71
  $fShowAirstream4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Specified "#) -}
c5e7f074b625dfb6bd3f395dd609a3d9
  $fShowAirstream5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "direction = "#) -}
a60887ecc1ae8d79575df2fb24a2385e
  $fShowAirstream6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
573ab742dc9db33e62905b5437c5dcbe
  $fShowAirstream7 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
0a9be41d55940c9349c863d5cb146bb8
  $fShowAirstream8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "initiator = "#) -}
355bf06edf14b009f06abed2ef70f036
  $fShowAirstream_$cshow :: PhonemeType.Airstream -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Airstream ->
                 PhonemeType.$fShowAirstream_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
355bf06edf14b009f06abed2ef70f036
  $fShowAirstream_$cshowList ::
    [PhonemeType.Airstream] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Airstream
                   PhonemeType.$fShowAirstream1) -}
355bf06edf14b009f06abed2ef70f036
  $fShowAirstream_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Airstream -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Airstream
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.Airstream ww3 ww4 ->
                 PhonemeType.$w$cshowsPrec1 ww1 ww3 ww4 w2 } }) -}
c8c9dbb9f561a555b4e4cf6cc619b39a
  $fShowAirstream_$s$cshowsPrec ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Direction
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Direction
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType.$fShowAirstream4
                            (case b1 of wild2 {
                               PhonemeType.INGRESSIVE
                               -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadDirection11 x1
                               PhonemeType.EGRESSIVE
                               -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadDirection8 x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
bfba7b6d17ba58e378aa91fb42b42407
  $fShowAirstream_$s$cshowsPrec1 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Initiator
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Initiator
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ eta1 :: GHC.Base.String[OneShot] ->
                          case b1 of wild2 {
                            PhonemeType.LINGUAL
                            -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadInitiator15 eta1
                            PhonemeType.GLOTTIC
                            -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadInitiator12 eta1
                            PhonemeType.PULMONIC
                            -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadInitiator9 eta1 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
4600283dc79ec1a04339fecb849d3137
  $fShowBackness :: GHC.Show.Show PhonemeType.Backness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Backness
                  PhonemeType.$fShowBackness_$cshowsPrec
                  PhonemeType.$fShowBackness_$cshow
                  PhonemeType.$fShowBackness_$cshowList -}
4600283dc79ec1a04339fecb849d3137
  $fShowBackness_$cshow :: PhonemeType.Backness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Backness ->
                 PhonemeType.$fShowBackness_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4600283dc79ec1a04339fecb849d3137
  $fShowBackness_$cshowList ::
    [PhonemeType.Backness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Backness
                   PhonemeType.$w$cshowsPrec2) -}
4600283dc79ec1a04339fecb849d3137
  $fShowBackness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Backness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Backness
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec2 w1 w2) -}
62312b673b3cb46a867844b1181e8c1b
  $fShowConsonantFeatures ::
    GHC.Show.Show PhonemeType.ConsonantFeatures
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ConsonantFeatures
                  PhonemeType.$fShowConsonantFeatures_$cshowsPrec
                  PhonemeType.$fShowConsonantFeatures_$cshow
                  PhonemeType.$fShowConsonantFeatures_$cshowList -}
62312b673b3cb46a867844b1181e8c1b
  $fShowConsonantFeatures1 ::
    PhonemeType.ConsonantFeatures -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType.ConsonantFeatures
                   w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType.ConsonantFeatures ww1 ww2 ww3 ww4 ->
                 PhonemeType.$w$cshowsPrec3 0 ww1 ww2 ww3 ww4 w1 }) -}
1948e9e73a47dc80569dd8d76a030f32
  $fShowConsonantFeatures2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "ConsonantFeatures {"#) -}
bde87d6181dc4d4d4f74467f6d66c65d
  $fShowConsonantFeatures3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "phonation = "#) -}
66cd9ab720cda9b7932960aa8a4f3997
  $fShowConsonantFeatures4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "airstream = "#) -}
5f4a48db7425b45b757e8709daaf0ed8
  $fShowConsonantFeatures5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "manner = "#) -}
c51eaabf5880da95c702f5017865ea0c
  $fShowConsonantFeatures6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Place {"#) -}
614022d982316cd6b6d0ed21e45f4aa6
  $fShowConsonantFeatures7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "passive = "#) -}
287209aebe85566c460605be834551ea
  $fShowConsonantFeatures8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "active = "#) -}
39c83dfed8863f2db295eda9748cd4ed
  $fShowConsonantFeatures9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "place = "#) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fShowConsonantFeaturesContour ::
    GHC.Show.Show PhonemeType.ConsonantFeaturesContour
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.ConsonantFeaturesContour
                  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec1
                  PhonemeType.$fShowConsonantFeaturesContour_$cshow
                  PhonemeType.$fShowConsonantFeaturesContour_$cshowList -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fShowConsonantFeaturesContour1 ::
    PhonemeType.ConsonantFeaturesContour -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: PhonemeType.ConsonantFeaturesContour ->
                 case w of ww { PhonemeType.ConsonantFeaturesContour ww1 ww2 ->
                 PhonemeType.$w$cshowsPrec8 0 ww1 ww2 }) -}
57b0c405194aacc2f98b40ca6cb8ba47
  $fShowConsonantFeaturesContour2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "secondCContour = "#) -}
7c1719fa62b4a8e3fa4a2bfb9e93ac77
  $fShowConsonantFeaturesContour3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "firstCContour = "#) -}
68f87f3a452735f838e71947bd69b26d
  $fShowConsonantFeaturesContour4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "ConsonantFeaturesContour {"#) -}
c4c4b3d144b6dcde4d6cbfc5344d312b
  $fShowConsonantFeaturesContour5 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   PhonemeType.$fReadMaybeBlank5) -}
83e2b98ae8e915f30eb06d8d60ac8ce1
  $fShowConsonantFeaturesContour6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Filled "#) -}
d578513ec0165938bb0bbc8499a65f97
  $fShowConsonantFeaturesContour7 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   PhonemeType.$fReadMaybeBlank10) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fShowConsonantFeaturesContour_$cshow ::
    PhonemeType.ConsonantFeaturesContour -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U,U,U,U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.ConsonantFeaturesContour ->
                 PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fShowConsonantFeaturesContour_$cshowList ::
    [PhonemeType.ConsonantFeaturesContour] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.ConsonantFeaturesContour
                   PhonemeType.$fShowConsonantFeaturesContour1) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fShowConsonantFeaturesContour_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> PhonemeType.MaybeUnspecified a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   a24 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified a23 ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a24 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a23 $dShow PhonemeType.$fReadMaybeBlank4 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++ @ GHC.Types.Char PhonemeType.$fShowAirstream4 (g x1)
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))) } }
                   PhonemeType.Unspecified
                   -> PhonemeType.$fShowConsonantFeaturesContour7 }) -}
0fafe33c29b0b10fbc3af36aea570fe2
  $fShowConsonantFeaturesContour_$cshowsPrec1 ::
    GHC.Types.Int
    -> PhonemeType.ConsonantFeaturesContour -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(U(U,U,U,U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: PhonemeType.ConsonantFeaturesContour ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.ConsonantFeaturesContour ww3 ww4 ->
                 PhonemeType.$w$cshowsPrec8 ww1 ww3 ww4 } }) -}
4aee2bafc948e0274894642cd72fce58
  $fShowConsonantFeaturesContour_$s$cshowsPrec ::
    GHC.Types.Int
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures)
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeBlank
                           (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures) ->
                 case ds of wild {
                   PhonemeType.Filled b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec
                            @ PhonemeType.ConsonantFeatures
                            PhonemeType.$fShowConsonantFeatures
                            PhonemeType.$fReadMaybeBlank4
                            b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowConsonantFeaturesContour6
                             (g x1)
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowConsonantFeaturesContour6
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))) } }
                   PhonemeType.Blank
                   -> PhonemeType.$fShowConsonantFeaturesContour5 }) -}
4869b32ec09764acd8dcd614a93dda84
  $fShowConsonantFeaturesContour_$s$cshowsPrec1 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Stricture
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Stricture
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ eta1 :: GHC.Base.String[OneShot] ->
                          case b1 of wild2 {
                            PhonemeType.OCCLUSION
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType.$fReadMaybeUnspecified78
                                 eta1
                            PhonemeType.TURBULENT
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType.$fReadMaybeUnspecified75
                                 eta1
                            PhonemeType.SLIGHTTURBULENT
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType.$fReadMaybeUnspecified72
                                 eta1 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
e9b83351af10388f4ba8ae3b590a8d96
  $fShowConsonantFeaturesContour_$s$cshowsPrec10 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Roundedness
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Roundedness
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType.$fShowAirstream4
                            (case b1 of wild2 {
                               PhonemeType.UNROUNDED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType.$fReadMaybeUnspecified134
                                    x1
                               PhonemeType.ROUNDED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType.$fReadMaybeUnspecified131
                                    x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
7548cdab3d607ee6d5db0627dc47b948
  $fShowConsonantFeaturesContour_$s$cshowsPrec2 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Trill -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Trill
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType.$fShowAirstream4
                            (case b1 of wild2 {
                               PhonemeType.TRILLED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType.$fReadMaybeImpossible16
                                    x1
                               PhonemeType.NOTTRILLED
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType.$fReadMaybeImpossible13
                                    x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
8c4d452fe4f72d7a725ee601e6cd58a9
  $fShowConsonantFeaturesContour_$s$cshowsPrec3 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Length
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ eta1 :: GHC.Base.String[OneShot] ->
                          case b1 of wild2 {
                            PhonemeType.SHORT
                            -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadLength15 eta1
                            PhonemeType.NORMAL
                            -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadLength12 eta1
                            PhonemeType.LONG
                            -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadLength9 eta1 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
1f1ddbf6d4c575532b69ca021a971568
  $fShowConsonantFeaturesContour_$s$cshowsPrec4 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Laterality
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Laterality
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType.$fShowAirstream4
                            (case b1 of wild2 {
                               PhonemeType.LATERAL
                               -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadLaterality11 x1
                               PhonemeType.NONLATERAL
                               -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadLaterality8 x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
275f1ce47f33bc7f6ec2d2a1b2a27e99
  $fShowConsonantFeaturesContour_$s$cshowsPrec5 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Silibance
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Silibance
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType.$fShowAirstream4
                            (case b1 of wild2 {
                               PhonemeType.SILIBANT
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType.$fReadMaybeImpossible31
                                    x1
                               PhonemeType.NONSILIBANT
                               -> GHC.Base.++
                                    @ GHC.Types.Char
                                    PhonemeType.$fReadMaybeImpossible28
                                    x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
9130dceedffde9c6ef4ccabe3ee67be5
  $fShowConsonantFeaturesContour_$s$cshowsPrec6 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.AirEscape
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            PhonemeType.$fShowAirstream4
                            (case b1 of wild2 {
                               PhonemeType.NASALIZED
                               -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadAirEscape11 x1
                               PhonemeType.ORAL
                               -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadAirEscape8 x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
3b50cadb9a92268b58193f1752991238
  $fShowConsonantFeaturesContour_$s$cshowsPrec7 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.VOT -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.VOT
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                          {- Arity: 1, Strictness: <L,1*U> -}
                        = \ eta1 :: GHC.Base.String[OneShot] ->
                          case b1 of wild2 {
                            PhonemeType.POSITIVE
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType.$fReadMaybeImpossible47
                                 eta1
                            PhonemeType.ZERO
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType.$fReadMaybeImpossible44
                                 eta1
                            PhonemeType.NEGATIVE
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 PhonemeType.$fReadMaybeImpossible41
                                 eta1 }
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (g eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
525880050113b0e0d72d9eab86e7181d
  $fShowConsonantFeaturesContour_$s$cshowsPrec8 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Height
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Height
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (PhonemeType.$w$cshowsPrec9 b1 eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (PhonemeType.$w$cshowsPrec9
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
2ca2d7b9acbbf9cb8286fd5681b3a36c
  $fShowConsonantFeaturesContour_$s$cshowsPrec9 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Backness
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Backness
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (PhonemeType.$w$cshowsPrec2 b1 eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (PhonemeType.$w$cshowsPrec2
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
62312b673b3cb46a867844b1181e8c1b
  $fShowConsonantFeatures_$cshow ::
    PhonemeType.ConsonantFeatures -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.ConsonantFeatures ->
                 PhonemeType.$fShowConsonantFeatures_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
62312b673b3cb46a867844b1181e8c1b
  $fShowConsonantFeatures_$cshowList ::
    [PhonemeType.ConsonantFeatures] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.ConsonantFeatures
                   PhonemeType.$fShowConsonantFeatures1) -}
62312b673b3cb46a867844b1181e8c1b
  $fShowConsonantFeatures_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.ConsonantFeatures -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.ConsonantFeatures
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.ConsonantFeatures ww3 ww4 ww5 ww6 ->
                 PhonemeType.$w$cshowsPrec3 ww1 ww3 ww4 ww5 ww6 w2 } }) -}
49c921eeb55dcc0f888d8f005c6900a9
  $fShowConsonantFeatures_$s$cshowsPrec ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Phonation
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (PhonemeType.$w$cshowsPrec4 b1 eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (PhonemeType.$w$cshowsPrec4
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
f873130afbafef25b409cc590f2a5e69
  $fShowConsonantFeatures_$s$cshowsPrec1 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Airstream
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (case b1 of ww { PhonemeType.Airstream ww1 ww2 ->
                              PhonemeType.$w$cshowsPrec1 11 ww1 ww2 eta })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (case b1 of ww { PhonemeType.Airstream ww1 ww2 ->
                                 PhonemeType.$w$cshowsPrec1
                                   11
                                   ww1
                                   ww2
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta) })) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
50995ed739b71c704e2c2b08fb8fba21
  $fShowConsonantFeatures_$s$cshowsPrec2 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Manner
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Manner
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (case b1 of ww { PhonemeType.Manner ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                              PhonemeType.$w$cshowsPrec5 11 ww1 ww2 ww3 ww4 ww5 ww6 ww7 eta })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (case b1 of ww { PhonemeType.Manner ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                                 PhonemeType.$w$cshowsPrec5
                                   11
                                   ww1
                                   ww2
                                   ww3
                                   ww4
                                   ww5
                                   ww6
                                   ww7
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta) })) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
646db69072a75b72e149bd2c8ed2b2b5
  $fShowConsonantFeatures_$s$cshowsPrec3 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.Place -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.Place
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (case b1 of ww { PhonemeType.Place ww1 ww2 ->
                              PhonemeType.$w$cshowsPrec6 11 ww1 ww2 eta })
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (case b1 of ww { PhonemeType.Place ww1 ww2 ->
                                 PhonemeType.$w$cshowsPrec6
                                   11
                                   ww1
                                   ww2
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta) })) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
14d9eeb7a3bd52883534134c588a11e7
  $fShowConsonantFeatures_$s$cshowsPrec4 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.PassiveArticulator
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.PassiveArticulator
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (PhonemeType.$w$cshowsPrec7 b1 eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (PhonemeType.$w$cshowsPrec7
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
a51af0a86d9d882e318fcd2d6085fea7
  $fShowConsonantFeatures_$s$cshowsPrec5 ::
    GHC.Types.Int
    -> PhonemeType.MaybeUnspecified PhonemeType.ActiveArticulator
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeUnspecified PhonemeType.ActiveArticulator
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Specified b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream4
                             (PhonemeType.$w$cshowsPrec b1 eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream4
                                (PhonemeType.$w$cshowsPrec
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Unspecified
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeBlank10
                        eta }) -}
40a9c5f987e37783909145cb5997138e
  $fShowDirection :: GHC.Show.Show PhonemeType.Direction
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Direction
                  PhonemeType.$fShowDirection_$cshowsPrec
                  PhonemeType.$fShowDirection_$cshow
                  PhonemeType.$fShowDirection_$cshowList -}
40a9c5f987e37783909145cb5997138e
  $fShowDirection1 :: PhonemeType.Direction -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Direction eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.INGRESSIVE
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadDirection11)
                        eta
                   PhonemeType.EGRESSIVE
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadDirection8)
                        eta }) -}
40a9c5f987e37783909145cb5997138e
  $fShowDirection_$cshow :: PhonemeType.Direction -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Direction ->
                 case x of wild {
                   PhonemeType.INGRESSIVE -> PhonemeType.$fReadDirection11
                   PhonemeType.EGRESSIVE -> PhonemeType.$fReadDirection8 }) -}
40a9c5f987e37783909145cb5997138e
  $fShowDirection_$cshowList ::
    [PhonemeType.Direction] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Direction
                   PhonemeType.$fShowDirection1) -}
40a9c5f987e37783909145cb5997138e
  $fShowDirection_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Direction -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType.Direction
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType.INGRESSIVE
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadDirection11)
                        eta
                   PhonemeType.EGRESSIVE
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadDirection8)
                        eta }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fShowHeight :: GHC.Show.Show PhonemeType.Height
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Height
                  PhonemeType.$fShowHeight_$cshowsPrec
                  PhonemeType.$fShowHeight_$cshow
                  PhonemeType.$fShowHeight_$cshowList -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fShowHeight_$cshow :: PhonemeType.Height -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Height ->
                 PhonemeType.$fShowHeight_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fShowHeight_$cshowList :: [PhonemeType.Height] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Height
                   PhonemeType.$w$cshowsPrec9) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $fShowHeight_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Height -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Height
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec9 w1 w2) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fShowInitiator :: GHC.Show.Show PhonemeType.Initiator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Initiator
                  PhonemeType.$fShowInitiator_$cshowsPrec
                  PhonemeType.$fShowInitiator_$cshow
                  PhonemeType.$fShowInitiator_$cshowList -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fShowInitiator_$cshow :: PhonemeType.Initiator -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Initiator ->
                 case x of wild {
                   PhonemeType.LINGUAL -> PhonemeType.$fReadInitiator15
                   PhonemeType.GLOTTIC -> PhonemeType.$fReadInitiator12
                   PhonemeType.PULMONIC -> PhonemeType.$fReadInitiator9 }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fShowInitiator_$cshowList ::
    [PhonemeType.Initiator] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Initiator
                   PhonemeType.$w$cshowsPrec10) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $fShowInitiator_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Initiator -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Initiator
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec10 w1 w2) -}
563547f95f31ce703bd3964698c86217
  $fShowLaterality :: GHC.Show.Show PhonemeType.Laterality
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Laterality
                  PhonemeType.$fShowLaterality_$cshowsPrec
                  PhonemeType.$fShowLaterality_$cshow
                  PhonemeType.$fShowLaterality_$cshowList -}
563547f95f31ce703bd3964698c86217
  $fShowLaterality1 :: PhonemeType.Laterality -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Laterality eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.LATERAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadLaterality11)
                        eta
                   PhonemeType.NONLATERAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadLaterality8)
                        eta }) -}
563547f95f31ce703bd3964698c86217
  $fShowLaterality_$cshow ::
    PhonemeType.Laterality -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Laterality ->
                 case x of wild {
                   PhonemeType.LATERAL -> PhonemeType.$fReadLaterality11
                   PhonemeType.NONLATERAL -> PhonemeType.$fReadLaterality8 }) -}
563547f95f31ce703bd3964698c86217
  $fShowLaterality_$cshowList ::
    [PhonemeType.Laterality] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Laterality
                   PhonemeType.$fShowLaterality1) -}
563547f95f31ce703bd3964698c86217
  $fShowLaterality_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Laterality -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType.Laterality
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType.LATERAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadLaterality11)
                        eta
                   PhonemeType.NONLATERAL
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadLaterality8)
                        eta }) -}
355f724f9de26105f3758df52d82fae4
  $fShowLength :: GHC.Show.Show PhonemeType.Length
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Length
                  PhonemeType.$fShowLength_$cshowsPrec
                  PhonemeType.$fShowLength_$cshow
                  PhonemeType.$fShowLength_$cshowList -}
355f724f9de26105f3758df52d82fae4
  $fShowLength_$cshow :: PhonemeType.Length -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Length ->
                 case x of wild {
                   PhonemeType.SHORT -> PhonemeType.$fReadLength15
                   PhonemeType.NORMAL -> PhonemeType.$fReadLength12
                   PhonemeType.LONG -> PhonemeType.$fReadLength9 }) -}
355f724f9de26105f3758df52d82fae4
  $fShowLength_$cshowList :: [PhonemeType.Length] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Length
                   PhonemeType.$w$cshowsPrec11) -}
355f724f9de26105f3758df52d82fae4
  $fShowLength_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Length -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Length
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec11 w1 w2) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fShowManner :: GHC.Show.Show PhonemeType.Manner
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Manner
                  PhonemeType.$fShowManner_$cshowsPrec
                  PhonemeType.$fShowManner_$cshow
                  PhonemeType.$fShowManner_$cshowList -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fShowManner1 :: PhonemeType.Manner -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType.Manner w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType.Manner ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 PhonemeType.$w$cshowsPrec5 0 ww1 ww2 ww3 ww4 ww5 ww6 ww7 w1 }) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fShowManner_$cshow :: PhonemeType.Manner -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Manner ->
                 PhonemeType.$fShowManner_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fShowManner_$cshowList :: [PhonemeType.Manner] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Manner
                   PhonemeType.$fShowManner1) -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $fShowManner_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Manner -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Manner
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.Manner ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$cshowsPrec5
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   w2 } }) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fShowMaybeBlank ::
    GHC.Show.Show a => GHC.Show.Show (PhonemeType.MaybeBlank a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dShow :: GHC.Show.Show a23.
                  @ (PhonemeType.MaybeBlank a23)
                  (PhonemeType.$fShowMaybeBlank_$cshowsPrec @ a23 $dShow)
                  (PhonemeType.$fShowMaybeBlank_$cshow @ a23 $dShow)
                  (PhonemeType.$fShowMaybeBlank_$cshowList @ a23 $dShow) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fShowMaybeBlank_$cshow ::
    GHC.Show.Show a => PhonemeType.MaybeBlank a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   x :: PhonemeType.MaybeBlank a23 ->
                 case x of wild {
                   PhonemeType.Filled b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowConsonantFeaturesContour6
                        (GHC.Show.showsPrec
                           @ a23
                           $dShow
                           PhonemeType.$fReadMaybeBlank4
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   PhonemeType.Blank -> PhonemeType.$fReadMaybeBlank5 }) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fShowMaybeBlank_$cshowList ::
    GHC.Show.Show a => [PhonemeType.MaybeBlank a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   eta :: [PhonemeType.MaybeBlank a23]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (PhonemeType.MaybeBlank a23)
                   (PhonemeType.$fShowMaybeBlank_$cshowsPrec
                      @ a23
                      $dShow
                      PhonemeType.$fShowAirstream7)
                   eta
                   eta1) -}
f37f61cc99a3307d20aa8b2457e6d204
  $fShowMaybeBlank_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> PhonemeType.MaybeBlank a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   a24 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeBlank a23 ->
                 case ds of wild {
                   PhonemeType.Filled b1
                   -> case a24 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a23 $dShow PhonemeType.$fReadMaybeBlank4 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowConsonantFeaturesContour6
                             (g x1)
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowConsonantFeaturesContour6
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))) } }
                   PhonemeType.Blank
                   -> PhonemeType.$fShowConsonantFeaturesContour5 }) -}
55416cce8f2dc04cf1d7d165690a8752
  $fShowMaybeBlank_$s$cshowsPrec ::
    GHC.Types.Int
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures)
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeBlank
                           (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures) ->
                 case ds of wild {
                   PhonemeType.Filled b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec
                            @ PhonemeType.VowelFeatures
                            PhonemeType.$fShowVowelFeatures
                            PhonemeType.$fReadMaybeBlank4
                            b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowConsonantFeaturesContour6
                             (g x1)
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowConsonantFeaturesContour6
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))) } }
                   PhonemeType.Blank
                   -> PhonemeType.$fShowConsonantFeaturesContour5 }) -}
60779ee60a7b7b6d291add8ce22569fb
  $fShowMaybeImpossible ::
    GHC.Show.Show a => GHC.Show.Show (PhonemeType.MaybeImpossible a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dShow :: GHC.Show.Show a23.
                  @ (PhonemeType.MaybeImpossible a23)
                  (PhonemeType.$fShowMaybeImpossible_$cshowsPrec @ a23 $dShow)
                  (PhonemeType.$fShowMaybeImpossible_$cshow @ a23 $dShow)
                  (PhonemeType.$fShowMaybeImpossible_$cshowList @ a23 $dShow) -}
d0c438c5ee0c531f6aa155ab8e9a3ada
  $fShowMaybeImpossible1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Possible "#) -}
e6a9178326374d347836434c179968d4
  $fShowMaybeImpossible2 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   PhonemeType.$fReadMaybeImpossible4) -}
60779ee60a7b7b6d291add8ce22569fb
  $fShowMaybeImpossible_$cshow ::
    GHC.Show.Show a => PhonemeType.MaybeImpossible a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   x :: PhonemeType.MaybeImpossible a23 ->
                 case x of wild {
                   PhonemeType.Possible b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowMaybeImpossible1
                        (GHC.Show.showsPrec
                           @ a23
                           $dShow
                           PhonemeType.$fReadMaybeBlank4
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   PhonemeType.Impossible -> PhonemeType.$fReadMaybeImpossible4 }) -}
60779ee60a7b7b6d291add8ce22569fb
  $fShowMaybeImpossible_$cshowList ::
    GHC.Show.Show a =>
    [PhonemeType.MaybeImpossible a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   eta :: [PhonemeType.MaybeImpossible a23]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (PhonemeType.MaybeImpossible a23)
                   (PhonemeType.$fShowMaybeImpossible_$cshowsPrec
                      @ a23
                      $dShow
                      PhonemeType.$fShowAirstream7)
                   eta
                   eta1) -}
60779ee60a7b7b6d291add8ce22569fb
  $fShowMaybeImpossible_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> PhonemeType.MaybeImpossible a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   a24 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeImpossible a23 ->
                 case ds of wild {
                   PhonemeType.Possible b1
                   -> case a24 of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a23 $dShow PhonemeType.$fReadMaybeBlank4 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowMaybeImpossible1
                             (g x1)
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowMaybeImpossible1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))) } }
                   PhonemeType.Impossible -> PhonemeType.$fShowMaybeImpossible2 }) -}
2555b8c44ae9e7ae7e60e8fc60236fcb
  $fShowMaybeImpossible_$s$cshowsPrec ::
    GHC.Types.Int
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Trill)
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeImpossible
                           (PhonemeType.MaybeUnspecified PhonemeType.Trill)
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Possible b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowMaybeImpossible1
                             (PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec2
                                PhonemeType.$fReadMaybeBlank4
                                b1
                                eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowMaybeImpossible1
                                (PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec2
                                   PhonemeType.$fReadMaybeBlank4
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Impossible
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeImpossible4
                        eta }) -}
aee7356e8d45a70feef8e338086c9fef
  $fShowMaybeImpossible_$s$cshowsPrec1 ::
    GHC.Types.Int
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeImpossible
                           (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Possible b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowMaybeImpossible1
                             (PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec4
                                PhonemeType.$fReadMaybeBlank4
                                b1
                                eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowMaybeImpossible1
                                (PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec4
                                   PhonemeType.$fReadMaybeBlank4
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Impossible
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeImpossible4
                        eta }) -}
ca286372a621e11359fabdf663ed417d
  $fShowMaybeImpossible_$s$cshowsPrec2 ::
    GHC.Types.Int
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeImpossible
                           (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Possible b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowMaybeImpossible1
                             (PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec5
                                PhonemeType.$fReadMaybeBlank4
                                b1
                                eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowMaybeImpossible1
                                (PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec5
                                   PhonemeType.$fReadMaybeBlank4
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Impossible
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeImpossible4
                        eta }) -}
9fde17285b5c1bf5ac84e5a28476e291
  $fShowMaybeImpossible_$s$cshowsPrec3 ::
    GHC.Types.Int
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.VOT)
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a23 :: GHC.Types.Int
                   ds :: PhonemeType.MaybeImpossible
                           (PhonemeType.MaybeUnspecified PhonemeType.VOT)
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.Possible b1
                   -> case a23 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowMaybeImpossible1
                             (PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec7
                                PhonemeType.$fReadMaybeBlank4
                                b1
                                eta)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowMaybeImpossible1
                                (PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec7
                                   PhonemeType.$fReadMaybeBlank4
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta))) } }
                   PhonemeType.Impossible
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeImpossible4
                        eta }) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fShowMaybeUnspecified ::
    GHC.Show.Show a => GHC.Show.Show (PhonemeType.MaybeUnspecified a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a23 $dShow :: GHC.Show.Show a23.
                  @ (PhonemeType.MaybeUnspecified a23)
                  (PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec
                     @ a23
                     $dShow)
                  (PhonemeType.$fShowMaybeUnspecified_$cshow @ a23 $dShow)
                  (PhonemeType.$fShowMaybeUnspecified_$cshowList @ a23 $dShow) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fShowMaybeUnspecified_$cshow ::
    GHC.Show.Show a =>
    PhonemeType.MaybeUnspecified a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   x :: PhonemeType.MaybeUnspecified a23 ->
                 case x of wild {
                   PhonemeType.Specified b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowAirstream4
                        (GHC.Show.showsPrec
                           @ a23
                           $dShow
                           PhonemeType.$fReadMaybeBlank4
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   PhonemeType.Unspecified -> PhonemeType.$fReadMaybeBlank10 }) -}
bd7b9b9f34ce1cb6f20900ef26c31eeb
  $fShowMaybeUnspecified_$cshowList ::
    GHC.Show.Show a =>
    [PhonemeType.MaybeUnspecified a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a23
                   $dShow :: GHC.Show.Show a23
                   eta :: [PhonemeType.MaybeUnspecified a23]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (PhonemeType.MaybeUnspecified a23)
                   (PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec
                      @ a23
                      $dShow
                      PhonemeType.$fShowAirstream7)
                   eta
                   eta1) -}
dcbf3455324a78016700898324489067
  $fShowPassiveArticulator ::
    GHC.Show.Show PhonemeType.PassiveArticulator
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PassiveArticulator
                  PhonemeType.$fShowPassiveArticulator_$cshowsPrec
                  PhonemeType.$fShowPassiveArticulator_$cshow
                  PhonemeType.$fShowPassiveArticulator_$cshowList -}
dcbf3455324a78016700898324489067
  $fShowPassiveArticulator_$cshow ::
    PhonemeType.PassiveArticulator -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.PassiveArticulator ->
                 PhonemeType.$fShowPassiveArticulator_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
dcbf3455324a78016700898324489067
  $fShowPassiveArticulator_$cshowList ::
    [PhonemeType.PassiveArticulator] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.PassiveArticulator
                   PhonemeType.$w$cshowsPrec7) -}
dcbf3455324a78016700898324489067
  $fShowPassiveArticulator_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.PassiveArticulator -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.PassiveArticulator
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec7 w1 w2) -}
1876b99e8b904b79707be731945482ec
  $fShowPhonation :: GHC.Show.Show PhonemeType.Phonation
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Phonation
                  PhonemeType.$fShowPhonation_$cshowsPrec
                  PhonemeType.$fShowPhonation_$cshow
                  PhonemeType.$fShowPhonation_$cshowList -}
1876b99e8b904b79707be731945482ec
  $fShowPhonation_$cshow :: PhonemeType.Phonation -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Phonation ->
                 PhonemeType.$fShowPhonation_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1876b99e8b904b79707be731945482ec
  $fShowPhonation_$cshowList ::
    [PhonemeType.Phonation] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Phonation
                   PhonemeType.$w$cshowsPrec4) -}
1876b99e8b904b79707be731945482ec
  $fShowPhonation_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Phonation -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Phonation
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec4 w1 w2) -}
d63366b958aa268c953fb9cc54988074
  $fShowPhonemeInventory ::
    GHC.Show.Show PhonemeType.PhonemeInventory
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.PhonemeInventory
                  PhonemeType.$fShowPhonemeInventory_$cshowsPrec
                  PhonemeType.$fShowPhonemeInventory_$cshow
                  PhonemeType.$fShowPhonemeInventory_$cshowList -}
d63366b958aa268c953fb9cc54988074
  $fShowPhonemeInventory1 ::
    PhonemeType.PhonemeInventory -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType.PhonemeInventory
                   w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType.PhonemeInventory ww1 ->
                 PhonemeType.$w$cshowsPrec13 0 ww1 w1 }) -}
fdefc0ea71827958bbc14b4349c33f03
  $fShowPhonemeInventory2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PhonemeInventory "#) -}
d63366b958aa268c953fb9cc54988074
  $fShowPhonemeInventory_$cshow ::
    PhonemeType.PhonemeInventory -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.PhonemeInventory ->
                 PhonemeType.$fShowPhonemeInventory_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d63366b958aa268c953fb9cc54988074
  $fShowPhonemeInventory_$cshowList ::
    [PhonemeType.PhonemeInventory] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.PhonemeInventory
                   PhonemeType.$fShowPhonemeInventory1) -}
d63366b958aa268c953fb9cc54988074
  $fShowPhonemeInventory_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.PhonemeInventory -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.PhonemeInventory
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.PhonemeInventory ww3 ->
                 PhonemeType.$w$cshowsPrec13 ww1 ww3 w2 } }) -}
95417ac7dbeb758b510442ae50c858cb
  $fShowPlace :: GHC.Show.Show PhonemeType.Place
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Place
                  PhonemeType.$fShowPlace_$cshowsPrec
                  PhonemeType.$fShowPlace_$cshow
                  PhonemeType.$fShowPlace_$cshowList -}
95417ac7dbeb758b510442ae50c858cb
  $fShowPlace1 :: PhonemeType.Place -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType.Place w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType.Place ww1 ww2 ->
                 PhonemeType.$w$cshowsPrec6 0 ww1 ww2 w1 }) -}
95417ac7dbeb758b510442ae50c858cb
  $fShowPlace_$cshow :: PhonemeType.Place -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Place ->
                 PhonemeType.$fShowPlace_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
95417ac7dbeb758b510442ae50c858cb
  $fShowPlace_$cshowList :: [PhonemeType.Place] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Place
                   PhonemeType.$fShowPlace1) -}
95417ac7dbeb758b510442ae50c858cb
  $fShowPlace_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Place -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Place
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.Place ww3 ww4 ->
                 PhonemeType.$w$cshowsPrec6 ww1 ww3 ww4 w2 } }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fShowRoundedness :: GHC.Show.Show PhonemeType.Roundedness
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Roundedness
                  PhonemeType.$fShowRoundedness_$cshowsPrec
                  PhonemeType.$fShowRoundedness_$cshow
                  PhonemeType.$fShowRoundedness_$cshowList -}
9c915b50edb2977ec86c27bd6c240a83
  $fShowRoundedness1 :: PhonemeType.Roundedness -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Roundedness eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.UNROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeUnspecified134)
                        eta
                   PhonemeType.ROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeUnspecified131)
                        eta }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fShowRoundedness_$cshow ::
    PhonemeType.Roundedness -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Roundedness ->
                 case x of wild {
                   PhonemeType.UNROUNDED -> PhonemeType.$fReadMaybeUnspecified134
                   PhonemeType.ROUNDED -> PhonemeType.$fReadMaybeUnspecified131 }) -}
9c915b50edb2977ec86c27bd6c240a83
  $fShowRoundedness_$cshowList ::
    [PhonemeType.Roundedness] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Roundedness
                   PhonemeType.$fShowRoundedness1) -}
9c915b50edb2977ec86c27bd6c240a83
  $fShowRoundedness_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Roundedness -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType.Roundedness
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType.UNROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeUnspecified134)
                        eta
                   PhonemeType.ROUNDED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeUnspecified131)
                        eta }) -}
1940ee84f46a7a0f1801689311b6be65
  $fShowSilibance :: GHC.Show.Show PhonemeType.Silibance
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Silibance
                  PhonemeType.$fShowSilibance_$cshowsPrec
                  PhonemeType.$fShowSilibance_$cshow
                  PhonemeType.$fShowSilibance_$cshowList -}
1940ee84f46a7a0f1801689311b6be65
  $fShowSilibance1 :: PhonemeType.Silibance -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Silibance eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.SILIBANT
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeImpossible31)
                        eta
                   PhonemeType.NONSILIBANT
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeImpossible28)
                        eta }) -}
1940ee84f46a7a0f1801689311b6be65
  $fShowSilibance_$cshow :: PhonemeType.Silibance -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Silibance ->
                 case x of wild {
                   PhonemeType.SILIBANT -> PhonemeType.$fReadMaybeImpossible31
                   PhonemeType.NONSILIBANT
                   -> PhonemeType.$fReadMaybeImpossible28 }) -}
1940ee84f46a7a0f1801689311b6be65
  $fShowSilibance_$cshowList ::
    [PhonemeType.Silibance] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Silibance
                   PhonemeType.$fShowSilibance1) -}
1940ee84f46a7a0f1801689311b6be65
  $fShowSilibance_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Silibance -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType.Silibance
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType.SILIBANT
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeImpossible31)
                        eta
                   PhonemeType.NONSILIBANT
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeImpossible28)
                        eta }) -}
f45b7454df7117690624094b2e33986b
  $fShowStricture :: GHC.Show.Show PhonemeType.Stricture
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Stricture
                  PhonemeType.$fShowStricture_$cshowsPrec
                  PhonemeType.$fShowStricture_$cshow
                  PhonemeType.$fShowStricture_$cshowList -}
f45b7454df7117690624094b2e33986b
  $fShowStricture_$cshow :: PhonemeType.Stricture -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Stricture ->
                 case x of wild {
                   PhonemeType.OCCLUSION -> PhonemeType.$fReadMaybeUnspecified78
                   PhonemeType.TURBULENT -> PhonemeType.$fReadMaybeUnspecified75
                   PhonemeType.SLIGHTTURBULENT
                   -> PhonemeType.$fReadMaybeUnspecified72 }) -}
f45b7454df7117690624094b2e33986b
  $fShowStricture_$cshowList ::
    [PhonemeType.Stricture] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Stricture
                   PhonemeType.$w$cshowsPrec14) -}
f45b7454df7117690624094b2e33986b
  $fShowStricture_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Stricture -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.Stricture
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec14 w1 w2) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fShowTrill :: GHC.Show.Show PhonemeType.Trill
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.Trill
                  PhonemeType.$fShowTrill_$cshowsPrec
                  PhonemeType.$fShowTrill_$cshow
                  PhonemeType.$fShowTrill_$cshowList -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fShowTrill1 :: PhonemeType.Trill -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: PhonemeType.Trill eta :: GHC.Base.String ->
                 case ds of wild {
                   PhonemeType.TRILLED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeImpossible16)
                        eta
                   PhonemeType.NOTTRILLED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeImpossible13)
                        eta }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fShowTrill_$cshow :: PhonemeType.Trill -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.Trill ->
                 case x of wild {
                   PhonemeType.TRILLED -> PhonemeType.$fReadMaybeImpossible16
                   PhonemeType.NOTTRILLED -> PhonemeType.$fReadMaybeImpossible13 }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fShowTrill_$cshowList :: [PhonemeType.Trill] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.Trill
                   PhonemeType.$fShowTrill1) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $fShowTrill_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.Trill -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: PhonemeType.Trill
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   PhonemeType.TRILLED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeImpossible16)
                        eta
                   PhonemeType.NOTTRILLED
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c4 :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr
                           @ GHC.Types.Char
                           @ b
                           c4
                           n
                           PhonemeType.$fReadMaybeImpossible13)
                        eta }) -}
16d61d06081f347fd36865d448a9e38e
  $fShowVOT :: GHC.Show.Show PhonemeType.VOT
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VOT
                  PhonemeType.$fShowVOT_$cshowsPrec
                  PhonemeType.$fShowVOT_$cshow
                  PhonemeType.$fShowVOT_$cshowList -}
16d61d06081f347fd36865d448a9e38e
  $fShowVOT_$cshow :: PhonemeType.VOT -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.VOT ->
                 case x of wild {
                   PhonemeType.POSITIVE -> PhonemeType.$fReadMaybeImpossible47
                   PhonemeType.ZERO -> PhonemeType.$fReadMaybeImpossible44
                   PhonemeType.NEGATIVE -> PhonemeType.$fReadMaybeImpossible41 }) -}
16d61d06081f347fd36865d448a9e38e
  $fShowVOT_$cshowList :: [PhonemeType.VOT] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.VOT
                   PhonemeType.$w$cshowsPrec15) -}
16d61d06081f347fd36865d448a9e38e
  $fShowVOT_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.VOT -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.VOT
                   w2 :: GHC.Base.String ->
                 PhonemeType.$w$cshowsPrec15 w1 w2) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fShowVowelFeatures :: GHC.Show.Show PhonemeType.VowelFeatures
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VowelFeatures
                  PhonemeType.$fShowVowelFeatures_$cshowsPrec
                  PhonemeType.$fShowVowelFeatures_$cshow
                  PhonemeType.$fShowVowelFeatures_$cshowList -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fShowVowelFeatures1 :: PhonemeType.VowelFeatures -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: PhonemeType.VowelFeatures
                   w1 :: GHC.Base.String ->
                 case w of ww { PhonemeType.VowelFeatures ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 PhonemeType.$w$cshowsPrec12 0 ww1 ww2 ww3 ww4 ww5 ww6 ww7 w1 }) -}
de5feaa368b0763e13d665742a85ee00
  $fShowVowelFeaturesContour ::
    GHC.Show.Show PhonemeType.VowelFeaturesContour
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PhonemeType.VowelFeaturesContour
                  PhonemeType.$fShowVowelFeaturesContour_$cshowsPrec
                  PhonemeType.$fShowVowelFeaturesContour_$cshow
                  PhonemeType.$fShowVowelFeaturesContour_$cshowList -}
de5feaa368b0763e13d665742a85ee00
  $fShowVowelFeaturesContour1 ::
    PhonemeType.VowelFeaturesContour -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: PhonemeType.VowelFeaturesContour ->
                 case w of ww { PhonemeType.VowelFeaturesContour ww1 ww2 ->
                 PhonemeType.$w$cshowsPrec16 0 ww1 ww2 }) -}
570f642d23df1c4383e785494945c813
  $fShowVowelFeaturesContour2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "secondVContour = "#) -}
e7f3ccc2cc76079713f6991e3b5eed5d
  $fShowVowelFeaturesContour3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "firstVContour = "#) -}
5f31842091f26d7849987af543605c01
  $fShowVowelFeaturesContour4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "VowelFeaturesContour {"#) -}
de5feaa368b0763e13d665742a85ee00
  $fShowVowelFeaturesContour_$cshow ::
    PhonemeType.VowelFeaturesContour -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U(U,U,U,U,U,U,U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.VowelFeaturesContour ->
                 PhonemeType.$fShowVowelFeaturesContour_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
de5feaa368b0763e13d665742a85ee00
  $fShowVowelFeaturesContour_$cshowList ::
    [PhonemeType.VowelFeaturesContour] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.VowelFeaturesContour
                   PhonemeType.$fShowVowelFeaturesContour1) -}
de5feaa368b0763e13d665742a85ee00
  $fShowVowelFeaturesContour_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.VowelFeaturesContour -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(U(U,U,U,U,U,U,U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: PhonemeType.VowelFeaturesContour ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.VowelFeaturesContour ww3 ww4 ->
                 PhonemeType.$w$cshowsPrec16 ww1 ww3 ww4 } }) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fShowVowelFeatures_$cshow ::
    PhonemeType.VowelFeatures -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PhonemeType.VowelFeatures ->
                 PhonemeType.$fShowVowelFeatures_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fShowVowelFeatures_$cshowList ::
    [PhonemeType.VowelFeatures] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PhonemeType.VowelFeatures
                   PhonemeType.$fShowVowelFeatures1) -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $fShowVowelFeatures_$cshowsPrec ::
    GHC.Types.Int -> PhonemeType.VowelFeatures -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U,1*U,1*U,1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: PhonemeType.VowelFeatures
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { PhonemeType.VowelFeatures ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 PhonemeType.$w$cshowsPrec12
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   w2 } }) -}
8c33c05697fb03b97e08d9da8673bb8c
  $w$c== ::
    PhonemeType.MaybeUnspecified PhonemeType.Initiator
    -> PhonemeType.MaybeUnspecified PhonemeType.Direction
    -> PhonemeType.MaybeUnspecified PhonemeType.Initiator
    -> PhonemeType.MaybeUnspecified PhonemeType.Direction
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: PhonemeType.MaybeUnspecified
                           PhonemeType.Initiator
                   ww1 :: PhonemeType.MaybeUnspecified PhonemeType.Direction
                   ww2 :: PhonemeType.MaybeUnspecified PhonemeType.Initiator
                   ww3 :: PhonemeType.MaybeUnspecified PhonemeType.Direction ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ w :: GHC.Prim.Void#[OneShot] ->
                     case ww1 of wild {
                       PhonemeType.Specified a23
                       -> case ww3 of wild1 {
                            PhonemeType.Specified b1 -> PhonemeType.$fEqAirstream_$c==1 a23 b1
                            PhonemeType.Unspecified -> GHC.Types.False }
                       PhonemeType.Unspecified
                       -> case ww3 of wild1 {
                            PhonemeType.Specified ipv -> GHC.Types.False
                            PhonemeType.Unspecified -> GHC.Types.True } }
                 } in
                 case ww of wild {
                   PhonemeType.Specified a23
                   -> case ww2 of wild1 {
                        PhonemeType.Specified b1
                        -> case a23 of wild2 {
                             PhonemeType.LINGUAL
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.LINGUAL -> $j GHC.Prim.void# }
                             PhonemeType.GLOTTIC
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.GLOTTIC -> $j GHC.Prim.void# }
                             PhonemeType.PULMONIC
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.PULMONIC -> $j GHC.Prim.void# } }
                        PhonemeType.Unspecified -> GHC.Types.False }
                   PhonemeType.Unspecified
                   -> case ww2 of wild1 {
                        PhonemeType.Specified ipv -> GHC.Types.False
                        PhonemeType.Unspecified -> $j GHC.Prim.void# } }) -}
b9677df80245b6746cab9c943cc14219
  $w$c==1 ::
    PhonemeType.MaybeUnspecified PhonemeType.Place
    -> PhonemeType.MaybeUnspecified PhonemeType.Manner
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> PhonemeType.MaybeUnspecified PhonemeType.Place
    -> PhonemeType.MaybeUnspecified PhonemeType.Manner
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
bb3d1dc0c900f1ee20b855cc73eb466b
  $w$c==2 ::
    PhonemeType.MaybeUnspecified PhonemeType.Place
    -> PhonemeType.MaybeUnspecified PhonemeType.Manner
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures)
    -> PhonemeType.MaybeUnspecified PhonemeType.Place
    -> PhonemeType.MaybeUnspecified PhonemeType.Manner
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures)
    -> GHC.Types.Bool
  {- Arity: 10, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: PhonemeType.MaybeUnspecified PhonemeType.Place
                   ww1 :: PhonemeType.MaybeUnspecified PhonemeType.Manner
                   ww2 :: PhonemeType.MaybeUnspecified PhonemeType.Airstream
                   ww3 :: PhonemeType.MaybeUnspecified PhonemeType.Phonation
                   ww4 :: PhonemeType.MaybeBlank
                            (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures)
                   ww5 :: PhonemeType.MaybeUnspecified PhonemeType.Place
                   ww6 :: PhonemeType.MaybeUnspecified PhonemeType.Manner
                   ww7 :: PhonemeType.MaybeUnspecified PhonemeType.Airstream
                   ww8 :: PhonemeType.MaybeUnspecified PhonemeType.Phonation
                   ww9 :: PhonemeType.MaybeBlank
                            (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures) ->
                 case PhonemeType.$w$c==1 ww ww1 ww2 ww3 ww5 ww6 ww7 ww8 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww4 of wild1 {
                        PhonemeType.Filled a23
                        -> case ww9 of wild2 {
                             PhonemeType.Filled b1
                             -> case a23 of wild3 {
                                  PhonemeType.Specified a24
                                  -> case b1 of wild4 {
                                       PhonemeType.Specified b2
                                       -> PhonemeType.$fEqConsonantFeatures_$c== a24 b2
                                       PhonemeType.Unspecified -> GHC.Types.False }
                                  PhonemeType.Unspecified
                                  -> case b1 of wild4 {
                                       PhonemeType.Specified ipv -> GHC.Types.False
                                       PhonemeType.Unspecified -> GHC.Types.True } }
                             PhonemeType.Blank -> GHC.Types.False }
                        PhonemeType.Blank
                        -> case ww9 of wild2 {
                             PhonemeType.Filled ipv -> GHC.Types.False
                             PhonemeType.Blank -> GHC.Types.True } } }) -}
9070a10166e9436d7ef53eda3ae94b60
  $w$c==3 ::
    PhonemeType.MaybeUnspecified PhonemeType.Stricture
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Trill)
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.VOT)
    -> PhonemeType.MaybeUnspecified PhonemeType.Stricture
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Trill)
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.VOT)
    -> GHC.Types.Bool
  {- Arity: 14, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
30561c72e284b19eb1c32056bd6725cd
  $w$c==4 ::
    PhonemeType.MaybeUnspecified PhonemeType.Height
    -> PhonemeType.MaybeUnspecified PhonemeType.Backness
    -> PhonemeType.MaybeUnspecified PhonemeType.Roundedness
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> PhonemeType.MaybeUnspecified PhonemeType.Height
    -> PhonemeType.MaybeUnspecified PhonemeType.Backness
    -> PhonemeType.MaybeUnspecified PhonemeType.Roundedness
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> GHC.Types.Bool
  {- Arity: 14, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0] -}
846bdc72f5f9832d920c9eb3d271b01a
  $w$c==5 ::
    PhonemeType.MaybeUnspecified PhonemeType.ActiveArticulator
    -> PhonemeType.MaybeUnspecified PhonemeType.PassiveArticulator
    -> PhonemeType.MaybeUnspecified PhonemeType.ActiveArticulator
    -> PhonemeType.MaybeUnspecified PhonemeType.PassiveArticulator
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: PhonemeType.MaybeUnspecified
                           PhonemeType.ActiveArticulator
                   ww1 :: PhonemeType.MaybeUnspecified PhonemeType.PassiveArticulator
                   ww2 :: PhonemeType.MaybeUnspecified PhonemeType.ActiveArticulator
                   ww3 :: PhonemeType.MaybeUnspecified
                            PhonemeType.PassiveArticulator ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ w :: GHC.Prim.Void#[OneShot] ->
                     case ww1 of wild {
                       PhonemeType.Specified a23
                       -> case ww3 of wild1 {
                            PhonemeType.Specified b1
                            -> case a23 of x1 { DEFAULT ->
                               case b1 of x2 { DEFAULT ->
                               GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==#
                                    (GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x1)
                                    (GHC.Prim.dataToTag# @ PhonemeType.PassiveArticulator x2)) } }
                            PhonemeType.Unspecified -> GHC.Types.False }
                       PhonemeType.Unspecified
                       -> case ww3 of wild1 {
                            PhonemeType.Specified ipv -> GHC.Types.False
                            PhonemeType.Unspecified -> GHC.Types.True } }
                 } in
                 case ww of wild {
                   PhonemeType.Specified a23
                   -> case ww2 of wild1 {
                        PhonemeType.Specified b1
                        -> case a23 of wild2 {
                             PhonemeType.LOWERLIP
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.LOWERLIP -> $j GHC.Prim.void# }
                             PhonemeType.TONGUEBLADE
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.TONGUEBLADE -> $j GHC.Prim.void# }
                             PhonemeType.TONGUETIP
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.TONGUETIP -> $j GHC.Prim.void# }
                             PhonemeType.TONGUEUNDER
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.TONGUEUNDER -> $j GHC.Prim.void# }
                             PhonemeType.TONGUEBODY
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.TONGUEBODY -> $j GHC.Prim.void# }
                             PhonemeType.TONGUEROOT
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.TONGUEROOT -> $j GHC.Prim.void# }
                             PhonemeType.LARYNX
                             -> case b1 of wild3 {
                                  DEFAULT -> GHC.Types.False
                                  PhonemeType.LARYNX -> $j GHC.Prim.void# } }
                        PhonemeType.Unspecified -> GHC.Types.False }
                   PhonemeType.Unspecified
                   -> case ww2 of wild1 {
                        PhonemeType.Specified ipv -> GHC.Types.False
                        PhonemeType.Unspecified -> $j GHC.Prim.void# } }) -}
2e816b2558423ad2603082e8d98d0570
  $w$c==6 ::
    PhonemeType.MaybeUnspecified PhonemeType.Height
    -> PhonemeType.MaybeUnspecified PhonemeType.Backness
    -> PhonemeType.MaybeUnspecified PhonemeType.Roundedness
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures)
    -> PhonemeType.MaybeUnspecified PhonemeType.Height
    -> PhonemeType.MaybeUnspecified PhonemeType.Backness
    -> PhonemeType.MaybeUnspecified PhonemeType.Roundedness
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures)
    -> GHC.Types.Bool
  {- Arity: 16, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: PhonemeType.MaybeUnspecified PhonemeType.Height
                   ww1 :: PhonemeType.MaybeUnspecified PhonemeType.Backness
                   ww2 :: PhonemeType.MaybeUnspecified PhonemeType.Roundedness
                   ww3 :: PhonemeType.MaybeUnspecified PhonemeType.Length
                   ww4 :: PhonemeType.MaybeUnspecified PhonemeType.AirEscape
                   ww5 :: PhonemeType.MaybeUnspecified PhonemeType.Airstream
                   ww6 :: PhonemeType.MaybeUnspecified PhonemeType.Phonation
                   ww7 :: PhonemeType.MaybeBlank
                            (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures)
                   ww8 :: PhonemeType.MaybeUnspecified PhonemeType.Height
                   ww9 :: PhonemeType.MaybeUnspecified PhonemeType.Backness
                   ww10 :: PhonemeType.MaybeUnspecified PhonemeType.Roundedness
                   ww11 :: PhonemeType.MaybeUnspecified PhonemeType.Length
                   ww12 :: PhonemeType.MaybeUnspecified PhonemeType.AirEscape
                   ww13 :: PhonemeType.MaybeUnspecified PhonemeType.Airstream
                   ww14 :: PhonemeType.MaybeUnspecified PhonemeType.Phonation
                   ww15 :: PhonemeType.MaybeBlank
                             (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures) ->
                 case PhonemeType.$w$c==4
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww8
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13
                        ww14 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww7 of wild1 {
                        PhonemeType.Filled a23
                        -> case ww15 of wild2 {
                             PhonemeType.Filled b1
                             -> case a23 of wild3 {
                                  PhonemeType.Specified a24
                                  -> case b1 of wild4 {
                                       PhonemeType.Specified b2
                                       -> PhonemeType.$fEqMaybeBlank_$c==1 a24 b2
                                       PhonemeType.Unspecified -> GHC.Types.False }
                                  PhonemeType.Unspecified
                                  -> case b1 of wild4 {
                                       PhonemeType.Specified ipv -> GHC.Types.False
                                       PhonemeType.Unspecified -> GHC.Types.True } }
                             PhonemeType.Blank -> GHC.Types.False }
                        PhonemeType.Blank
                        -> case ww15 of wild2 {
                             PhonemeType.Filled ipv -> GHC.Types.False
                             PhonemeType.Blank -> GHC.Types.True } } }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $w$cshowsPrec ::
    PhonemeType.ActiveArticulator -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.ActiveArticulator
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.LOWERLIP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadActiveArticulator31
                        w1
                   PhonemeType.TONGUEBLADE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadActiveArticulator28
                        w1
                   PhonemeType.TONGUETIP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadActiveArticulator25
                        w1
                   PhonemeType.TONGUEUNDER
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadActiveArticulator22
                        w1
                   PhonemeType.TONGUEBODY
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadActiveArticulator19
                        w1
                   PhonemeType.TONGUEROOT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadActiveArticulator16
                        w1
                   PhonemeType.LARYNX
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadActiveArticulator13
                        w1 }) -}
389add1cde709e183b5977f62d43956e
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> PhonemeType.MaybeUnspecified PhonemeType.Initiator
    -> PhonemeType.MaybeUnspecified PhonemeType.Direction
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType.MaybeUnspecified PhonemeType.Initiator
                   ww2 :: PhonemeType.MaybeUnspecified PhonemeType.Direction
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType.$fShowAirstream8
                       (PhonemeType.$fShowAirstream_$s$cshowsPrec1
                          PhonemeType.$fShowAirstream7
                          ww1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream6
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream5
                                (PhonemeType.$fShowAirstream_$s$cshowsPrec
                                   PhonemeType.$fShowAirstream7
                                   ww2
                                   (GHC.Base.++ @ GHC.Types.Char PhonemeType.$fShowAirstream3 x)))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fShowAirstream2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType.$fShowAirstream2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $w$cshowsPrec10 ::
    PhonemeType.Initiator -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Initiator w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.LINGUAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadInitiator15 w1
                   PhonemeType.GLOTTIC
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadInitiator12 w1
                   PhonemeType.PULMONIC
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadInitiator9
                        w1 }) -}
355f724f9de26105f3758df52d82fae4
  $w$cshowsPrec11 ::
    PhonemeType.Length -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Length w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.SHORT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadLength15 w1
                   PhonemeType.NORMAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadLength12 w1
                   PhonemeType.LONG
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadLength9 w1 }) -}
087f3760f4cabf695162cf54eca817a6
  $w$cshowsPrec12 ::
    GHC.Prim.Int#
    -> PhonemeType.MaybeUnspecified PhonemeType.Height
    -> PhonemeType.MaybeUnspecified PhonemeType.Backness
    -> PhonemeType.MaybeUnspecified PhonemeType.Roundedness
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 9,
     Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0] -}
913de677c1a32c9344108088ed92179c
  $w$cshowsPrec13 ::
    GHC.Prim.Int#
    -> [PhonemeType.ConsonantFeaturesContour]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: [PhonemeType.ConsonantFeaturesContour]
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowPhonemeInventory2
                        (GHC.Show.showList__
                           @ PhonemeType.ConsonantFeaturesContour
                           PhonemeType.$fShowConsonantFeaturesContour1
                           ww1
                           w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType.$fShowPhonemeInventory2
                           (GHC.Show.showList__
                              @ PhonemeType.ConsonantFeaturesContour
                              PhonemeType.$fShowConsonantFeaturesContour1
                              ww1
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
f45b7454df7117690624094b2e33986b
  $w$cshowsPrec14 ::
    PhonemeType.Stricture -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Stricture w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.OCCLUSION
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified78
                        w1
                   PhonemeType.TURBULENT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified75
                        w1
                   PhonemeType.SLIGHTTURBULENT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified72
                        w1 }) -}
16d61d06081f347fd36865d448a9e38e
  $w$cshowsPrec15 ::
    PhonemeType.VOT -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.VOT w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.POSITIVE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeImpossible47
                        w1
                   PhonemeType.ZERO
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeImpossible44
                        w1
                   PhonemeType.NEGATIVE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeImpossible41
                        w1 }) -}
56563a3ea1169f05a3848759e3aabbdc
  $w$cshowsPrec16 ::
    GHC.Prim.Int#
    -> PhonemeType.VowelFeatures
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures)
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U><L,U(U,U,U,U,U,U,U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType.VowelFeatures
                   ww2 :: PhonemeType.MaybeBlank
                            (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = PhonemeType.$fShowMaybeBlank_$s$cshowsPrec
                       PhonemeType.$fShowAirstream7
                       ww2
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType.$fShowVowelFeaturesContour4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          PhonemeType.$fShowVowelFeaturesContour3
                          (case ww1 of ww3 { PhonemeType.VowelFeatures ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                           PhonemeType.$w$cshowsPrec12
                             0
                             ww4
                             ww5
                             ww6
                             ww7
                             ww8
                             ww9
                             ww10
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream6
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   PhonemeType.$fShowVowelFeaturesContour2
                                   (f (GHC.Base.++
                                         @ GHC.Types.Char
                                         PhonemeType.$fShowAirstream3
                                         x)))) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
4600283dc79ec1a04339fecb849d3137
  $w$cshowsPrec2 ::
    PhonemeType.Backness -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Backness w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.BACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadBackness23 w1
                   PhonemeType.NEARBACK
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadBackness20 w1
                   PhonemeType.CENTRAL
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadBackness17 w1
                   PhonemeType.NEARFRONT
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadBackness14 w1
                   PhonemeType.FRONT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadBackness11
                        w1 }) -}
8478b5648265efae77b0268f309f0d65
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> PhonemeType.MaybeUnspecified PhonemeType.Place
    -> PhonemeType.MaybeUnspecified PhonemeType.Manner
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 6, Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType.MaybeUnspecified PhonemeType.Place
                   ww2 :: PhonemeType.MaybeUnspecified PhonemeType.Manner
                   ww3 :: PhonemeType.MaybeUnspecified PhonemeType.Airstream
                   ww4 :: PhonemeType.MaybeUnspecified PhonemeType.Phonation
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType.$fShowConsonantFeatures9
                       (PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec3
                          PhonemeType.$fShowAirstream7
                          ww1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream6
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowConsonantFeatures5
                                (PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec2
                                   PhonemeType.$fShowAirstream7
                                   ww2
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      PhonemeType.$fShowAirstream6
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         PhonemeType.$fShowConsonantFeatures4
                                         (PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec1
                                            PhonemeType.$fShowAirstream7
                                            ww3
                                            (GHC.Base.++
                                               @ GHC.Types.Char
                                               PhonemeType.$fShowAirstream6
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  PhonemeType.$fShowConsonantFeatures3
                                                  (PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec
                                                     PhonemeType.$fShowAirstream7
                                                     ww4
                                                     (GHC.Base.++
                                                        @ GHC.Types.Char
                                                        PhonemeType.$fShowAirstream3
                                                        x)))))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowConsonantFeatures2
                        (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType.$fShowConsonantFeatures2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
1876b99e8b904b79707be731945482ec
  $w$cshowsPrec4 ::
    PhonemeType.Phonation -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Phonation w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.VOICELESS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified119
                        w1
                   PhonemeType.BREATHY
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified116
                        w1
                   PhonemeType.SLACK
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified113
                        w1
                   PhonemeType.MODAL
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified110
                        w1
                   PhonemeType.STIFF
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified107
                        w1
                   PhonemeType.CREAKY
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified104
                        w1
                   PhonemeType.CLOSURE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified101
                        w1 }) -}
487f3652e9c1311a35f563c10b1b2582
  $w$cshowsPrec5 ::
    GHC.Prim.Int#
    -> PhonemeType.MaybeUnspecified PhonemeType.Stricture
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Trill)
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.VOT)
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 9,
     Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,U>,
     Inline: [0] -}
09ec6c757411fdc13ddb367a20df4383
  $w$cshowsPrec6 ::
    GHC.Prim.Int#
    -> PhonemeType.MaybeUnspecified PhonemeType.ActiveArticulator
    -> PhonemeType.MaybeUnspecified PhonemeType.PassiveArticulator
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType.MaybeUnspecified PhonemeType.ActiveArticulator
                   ww2 :: PhonemeType.MaybeUnspecified PhonemeType.PassiveArticulator
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType.$fShowConsonantFeatures8
                       (PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec5
                          PhonemeType.$fShowAirstream7
                          ww1
                          (GHC.Base.++
                             @ GHC.Types.Char
                             PhonemeType.$fShowAirstream6
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowConsonantFeatures7
                                (PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec4
                                   PhonemeType.$fShowAirstream7
                                   ww2
                                   (GHC.Base.++ @ GHC.Types.Char PhonemeType.$fShowAirstream3 x)))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fShowConsonantFeatures6
                        (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           PhonemeType.$fShowConsonantFeatures6
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
dcbf3455324a78016700898324489067
  $w$cshowsPrec7 ::
    PhonemeType.PassiveArticulator
    -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.PassiveArticulator
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.UPPERLIP
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified61
                        w1
                   PhonemeType.UPPERTEETH
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified58
                        w1
                   PhonemeType.TEETHRIDGE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified55
                        w1
                   PhonemeType.RIDGE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified52
                        w1
                   PhonemeType.BACKRIDGE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified49
                        w1
                   PhonemeType.HARDPALATE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified46
                        w1
                   PhonemeType.SOFTPALATE
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified43
                        w1
                   PhonemeType.UVULA
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified40
                        w1
                   PhonemeType.PHARYNX
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified37
                        w1
                   PhonemeType.EPIGLOTTIS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified34
                        w1
                   PhonemeType.GLOTTIS
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        PhonemeType.$fReadMaybeUnspecified31
                        w1 }) -}
28936f694939becb74980f71809f276f
  $w$cshowsPrec8 ::
    GHC.Prim.Int#
    -> PhonemeType.ConsonantFeatures
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures)
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U><L,U(U,U,U,U)><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: PhonemeType.ConsonantFeatures
                   ww2 :: PhonemeType.MaybeBlank
                            (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec
                       PhonemeType.$fShowAirstream7
                       ww2
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       PhonemeType.$fShowConsonantFeaturesContour4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          PhonemeType.$fShowConsonantFeaturesContour3
                          (case ww1 of ww3 { PhonemeType.ConsonantFeatures ww4 ww5 ww6 ww7 ->
                           PhonemeType.$w$cshowsPrec3
                             0
                             ww4
                             ww5
                             ww6
                             ww7
                             (GHC.Base.++
                                @ GHC.Types.Char
                                PhonemeType.$fShowAirstream6
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   PhonemeType.$fShowConsonantFeaturesContour2
                                   (f (GHC.Base.++
                                         @ GHC.Types.Char
                                         PhonemeType.$fShowAirstream3
                                         x)))) }))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $w$cshowsPrec9 ::
    PhonemeType.Height -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: PhonemeType.Height w1 :: GHC.Base.String ->
                 case w of wild {
                   PhonemeType.CLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight31 w1
                   PhonemeType.NEARCLOSE
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight28 w1
                   PhonemeType.CLOSEMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight25 w1
                   PhonemeType.MID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight22 w1
                   PhonemeType.OPENMID
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight19 w1
                   PhonemeType.NEAROPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight16 w1
                   PhonemeType.OPEN
                   -> GHC.Base.++ @ GHC.Types.Char PhonemeType.$fReadHeight13 w1 }) -}
fd40a704b56f8a83c2b0aea2398f0cd7
  $w$ctoEnum :: GHC.Prim.Int# -> PhonemeType.ActiveArticulator
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumActiveArticulator8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumActiveArticulator8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.ActiveArticulator ww } }) -}
483edd05f8d1cf327b30114f3225d3b2
  $w$ctoEnum1 :: GHC.Prim.Int# -> PhonemeType.AirEscape
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumAirEscape1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumAirEscape1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.AirEscape ww } }) -}
9c915b50edb2977ec86c27bd6c240a83
  $w$ctoEnum10 :: GHC.Prim.Int# -> PhonemeType.Roundedness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumRoundedness1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumRoundedness1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Roundedness ww } }) -}
1940ee84f46a7a0f1801689311b6be65
  $w$ctoEnum11 :: GHC.Prim.Int# -> PhonemeType.Silibance
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumSilibance1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumSilibance1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Silibance ww } }) -}
f45b7454df7117690624094b2e33986b
  $w$ctoEnum12 :: GHC.Prim.Int# -> PhonemeType.Stricture
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumStricture1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumStricture1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Stricture ww } }) -}
e0b8c14bfe6f634e0e1999cc8005c803
  $w$ctoEnum13 :: GHC.Prim.Int# -> PhonemeType.Trill
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumTrill1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumTrill1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Trill ww } }) -}
16d61d06081f347fd36865d448a9e38e
  $w$ctoEnum14 :: GHC.Prim.Int# -> PhonemeType.VOT
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumVOT1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumVOT1 ww
                        GHC.Types.True -> GHC.Prim.tagToEnum# @ PhonemeType.VOT ww } }) -}
4600283dc79ec1a04339fecb849d3137
  $w$ctoEnum2 :: GHC.Prim.Int# -> PhonemeType.Backness
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumBackness6 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 4) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumBackness6 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Backness ww } }) -}
40a9c5f987e37783909145cb5997138e
  $w$ctoEnum3 :: GHC.Prim.Int# -> PhonemeType.Direction
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumDirection1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumDirection1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Direction ww } }) -}
9ff0259cd9d57252fd1cd0d1ab9af2f2
  $w$ctoEnum4 :: GHC.Prim.Int# -> PhonemeType.Height
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumHeight8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumHeight8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Height ww } }) -}
43c58c7184f57bb8ec8e69d85750c9a1
  $w$ctoEnum5 :: GHC.Prim.Int# -> PhonemeType.Initiator
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumInitiator1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumInitiator1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Initiator ww } }) -}
563547f95f31ce703bd3964698c86217
  $w$ctoEnum6 :: GHC.Prim.Int# -> PhonemeType.Laterality
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumLaterality1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 1) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumLaterality1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Laterality ww } }) -}
355f724f9de26105f3758df52d82fae4
  $w$ctoEnum7 :: GHC.Prim.Int# -> PhonemeType.Length
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumLength1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 2) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumLength1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Length ww } }) -}
dcbf3455324a78016700898324489067
  $w$ctoEnum8 :: GHC.Prim.Int# -> PhonemeType.PassiveArticulator
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumPassiveArticulator1 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 10) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumPassiveArticulator1 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.PassiveArticulator ww } }) -}
1876b99e8b904b79707be731945482ec
  $w$ctoEnum9 :: GHC.Prim.Int# -> PhonemeType.Phonation
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 0) of wild {
                   GHC.Types.False -> PhonemeType.$fEnumPhonation8 ww
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww 6) of wild1 {
                        GHC.Types.False -> PhonemeType.$fEnumPhonation8 ww
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum# @ PhonemeType.Phonation ww } }) -}
355bf06edf14b009f06abed2ef70f036
  $wa ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.Airstream -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
62312b673b3cb46a867844b1181e8c1b
  $wa1 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.ConsonantFeatures -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
0fafe33c29b0b10fbc3af36aea570fe2
  $wa2 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.ConsonantFeaturesContour
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
e703c4ac2d48fb63ab47cfa0f4f09709
  $wa3 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.Manner -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
2f7a6a4ef65b4dfb284d4e1b045483a0
  $wa4 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.VowelFeatures -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
95417ac7dbeb758b510442ae50c858cb
  $wa5 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.Place -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
d63366b958aa268c953fb9cc54988074
  $wa6 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.PhonemeInventory -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   @ b
                   w :: PhonemeType.PhonemeInventory
                        -> Text.ParserCombinators.ReadP.P b ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 10) of wild2 {
                   GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                   GHC.Types.True
                   -> let {
                        lvl130 :: Text.ParserCombinators.ReadP.P b
                        = let {
                            lvl131 :: Text.ParserCombinators.ReadP.P b
                            = GHC.Read.$wa
                                @ PhonemeType.ConsonantFeaturesContour
                                PhonemeType.$fReadConsonantFeaturesContour2
                                  `cast`
                                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                          <PhonemeType.ConsonantFeaturesContour>_R))
                                @ b
                                (\ a23 :: [PhonemeType.ConsonantFeaturesContour] ->
                                 w (PhonemeType.PhonemeInventory a23))
                          } in
                          Text.Read.Lex.expect2
                            @ b
                            (\ a98 :: Text.Read.Lex.Lexeme ->
                             case a98 of wild {
                               DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b
                               Text.Read.Lex.Ident a23
                               -> case GHC.Base.eqString
                                         a23
                                         PhonemeType.$fReadPhonemeInventory4 of wild1 {
                                    GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b
                                    GHC.Types.True -> lvl131 } })
                      } in
                      let {
                        k :: () -> Text.ParserCombinators.ReadP.P b
                          {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                             Unfolding: InlineRule (1, True, True) (\ w2 :: () -> lvl130) -}
                        = \ w2 :: () -> lvl130
                      } in
                      Text.ParserCombinators.ReadP.Look
                        @ b
                        (\ a98 :: GHC.Base.String ->
                         (Text.ParserCombinators.ReadP.skipSpaces_skip a98)
                           `cast`
                         (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <()>_R)
                           @ b
                           k) }) -}
de5feaa368b0763e13d665742a85ee00
  $wa7 ::
    GHC.Prim.Int#
    -> forall b.
       (PhonemeType.VowelFeaturesContour
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
fd40a704b56f8a83c2b0aea2398f0cd7
  data ActiveArticulator
    = LOWERLIP
    | TONGUEBLADE
    | TONGUETIP
    | TONGUEUNDER
    | TONGUEBODY
    | TONGUEROOT
    | LARYNX
    Promotable
483edd05f8d1cf327b30114f3225d3b2
  data AirEscape = NASALIZED | ORAL
    Promotable
355bf06edf14b009f06abed2ef70f036
  data Airstream
    = Airstream {initiator :: PhonemeType.MaybeUnspecified
                                PhonemeType.Initiator,
                 direction :: PhonemeType.MaybeUnspecified PhonemeType.Direction}
    Promotable
4600283dc79ec1a04339fecb849d3137
  data Backness = BACK | NEARBACK | CENTRAL | NEARFRONT | FRONT
    Promotable
62312b673b3cb46a867844b1181e8c1b
  data ConsonantFeatures
    = ConsonantFeatures {place :: PhonemeType.MaybeUnspecified
                                    PhonemeType.Place,
                         manner :: PhonemeType.MaybeUnspecified PhonemeType.Manner,
                         airstream :: PhonemeType.MaybeUnspecified PhonemeType.Airstream,
                         phonation :: PhonemeType.MaybeUnspecified PhonemeType.Phonation}
    Promotable
0fafe33c29b0b10fbc3af36aea570fe2
  data ConsonantFeaturesContour
    = ConsonantFeaturesContour {firstCContour :: PhonemeType.ConsonantFeatures,
                                secondCContour :: PhonemeType.MaybeBlank
                                                    (PhonemeType.MaybeUnspecified
                                                       PhonemeType.ConsonantFeatures)}
    Promotable
40a9c5f987e37783909145cb5997138e
  data Direction = INGRESSIVE | EGRESSIVE
    Promotable
9ff0259cd9d57252fd1cd0d1ab9af2f2
  data Height
    = CLOSE | NEARCLOSE | CLOSEMID | MID | OPENMID | NEAROPEN | OPEN
    Promotable
43c58c7184f57bb8ec8e69d85750c9a1
  data Initiator = LINGUAL | GLOTTIC | PULMONIC
    Promotable
563547f95f31ce703bd3964698c86217
  data Laterality = LATERAL | NONLATERAL
    Promotable
355f724f9de26105f3758df52d82fae4
  data Length = SHORT | NORMAL | LONG
    Promotable
e703c4ac2d48fb63ab47cfa0f4f09709
  data Manner
    = Manner {stricture :: PhonemeType.MaybeUnspecified
                             PhonemeType.Stricture,
              trill :: PhonemeType.MaybeImpossible
                         (PhonemeType.MaybeUnspecified PhonemeType.Trill),
              mannerLength :: PhonemeType.MaybeUnspecified PhonemeType.Length,
              laterality :: PhonemeType.MaybeImpossible
                              (PhonemeType.MaybeUnspecified PhonemeType.Laterality),
              silibance :: PhonemeType.MaybeImpossible
                             (PhonemeType.MaybeUnspecified PhonemeType.Silibance),
              airescape :: PhonemeType.MaybeUnspecified PhonemeType.AirEscape,
              vot :: PhonemeType.MaybeImpossible
                       (PhonemeType.MaybeUnspecified PhonemeType.VOT)}
    Promotable
f37f61cc99a3307d20aa8b2457e6d204
  data MaybeBlank a = Filled a | Blank
    Promotable
60779ee60a7b7b6d291add8ce22569fb
  data MaybeImpossible a = Possible a | Impossible
    Promotable
bd7b9b9f34ce1cb6f20900ef26c31eeb
  data MaybeUnspecified a = Specified a | Unspecified
    Promotable
dcbf3455324a78016700898324489067
  data PassiveArticulator
    = UPPERLIP
    | UPPERTEETH
    | TEETHRIDGE
    | RIDGE
    | BACKRIDGE
    | HARDPALATE
    | SOFTPALATE
    | UVULA
    | PHARYNX
    | EPIGLOTTIS
    | GLOTTIS
    Promotable
1876b99e8b904b79707be731945482ec
  data Phonation
    = VOICELESS | BREATHY | SLACK | MODAL | STIFF | CREAKY | CLOSURE
    Promotable
d63366b958aa268c953fb9cc54988074
  data PhonemeInventory
    = PhonemeInventory [PhonemeType.ConsonantFeaturesContour]
    Promotable
95417ac7dbeb758b510442ae50c858cb
  data Place
    = Place {active :: PhonemeType.MaybeUnspecified
                         PhonemeType.ActiveArticulator,
             passive :: PhonemeType.MaybeUnspecified
                          PhonemeType.PassiveArticulator}
    Promotable
9c915b50edb2977ec86c27bd6c240a83
  data Roundedness = UNROUNDED | ROUNDED
    Promotable
1940ee84f46a7a0f1801689311b6be65
  data Silibance = SILIBANT | NONSILIBANT
    Promotable
f45b7454df7117690624094b2e33986b
  data Stricture = OCCLUSION | TURBULENT | SLIGHTTURBULENT
    Promotable
e0b8c14bfe6f634e0e1999cc8005c803
  data Trill = TRILLED | NOTTRILLED
    Promotable
16d61d06081f347fd36865d448a9e38e
  data VOT = POSITIVE | ZERO | NEGATIVE
    Promotable
2f7a6a4ef65b4dfb284d4e1b045483a0
  data VowelFeatures
    = VowelFeatures {height :: PhonemeType.MaybeUnspecified
                                 PhonemeType.Height,
                     backness :: PhonemeType.MaybeUnspecified PhonemeType.Backness,
                     roundedness :: PhonemeType.MaybeUnspecified
                                      PhonemeType.Roundedness,
                     length2 :: PhonemeType.MaybeUnspecified PhonemeType.Length,
                     airescape2 :: PhonemeType.MaybeUnspecified PhonemeType.AirEscape,
                     airstream2 :: PhonemeType.MaybeUnspecified PhonemeType.Airstream,
                     phonation2 :: PhonemeType.MaybeUnspecified PhonemeType.Phonation}
    Promotable
de5feaa368b0763e13d665742a85ee00
  data VowelFeaturesContour
    = VowelFeaturesContour {firstVContour :: PhonemeType.VowelFeatures,
                            secondVContour :: PhonemeType.MaybeBlank
                                                (PhonemeType.MaybeUnspecified
                                                   PhonemeType.VowelFeatures)}
    Promotable
7d09cf781466ac082de6406a334343b9
  active ::
    PhonemeType.Place
    -> PhonemeType.MaybeUnspecified PhonemeType.ActiveArticulator
  RecSel PhonemeType.Place
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Place ->
                 case ds of wild { PhonemeType.Place ds1 ds2 -> ds1 }) -}
e866305273ef51b0a10662dda39457cb
  airescape ::
    PhonemeType.Manner
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
  RecSel PhonemeType.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSL),1*U(A,A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Manner ->
                 case ds of wild { PhonemeType.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds6 }) -}
4087bf97a19c52ff8af74c89660b24ba
  airescape2 ::
    PhonemeType.VowelFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.AirEscape
  RecSel PhonemeType.VowelFeatures
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLL),1*U(A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeatures ->
                 case ds of wild { PhonemeType.VowelFeatures ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds5 }) -}
8b5f4905a8611b4250da0debdbd4e2b4
  airstream ::
    PhonemeType.ConsonantFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
  RecSel PhonemeType.ConsonantFeatures
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.ConsonantFeatures ->
                 case ds of wild { PhonemeType.ConsonantFeatures ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
875e6ed3e0629d996d27fff1d40fcbc7
  airstream2 ::
    PhonemeType.VowelFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Airstream
  RecSel PhonemeType.VowelFeatures
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLSL),1*U(A,A,A,A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeatures ->
                 case ds of wild { PhonemeType.VowelFeatures ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds6 }) -}
1764f8f6f462114f299bb97aa727db0b
  backness ::
    PhonemeType.VowelFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Backness
  RecSel PhonemeType.VowelFeatures
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLL),1*U(A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeatures ->
                 case ds of wild { PhonemeType.VowelFeatures ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds2 }) -}
4e6ce8a38f2bd7424df09ad8a2aa0525
  direction ::
    PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Direction
  RecSel PhonemeType.Airstream
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Airstream ->
                 case ds of wild { PhonemeType.Airstream ds1 ds2 -> ds2 }) -}
ada3bbcfdb0216fa3313e1ee3aa74451
  firstCContour ::
    PhonemeType.ConsonantFeaturesContour
    -> PhonemeType.ConsonantFeatures
  RecSel PhonemeType.ConsonantFeaturesContour
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U,U,U,U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.ConsonantFeaturesContour ->
                 case ds of wild { PhonemeType.ConsonantFeaturesContour ds1 ds2 ->
                 ds1 }) -}
47b591526a8384202ef0f1f02141770e
  firstVContour ::
    PhonemeType.VowelFeaturesContour -> PhonemeType.VowelFeatures
  RecSel PhonemeType.VowelFeaturesContour
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U(U,U,U,U,U,U,U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeaturesContour ->
                 case ds of wild { PhonemeType.VowelFeaturesContour ds1 ds2 ->
                 ds1 }) -}
ee5b0a61eb0ff71b718acb9dea57a325
  height ::
    PhonemeType.VowelFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Height
  RecSel PhonemeType.VowelFeatures
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeatures ->
                 case ds of wild { PhonemeType.VowelFeatures ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds1 }) -}
948516a72bd1869825e3e6ddb7f42520
  initiator ::
    PhonemeType.Airstream
    -> PhonemeType.MaybeUnspecified PhonemeType.Initiator
  RecSel PhonemeType.Airstream
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Airstream ->
                 case ds of wild { PhonemeType.Airstream ds1 ds2 -> ds1 }) -}
f8454a2091e21fe57bcee6dffcf664ce
  laterality ::
    PhonemeType.Manner
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Laterality)
  RecSel PhonemeType.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLL),1*U(A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Manner ->
                 case ds of wild { PhonemeType.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds4 }) -}
3cf09e1ef1a6f946bf246eeefd4b9eba
  length2 ::
    PhonemeType.VowelFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
  RecSel PhonemeType.VowelFeatures
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLL),1*U(A,A,A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeatures ->
                 case ds of wild { PhonemeType.VowelFeatures ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds4 }) -}
61974f1e4fee4990d0befb202f5d71b9
  manner ::
    PhonemeType.ConsonantFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Manner
  RecSel PhonemeType.ConsonantFeatures
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.ConsonantFeatures ->
                 case ds of wild { PhonemeType.ConsonantFeatures ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
7bc1a789b022aac680ed41f1713a4913
  mannerLength ::
    PhonemeType.Manner
    -> PhonemeType.MaybeUnspecified PhonemeType.Length
  RecSel PhonemeType.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLL),1*U(A,A,1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Manner ->
                 case ds of wild { PhonemeType.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds3 }) -}
512b24312b93b519336cbeafabb6b580
  passive ::
    PhonemeType.Place
    -> PhonemeType.MaybeUnspecified PhonemeType.PassiveArticulator
  RecSel PhonemeType.Place
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Place ->
                 case ds of wild { PhonemeType.Place ds1 ds2 -> ds2 }) -}
5c127b5077ac21ca25cfa33adeafd1ec
  phonation ::
    PhonemeType.ConsonantFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
  RecSel PhonemeType.ConsonantFeatures
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.ConsonantFeatures ->
                 case ds of wild { PhonemeType.ConsonantFeatures ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
d0ac39924325a131bd4f4ceea7e7d949
  phonation2 ::
    PhonemeType.VowelFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Phonation
  RecSel PhonemeType.VowelFeatures
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLS),1*U(A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeatures ->
                 case ds of wild { PhonemeType.VowelFeatures ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds7 }) -}
7575d6ccde4942febef7615f4a22d6ad
  place ::
    PhonemeType.ConsonantFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Place
  RecSel PhonemeType.ConsonantFeatures
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.ConsonantFeatures ->
                 case ds of wild { PhonemeType.ConsonantFeatures ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
9f97f75b7db7acadf1b4c165177a1e82
  roundedness ::
    PhonemeType.VowelFeatures
    -> PhonemeType.MaybeUnspecified PhonemeType.Roundedness
  RecSel PhonemeType.VowelFeatures
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLLLL),1*U(A,A,1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeatures ->
                 case ds of wild { PhonemeType.VowelFeatures ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds3 }) -}
a2db188ed1df922cb8d69f6ed8302b62
  secondCContour ::
    PhonemeType.ConsonantFeaturesContour
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.ConsonantFeatures)
  RecSel PhonemeType.ConsonantFeaturesContour
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.ConsonantFeaturesContour ->
                 case ds of wild { PhonemeType.ConsonantFeaturesContour ds1 ds2 ->
                 ds2 }) -}
a9f6ff9087ab0f8360c39b62a26a9a99
  secondVContour ::
    PhonemeType.VowelFeaturesContour
    -> PhonemeType.MaybeBlank
         (PhonemeType.MaybeUnspecified PhonemeType.VowelFeatures)
  RecSel PhonemeType.VowelFeaturesContour
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.VowelFeaturesContour ->
                 case ds of wild { PhonemeType.VowelFeaturesContour ds1 ds2 ->
                 ds2 }) -}
88cdc16298be3ed3a85121fac4f9f036
  silibance ::
    PhonemeType.Manner
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Silibance)
  RecSel PhonemeType.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLSLL),1*U(A,A,A,A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Manner ->
                 case ds of wild { PhonemeType.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds5 }) -}
7578f922a83dc75d9ca7484ed465688a
  stricture ::
    PhonemeType.Manner
    -> PhonemeType.MaybeUnspecified PhonemeType.Stricture
  RecSel PhonemeType.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLLLLL),1*U(1*U,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Manner ->
                 case ds of wild { PhonemeType.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds1 }) -}
b84bf837fa35cbd163e41c7669ee5ee2
  trill ::
    PhonemeType.Manner
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.Trill)
  RecSel PhonemeType.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLL),1*U(A,1*U,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Manner ->
                 case ds of wild { PhonemeType.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds2 }) -}
d62b396c37bb33145dd8db99001bbc8a
  vot ::
    PhonemeType.Manner
    -> PhonemeType.MaybeImpossible
         (PhonemeType.MaybeUnspecified PhonemeType.VOT)
  RecSel PhonemeType.Manner
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLS),1*U(A,A,A,A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: PhonemeType.Manner ->
                 case ds of wild { PhonemeType.Manner ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 ds7 }) -}
instance GHC.Enum.Bounded [PhonemeType.ActiveArticulator]
  = PhonemeType.$fBoundedActiveArticulator
instance GHC.Enum.Bounded [PhonemeType.AirEscape]
  = PhonemeType.$fBoundedAirEscape
instance GHC.Enum.Bounded [PhonemeType.Backness]
  = PhonemeType.$fBoundedBackness
instance GHC.Enum.Bounded [PhonemeType.Direction]
  = PhonemeType.$fBoundedDirection
instance GHC.Enum.Bounded [PhonemeType.Height]
  = PhonemeType.$fBoundedHeight
instance GHC.Enum.Bounded [PhonemeType.Initiator]
  = PhonemeType.$fBoundedInitiator
instance GHC.Enum.Bounded [PhonemeType.Laterality]
  = PhonemeType.$fBoundedLaterality
instance GHC.Enum.Bounded [PhonemeType.Length]
  = PhonemeType.$fBoundedLength
instance GHC.Enum.Bounded [PhonemeType.PassiveArticulator]
  = PhonemeType.$fBoundedPassiveArticulator
instance GHC.Enum.Bounded [PhonemeType.Phonation]
  = PhonemeType.$fBoundedPhonation
instance GHC.Enum.Bounded [PhonemeType.Roundedness]
  = PhonemeType.$fBoundedRoundedness
instance GHC.Enum.Bounded [PhonemeType.Silibance]
  = PhonemeType.$fBoundedSilibance
instance GHC.Enum.Bounded [PhonemeType.Stricture]
  = PhonemeType.$fBoundedStricture
instance GHC.Enum.Bounded [PhonemeType.Trill]
  = PhonemeType.$fBoundedTrill
instance GHC.Enum.Bounded [PhonemeType.VOT]
  = PhonemeType.$fBoundedVOT
instance GHC.Enum.Enum [PhonemeType.ActiveArticulator]
  = PhonemeType.$fEnumActiveArticulator
instance GHC.Enum.Enum [PhonemeType.AirEscape]
  = PhonemeType.$fEnumAirEscape
instance GHC.Enum.Enum [PhonemeType.Backness]
  = PhonemeType.$fEnumBackness
instance GHC.Enum.Enum [PhonemeType.Direction]
  = PhonemeType.$fEnumDirection
instance GHC.Enum.Enum [PhonemeType.Height]
  = PhonemeType.$fEnumHeight
instance GHC.Enum.Enum [PhonemeType.Initiator]
  = PhonemeType.$fEnumInitiator
instance GHC.Enum.Enum [PhonemeType.Laterality]
  = PhonemeType.$fEnumLaterality
instance GHC.Enum.Enum [PhonemeType.Length]
  = PhonemeType.$fEnumLength
instance GHC.Enum.Enum [PhonemeType.PassiveArticulator]
  = PhonemeType.$fEnumPassiveArticulator
instance GHC.Enum.Enum [PhonemeType.Phonation]
  = PhonemeType.$fEnumPhonation
instance GHC.Enum.Enum [PhonemeType.Roundedness]
  = PhonemeType.$fEnumRoundedness
instance GHC.Enum.Enum [PhonemeType.Silibance]
  = PhonemeType.$fEnumSilibance
instance GHC.Enum.Enum [PhonemeType.Stricture]
  = PhonemeType.$fEnumStricture
instance GHC.Enum.Enum [PhonemeType.Trill]
  = PhonemeType.$fEnumTrill
instance GHC.Enum.Enum [PhonemeType.VOT] = PhonemeType.$fEnumVOT
instance GHC.Classes.Eq [PhonemeType.ActiveArticulator]
  = PhonemeType.$fEqActiveArticulator
instance GHC.Classes.Eq [PhonemeType.AirEscape]
  = PhonemeType.$fEqAirEscape
instance GHC.Classes.Eq [PhonemeType.Airstream]
  = PhonemeType.$fEqAirstream
instance GHC.Classes.Eq [PhonemeType.Backness]
  = PhonemeType.$fEqBackness
instance GHC.Classes.Eq [PhonemeType.ConsonantFeatures]
  = PhonemeType.$fEqConsonantFeatures
instance GHC.Classes.Eq [PhonemeType.ConsonantFeaturesContour]
  = PhonemeType.$fEqConsonantFeaturesContour
instance GHC.Classes.Eq [PhonemeType.Direction]
  = PhonemeType.$fEqDirection
instance GHC.Classes.Eq [PhonemeType.Height]
  = PhonemeType.$fEqHeight
instance GHC.Classes.Eq [PhonemeType.Initiator]
  = PhonemeType.$fEqInitiator
instance GHC.Classes.Eq [PhonemeType.Laterality]
  = PhonemeType.$fEqLaterality
instance GHC.Classes.Eq [PhonemeType.Length]
  = PhonemeType.$fEqLength
instance GHC.Classes.Eq [PhonemeType.Manner]
  = PhonemeType.$fEqManner
instance GHC.Classes.Eq [PhonemeType.MaybeBlank]
  = PhonemeType.$fEqMaybeBlank
instance GHC.Classes.Eq [PhonemeType.MaybeImpossible]
  = PhonemeType.$fEqMaybeImpossible
instance GHC.Classes.Eq [PhonemeType.MaybeUnspecified]
  = PhonemeType.$fEqMaybeUnspecified
instance GHC.Classes.Eq [PhonemeType.PassiveArticulator]
  = PhonemeType.$fEqPassiveArticulator
instance GHC.Classes.Eq [PhonemeType.Phonation]
  = PhonemeType.$fEqPhonation
instance GHC.Classes.Eq [PhonemeType.PhonemeInventory]
  = PhonemeType.$fEqPhonemeInventory
instance GHC.Classes.Eq [PhonemeType.Place] = PhonemeType.$fEqPlace
instance GHC.Classes.Eq [PhonemeType.Roundedness]
  = PhonemeType.$fEqRoundedness
instance GHC.Classes.Eq [PhonemeType.Silibance]
  = PhonemeType.$fEqSilibance
instance GHC.Classes.Eq [PhonemeType.Stricture]
  = PhonemeType.$fEqStricture
instance GHC.Classes.Eq [PhonemeType.Trill] = PhonemeType.$fEqTrill
instance GHC.Classes.Eq [PhonemeType.VOT] = PhonemeType.$fEqVOT
instance GHC.Classes.Eq [PhonemeType.VowelFeatures]
  = PhonemeType.$fEqVowelFeatures
instance GHC.Classes.Eq [PhonemeType.VowelFeaturesContour]
  = PhonemeType.$fEqVowelFeaturesContour
instance GHC.Read.Read [PhonemeType.ActiveArticulator]
  = PhonemeType.$fReadActiveArticulator
instance GHC.Read.Read [PhonemeType.AirEscape]
  = PhonemeType.$fReadAirEscape
instance GHC.Read.Read [PhonemeType.Airstream]
  = PhonemeType.$fReadAirstream
instance GHC.Read.Read [PhonemeType.Backness]
  = PhonemeType.$fReadBackness
instance GHC.Read.Read [PhonemeType.ConsonantFeatures]
  = PhonemeType.$fReadConsonantFeatures
instance GHC.Read.Read [PhonemeType.ConsonantFeaturesContour]
  = PhonemeType.$fReadConsonantFeaturesContour
instance GHC.Read.Read [PhonemeType.Direction]
  = PhonemeType.$fReadDirection
instance GHC.Read.Read [PhonemeType.Height]
  = PhonemeType.$fReadHeight
instance GHC.Read.Read [PhonemeType.Initiator]
  = PhonemeType.$fReadInitiator
instance GHC.Read.Read [PhonemeType.Laterality]
  = PhonemeType.$fReadLaterality
instance GHC.Read.Read [PhonemeType.Length]
  = PhonemeType.$fReadLength
instance GHC.Read.Read [PhonemeType.Manner]
  = PhonemeType.$fReadManner
instance GHC.Read.Read [PhonemeType.MaybeBlank]
  = PhonemeType.$fReadMaybeBlank
instance GHC.Read.Read [PhonemeType.MaybeImpossible]
  = PhonemeType.$fReadMaybeImpossible
instance GHC.Read.Read [PhonemeType.MaybeUnspecified]
  = PhonemeType.$fReadMaybeUnspecified
instance GHC.Read.Read [PhonemeType.PassiveArticulator]
  = PhonemeType.$fReadPassiveArticulator
instance GHC.Read.Read [PhonemeType.Phonation]
  = PhonemeType.$fReadPhonation
instance GHC.Read.Read [PhonemeType.PhonemeInventory]
  = PhonemeType.$fReadPhonemeInventory
instance GHC.Read.Read [PhonemeType.Place]
  = PhonemeType.$fReadPlace
instance GHC.Read.Read [PhonemeType.Roundedness]
  = PhonemeType.$fReadRoundedness
instance GHC.Read.Read [PhonemeType.Silibance]
  = PhonemeType.$fReadSilibance
instance GHC.Read.Read [PhonemeType.Stricture]
  = PhonemeType.$fReadStricture
instance GHC.Read.Read [PhonemeType.Trill]
  = PhonemeType.$fReadTrill
instance GHC.Read.Read [PhonemeType.VOT] = PhonemeType.$fReadVOT
instance GHC.Read.Read [PhonemeType.VowelFeatures]
  = PhonemeType.$fReadVowelFeatures
instance GHC.Read.Read [PhonemeType.VowelFeaturesContour]
  = PhonemeType.$fReadVowelFeaturesContour
instance GHC.Show.Show [PhonemeType.ActiveArticulator]
  = PhonemeType.$fShowActiveArticulator
instance GHC.Show.Show [PhonemeType.AirEscape]
  = PhonemeType.$fShowAirEscape
instance GHC.Show.Show [PhonemeType.Airstream]
  = PhonemeType.$fShowAirstream
instance GHC.Show.Show [PhonemeType.Backness]
  = PhonemeType.$fShowBackness
instance GHC.Show.Show [PhonemeType.ConsonantFeatures]
  = PhonemeType.$fShowConsonantFeatures
instance GHC.Show.Show [PhonemeType.ConsonantFeaturesContour]
  = PhonemeType.$fShowConsonantFeaturesContour
instance GHC.Show.Show [PhonemeType.Direction]
  = PhonemeType.$fShowDirection
instance GHC.Show.Show [PhonemeType.Height]
  = PhonemeType.$fShowHeight
instance GHC.Show.Show [PhonemeType.Initiator]
  = PhonemeType.$fShowInitiator
instance GHC.Show.Show [PhonemeType.Laterality]
  = PhonemeType.$fShowLaterality
instance GHC.Show.Show [PhonemeType.Length]
  = PhonemeType.$fShowLength
instance GHC.Show.Show [PhonemeType.Manner]
  = PhonemeType.$fShowManner
instance GHC.Show.Show [PhonemeType.MaybeBlank]
  = PhonemeType.$fShowMaybeBlank
instance GHC.Show.Show [PhonemeType.MaybeImpossible]
  = PhonemeType.$fShowMaybeImpossible
instance GHC.Show.Show [PhonemeType.MaybeUnspecified]
  = PhonemeType.$fShowMaybeUnspecified
instance GHC.Show.Show [PhonemeType.PassiveArticulator]
  = PhonemeType.$fShowPassiveArticulator
instance GHC.Show.Show [PhonemeType.Phonation]
  = PhonemeType.$fShowPhonation
instance GHC.Show.Show [PhonemeType.PhonemeInventory]
  = PhonemeType.$fShowPhonemeInventory
instance GHC.Show.Show [PhonemeType.Place]
  = PhonemeType.$fShowPlace
instance GHC.Show.Show [PhonemeType.Roundedness]
  = PhonemeType.$fShowRoundedness
instance GHC.Show.Show [PhonemeType.Silibance]
  = PhonemeType.$fShowSilibance
instance GHC.Show.Show [PhonemeType.Stricture]
  = PhonemeType.$fShowStricture
instance GHC.Show.Show [PhonemeType.Trill]
  = PhonemeType.$fShowTrill
instance GHC.Show.Show [PhonemeType.VOT] = PhonemeType.$fShowVOT
instance GHC.Show.Show [PhonemeType.VowelFeatures]
  = PhonemeType.$fShowVowelFeatures
instance GHC.Show.Show [PhonemeType.VowelFeaturesContour]
  = PhonemeType.$fShowVowelFeaturesContour
"SPEC $c== @ VOT" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                            PhonemeType.VOT
  PhonemeType.$fEqMaybeUnspecified_$c== @ PhonemeType.VOT $dEq
  = PhonemeType.$fEqMaybeImpossible_$s$c==7
"SPEC $creadList @ Laterality" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                            PhonemeType.Laterality
  PhonemeType.$fReadMaybeUnspecified_$creadList @ PhonemeType.Laterality
                                                $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$sreadListDefault1
"SPEC $creadList @ Silibance" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                           PhonemeType.Silibance
  PhonemeType.$fReadMaybeUnspecified_$creadList @ PhonemeType.Silibance
                                                $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$sreadListDefault2
"SPEC $creadList @ Trill" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                       PhonemeType.Trill
  PhonemeType.$fReadMaybeUnspecified_$creadList @ PhonemeType.Trill
                                                $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$sreadListDefault
"SPEC $creadList @ VOT" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                     PhonemeType.VOT
  PhonemeType.$fReadMaybeUnspecified_$creadList @ PhonemeType.VOT
                                                $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$sreadListDefault3
"SPEC $creadListPrec @ Laterality" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                PhonemeType.Laterality
  PhonemeType.$fReadMaybeUnspecified_$creadListPrec @ PhonemeType.Laterality
                                                    $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec1
"SPEC $creadListPrec @ Silibance" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                               PhonemeType.Silibance
  PhonemeType.$fReadMaybeUnspecified_$creadListPrec @ PhonemeType.Silibance
                                                    $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec2
"SPEC $creadListPrec @ Trill" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                           PhonemeType.Trill
  PhonemeType.$fReadMaybeUnspecified_$creadListPrec @ PhonemeType.Trill
                                                    $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec
"SPEC $creadListPrec @ VOT" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                         PhonemeType.VOT
  PhonemeType.$fReadMaybeUnspecified_$creadListPrec @ PhonemeType.VOT
                                                    $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadListPrec3
"SPEC $creadPrec @ Laterality" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                            PhonemeType.Laterality
  PhonemeType.$fReadMaybeUnspecified_$creadPrec @ PhonemeType.Laterality
                                                $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadPrec1
"SPEC $creadPrec @ Silibance" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                           PhonemeType.Silibance
  PhonemeType.$fReadMaybeUnspecified_$creadPrec @ PhonemeType.Silibance
                                                $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadPrec2
"SPEC $creadPrec @ Trill" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                       PhonemeType.Trill
  PhonemeType.$fReadMaybeUnspecified_$creadPrec @ PhonemeType.Trill
                                                $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadPrec
"SPEC $creadPrec @ VOT" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                     PhonemeType.VOT
  PhonemeType.$fReadMaybeUnspecified_$creadPrec @ PhonemeType.VOT
                                                $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadPrec3
"SPEC $creadsPrec @ Laterality" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                             PhonemeType.Laterality
  PhonemeType.$fReadMaybeUnspecified_$creadsPrec @ PhonemeType.Laterality
                                                 $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadsPrec1
"SPEC $creadsPrec @ Silibance" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                            PhonemeType.Silibance
  PhonemeType.$fReadMaybeUnspecified_$creadsPrec @ PhonemeType.Silibance
                                                 $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadsPrec2
"SPEC $creadsPrec @ Trill" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                        PhonemeType.Trill
  PhonemeType.$fReadMaybeUnspecified_$creadsPrec @ PhonemeType.Trill
                                                 $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadsPrec
"SPEC $creadsPrec @ VOT" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                      PhonemeType.VOT
  PhonemeType.$fReadMaybeUnspecified_$creadsPrec @ PhonemeType.VOT
                                                 $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$creadsPrec3
"SPEC $cshowsPrec @ (MaybeUnspecified ConsonantFeatures)" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                                      (PhonemeType.MaybeUnspecified
                                                                                         PhonemeType.ConsonantFeatures)
  PhonemeType.$fShowMaybeBlank_$cshowsPrec @ (PhonemeType.MaybeUnspecified
                                                PhonemeType.ConsonantFeatures)
                                           $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec
"SPEC $cshowsPrec @ (MaybeUnspecified Laterality)" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                               (PhonemeType.MaybeUnspecified
                                                                                  PhonemeType.Laterality)
  PhonemeType.$fShowMaybeImpossible_$cshowsPrec @ (PhonemeType.MaybeUnspecified
                                                     PhonemeType.Laterality)
                                                $dShow
  = PhonemeType.$fShowMaybeImpossible_$s$cshowsPrec1
"SPEC $cshowsPrec @ (MaybeUnspecified Silibance)" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                              (PhonemeType.MaybeUnspecified
                                                                                 PhonemeType.Silibance)
  PhonemeType.$fShowMaybeImpossible_$cshowsPrec @ (PhonemeType.MaybeUnspecified
                                                     PhonemeType.Silibance)
                                                $dShow
  = PhonemeType.$fShowMaybeImpossible_$s$cshowsPrec2
"SPEC $cshowsPrec @ (MaybeUnspecified Trill)" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                          (PhonemeType.MaybeUnspecified
                                                                             PhonemeType.Trill)
  PhonemeType.$fShowMaybeImpossible_$cshowsPrec @ (PhonemeType.MaybeUnspecified
                                                     PhonemeType.Trill)
                                                $dShow
  = PhonemeType.$fShowMaybeImpossible_$s$cshowsPrec
"SPEC $cshowsPrec @ (MaybeUnspecified VOT)" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                        (PhonemeType.MaybeUnspecified
                                                                           PhonemeType.VOT)
  PhonemeType.$fShowMaybeImpossible_$cshowsPrec @ (PhonemeType.MaybeUnspecified
                                                     PhonemeType.VOT)
                                                $dShow
  = PhonemeType.$fShowMaybeImpossible_$s$cshowsPrec3
"SPEC $cshowsPrec @ (MaybeUnspecified VowelFeatures)" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                                  (PhonemeType.MaybeUnspecified
                                                                                     PhonemeType.VowelFeatures)
  PhonemeType.$fShowMaybeBlank_$cshowsPrec @ (PhonemeType.MaybeUnspecified
                                                PhonemeType.VowelFeatures)
                                           $dShow
  = PhonemeType.$fShowMaybeBlank_$s$cshowsPrec
"SPEC $cshowsPrec @ ActiveArticulator" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                   PhonemeType.ActiveArticulator
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.ActiveArticulator
                                                         $dShow
  = PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec5
"SPEC $cshowsPrec @ AirEscape" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                           PhonemeType.AirEscape
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.AirEscape
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec6
"SPEC $cshowsPrec @ Airstream" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                           PhonemeType.Airstream
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Airstream
                                                         $dShow
  = PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec1
"SPEC $cshowsPrec @ Backness" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                          PhonemeType.Backness
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Backness
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec9
"SPEC $cshowsPrec @ Direction" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                           PhonemeType.Direction
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Direction
                                                         $dShow
  = PhonemeType.$fShowAirstream_$s$cshowsPrec
"SPEC $cshowsPrec @ Height" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                        PhonemeType.Height
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Height
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec8
"SPEC $cshowsPrec @ Initiator" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                           PhonemeType.Initiator
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Initiator
                                                         $dShow
  = PhonemeType.$fShowAirstream_$s$cshowsPrec1
"SPEC $cshowsPrec @ Laterality" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                            PhonemeType.Laterality
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Laterality
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec4
"SPEC $cshowsPrec @ Length" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                        PhonemeType.Length
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Length
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec3
"SPEC $cshowsPrec @ Manner" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                        PhonemeType.Manner
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Manner
                                                         $dShow
  = PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec2
"SPEC $cshowsPrec @ PassiveArticulator" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                    PhonemeType.PassiveArticulator
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.PassiveArticulator
                                                         $dShow
  = PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec4
"SPEC $cshowsPrec @ Phonation" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                           PhonemeType.Phonation
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Phonation
                                                         $dShow
  = PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec
"SPEC $cshowsPrec @ Place" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                       PhonemeType.Place
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Place
                                                         $dShow
  = PhonemeType.$fShowConsonantFeatures_$s$cshowsPrec3
"SPEC $cshowsPrec @ Roundedness" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                             PhonemeType.Roundedness
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Roundedness
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec10
"SPEC $cshowsPrec @ Silibance" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                           PhonemeType.Silibance
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Silibance
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec5
"SPEC $cshowsPrec @ Stricture" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                           PhonemeType.Stricture
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Stricture
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec1
"SPEC $cshowsPrec @ Trill" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                       PhonemeType.Trill
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.Trill
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec2
"SPEC $cshowsPrec @ VOT" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                     PhonemeType.VOT
  PhonemeType.$fShowConsonantFeaturesContour_$cshowsPrec @ PhonemeType.VOT
                                                         $dShow
  = PhonemeType.$fShowConsonantFeaturesContour_$s$cshowsPrec7
"SPEC $fReadMaybeUnspecified @ Laterality" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                        PhonemeType.Laterality
  PhonemeType.$fReadMaybeUnspecified @ PhonemeType.Laterality $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$fReadMaybeUnspecified1
"SPEC $fReadMaybeUnspecified @ Silibance" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                       PhonemeType.Silibance
  PhonemeType.$fReadMaybeUnspecified @ PhonemeType.Silibance $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$fReadMaybeUnspecified2
"SPEC $fReadMaybeUnspecified @ Trill" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                   PhonemeType.Trill
  PhonemeType.$fReadMaybeUnspecified @ PhonemeType.Trill $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$fReadMaybeUnspecified
"SPEC $fReadMaybeUnspecified @ VOT" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                 PhonemeType.VOT
  PhonemeType.$fReadMaybeUnspecified @ PhonemeType.VOT $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$s$fReadMaybeUnspecified3
"SPEC/PhonemeType $dmreadsPrec @ ActiveArticulator" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                 PhonemeType.ActiveArticulator
  GHC.Read.$dmreadsPrec @ PhonemeType.ActiveArticulator $dRead2
  = PhonemeType.$fReadActiveArticulator_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ AirEscape" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.AirEscape
  GHC.Read.$dmreadsPrec @ PhonemeType.AirEscape $dRead2
  = PhonemeType.$fReadAirEscape_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Backness" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                        PhonemeType.Backness
  GHC.Read.$dmreadsPrec @ PhonemeType.Backness $dRead2
  = PhonemeType.$fReadBackness_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Direction" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.Direction
  GHC.Read.$dmreadsPrec @ PhonemeType.Direction $dRead2
  = PhonemeType.$fReadDirection_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Height" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                      PhonemeType.Height
  GHC.Read.$dmreadsPrec @ PhonemeType.Height $dRead2
  = PhonemeType.$fReadHeight_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Initiator" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.Initiator
  GHC.Read.$dmreadsPrec @ PhonemeType.Initiator $dRead2
  = PhonemeType.$fReadInitiator_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Laterality" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                          PhonemeType.Laterality
  GHC.Read.$dmreadsPrec @ PhonemeType.Laterality $dRead2
  = PhonemeType.$fReadLaterality_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Length" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                      PhonemeType.Length
  GHC.Read.$dmreadsPrec @ PhonemeType.Length $dRead2
  = PhonemeType.$fReadLength_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ PassiveArticulator" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                  PhonemeType.PassiveArticulator
  GHC.Read.$dmreadsPrec @ PhonemeType.PassiveArticulator $dRead2
  = PhonemeType.$fReadPassiveArticulator_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Phonation" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.Phonation
  GHC.Read.$dmreadsPrec @ PhonemeType.Phonation $dRead2
  = PhonemeType.$fReadPhonation_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Roundedness" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                           PhonemeType.Roundedness
  GHC.Read.$dmreadsPrec @ PhonemeType.Roundedness $dRead2
  = PhonemeType.$fReadRoundedness_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Silibance" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.Silibance
  GHC.Read.$dmreadsPrec @ PhonemeType.Silibance $dRead2
  = PhonemeType.$fReadSilibance_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Stricture" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.Stricture
  GHC.Read.$dmreadsPrec @ PhonemeType.Stricture $dRead2
  = PhonemeType.$fReadStricture_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ Trill" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                     PhonemeType.Trill
  GHC.Read.$dmreadsPrec @ PhonemeType.Trill $dRead2
  = PhonemeType.$fReadTrill_$s$dmreadsPrec
"SPEC/PhonemeType $dmreadsPrec @ VOT" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                   PhonemeType.VOT
  GHC.Read.$dmreadsPrec @ PhonemeType.VOT $dRead2
  = PhonemeType.$fReadVOT_$s$dmreadsPrec
"SPEC/PhonemeType readListDefault @ (MaybeUnspecified Laterality)" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                                (PhonemeType.MaybeUnspecified
                                                                                                   PhonemeType.Laterality)
  GHC.Read.readListDefault @ (PhonemeType.MaybeUnspecified
                                PhonemeType.Laterality)
                           $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$sreadListDefault1
"SPEC/PhonemeType readListDefault @ (MaybeUnspecified Silibance)" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                               (PhonemeType.MaybeUnspecified
                                                                                                  PhonemeType.Silibance)
  GHC.Read.readListDefault @ (PhonemeType.MaybeUnspecified
                                PhonemeType.Silibance)
                           $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$sreadListDefault2
"SPEC/PhonemeType readListDefault @ (MaybeUnspecified Trill)" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                           (PhonemeType.MaybeUnspecified
                                                                                              PhonemeType.Trill)
  GHC.Read.readListDefault @ (PhonemeType.MaybeUnspecified
                                PhonemeType.Trill)
                           $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$sreadListDefault
"SPEC/PhonemeType readListDefault @ (MaybeUnspecified VOT)" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                         (PhonemeType.MaybeUnspecified
                                                                                            PhonemeType.VOT)
  GHC.Read.readListDefault @ (PhonemeType.MaybeUnspecified
                                PhonemeType.VOT)
                           $dRead2
  = PhonemeType.$fReadMaybeUnspecified_$sreadListDefault3
"SPEC/PhonemeType readListDefault @ ActiveArticulator" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                    PhonemeType.ActiveArticulator
  GHC.Read.readListDefault @ PhonemeType.ActiveArticulator $dRead2
  = PhonemeType.$fReadActiveArticulator_$sreadListDefault
"SPEC/PhonemeType readListDefault @ AirEscape" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                            PhonemeType.AirEscape
  GHC.Read.readListDefault @ PhonemeType.AirEscape $dRead2
  = PhonemeType.$fReadAirEscape_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Airstream" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                            PhonemeType.Airstream
  GHC.Read.readListDefault @ PhonemeType.Airstream $dRead2
  = PhonemeType.$fReadAirstream_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Backness" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                           PhonemeType.Backness
  GHC.Read.readListDefault @ PhonemeType.Backness $dRead2
  = PhonemeType.$fReadBackness_$sreadListDefault
"SPEC/PhonemeType readListDefault @ ConsonantFeatures" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                    PhonemeType.ConsonantFeatures
  GHC.Read.readListDefault @ PhonemeType.ConsonantFeatures $dRead2
  = PhonemeType.$fReadConsonantFeatures_$sreadListDefault
"SPEC/PhonemeType readListDefault @ ConsonantFeaturesContour" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                           PhonemeType.ConsonantFeaturesContour
  GHC.Read.readListDefault @ PhonemeType.ConsonantFeaturesContour
                           $dRead2
  = PhonemeType.$fReadConsonantFeaturesContour_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Direction" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                            PhonemeType.Direction
  GHC.Read.readListDefault @ PhonemeType.Direction $dRead2
  = PhonemeType.$fReadDirection_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Height" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.Height
  GHC.Read.readListDefault @ PhonemeType.Height $dRead2
  = PhonemeType.$fReadHeight_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Initiator" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                            PhonemeType.Initiator
  GHC.Read.readListDefault @ PhonemeType.Initiator $dRead2
  = PhonemeType.$fReadInitiator_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Laterality" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                             PhonemeType.Laterality
  GHC.Read.readListDefault @ PhonemeType.Laterality $dRead2
  = PhonemeType.$fReadLaterality_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Length" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.Length
  GHC.Read.readListDefault @ PhonemeType.Length $dRead2
  = PhonemeType.$fReadLength_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Manner" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                         PhonemeType.Manner
  GHC.Read.readListDefault @ PhonemeType.Manner $dRead2
  = PhonemeType.$fReadManner_$sreadListDefault
"SPEC/PhonemeType readListDefault @ PassiveArticulator" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                     PhonemeType.PassiveArticulator
  GHC.Read.readListDefault @ PhonemeType.PassiveArticulator $dRead2
  = PhonemeType.$fReadPassiveArticulator_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Phonation" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                            PhonemeType.Phonation
  GHC.Read.readListDefault @ PhonemeType.Phonation $dRead2
  = PhonemeType.$fReadPhonation_$sreadListDefault
"SPEC/PhonemeType readListDefault @ PhonemeInventory" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                   PhonemeType.PhonemeInventory
  GHC.Read.readListDefault @ PhonemeType.PhonemeInventory $dRead2
  = PhonemeType.$fReadPhonemeInventory_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Place" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                        PhonemeType.Place
  GHC.Read.readListDefault @ PhonemeType.Place $dRead2
  = PhonemeType.$fReadPlace_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Roundedness" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                              PhonemeType.Roundedness
  GHC.Read.readListDefault @ PhonemeType.Roundedness $dRead2
  = PhonemeType.$fReadRoundedness_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Silibance" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                            PhonemeType.Silibance
  GHC.Read.readListDefault @ PhonemeType.Silibance $dRead2
  = PhonemeType.$fReadSilibance_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Stricture" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                            PhonemeType.Stricture
  GHC.Read.readListDefault @ PhonemeType.Stricture $dRead2
  = PhonemeType.$fReadStricture_$sreadListDefault
"SPEC/PhonemeType readListDefault @ Trill" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                        PhonemeType.Trill
  GHC.Read.readListDefault @ PhonemeType.Trill $dRead2
  = PhonemeType.$fReadTrill_$sreadListDefault
"SPEC/PhonemeType readListDefault @ VOT" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                      PhonemeType.VOT
  GHC.Read.readListDefault @ PhonemeType.VOT $dRead2
  = PhonemeType.$fReadVOT_$sreadListDefault
"SPEC/PhonemeType readListDefault @ VowelFeatures" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                PhonemeType.VowelFeatures
  GHC.Read.readListDefault @ PhonemeType.VowelFeatures $dRead2
  = PhonemeType.$fReadVowelFeatures_$sreadListDefault
"SPEC/PhonemeType readListDefault @ VowelFeaturesContour" [ALWAYS] forall $dRead2 :: GHC.Read.Read
                                                                                       PhonemeType.VowelFeaturesContour
  GHC.Read.readListDefault @ PhonemeType.VowelFeaturesContour $dRead2
  = PhonemeType.$fReadVowelFeaturesContour_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

